#include "stdafx.h"
#include "Wintempla.h"
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.  I ACCEPT NO LIABILITY FOR ANY DAMAGE OR LOSS
   OF BUSINESS THAT THIS SOFTWARE MAY CAUSE.

   Wintempla.cpp
 
   © Copyright 2000 - 2016 Sergio Ledesma.  All Rights Reserved.

   THIS CODE IS PROTECTED BY COPYRIGHT LAW AND INTERNATIONAL TREATIES.
	UNAUTHORIZED REPRODUCTION OR DISTRIBUTION OF THIS CODE, OR ANY PORTION
	OF IT, MAY RESULT IN SEVERE CIVIL AND CRIMINAL PENALTIES, AND WILL BE
	PROSECUTED TO THE MAXIMUM EXTENT POSSIBLE UNDER THE LAW.

	ESTE CODIGO ESTA PROTEGIDO POR LAS LEYES Y TRATADOS DE DERECHO AUTOR
	INTERNACIONALES.  LA REPRODUCCION SIN AUTORIZACION O LA DISTRIBUCION
	DE ESTE CODIGO, O CUALQUIER PARTE DE ESTE, RESULTARA EN SEVERA
	PENALIDAD CIVIL Y CRIMINAL, Y SERA PERSEGUIDA HASTA SU MAXIMA 
	EXTENSION BAJO LO QUE PERMITA LA LEY.
***************************************************************************/

namespace Com //_______________________________________ namespace Com::Ini
{
//___________________________________________________________________ Base
HINSTANCE Base::hInstance = NULL;
int Base::lockCount = 0;
int Base::objectCount = 0;

Base::Base()
{
}

Base::~Base()
{
}

DWORD Base::Begin(HINSTANCE hInstance, ULONG reason)
{
	if (reason == DLL_PROCESS_ATTACH)
	{
		Com::Base::hInstance = hInstance;
	}
	return TRUE;
}

void Base::IncreaseObjectCount()
{
	objectCount++;
}

void Base::DecreaseObjectCount()
{
	objectCount--;
}

void Base::IncreaseLockCount()
{
	lockCount++;
}

void Base::DecreaseLockCount()
{
	lockCount--;
}

bool Base::CanUnloadNow()
{
	if (lockCount == 0 && objectCount == 0) return S_OK;
	return S_FALSE;
}

HRESULT Base::RegisterComClass(HINSTANCE hInstance, const wchar_t* libidString, const wchar_t* clsidString, const wchar_t* companyName, const wchar_t* className, int version)
{
	const wchar_t* catid_SafeForScripting = L"{7DD95801-9882-11CF-9FA9-00AA006C42C4}";
	const wchar_t* catid_SafeForInitializing = L"{7DD95802-9882-11CF-9FA9-00AA006C42C4}";
	//____________________________________________________ Get DLL Name
	wstring filename;
	if (Sys::Information::getProgramFileName(hInstance, filename) == false) return SELFREG_E_CLASS;
	//____________________________________________________  Compute Caption
	wstring caption(className);
	caption += L" Class";
	//____________________________________________________ Compute ProgID
	wstring ProgID;
	Sys::Format(ProgID, L"%s.%s.%d", companyName, className, version);
	//____________________________________________________ Compute VersionIndependentProgID
	wstring VersionIndependentProgID;
	Sys::Format(VersionIndependentProgID, L"%s.%s", companyName, className);

	//_____________________________________________________________________ Open HKEY_CLASSES_ROOT/CLSID
	Sys::RegistryKey keyCLSID;
	if (keyCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	//_____________________________________________________________________ Create {clsid}
	Sys::RegistryKey keyGuid;
	if (keyCLSID.CreateSubKey(clsidString, KEY_ALL_ACCESS, keyGuid) == false) return SELFREG_E_CLASS;
	if (keyGuid.SetValue(NULL, caption.c_str()) == false) return SELFREG_E_CLASS;
	//______________________________________________________________________ InprocServer32
	Sys::RegistryKey keyInprocServer32;
	if (keyGuid.CreateSubKey(L"InProcServer32", KEY_ALL_ACCESS, keyInprocServer32) == false) return SELFREG_E_CLASS;
	if (keyInprocServer32.SetValue(NULL, filename.c_str()) == false) return SELFREG_E_CLASS;
	if (keyInprocServer32.SetValue(L"ThreadingModel", L"Apartment") == false) return SELFREG_E_CLASS;
	//_______________________________________________________________________ ProgID
	Sys::RegistryKey keyProgID;
	if (keyGuid.CreateSubKey(L"ProgID", KEY_ALL_ACCESS, keyProgID) == false) return SELFREG_E_CLASS;
	if (keyProgID.SetValue(NULL, ProgID.c_str()) == false) return SELFREG_E_CLASS;
	//_______________________________________________________________________ VersionIndependentProgID
	Sys::RegistryKey keyVersionIndependentProgID;
	if (keyGuid.CreateSubKey(L"VersionIndependentProgID", KEY_ALL_ACCESS, keyVersionIndependentProgID) == false) return SELFREG_E_CLASS;
	if (keyVersionIndependentProgID.SetValue(NULL, VersionIndependentProgID.c_str()) == false) return SELFREG_E_CLASS;
	//_______________________________________________________________________ TypeLib
	Sys::RegistryKey keyTypeLib;
	if (keyGuid.CreateSubKey(L"TypeLib", KEY_ALL_ACCESS, keyTypeLib) == false) return SELFREG_E_CLASS;
	if (keyTypeLib.SetValue(NULL, libidString) == false) return SELFREG_E_CLASS;
	//_______________________________________________________________________ Implemented Categories
	Sys::RegistryKey keyImplementedCategories;
	if (keyGuid.CreateSubKey(L"Implemented Categories", KEY_ALL_ACCESS, keyImplementedCategories) == false) return SELFREG_E_CLASS;
	Sys::RegistryKey keySafeForScripting;
	if (keyImplementedCategories.CreateSubKey(catid_SafeForScripting, KEY_ALL_ACCESS, keySafeForScripting) == false) return SELFREG_E_CLASS;
	Sys::RegistryKey keySafeForInitializing;
	if (keyImplementedCategories.CreateSubKey(catid_SafeForInitializing, KEY_ALL_ACCESS, keySafeForInitializing) == false) return SELFREG_E_CLASS;
	//_____________________________________________________________________ companyName.className
	Sys::RegistryKey keyCR;
	if (keyCR.Open(HKEY_CLASSES_ROOT, NULL, KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	Sys::RegistryKey keyVIPI;
	if (keyCR.CreateSubKey(VersionIndependentProgID.c_str(), KEY_ALL_ACCESS, keyVIPI) == false) return SELFREG_E_CLASS;
	if (keyVIPI.SetValue(NULL, caption.c_str()) == false) return SELFREG_E_CLASS;
	//_________________________________________ CurVer
	Sys::RegistryKey keyCurVer;
	if (keyVIPI.CreateSubKey(L"CurVer", KEY_ALL_ACCESS, keyCurVer) == false) return SELFREG_E_CLASS;
	if (keyCurVer.SetValue(NULL, ProgID.c_str()) == false) return SELFREG_E_CLASS;
	//_____________________________________________________________________ companyName.className.version
	Sys::RegistryKey keyPI;
	if (keyCR.CreateSubKey(ProgID.c_str(), KEY_ALL_ACCESS, keyPI) == false) return SELFREG_E_CLASS;
	if (keyPI.SetValue(NULL, caption.c_str()) == false) return SELFREG_E_CLASS;
	//_________________________________________ CLSID
	Sys::RegistryKey keyPiClsdi;
	if (keyPI.CreateSubKey(L"CLSID", KEY_ALL_ACCESS, keyPiClsdi) == false) return SELFREG_E_CLASS;
	if (keyPiClsdi.SetValue(NULL, clsidString) == false) return SELFREG_E_CLASS;
	return S_OK;
}

HRESULT Base::RegisterComClass(const wchar_t* libidString, const wchar_t* clsidString, const wchar_t* companyName, const wchar_t* className, int version)
{
	return Com::Base::RegisterComClass(Com::Base::hInstance, libidString, clsidString, companyName, className, version);
}

HRESULT Base::RegisterComClass(HINSTANCE hInstance, REFIID libid, REFCLSID clsid, const wchar_t* companyName, const wchar_t* className, int version)
{
	wstring text;
	//
	wstring clsidString(L"{");
	Sys::Convert::ClsidToString(clsid, text);
	clsidString += text;
	clsidString += L"}";
	//
	wstring libidString(L"{");
	Sys::Convert::ClsidToString(libid, text);
	libidString += text;
	libidString += L"}";
	//
	return RegisterComClass(hInstance, libidString.c_str(), clsidString.c_str(), companyName, className, version);

	//wchar_t* clsidString;
	//StringFromCLSID(clsid, &clsidString);
	//HRESULT hr = RegisterServer(hInstance, clsidString, companyName, className, version);
	//::CoTaskMemFree(clsidString);
	//return hr;
}

HRESULT Base::RegisterComClass(REFIID libid, REFCLSID clsid, const wchar_t* companyName, const wchar_t* className, int version)
{
	wstring text;
	//
	wstring clsidString(L"{");
	Sys::Convert::ClsidToString(clsid, text);
	clsidString += text;
	clsidString += L"}";
	//
	wstring libidString(L"{");
	Sys::Convert::ClsidToString(libid, text);
	libidString += text;
	libidString += L"}";
	//
	return RegisterComClass(libidString.c_str(), clsidString.c_str(), companyName, className, version);
}

HRESULT Base::UnRegisterComClass(REFIID libid, REFCLSID clsid)
{
	wstring text;
	//
	wstring clsidString(L"{");
	Sys::Convert::ClsidToString(clsid, text);
	clsidString += text;
	clsidString += L"}";
	//
	wstring libidString(L"{");
	Sys::Convert::ClsidToString(libid, text);
	libidString += text;
	libidString += L"}";
	//
	return UnRegisterComClass(libidString.c_str(), clsidString.c_str());
}

HRESULT Base::UnRegisterComClass(const wchar_t* libidString, const wchar_t* clsid)
{
	const wchar_t* catid_SafeForScripting = L"{7DD95801-9882-11CF-9FA9-00AA006C42C4}";
	const wchar_t* catid_SafeForInitializing = L"{7DD95802-9882-11CF-9FA9-00AA006C42C4}";
	//
	wstring text;
	//_______________________________________________________ Open HKEY_CLASSES_ROOT/CLSID/{clsid}/Implemented Categories
	Sys::Format(text, L"CLSID\\%s\\Implemented Categories", clsid);
	Sys::RegistryKey keyImplementedCategories;
	if (keyImplementedCategories.Open(HKEY_CLASSES_ROOT, text.c_str(), KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	if (keyImplementedCategories.DeleteSubKey(catid_SafeForScripting) == false) return SELFREG_E_CLASS;
	if (keyImplementedCategories.DeleteSubKey(catid_SafeForInitializing) == false) return SELFREG_E_CLASS;
	keyImplementedCategories.Close();
	//_______________________________________________________ Open HKEY_CLASSES_ROOT/CLSID
	Sys::RegistryKey keyCLSID;
	if (keyCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	//________________________________________________________ Delete {clsid}/InprocServer32
	text = clsid;
	text += L"\\InprocServer32";
	if (keyCLSID.DeleteSubKey(text.c_str()) == false) return SELFREG_E_CLASS;
	//________________________________________________________ Delete {clsid}/ProgID
	text = clsid;
	text += L"\\ProgID";
	if (keyCLSID.DeleteSubKey(text.c_str()) == false) return SELFREG_E_CLASS;
	//________________________________________________________ Delete {clsid}/VersionIndependentProgID
	text = clsid;
	text += L"\\VersionIndependentProgID";
	if (keyCLSID.DeleteSubKey(text.c_str()) == false) return SELFREG_E_CLASS;
	//________________________________________________________ Delete {clsid}/TypeLib
	text = clsid;
	text += L"\\TypeLib";
	if (keyCLSID.DeleteSubKey(text.c_str()) == false) return SELFREG_E_CLASS;
	//________________________________________________________ Delete {clsid}/Implemented Categories
	text = clsid;
	text += L"\\Implemented Categories";
	if (keyCLSID.DeleteSubKey(text.c_str()) == false) return SELFREG_E_CLASS;
	//________________________________________________________ Delete {clsid}
	if (keyCLSID.DeleteSubKey(clsid) == false) return SELFREG_E_CLASS;
	return S_OK;
}

HRESULT Base::RegisterTypeLib(HINSTANCE hInstance, const wchar_t* libidString, int version, int subversion)
{
	//____________________________________________________ Get DLL Filename with Path
	wstring filenameWithPath;
	if (Sys::Information::getProgramFileName(hInstance, filenameWithPath) == false) return SELFREG_E_CLASS;
	// Change the file extension from dll or exe to tlb
	const size_t len = filenameWithPath.size();
	filenameWithPath[len - 3] = 't';
	filenameWithPath[len - 2] = 'l';
	filenameWithPath[len - 1] = 'b';
	//____________________________________________________ Get DLL Filename
	wchar_t text[256];
	if (Sys::TextAssistant::ExtractFileName(filenameWithPath.c_str(), false, text, 256) == false) return SELFREG_E_CLASS;
	//____________________________________________________  Compute libname
	wstring libname;
	Sys::Format(libname, L"%s library %d.%d", text, version, subversion);

	//____________________________________________________ Open HKEY_CLASSES_ROOT/TypeLib
	Sys::RegistryKey keyTypeLib;
	if (keyTypeLib.Open(HKEY_CLASSES_ROOT, L"TypeLib", KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	//___________________________________________________ Create HKEY_CLASSES_ROOT/TypeLib/{libid}
	Sys::RegistryKey keyLibId;
	if (keyTypeLib.CreateSubKey(libidString, KEY_ALL_ACCESS, keyLibId) == false) return SELFREG_E_CLASS;
	//___________________________________________________ Create HKEY_CLASSES_ROOT/TypeLib/{libid}/version
	_snwprintf_s(text, 256, _TRUNCATE, L"%d.%d", version, subversion);
	Sys::RegistryKey keyVersion;
	if (keyLibId.CreateSubKey(text, KEY_ALL_ACCESS, keyVersion) == false) return SELFREG_E_CLASS;
	if (keyVersion.SetValue(NULL, libname.c_str()) == false)  return SELFREG_E_CLASS;
	//___________________________________________________ Create HKEY_CLASSES_ROOT/TypeLib/{libid}/version/0
	Sys::RegistryKey keyZero;
	if (keyVersion.CreateSubKey(L"0", KEY_ALL_ACCESS, keyZero) == false) return SELFREG_E_CLASS;
	//___________________________________________________ Create HKEY_CLASSES_ROOT/TypeLib/{libid}/version/FLAGS
	Sys::RegistryKey keyFlags;
	if (keyVersion.CreateSubKey(L"FLAGS", KEY_ALL_ACCESS, keyFlags) == false) return SELFREG_E_CLASS;
	if (keyFlags.SetValue(NULL, L"0") == false)  return SELFREG_E_CLASS;
	//___________________________________________________ Create HKEY_CLASSES_ROOT/TypeLib/{libid}/version/HELPDIR
	Sys::RegistryKey keyHelpDir;
	if (keyVersion.CreateSubKey(L"HELPDIR", KEY_ALL_ACCESS, keyHelpDir) == false) return SELFREG_E_CLASS;
	//___________________________________________________ Create HKEY_CLASSES_ROOT/TypeLib/{libid}/version/0/Win32
	Sys::RegistryKey keyWin32;
	if (keyZero.CreateSubKey(L"Win32", KEY_ALL_ACCESS, keyWin32) == false) return SELFREG_E_CLASS;
	if (keyWin32.SetValue(NULL, filenameWithPath.c_str()) == false) return SELFREG_E_CLASS;
	return S_OK;
}

HRESULT Base::RegisterTypeLib(const wchar_t* libidString, int version, int subversion)
{
	return Com::Base::RegisterTypeLib(Com::Base::hInstance, libidString, version, subversion);
}

HRESULT Base::RegisterTypeLib(HINSTANCE hInstance, REFIID libid, int version, int subversion)
{
	wstring text;
	wstring libidString(L"{");
	Sys::Convert::ClsidToString(libid, text);
	libidString += text;
	libidString += L"}";
	return Com::Base::RegisterTypeLib(hInstance, libidString.c_str(), version, subversion);
}

HRESULT Base::RegisterTypeLib(REFIID libid, int version, int subversion)
{
	wstring text;
	wstring libidString(L"{");
	Sys::Convert::ClsidToString(libid, text);
	libidString += text;
	libidString += L"}";
	return Com::Base::RegisterTypeLib(libidString.c_str(), version, subversion);
}

HRESULT Base::UnRegisterTypeLib(const wchar_t* libidString, int version, int subversion)
{
	wchar_t text[256];
	//____________________________________________________ 1. Open HKEY_CLASSES_ROOT/TypeLib/{libid}/version/0
	Sys::RegistryKey keyTmp;
	_snwprintf_s(text, 256, _TRUNCATE, L"TypeLib\\%s\\%d.%d\\0", libidString, version, subversion);
	if (keyTmp.Open(HKEY_CLASSES_ROOT, text, KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	//________________ Delete HKEY_CLASSES_ROOT/TypeLib/{libid}/version/0/Win32
	if (keyTmp.DeleteSubKey(L"Win32") == false) return SELFREG_E_CLASS;
	keyTmp.Close();
	//____________________________________________________ 2. Open HKEY_CLASSES_ROOT/TypeLib/{libid}/version
	_snwprintf_s(text, 256, _TRUNCATE, L"TypeLib\\%s\\%d.%d", libidString, version, subversion);
	if (keyTmp.Open(HKEY_CLASSES_ROOT, text, KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	//_________________ Delete HKEY_CLASSES_ROOT/TypeLib/{libid}/version/0
	if (keyTmp.DeleteSubKey(L"0") == false) return SELFREG_E_CLASS;
	//_________________ Delete HKEY_CLASSES_ROOT/TypeLib/{libid}/version/FLAGS
	if (keyTmp.DeleteSubKey(L"FLAGS") == false) return SELFREG_E_CLASS;
	//_________________ Delete HKEY_CLASSES_ROOT/TypeLib/{libid}/version/HELPDIR
	if (keyTmp.DeleteSubKey(L"HELPDIR") == false) return SELFREG_E_CLASS;
	keyTmp.Close();
	//____________________________________________________ 3. Open HKEY_CLASSES_ROOT/TypeLib/{libid}
	_snwprintf_s(text, 256, _TRUNCATE, L"TypeLib\\%s", libidString);
	if (keyTmp.Open(HKEY_CLASSES_ROOT, text, KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	//_________________ Delete HKEY_CLASSES_ROOT/TypeLib/{libid}/version
	_snwprintf_s(text, 256, _TRUNCATE, L"%d.%d", version, subversion);
	if (keyTmp.DeleteSubKey(text) == false) return SELFREG_E_CLASS;
	keyTmp.Close();
	//____________________________________________________ 4. Open HKEY_CLASSES_ROOT/TypeLib
	if (keyTmp.Open(HKEY_CLASSES_ROOT, L"TypeLib", KEY_ALL_ACCESS) == false) return SELFREG_E_CLASS;
	//_________________ Delete HKEY_CLASSES_ROOT/TypeLib/{libid}
	if (keyTmp.DeleteSubKey(libidString) == false) return SELFREG_E_CLASS;
	keyTmp.Close();
	return S_OK;
}

HRESULT Base::UnRegisterTypeLib(REFIID libid, int version, int subversion)
{
	wstring text;
	wstring libidString(L"{");
	Sys::Convert::ClsidToString(libid, text);
	libidString += text;
	libidString += L"}";
	return Com::Base::UnRegisterTypeLib(libidString.c_str(), version, subversion);
}

//_____________________________________________________________________ DispInfo
DispInfo::DispInfo()
{
	isInitialized = false;
	typeInfo = NULL;
	hr = E_FAIL;
}

DispInfo::~DispInfo()
{
	if (SUCCEEDED(hr)) typeInfo->Release();
}

//_____________________________________________________________________ LifeCycle
LifeCycle::LifeCycle()
{
	refCount = 0;
	Com::Base::IncreaseObjectCount();
}

LifeCycle::~LifeCycle()
{
	Com::Base::DecreaseObjectCount();
}

int LifeCycle::Inc()
{
	refCount++;
	return refCount;
}

int LifeCycle::Dec()
{
	refCount--;
	return refCount;
}

//___________________________________________________________________ ClassFactory

//___________________________________________________________________ Param
Param::Param()
{
	Constructor();
}

Param::Param(int count)
{
	Constructor();
	Create(count);
}

void Param::Constructor()
{
	dispparam.cArgs = 0;
	dispparam.cNamedArgs = 0;
	//
	dispparam.rgdispidNamedArgs = NULL;
	dispparam.rgvarg = NULL;
	//
	variantx = NULL;
}

bool Param::Create(int count)
{
	//____________________________________________ Clean
	if (variantx != NULL) delete[] variantx;
	//
	Constructor();
	//
	variantx = new _variant_t[count];
	for (int i = 0; i < count; i++)
	{
		variantx[i].vt = VT_ERROR;
		variantx[i].scode = DISP_E_PARAMNOTFOUND;
	}
	if (variantx == NULL) return false;
	dispparam.rgvarg = variantx;
	dispparam.cArgs = count;
	return true;
}

Param::~Param()
{
	if (variantx != NULL) delete[] variantx;
}

void Param::PrepareInvoke(int dispatch_type)
{
	if (dispatch_type == DISPATCH_PROPERTYPUT)
	{
		dispparam.cNamedArgs = 1;
		dispid[0] = DISPID_PROPERTYPUT;
		dispparam.rgdispidNamedArgs = dispid;
	}
	else if (dispatch_type == DISPATCH_PROPERTYPUTREF)
	{
		dispparam.cNamedArgs = 1;
		dispid[0] = DISPID_PROPERTYPUT;
		dispparam.rgdispidNamedArgs = dispid;
	}
	else
	{
		dispparam.cNamedArgs = 0;
		dispid[0] = 0;
		dispparam.rgdispidNamedArgs = NULL;
	}
}

// Returns the number of parameter until it finds a VT_ERROR or VT_EMPTY
int Param::GetRequiredParamCount()
{
	int count = 0;
	for (int i = dispparam.cArgs - 1; i >= 0; i--)
	{
		if (dispparam.rgvarg[i].vt == VT_ERROR) return count;
		if (dispparam.rgvarg[i].vt == VT_EMPTY) return count;
		count++;
	}
	return count;
}

void Param::SetMissing(int index)
{
	variantx[dispparam.cArgs - index - 1].vt = VT_ERROR;
	variantx[dispparam.cArgs - index - 1].scode = DISP_E_PARAMNOTFOUND;
}

_variant_t& Param::operator[](long index)
{
	return variantx[dispparam.cArgs - index - 1];
}

const _variant_t& Param::operator[](long index) const
{
	return variantx[dispparam.cArgs - index - 1];
}

//___________________________________________________________________ Array
//Array::Array()
//{
//	Constructor();
//}
//
//Array::Array(int count)
//{
//	Constructor();
//	bound[0].cElements = count;
//	this->parray = ::SafeArrayCreate(VT_I4, 1, bound);
//}
//
//Array::Array(int rows, int cols)
//{
//	Constructor();
//	bound[0].cElements = rows;
//	bound[1].cElements = cols;
//	this->parray = ::SafeArrayCreate(VT_I4, 2, bound);
//}
//
//long Array::GetRowCount() throw()
//{
//	return bound[0].cElements;
//}
//
//long Array::GetColCount() throw()
//{
//	return bound[1].cElements;
//}
//
//void Array::Constructor()
//{
//	this->vt = VT_ARRAY | VT_I4;
//	for(int i = 0; i < 5; i++)
//	{
//		bound[i].cElements = 0;
//		bound[i].lLbound = 0;
//	}
//}
//
//Array::~Array()
//{
//	if (this->parray != NULL && this->vt != VT_EMPTY)
//	{
//		::SafeArrayDestroy(this->parray);
//	}
//}
//
//HRESULT Array::Create(int count)
//{
//	return S_OK;
//}
//
//HRESULT Array::Create(int rows, int cols)
//{
//	return S_OK;
//}
//
//void Array::Destroy()
//{
//}

//___________________________________________________________________ ClassInfo
ClassInfo::ClassInfo()
{
	Clear();
}

ClassInfo::~ClassInfo()
{
}

void ClassInfo::Clear()
{
	typeKind = TKIND_DISPATCH;
	clsid = GUID_NULL;
	isDefault = false;
}


//___________________________________________________________________ Enum
Enum::Enum()
{
}

Enum::~Enum()
{
}

void Enum::Clear()
{
	name.clear();
	value.Clear();
}

//___________________________________________________________________ FuncParam
FuncParam::FuncParam()
{
	Clear();
}

FuncParam::~FuncParam()
{
}

void FuncParam::Clear()
{
	name.clear();
	datatype = VT_NULL;
	//
	iidLink = GUID_NULL;
	typeKindLink = TKIND_DISPATCH;
	descrLink.clear();
	isValid = true;
}

bool FuncParam::AreCompatible(Com::FuncParam& param1, Com::FuncParam& param2)
{
	if (param1.datatype == VT_NULL) return false;
	if (param2.datatype == VT_NULL) return false;
	if (param1.datatype == VT_USERDEFINED && param2.datatype == VT_USERDEFINED)
	{
		return (param1.typeKindLink == param2.typeKindLink);
	}
	return true;
}

//___________________________________________________________________ FuncInfo
FuncInfo::FuncInfo()
{
	Clear();
}

FuncInfo::~FuncInfo()
{
}

void FuncInfo::Clear()
{
	name.clear();
	dispatch_type = DISPATCH_METHOD;
	param.clear();
	numOptionalParameters = 0;
	callConv = CC_STDCALL;
	memid = 0;
	isNameValidForProperty = true;
	//
	returnType.Clear();
	helpString.clear();
}

//bool FuncInfo::AreParametersValid()
//{
//	if (returnType.isValid == false) return false;
//	const int count = param.size();
//	for (int i = 0; i < count; i++)
//	{
//		if (param[i].isValid == false) return false;
//	}
//	return true;
//}

bool FuncInfo::HasPutProperty(list<Com::FuncInfo>& fi)
{
	list<Com::FuncInfo>::iterator pfi;
	list<Com::FuncInfo>::const_iterator fiend = fi.end();

	for (pfi = fi.begin(); pfi != fiend; pfi++)
	{
		if (pfi->name == name && pfi->dispatch_type == DISPATCH_PROPERTYPUT) return true;
	}
	return false;
}

bool FuncInfo::HasGetProperty(list<Com::FuncInfo>& fi)
{
	list<Com::FuncInfo>::iterator pfi;
	list<Com::FuncInfo>::const_iterator fiend = fi.end();

	for (pfi = fi.begin(); pfi != fiend; pfi++)
	{
		if (pfi->name == name && pfi->dispatch_type == DISPATCH_PROPERTYGET) return true;
	}
	return false;
}

bool FuncInfo::HasProperty(list<Com::FuncInfo>& fi)
{
	if (dispatch_type != DISPATCH_PROPERTYGET) return false;
	list<Com::FuncInfo>::iterator pfi;
	list<Com::FuncInfo>::const_iterator fiend = fi.end();
	Com::FuncParam paramGet;
	Com::FuncParam paramPut;
	bool foundGet = false;
	bool foundPut = false;
	bool isGetValid = false;
	bool isPutValid = false;

	for (pfi = fi.begin(); pfi != fiend; pfi++)
	{
		if (foundGet == false && pfi->name == name && pfi->dispatch_type == DISPATCH_PROPERTYGET)
		{
			foundGet = true;
			if (pfi->param.size() == 0)
			{
				isGetValid = true;
				paramGet = pfi->returnType;
				if (pfi->returnType.datatype == VT_VOID) isGetValid = false;
			}
		}
		if (foundPut == false && pfi->name == name && pfi->dispatch_type == DISPATCH_PROPERTYPUT)
		{
			foundPut = true;
			if (pfi->param.size() == 1)
			{
				isPutValid = true;
				paramPut = pfi->param[0];
			}
		}
	}
	//___________________________________________________ Compatible
	if (foundGet == true && foundPut == true)
	{
		return Com::FuncParam::AreCompatible(paramGet, paramPut);
	}
	else if (foundGet == true && foundPut == false)
	{
		return isGetValid;
	}
	else if (foundGet == false && foundPut == true)
	{
		return isPutValid;
	}
	return false;
}

bool FuncInfo::operator<(const FuncInfo& fi)
{
	return name < fi.name;
}

bool FuncInfo::IsEnumUserDefined(Com::FuncParam& param)
{
	if (param.datatype == VT_USERDEFINED || param.datatype == (VT_USERDEFINED | VT_BYREF))
	{
		if (param.typeKindLink == TKIND_ENUM)
		{
			return true;
		}
		else if (param.typeKindLink == TKIND_COCLASS)
		{
			return false;
		}
		else if (param.typeKindLink == TKIND_DISPATCH)
		{
			return false;
		}
	}
	return false;
}

bool FuncInfo::IsDataTypeObject(Com::FuncParam& param)
{
	if (param.datatype == VT_DISPATCH) return true;
	if (param.datatype == VT_PTR) return true;
	if (param.datatype == (VT_DISPATCH | VT_BYREF)) return true;
	if (param.datatype == (VT_PTR | VT_BYREF)) return true;
	if (param.datatype == VT_USERDEFINED || param.datatype == (VT_USERDEFINED | VT_BYREF))
	{
		if (param.typeKindLink == TKIND_ENUM)
		{
			return false;
		}
		else if (param.typeKindLink == TKIND_COCLASS)
		{
			return true;
		}
		else if (param.typeKindLink == TKIND_DISPATCH)
		{
			return true;
		}
	}

	return false;
}

bool FuncInfo::IsReturnedValueBool()
{
	if (returnType.datatype == VT_BOOL) return true;
	if (returnType.datatype == (VT_BOOL | VT_BYREF)) return true;
	return false;
}

bool FuncInfo::RequiresConversion(int datatype)
{
	if (datatype == VT_VARIANT) return true;
	if (datatype == (VT_VARIANT | VT_BYREF)) return true;
	return false;
}

//bool FuncInfo::IsReturnedValueVoid()
//{
//	if (returnType == VT_EMPTY) return true;
//	if (returnType == VT_NULL) return true;
//	if (returnType == VT_VOID) return true;
//	if (returnType == VT_RESERVED) return true;
//	if (returnType == VT_ILLEGAL) return true;
//	return false;
//}
//
//bool FuncInfo::IsReturnedValueWstring()
//{
//	if (returnType == VT_BSTR) return true;
//	if (returnType == VT_LPWSTR) return true;
//	if (returnType == (VT_BSTR | VT_BYREF)) return true;
//	if (returnType == (VT_LPWSTR | VT_BYREF)) return true;
//	return false;
//}

bool FuncInfo::ExludeFunction(bool includeAllParameters)
{
	//________________________________________________________ Do not include functions from: IUnknown nor IDispatch
	if (Com::FuncInfo::IsIUnknownFunction(name.c_str()) == true) return true;
	if (Com::FuncInfo::IsIDispatchFunction(name.c_str()) == true) return true;
	//________________________________________________________ Prevent rendering the function twice
	//                                                                                                                  Function 1 with all parameters (includeAllParameters is true)
	//                                                                                                                  Function 2 with required parameters only (includeAllParameters is false)
	if (includeAllParameters == true) return false;
	const int paramCount = (int)param.size();
	const int requiredCount = paramCount - numOptionalParameters;
	if (paramCount == 0) return true;
	if (paramCount == requiredCount) return true;
	return false;
}

void FuncInfo::RenderProperty(const wchar_t* nameSpace, bool earlyBinding, bool isIDispatch, list<Com::FuncInfo>& fi, wstring& output)
{
	//if (name == L"RGB")
	//{
	//	double y = 100.5;
	//	double x = sin(y);
	//}
	//___________________________________________________ Do we need to render?
	const bool hasProperty = HasProperty(fi);
	if (hasProperty == false) return;
	const bool hasGetProperty = HasGetProperty(fi);
	const bool hasPutProperty = HasPutProperty(fi);
	//___________________________________________________
	wstring text;
	wstring textReturnType;
	Com::FuncInfo::GetParamTypeText(true, nameSpace, earlyBinding, isIDispatch, returnType, textReturnType);
	if (textReturnType.length() <= 0) return;
	//_____________________________________________________________________________________ Property
	if (isNameValidForProperty == true)
	{
		
		if (dispatch_type == DISPATCH_PROPERTYGET && hasPutProperty == true)
		{
			Sys::Format(text, L"\t//\r\n\t__declspec(property(get=get_%s, put=put_%s)) %s %s;\r\n", name.c_str(), name.c_str(), textReturnType.c_str(), name.c_str());
			output += text;
		}
		else if (dispatch_type == DISPATCH_PROPERTYGET && hasPutProperty == false)
		{
			Sys::Format(text, L"\t//\r\n\t__declspec(property(get=get_%s)) %s %s;\r\n", name.c_str(), textReturnType.c_str(), name.c_str());
			output += text;
		}
		else if (dispatch_type == DISPATCH_PROPERTYPUT && hasGetProperty == false)
		{
			Sys::Format(text, L"\t//\r\n\t__declspec(property(put=put_%s)) %s %s;\r\n", name, textReturnType.c_str(), name.c_str());
			output += text;
		}
	}
	else
	{
		//______________________________________________________________________________________ Property Name is invalid, add an X
		if (dispatch_type == DISPATCH_PROPERTYGET && hasPutProperty == true)
		{
			Sys::Format(text, L"\t//\r\n\t__declspec(property(get=get_%s, put=put_%s)) %s %sX;\r\n", name.c_str(), name.c_str(), textReturnType.c_str(), name.c_str());
			output += text;
		}
		else if (dispatch_type == DISPATCH_PROPERTYGET && hasPutProperty == false)
		{
			Sys::Format(text, L"\t//\r\n\t__declspec(property(get=get_%s)) %s %sX;\r\n", name.c_str(), textReturnType.c_str(), name.c_str());
			output += text;
		}
		else if (dispatch_type == DISPATCH_PROPERTYPUT && hasGetProperty == false)
		{
			Sys::Format(text, L"\t//\r\n\t__declspec(property(put=put_%s)) %s %sX;\r\n", name, textReturnType.c_str(), name.c_str());
			output += text;
		}
	}
}

void FuncInfo::RenderFuncDeclaration(const wchar_t* nameSpace, bool earlyBinding, bool isIDispatch, bool includeAllParameters, wstring& output)
{
	if (ExludeFunction(includeAllParameters) == true) return;
	wstring text;

	wstring paramText;
	int i;
	//________________________________________________________ Help String
	if (helpString.length() > 0)
	{
		output += L"\t//\r\n\t// ";
		output += helpString;
		output += L"\r\n";
	}
	//________________________________________________________ Return Type
	Com::FuncInfo::GetParamTypeText(true, nameSpace, earlyBinding, isIDispatch, returnType, paramText);
	output += L"\t";
	output += paramText;
	output += L" ";
	//
	//_______________________________________________________ Function Type
	if (dispatch_type == DISPATCH_METHOD)
	{
		Sys::Format(text, L"%s(", name.c_str());
	}
	else if (dispatch_type == DISPATCH_PROPERTYGET)
	{
		Sys::Format(text, L"get_%s(", name.c_str());
	}
	else if (dispatch_type == DISPATCH_PROPERTYPUT)
	{
		Sys::Format(text, L"put_%s(", name.c_str());
	}
	if (dispatch_type == DISPATCH_PROPERTYPUTREF)
	{
		Sys::Format(text, L"put_%s(", name.c_str());
	}
	output += text;
	//____________________________________________ Parameters
	const int paramCount = (int)param.size();
	const int requiredCount = paramCount - numOptionalParameters;
	const int count = (includeAllParameters == true) ? paramCount : requiredCount;
	for (i = 0; i < count; i++)
	{
		//output += Com::FuncInfo::GetParamTypeText(param[i].datatype);
		Com::FuncInfo::GetParamTypeText(false, nameSpace, earlyBinding, isIDispatch, param[i], paramText);
		output += paramText;
		//
		output += L" ";
		output += param[i].name;
		if (i != count - 1) output += L", ";
	}
	output += L");\r\n";
}

void FuncInfo::RenderFuncDefinition(const wchar_t* nameSpace, bool earlyBinding, bool isIDispatch, const wchar_t* className, bool includeAllParameters, wstring& output)
{
	if (ExludeFunction(includeAllParameters) == true) return;
	wstring text;
	wstring returnParamText;
	wstring paramText;
	int i;
	//________________________________________________________ Return Type
	Com::FuncInfo::GetParamTypeText(true, nameSpace, earlyBinding, isIDispatch, returnType, returnParamText);
	output += returnParamText;
	output += L" ";
	output += className;
	output += L"::";
	//
	//_______________________________________________________ Function Type
	if (dispatch_type == DISPATCH_METHOD)
	{
		Sys::Format(text, L"%s(", name.c_str());
	}
	else if (dispatch_type == DISPATCH_PROPERTYGET)
	{
		Sys::Format(text, L"get_%s(", name.c_str());
	}
	else if (dispatch_type == DISPATCH_PROPERTYPUT)
	{
		Sys::Format(text, L"put_%s(", name.c_str());
	}
	else if (dispatch_type == DISPATCH_PROPERTYPUTREF)
	{
		Sys::Format(text, L"put_%s(", name.c_str());
	}
	output += text;
	//____________________________________________ Parameters
	const int paramCount = (int)param.size();
	const int requiredCount = paramCount - numOptionalParameters;
	const int count = (includeAllParameters == true) ? paramCount : requiredCount;
	for (i = 0; i < count; i++)
	{
		Com::FuncInfo::GetParamTypeText(false, nameSpace, earlyBinding, isIDispatch, param[i], paramText);
		output += paramText;
		output += L" ";
		output += param[i].name;
		if (i != count - 1) output += L", ";
	}
	output += L")\r\n{\r\n";
	//______________________________________________________ Declared returnedValue;
	if (IsDataTypeObject(returnType) == true)
	{
		if (isIDispatch == true)
		{
			output += L"\tCom::Object returnedValue;\r\n";
		}
		else
		{
			output += L"\t";
			output += returnParamText;
			output += L" returnedValue;\r\n";
		}
	}
	else
	{
		output += L"\t_variant_t returnedValue;\r\n";
	}
	//______________________________________________________ Com::Param param;
	if (paramCount == 0)
	{
		output += L"\tCom::Param param;\r\n";
	}
	else
	{
		Sys::Format(text, L"\tCom::Param param(%d);\r\n", count);
		output += text;
	}
	for (i = 0; i < count; i++)
	{
		RenderParameter(i, output);
	}

	//_____________________________________________________ Invoke
	const wchar_t *dispatch_typeText = GetFuncTypeText();
	Sys::Format(text, L"\tInvoke(%d, %d, L\"%s\", param, returnedValue, %s);\r\n", count, memid, name.c_str(), dispatch_typeText);
	output += text;
	//______________________________________________________ return
	RenderReturnedValue(returnParamText, output);
	//_____________________________________________________ Function End
	output += L"}\r\n\r\n";
}

void FuncInfo::RenderParameter(int paramIndex, wstring& output)
{
	wstring text;
	const wchar_t* variantText = GetVariantText(param[paramIndex].datatype);
	if (variantText == NULL) return;
	const wchar_t* vtText = GetVariantVT(param[paramIndex].datatype);
	if (vtText == NULL) return;
	//_________________________________________________________________________________________ FIRST LINE
	if (param[paramIndex].datatype == VT_VARIANT || param[paramIndex].datatype == (VT_VARIANT | VT_BYREF))
	{
		// Nothing
	}
	else if (IsDataTypeObject(param[paramIndex]) == true)
	{
		Sys::Format(text, L"\tparam[%d].vt = VT_DISPATCH;\r\n", paramIndex);
	}
	else if (IsEnumUserDefined(param[paramIndex]) == true)
	{
		Sys::Format(text, L"\tparam[%d].vt = VT_I2;\r\n", paramIndex);
	}
	else
	{
		Sys::Format(text, L"\tparam[%d].vt = %s;\r\n", paramIndex, vtText);
	}
	output += text;
	//_________________________________________________________________________________________ SECOND LINE
	if (param[paramIndex].datatype == VT_VARIANT || param[paramIndex].datatype == (VT_VARIANT | VT_BYREF))
	{
		Sys::Format(text, L"\tparam[%d] = %s;\r\n", paramIndex, param[paramIndex].name.c_str());
	}
	else if (param[paramIndex].datatype == VT_BSTR)
	{
		Sys::Format(text, L"\tparam[%d].%s = _bstr_t(%s.c_str());\r\n", paramIndex, variantText, param[paramIndex].name.c_str());
	}
	else if (param[paramIndex].datatype == VT_BOOL)
	{
		Sys::Format(text, L"\tparam[%d].%s = (%s == true) ? 1: 0;\r\n", paramIndex, variantText, param[paramIndex].name.c_str());
	}
	else if (param[paramIndex].datatype == VT_DATE)
	{
		//Sys::Format(text, L"\tparam[%d].%s = (%s == true) ? 1: 0;\r\n", paramIndex, variantText, param[paramIndex].name);
		Sys::Format(text, L"\tparam[%d] = Sys::Convert::DateToVariant(%s);\r\n", paramIndex, param[paramIndex].name.c_str());
	}
	else if (param[paramIndex].datatype == (VT_BSTR | VT_BYREF))
	{
		Sys::Format(text, L"\tparam[%d].%s = &%s.GetBSTR();\r\n", paramIndex, variantText, param[paramIndex].name.c_str());
	}
	else if (param[paramIndex].datatype == (VT_SAFEARRAY | VT_BYREF))
	{
		Sys::Format(text, L"\tparam[%d].%s = &%s;\r\n", paramIndex, variantText, param[paramIndex].name.c_str());
	}
	else if (IsDataTypeObject(param[paramIndex]) == true)
	{
		Sys::Format(text, L"\tparam[%d].pdispVal = %s.dispatch.GetInterfacePtr();\r\n", paramIndex, param[paramIndex].name.c_str());
	}
	else if (IsEnumUserDefined(param[paramIndex]) == true)
	{
		Sys::Format(text, L"\tparam[%d].iVal = %s;\r\n", paramIndex, param[paramIndex].name.c_str());
	}
	else if (RequiresConversion(param[paramIndex].datatype) == true)
	{
		Sys::Format(text, L"\tparam[%d].%s = %s.%s;\r\n", paramIndex, variantText, param[paramIndex].name.c_str(), variantText);
	}
	else
	{
		if ((param[paramIndex].datatype & VT_BYREF) != 0)
		{
			Sys::Format(text, L"\tparam[%d].%s = &%s;\r\n", paramIndex, variantText, param[paramIndex].name.c_str());
		}
		else
		{
			Sys::Format(text, L"\tparam[%d].%s = %s;\r\n", paramIndex, variantText, param[paramIndex].name.c_str());
		}
	}
	output += text;
}

void FuncInfo::RenderReturnedValue(const wstring& returnParamText, wstring& output)
{
	if (returnType.datatype == VT_VOID)
	{
	}
	else if (returnType.datatype == VT_VARIANT)
	{
		output += L"\treturn returnedValue;\r\n";
	}
	else if (IsDataTypeObject(returnType) == true)
	{
		output += L"\treturn returnedValue; \r\n";
	}
	else if (IsReturnedValueBool() == true)
	{
		const wchar_t* variantText = GetVariantText(returnType.datatype);
		if (variantText == NULL) return;
		output += L"\treturn (returnedValue.";
		output += variantText;
		output += L" != 0);\r\n";
	}
	else if ((returnType.datatype == VT_DATE) || (returnType.datatype == (VT_DATE | VT_BYREF)))
	{
		output += L"\treturn Sys::Convert::VariantToTime(returnedValue);\r\n";
	}
	else
	{
		const wchar_t* variantText = GetVariantText(returnType.datatype);
		if (variantText == NULL) return;
		if (IsEnumUserDefined(returnType) == true)
		{
			output += L"\treturn (";
			output += returnParamText;
			output += L")returnedValue.";
			output += variantText;
			output += L";\r\n";
		}
		else
		{
			output += L"\treturn returnedValue.";
			output += variantText;
			output += L";\r\n";
		}
	}
}

wchar_t* FuncInfo::GetFuncTypeText(int dispatch_type)
{
	switch (dispatch_type)
	{
	case DISPATCH_METHOD: return L"Method";
	case DISPATCH_PROPERTYGET: return L"Get";
	case DISPATCH_PROPERTYPUT: return L"Put";
	case DISPATCH_PROPERTYPUTREF: return L"PutRef";
	}
	return L"Error";
}

wchar_t* FuncInfo::GetFuncTypeText()
{
	switch (dispatch_type)
	{
	case DISPATCH_METHOD: return L"DISPATCH_METHOD";
	case DISPATCH_PROPERTYGET: return L"DISPATCH_PROPERTYGET";
	case DISPATCH_PROPERTYPUT: return L"DISPATCH_PROPERTYPUT";
	case DISPATCH_PROPERTYPUTREF: return L"DISPATCH_PROPERTYPUTREF";
	}
	return L"Error";
}

wchar_t* FuncInfo::GetFuncCallConvText(int callConv)
{
	switch (callConv)
	{
	case CC_FASTCALL: return L"fastcall";
	case CC_CDECL: return L"cdecl";
	case CC_PASCAL: return L"pascal";
	case CC_MACPASCAL: return L"macpascal";
	case CC_STDCALL: return L"stdcall";
	case CC_FPFASTCALL: return L"fpfastcall";
	case CC_SYSCALL: return L"syscall";
	case CC_MPWCDECL: return L"mpwcdecl";
	case CC_MPWPASCAL: return L"mpwpascal";
	case CC_MAX: return L"max";
	}
	return L"error";
}

bool FuncInfo::IsIUnknownFunction(const wchar_t* functionName)
{
	if (wcscmp(functionName, L"QueryInterface") == 0) return true;
	if (wcscmp(functionName, L"AddRef") == 0) return true;
	if (wcscmp(functionName, L"Release") == 0) return true;
	return false;
}

bool FuncInfo::IsIDispatchFunction(const wchar_t* functionName)
{
	if (wcscmp(functionName, L"GetTypeInfoCount") == 0) return true;
	if (wcscmp(functionName, L"GetTypeInfo") == 0) return true;
	if (wcscmp(functionName, L"GetIDsOfNames") == 0) return true;
	if (wcscmp(functionName, L"Invoke") == 0) return true;
	return false;
}

void FuncInfo::GetParamTypeText(bool isReturn, const wchar_t* nameSpace, bool earlyBinding, bool isIDispatch, Com::FuncParam& param, wstring& output)
{
	const wchar_t * text = Com::FuncInfo::GetParamTypeText(param.datatype);
	const bool isUserDefined = (param.datatype == VT_USERDEFINED);
	const bool isUserDefinedByRef = (param.datatype == (VT_USERDEFINED | VT_BYREF));
	const bool isVariant = (param.datatype == VT_VARIANT) || (param.datatype == (VT_VARIANT | VT_BYREF));
	wstring sname;
	Com::Assistant::CreateClassName(param.descrLink, sname);

	if (isIDispatch == true) // ______________________________________________________________  IDispatch: Obviously earlyBinding is false
	{
		output.clear();
		//_____________________ Add comment describing variable
		if (sname.empty() == false && isVariant == false)
		{
			output += L"/* ";
			output += sname;
			output += L" */ ";
		}
		if (isUserDefined == true)
		{
			if (param.typeKindLink == TKIND_ENUM || param.typeKindLink == TKIND_ALIAS)
			{
				output += L"short";
			}
			else if (param.typeKindLink == TKIND_DISPATCH || param.typeKindLink == TKIND_COCLASS)
			{
				output += L"Com::Object";
			}
			else
			{
				output += L"short";
			}
		}
		else if (isUserDefinedByRef == true)
		{
			if (param.typeKindLink == TKIND_ENUM || param.typeKindLink == TKIND_ALIAS)
			{
				if (isReturn == true)
				{
					output += L"short";
				}
				else
				{
					output += L"short&";
				}
			}
			else if (param.typeKindLink == TKIND_DISPATCH || param.typeKindLink == TKIND_COCLASS)
			{
				if (isReturn == true)
				{
					output += L"Com::Object";
				}
				else
				{
					output += L"Com::Object&";
				}
			}
			else
			{
				if (isReturn == true)
				{
					output += L"short";
				}
				else
				{
					output += L"short&";
				}
			}
		}
		else
		{
			output += text;
		}
	}
	else //_____________________________________________________________________________________________
	{
		if (isUserDefined == true)
		{
			if (param.typeKindLink == TKIND_ENUM)
			{
				if (sname.empty() == true)
				{
					output = L"short";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ short";
					
				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
				}
			}
			else if (param.typeKindLink == TKIND_DISPATCH)
			{
				if (sname.empty() == true)
				{
					output = L"Com::Object";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ Com::Object";

				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
				}
			}
			else if (param.typeKindLink == TKIND_COCLASS)
			{
				if (sname.empty() == true)
				{
					output = L"Com::Object";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ Com::Object";

				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
				}
			}
			else if (param.typeKindLink == TKIND_ALIAS)
			{
				if (sname.empty() == true)
				{
					output = L"short";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ short";

				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
				}
			}
			else
			{
				output = text;
			}
		}
		else if (isUserDefinedByRef == true)
		{
			if (param.typeKindLink == TKIND_ENUM)
			{
				if (sname.empty() == true)
				{
					output = L"short";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ short";

				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
					if (isReturn == false) output += L"&";
				}
			}
			else if (param.typeKindLink == TKIND_DISPATCH)
			{
				if (sname.empty() == true)
				{
					output = L"Com::Object";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ Com::Object";

				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
					if (isReturn == false) output += L"&";
				}
			}
			else if (param.typeKindLink == TKIND_COCLASS)
			{
				if (sname.empty() == true)
				{
					output = L"Com::Object";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ Com::Object";

				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
					if (isReturn == false) output += L"&";
				}
			}
			else if (param.typeKindLink == TKIND_ALIAS)
			{
				if (sname.empty() == true)
				{
					output = L"short";
				}
				else if (param.isValid == false)
				{
					output = L"/* ";
					output += sname;
					output += L"*/ short";

				}
				else
				{
					output = nameSpace;
					output += L"::";
					output += sname;
					if (isReturn == false) output += L"&";
				}
			}
			else
			{
				output = text;
			}
		}
		else
		{
			output = text;
		}
	}
}

wchar_t* FuncInfo::GetParamTypeText(WORD vt)
{
	switch (vt)
	{
	case VT_EMPTY: return L"";
	case VT_NULL: return L"NULL";
	case VT_I2: return L"short"; // value->iVal, SHORT = short
	case VT_I4: return L"long"; // value->lVal LONG = long
	case VT_R4: return L"float"; // value->fltVal FLOAT = float
	case VT_R8: return L"double"; // value->dblVal DOUBLE = double
	case VT_CY: return L"CY"; // value->cyVal CY
	case VT_DATE: return L"Sys::Time"; // value->date DATE = double
	case VT_BSTR: return L"wstring"; // value->bstrVal BSTR = wchar_t *
	case VT_DISPATCH: return L"Com::Object"; //L"IDispatchPtr"; // value->pdispVal IDispatch = DISPATCH* = LPDISPATCH
	case VT_ERROR: return L"long"; // value->scode SCODE = LONG
	case VT_BOOL: return L"bool"; //value = boolVal VARIANT_BOOL = short (FALSE = 0, TRUE = -1)
	case VT_VARIANT: return L"_variant_t"; //*value VARIANT
	case VT_UNKNOWN: return L"IUnknownPtr"; //value->punkVal IUnknown = UNKNOWN* = LPUNKNOWN
	case VT_DECIMAL: return L"DECIMAL"; //  value->decVal DECIMAL
	case VT_I1: return L"char";  // value->bVal, CHAR = char
	case VT_UI1: return L"unsigned char";  // value->bVal, BYTE = unsigned char
	case VT_UI2: return L"unsigned short"; // value->uiVal USHORT = unsigned short
	case VT_UI4: return L"unsigned long"; // value->ulVal ULONG = unsigned long
	case VT_I8: return L"long long"; // value->llVal LONGLONG = long long
	case VT_UI8: return L"unsigned long long"; // value->ullVal ULONGLONG = unsigned long long
	case VT_INT: return L"int"; // value->intVal INT = int
	case VT_UINT: return L"unsigned int"; // value->uintVal UINT = unsigned int
	case VT_VOID: return L"void"; // value->byref PVOID = void*
	case VT_HRESULT: return L"HRESULT"; // value->
	case VT_PTR: return L"Com::Object"; // value->byref PVOID = void*
	case VT_SAFEARRAY: return L"SAFEARRAY"; //value->parray SAFEARRAY
	case VT_CARRAY: return L"void*"; // value->byref PVOID = void*
	case VT_USERDEFINED: return L"USERDEFINED";
	case VT_LPSTR: return L"char *"; // value->pcVal CHAR* = char*
	case VT_LPWSTR: return L"wchar_t *"; // value->pbstrVal BSTR* = wchar_t*
	case VT_RECORD: return L"RECORD";
#ifndef __vsshell_h__
	case VT_INT_PTR: return L"int *"; // value->pintVal INT* = int*
	case VT_UINT_PTR: return L"unsigned int *"; // value ->puintVal UINT * unsigned int*
#endif
	case VT_ARRAY: return L"array";
		//________________________________________________________________ BYREF
	case VT_I2 | VT_BYREF: return L"short&"; // value->piVal, SHORT* = short*
	case VT_I4 | VT_BYREF: return L"long&"; // value->plVal LONG* = long*
	case VT_R4 | VT_BYREF: return L"float&"; // value->pfltVal FLOAT* = float*
	case VT_R8 | VT_BYREF: return L"double&"; // value->pdblVal DOUBLE* = double*
	case VT_CY | VT_BYREF: return L"CY&"; // value->pcyVal CY*
	case VT_DATE | VT_BYREF: return L"Sys::Time&"; // value->pdate DATE* = double*
	case VT_BSTR | VT_BYREF: return L"_bstr_t&"; // value->pbstrVal BSTR* = wchar_t **
	case VT_DISPATCH | VT_BYREF: return L"Com::Object&";//L"IDispatchPtr*"; // value->ppdispVal IDispatch* = DISPATCH** = LPDISPATCH*
	case VT_ERROR | VT_BYREF: return L"long&"; // value->pscode SCODE* = LONG*
	case VT_BOOL | VT_BYREF: return L"VARIANT_BOOL&"; //value = pboolVal VARIANT_BOOL* = short (FALSE = 0, TRUE = -1)
	case VT_VARIANT | VT_BYREF: return L"_variant_t&"; //value->pvarVal VARIANT*
	case VT_UNKNOWN | VT_BYREF: return L"IUnknownPtr&"; //value->ppunkVal IUnknown* = UNKNOWN** = LPUNKNOWN*
	case VT_DECIMAL | VT_BYREF: return L"DECIMAL&"; //  value->pdecVal  DECIMAL
	case VT_I1 | VT_BYREF: return L"char&";  // value->pbVal, CHAR* = char*
	case VT_UI1 | VT_BYREF: return L"unsigned char&";  // value->pbVal, BYTE* = unsigned char*
	case VT_UI2 | VT_BYREF: return L"unsigned short&"; // value->puiVal USHORT* = unsigned short*
	case VT_UI4 | VT_BYREF: return L"unsigned long&"; // value->pulVal ULONG* = unsigned long*
	case VT_I8 | VT_BYREF: return L"long long&"; // value->pllVal LONGLONG* = long long*
	case VT_UI8 | VT_BYREF: return L"unsigned long long&"; // value->pullVal ULONGLONG = unsigned long long *
	case VT_INT | VT_BYREF: return L"int&"; // value->pintVal INT* = int*
	case VT_UINT | VT_BYREF: return L"unsigned int&"; // value->puintVal UINT* = unsigned int*
	case VT_VOID | VT_BYREF: return L"void*"; // value->byref PVOID = void*
	case VT_HRESULT | VT_BYREF: return L"HRESULT&"; // value->
	case VT_PTR | VT_BYREF: return L"Com::Object&"; // value->byref PVOID = void*
	case VT_SAFEARRAY | VT_BYREF: return L"SAFEARRAY*"; //value->pparray SAFEARRAY*
	case VT_CARRAY | VT_BYREF: return L"void**"; // value->pbyref PVOID = void**
	case VT_USERDEFINED | VT_BYREF: return L"USERDEFINED*";
	case VT_LPSTR | VT_BYREF: return L"char **"; // value->ppcVal CHAR** = char**
	case VT_LPWSTR | VT_BYREF: return L"wchar_t **"; // value->ppbstrVal BSTR* = wchar_t**
	case VT_RECORD | VT_BYREF: return L"RECORD**";
#ifndef __vsshell_h__
	case VT_INT_PTR | VT_BYREF: return L"int ***"; // value->ppintVal INT** = int**
	case VT_UINT_PTR | VT_BYREF: return L"unsigned int ***"; // value ->ppuintVal UINT ** unsigned int**
#endif
	case VT_ARRAY | VT_BYREF: return L"array*";
		//________________________________________________________________ SPECIAL
	case VT_RESERVED: return L"reserved";
	case VT_ILLEGAL: return L"illegal";
	case VT_TYPEMASK: return L"typemask";
	}
	return L"void";
}

wchar_t* FuncInfo::GetVariantText(WORD vt)
{
	switch (vt)
	{
	case VT_EMPTY: return NULL;
	case VT_NULL: return NULL;
	case VT_I2: return L"iVal";
	case VT_I4: return L"lVal";
	case VT_R4: return L"fltVal";
	case VT_R8: return L"dblVal";
	case VT_CY: return L"cyVal";
	case VT_DATE: return L"date";
	case VT_BSTR: return L"bstrVal";
	case VT_DISPATCH: return L"pdispVal";
	case VT_ERROR: return L"scode";
	case VT_BOOL: return L"boolVal";
	case VT_VARIANT: return L"varVal";
	case VT_UNKNOWN: return L"punkVal";
	case VT_DECIMAL: return L"decVal";
	case VT_I1: return L"bVal";
	case VT_UI1: return L"bVal";
	case VT_UI2: return L"uiVal";
	case VT_UI4: return L"ulVal";
	case VT_I8: return L"llVal";
	case VT_UI8: return L"ullVal";
	case VT_INT: return L"intVal";
	case VT_UINT: return L"uintVal";
	case VT_VOID: return L"byref";
	case VT_HRESULT: return L"lVal";
	case VT_PTR: return L"byref";
	case VT_SAFEARRAY: return L"parray";
	case VT_CARRAY: return L"byref";
	case VT_USERDEFINED: return L"iVal";
	case VT_LPSTR: return L"pcVal";
	case VT_LPWSTR: return L"pbstrVal";
	case VT_RECORD: return L"dummy";
#ifndef __vsshell_h__
	case VT_INT_PTR: return L"pintVal";
	case VT_UINT_PTR: return L"puintVal";
#endif
	case VT_ARRAY: return L"dummy";
		//________________________________________________________________ BYREF
	case VT_I2 | VT_BYREF: return L"piVal";
	case VT_I4 | VT_BYREF: return L"plVal";
	case VT_R4 | VT_BYREF: return L"pfltVal";
	case VT_R8 | VT_BYREF: return L"pdblVal";
	case VT_CY | VT_BYREF: return L"pcyVal";
	case VT_DATE | VT_BYREF: return L"pdate";
	case VT_BSTR | VT_BYREF: return L"pbstrVal";
	case VT_DISPATCH | VT_BYREF: return L"ppdispVal";
	case VT_ERROR | VT_BYREF: return L"pscode";
	case VT_BOOL | VT_BYREF: return L"pboolVal";
	case VT_VARIANT | VT_BYREF: L"pvarVal";
	case VT_UNKNOWN | VT_BYREF: return L"ppunkVal";
	case VT_DECIMAL | VT_BYREF: return L"pdecVal";
	case VT_I1 | VT_BYREF: return L"pbVal";
	case VT_UI1 | VT_BYREF: return L"pbVal";
	case VT_UI2 | VT_BYREF: return L"puiVal";
	case VT_UI4 | VT_BYREF: return L"pulVal";
	case VT_I8 | VT_BYREF: return L"pllVal";
	case VT_UI8 | VT_BYREF: return L"pullVal";
	case VT_INT | VT_BYREF: return L"pintVal";
	case VT_UINT | VT_BYREF: return L"puintVal";
	case VT_VOID | VT_BYREF: return L"byref";
	case VT_HRESULT | VT_BYREF: return L"plVal";
	case VT_PTR | VT_BYREF: return L"byref";
	case VT_SAFEARRAY | VT_BYREF: return L"pparray";
	case VT_CARRAY | VT_BYREF: return L"byref";
	case VT_USERDEFINED | VT_BYREF: return L"piVal";
	case VT_LPSTR | VT_BYREF: return L"ppcVal";
	case VT_LPWSTR | VT_BYREF: return L"ppbstrVal";
	case VT_RECORD | VT_BYREF: return L"dummy";
#ifndef __vsshell_h__
	case VT_INT_PTR | VT_BYREF: return L"ppintVal";
	case VT_UINT_PTR | VT_BYREF: return L"ppuintVal";
#endif
	case VT_ARRAY | VT_BYREF: return L"dummy";
		//________________________________________________________________ SPECIAL
	case VT_RESERVED: return NULL;
	case VT_ILLEGAL: return NULL;
	case VT_TYPEMASK: return NULL;
	}
	return NULL;
}

wchar_t* FuncInfo::GetVariantVT(WORD vt)
{
	switch (vt)
	{
	case VT_EMPTY: return L"VT_EMPTY";
	case VT_NULL: return L"VT_NULL";
	case VT_I2: return L"VT_I2";
	case VT_I4: return L"VT_I4";
	case VT_R4: return L"VT_R4";
	case VT_R8: return L"VT_R8";
	case VT_CY: return L"VT_CY";
	case VT_DATE: return L"VT_DATE";
	case VT_BSTR: return L"VT_BSTR";
	case VT_DISPATCH: return L"VT_DISPATCH";
	case VT_ERROR: return L"VT_ERROR";
	case VT_BOOL: return L"VT_BOOL";
	case VT_VARIANT: return L"VT_VARIANT";
	case VT_UNKNOWN: return L"VT_UNKNOWN";
	case VT_DECIMAL: return L"VT_DECIMAL";
	case VT_I1: return L"VT_I1";
	case VT_UI1: return L"VT_UI1";
	case VT_UI2: return L"VT_UI2";
	case VT_UI4: return L"VT_UI4";
	case VT_I8: return L"VT_I8";
	case VT_UI8: return L"VT_UI8";
	case VT_INT: return L"VT_INT";
	case VT_UINT: return L"VT_UINT";
	case VT_VOID: return L"VT_VOID";
	case VT_HRESULT: return L"VT_HRESULT";
	case VT_PTR: return L"VT_PTR ";
	case VT_SAFEARRAY: return L"VT_SAFEARRAY";
	case VT_CARRAY: return L"VT_CARRAY";
	case VT_USERDEFINED: return L"VT_USERDEFINED";
	case VT_LPSTR: return L"VT_LPSTR";
	case VT_LPWSTR: return L"VT_LPWSTR";
	case VT_RECORD: return L"VT_RECORD";
#ifndef __vsshell_h__
	case VT_INT_PTR: return L"VT_INT_PTR";
	case VT_UINT_PTR: return L"VT_UINT_PTR";
#endif
	case VT_ARRAY: return NULL;
		//________________________________________________________________ BYREF
	case VT_I2 | VT_BYREF: return L"VT_I2 | VT_BYREF";
	case VT_I4 | VT_BYREF: return L"VT_I4 | VT_BYREF";
	case VT_R4 | VT_BYREF: return L"VT_R4 | VT_BYREF";
	case VT_R8 | VT_BYREF: return L"VT_R8 | VT_BYREF";
	case VT_CY | VT_BYREF: return L"T_CY | VT_BYREF";
	case VT_DATE | VT_BYREF: return L"VT_DATE | VT_BYREF";
	case VT_BSTR | VT_BYREF: return L"VT_BSTR | VT_BYREF";
	case VT_DISPATCH | VT_BYREF: return L"VT_DISPATCH | VT_BYREF";
	case VT_ERROR | VT_BYREF: return L"VT_ERROR | VT_BYREF";
	case VT_BOOL | VT_BYREF: return L"VT_BOOL | VT_BYREF";
	case VT_VARIANT | VT_BYREF: return L"VT_VARIANT | VT_BYREF";
	case VT_UNKNOWN | VT_BYREF: return L"VT_UNKNOWN | VT_BYREF";
	case VT_DECIMAL | VT_BYREF: return L"VT_DECIMAL | VT_BYREF";
	case VT_I1 | VT_BYREF: return L"VT_I1 | VT_BYREF";
	case VT_UI1 | VT_BYREF: return L"VT_UI1 | VT_BYREF";
	case VT_UI2 | VT_BYREF: return L"VT_UI2 | VT_BYREF";
	case VT_UI4 | VT_BYREF: return L"VT_UI4 | VT_BYREF";
	case VT_I8 | VT_BYREF: return L"VT_I8 | VT_BYREF";
	case VT_UI8 | VT_BYREF: return L"VT_UI8 | VT_BYREF";
	case VT_INT | VT_BYREF: return L"VT_INT | VT_BYREF";
	case VT_UINT | VT_BYREF: return L"VT_UINT | VT_BYREF";
	case VT_VOID | VT_BYREF: return L"VT_VOID | VT_BYREF";
	case VT_HRESULT | VT_BYREF: return L"VT_HRESULT | VT_BYREF";
	case VT_PTR | VT_BYREF: return L"VT_PTR | VT_BYREF";
	case VT_SAFEARRAY | VT_BYREF: return L"VT_SAFEARRAY | VT_BYREF";
	case VT_CARRAY | VT_BYREF: return L"VT_CARRAY | VT_BYREF";
	case VT_USERDEFINED | VT_BYREF: return L"VT_USERDEFINED | VT_BYREF";
	case VT_LPSTR | VT_BYREF: return L"VT_LPSTR | VT_BYREF:";
	case VT_LPWSTR | VT_BYREF: return L"VT_LPWSTR | VT_BYREF";
	case VT_RECORD | VT_BYREF: return L"VT_RECORD | VT_BYREF";
#ifndef __vsshell_h__
	case VT_INT_PTR | VT_BYREF: return L"VT_INT_PTR | VT_BYREF";
	case VT_UINT_PTR | VT_BYREF: return L"VT_UINT_PTR | VT_BYREF";
#endif
	case VT_ARRAY | VT_BYREF: return L"VT_ARRAY | VT_BYREF";
		//________________________________________________________________ SPECIAL
	case VT_RESERVED: return L"VT_RESERVED";
	case VT_ILLEGAL: return L"VT_ILLEGAL";
	case VT_TYPEMASK: return L"VT_TYPEMASK";
	}
	return NULL;
}

wchar_t* FuncInfo::GetParamTypeText(WORD vt, bool cppTypes)
{
	if (cppTypes == true)
	{
		switch (vt)
		{
		case VT_EMPTY: return L"";
		case VT_NULL: return L"NULL";
		case VT_I2: return L"__int16"; // value->iVal, SHORT = short
		case VT_I4: return L"__int32"; // value->lVal LONG = long
		case VT_R4: return L"float"; // value->fltVal FLOAT = float
		case VT_R8: return L"double"; // value->dblVal DOUBLE = double
		case VT_CY: return L"CY"; // value->cyVal CY
		case VT_DATE: return L"DATE"; // value->date DATE = double
		case VT_BSTR: return L"_bstr_t"; // value->bstrVal BSTR = wchar_t *
		case VT_DISPATCH: return L"Com::Object"; //L"IDispatchPtr"; // value->pdispVal IDispatch = DISPATCH* = LPDISPATCH
		case VT_ERROR: return L"SCODE"; // value->scode SCODE = LONG
		case VT_BOOL: return L"bool"; //value = boolVal VARIANT_BOOL = short (FALSE = 0, TRUE = -1)
		case VT_VARIANT: return L"_variant_t"; //*value VARIANT
		case VT_UNKNOWN: return L"IUnknownPtr"; //value->punkVal IUnknown = UNKNOWN* = LPUNKNOWN
		case VT_DECIMAL: return L"DECIMAL"; //  value->decVal DECIMAL
		case VT_I1: return L"__int8";  // value->bVal, CHAR = char
		case VT_UI1: return L"unsigned __int8";  // value->bVal, BYTE = unsigned char
		case VT_UI2: return L"unsigned __int16"; // value->uiVal USHORT = unsigned short
		case VT_UI4: return L"unsigned __int32"; // value->ulVal ULONG = unsigned long
		case VT_I8: return L"__int64"; // value->llVal LONGLONG = long long
		case VT_UI8: return L"unsigned long long"; // value->ullVal ULONGLONG = unsigned long long
		case VT_INT: return L"int"; // value->intVal INT = int
		case VT_UINT: return L"unsigned int"; // value->uintVal UINT = unsigned int
		case VT_VOID: return L"void"; // value->byref PVOID = void*
		case VT_HRESULT: return L"HRESULT"; // value->
		case VT_PTR: return L"Com::Object"; // value->byref PVOID = void*
		case VT_SAFEARRAY: return L"SAFEARRAY"; //value->parray SAFEARRAY
		case VT_CARRAY: return L"CARRAY"; // value->byref PVOID = void*
		case VT_USERDEFINED: return L"USERDEFINED";
		case VT_LPSTR: return L"char *"; // value->pcVal CHAR* = char*
		case VT_LPWSTR: return L"wchar_t *"; // value->pbstrVal BSTR* = wchar_t*
		case VT_RECORD: return L"RECORD";
#ifndef __vsshell_h__
		case VT_INT_PTR: return L"int *"; // value->pintVal INT* = int*
		case VT_UINT_PTR: return L"unsigned int *"; // value ->puintVal UINT * unsigned int*
#endif
		case VT_ARRAY: return L"array";
			//________________________________________________________________ BYREF
		case VT_I2 | VT_BYREF: return L"__int16&"; // value->piVal, SHORT* = short*
		case VT_I4 | VT_BYREF: return L"__int32&"; // value->plVal LONG* = long*
		case VT_R4 | VT_BYREF: return L"float&"; // value->pfltVal FLOAT* = float*
		case VT_R8 | VT_BYREF: return L"double&"; // value->pdblVal DOUBLE* = double*
		case VT_CY | VT_BYREF: return L"CY&"; // value->pcyVal CY*
		case VT_DATE | VT_BYREF: return L"DATE&"; // value->pdate DATE* = double*
		case VT_BSTR | VT_BYREF: return L"_bstr_t&"; // value->pbstrVal BSTR* = wchar_t **
		case VT_DISPATCH | VT_BYREF: return L"Com::Object&";//L"IDispatchPtr*"; // value->ppdispVal IDispatch* = DISPATCH** = LPDISPATCH*
		case VT_ERROR | VT_BYREF: return L"SCODE&"; // value->pscode SCODE* = LONG*
		case VT_BOOL | VT_BYREF: return L"bool&"; //value = pboolVal VARIANT_BOOL* = short (FALSE = 0, TRUE = -1)
		case VT_VARIANT | VT_BYREF: return L"_variant_t&"; //value->pvarVal VARIANT*
		case VT_UNKNOWN | VT_BYREF: return L"IUnknownPtr&"; //value->ppunkVal IUnknown* = UNKNOWN** = LPUNKNOWN*
		case VT_DECIMAL | VT_BYREF: return L"DECIMAL&"; //  value->pdecVal  DECIMAL
		case VT_I1 | VT_BYREF: return L"__int8&";  // value->pbVal, CHAR* = char*
		case VT_UI1 | VT_BYREF: return L"unsigned __int8&";  // value->pbVal, BYTE* = unsigned char*
		case VT_UI2 | VT_BYREF: return L"unsigned __int16&"; // value->puiVal USHORT* = unsigned short*
		case VT_UI4 | VT_BYREF: return L"unsigned __int32&"; // value->pulVal ULONG* = unsigned long*
		case VT_I8 | VT_BYREF: return L"__int64&"; // value->pllVal LONGLONG* = long long*
		case VT_UI8 | VT_BYREF: return L"unsigned __int64&"; // value->pullVal ULONGLONG = unsigned long long *
		case VT_INT | VT_BYREF: return L"int&"; // value->pintVal INT* = int*
		case VT_UINT | VT_BYREF: return L"unsigned int&"; // value->puintVal UINT* = unsigned int*
		case VT_VOID | VT_BYREF: return L"void*"; // value->byref PVOID = void*
		case VT_HRESULT | VT_BYREF: return L"HRESULT&"; // value->
		case VT_PTR | VT_BYREF: return L"Com::Object&"; // value->byref PVOID = void*
		case VT_SAFEARRAY | VT_BYREF: return L"SAFEARRAY&"; //value->pparray SAFEARRAY*
		case VT_CARRAY | VT_BYREF: return L"CARRAY&"; // value->pbyref PVOID = void**
		case VT_USERDEFINED | VT_BYREF: return L"USERDEFINED&";
		case VT_LPSTR | VT_BYREF: return L"char **"; // value->ppcVal CHAR** = char**
		case VT_LPWSTR | VT_BYREF: return L"wchar_t **"; // value->ppbstrVal BSTR* = wchar_t**
		case VT_RECORD | VT_BYREF: return L"RECORD**";
#ifndef __vsshell_h__
		case VT_INT_PTR | VT_BYREF: return L"int ***"; // value->ppintVal INT** = int**
		case VT_UINT_PTR | VT_BYREF: return L"unsigned int ***"; // value ->ppuintVal UINT ** unsigned int**
#endif
		case VT_ARRAY | VT_BYREF: return L"array*";
			//________________________________________________________________ SPECIAL
		case VT_RESERVED: return L"reserved";
		case VT_ILLEGAL: return L"illegal";
		case VT_TYPEMASK: return L"typemask";
		}
		return L"void";
	}
	else
	{
		switch (vt)
		{
		case VT_EMPTY: return L"VT_EMPTY";
		case VT_NULL: return L"VT_NULL";
		case VT_I2: return L"VT_I2";
		case VT_I4: return L"VT_I4";
		case VT_R4: return L"VT_R4";
		case VT_R8: return L"VT_R8";
		case VT_CY: return L"VT_CY";
		case VT_DATE: return L"VT_DATE";
		case VT_BSTR: return L"VT_BSTR";
		case VT_DISPATCH: return L"VT_DISPATCH";
		case VT_ERROR: return L"VT_ERROR";
		case VT_BOOL: return L"VT_BOOL";
		case VT_VARIANT: return L"VT_VARIANT";
		case VT_UNKNOWN: return L"VT_UNKNOWN";
		case VT_DECIMAL: return L"VT_DECIMAL";
		case VT_I1: return L"VT_I1";
		case VT_UI1: return L"VT_UI1";
		case VT_UI2: return L"VT_UI2";
		case VT_UI4: return L"VT_UI4";
		case VT_I8: return L"VT_I8";
		case VT_UI8: return L"VT_UI8";
		case VT_INT: return L"VT_INT";
		case VT_UINT: return L"VT_UINT";
		case VT_VOID: return L"VT_VOID";
		case VT_HRESULT: return L"VT_HRESULT";
		case VT_PTR: return L"VT_PTR";
		case VT_SAFEARRAY: return L"VT_SAFEARRAY";
		case VT_CARRAY: return L"VT_CARRAY";
		case VT_USERDEFINED: return L"VT_USERDEFINED";
		case VT_LPSTR: return L"VT_LPSTR";
		case VT_LPWSTR: return L"VT_LPWSTR";
		case VT_RECORD: return L"VT_RECORD";
#ifndef __vsshell_h__
		case VT_INT_PTR: return L"VT_INT_PTR";
		case VT_UINT_PTR: return L"VT_UINT_PTR";
#endif
		case VT_ARRAY: return L"VT_ARRAY";
		case VT_BYREF: return L"VT_BYREF";
		case VT_RESERVED: return L"VT_RESERVED";
		case VT_ILLEGAL: return L"VT_ILLEGAL";
		case VT_TYPEMASK: return L"VT_TYPEMASK";
		}
		return L"VOID";
	}
	return L"void";
}

//___________________________________________________________________ TypeInfoData
TypeInfoData::TypeInfoData()
{
	Clear();
}

TypeInfoData::~TypeInfoData()
{
}

void TypeInfoData::Clear()
{
	name.clear();
	kind = TKIND_DISPATCH;
	iid = GUID_NULL;
	enumList.clear();
	funcList.clear();
	classList.clear();
}

//__________________________________________________________________ TypeLibData
TypeLibData::TypeLibData()
{
}

TypeLibData::~TypeLibData()
{
}

void TypeLibData::Clear()
{
	tid.clear();
	name.clear();
	description.clear();
	helpFile.clear();
	progID.clear();
}

bool TypeLibData::IsNameValid(const wstring& name)
{
	const int count = (int)tid.size();
	if (count == 0) return false;
	vector<Com::TypeInfoData>::iterator p;
	vector<Com::TypeInfoData>::const_iterator tidend = tid.end();
	for (p = tid.begin(); p != tidend; p++)
	{
		if (p->kind == TKIND_DISPATCH || p->kind == TKIND_ENUM)
		{
			if (p->name == name) return true;
		}
	}
	return false;
}

//___________________________________________________________________ FuncBasicInfo

//___________________________________________________________________ InvokeInfo

//_______________________________________________________________ Boot

//_______________________________________________________________ ProgInfo
ProgInfo::ProgInfo()
{
	//isControl = false;
	//clsid = GUID_NULL;
}

ProgInfo::~ProgInfo()
{
}

bool ProgInfo::operator<(const ProgInfo& input) const
{
	return (this->descr < input.descr);
}

bool ProgInfo::GetClsid(CLSID& output)
{
	//NOERROR The CLSID was obtained successfully.
	//CO_E_CLASSSTRING The class string was improperly formatted.
	//REGDB_E_CLASSNOTREG The CLSID corresponding to the class string was not found in the registry.
	//REGDB_E_READREGDB The registry could not be opened for reading.
	HRESULT hr = CLSIDFromString(_bstr_t(clsid.c_str()), &output);
	if (FAILED(hr)) return false;
	return true;
}

//_______________________________________________________________ Assistant
Assistant::Assistant()
{
}

Assistant::~Assistant()
{
}

void Assistant::ReplaceNameConflicts(wstring& in_out)
{
	Sys::TextAssistant::Replace(in_out, L"ExitWindows()", L"ExitWindows_()", false);
	Sys::TextAssistant::Replace(in_out, L"DialogBox()", L"DialogBox_()", false);
}

HRESULT Assistant::GetTypeLibHelp(REFCLSID clsidTypeLib, WORD version, WORD subversion, wstring& out_help, wstring& out_helpFile)
{
	ITypeLibPtr typeLib;
	HRESULT hr = LoadRegTypeLib(clsidTypeLib, version, subversion, 0, &typeLib);
	if (FAILED(hr)) return hr;
	//
	_bstr_t help;
	_bstr_t helpFile;
	hr = typeLib->GetDocumentation((unsigned int)-1, NULL, &help.GetBSTR(), NULL, &helpFile.GetBSTR());
	if (FAILED(hr)) return hr;
	//TypeLibItem
	out_help = help;
	out_helpFile = helpFile;
	typeLib = NULL;
	return S_OK;
}

bool Assistant::Copy(HRESULT hr, _bstr_t& source, wstring& destination)
{
	if (FAILED(hr))
	{
		destination = Com::Exception::GetErrorDescr(hr);
		return false;
	}
	else
	{
		if (source.length() > 0)
		{
			destination = source;
		}
		else
		{
			destination.clear();
		}
	}
	return true;
}

HRESULT Assistant::ReadTypeLibFromFile(const wchar_t* filename, Com::TypeLibData& out_data)
{
	out_data.Clear();
	Com::Boot boot;
	ITypeLibPtr typeLib;
	HRESULT hr = LoadTypeLib(filename, &typeLib);
	if (FAILED(hr)) return hr;
	return GetTypeLibData(typeLib, out_data);
}

HRESULT Assistant::GetTypeLibData(ITypeLibPtr typeLib, Com::TypeLibData& out_data)
{
	HRESULT hr;
	//_________________________________________________________________ Library Information
	_bstr_t libName;
	_bstr_t libDesc;
	_bstr_t helpFile;
	hr = typeLib->GetDocumentation(MEMBERID_NIL, &libName.GetBSTR(), &libDesc.GetBSTR(), NULL, &helpFile.GetBSTR());
	if (SUCCEEDED(hr))
	{
		if (libName.length() > 0) out_data.name = libName;
		if (libDesc.length() > 0) out_data.description = libDesc;
		if (helpFile.length() > 0) out_data.helpFile = helpFile;
	}
	else
	{
		libName = L"NoName";
		libDesc = Com::Exception::GetErrorDescr(hr);
		helpFile = libDesc;
	}
	//_____________________________________________________________________ Loop Items in TypeLib
	const long countTypeInfo = typeLib->GetTypeInfoCount();
	if (countTypeInfo == 0) S_OK;
	_bstr_t name;
	Com::TypeInfoData tid;
	ITypeInfoPtr typeInfo;
	long i;
	for (i = 0; i < countTypeInfo; i++)
	{
		tid.Clear();
		typeInfo = NULL;
		//___________________________________________________ Name
		hr = typeLib->GetDocumentation(i, &name.GetBSTR(), NULL, NULL, NULL);
		Com::Assistant::Copy(hr, name, tid.name);
		//___________________________________________________ TYPEKIND	
		hr = typeLib->GetTypeInfoType((unsigned int)i, &tid.kind);
		if (FAILED(hr)) continue;
		//___________________________________________________ Read Item
		if (tid.kind == TKIND_ENUM)
		{
			hr = typeLib->GetTypeInfo(i, &typeInfo);
			if (FAILED(hr)) continue;
			hr = Com::Assistant::ReadEnum(typeInfo, tid);
			if (FAILED(hr)) continue;
		}
		else if (tid.kind == TKIND_DISPATCH)
		{
			hr = typeLib->GetTypeInfo(i, &typeInfo);
			if (FAILED(hr)) continue;
			hr = Com::Assistant::ReadDispatch(typeInfo, tid);
			if (FAILED(hr)) continue;
		}
		else if (tid.kind == TKIND_COCLASS)
		{
			hr = typeLib->GetTypeInfo(i, &typeInfo);
			if (FAILED(hr)) continue;
			hr = Com::Assistant::ReadCoClass(typeInfo, tid);
			if (FAILED(hr)) continue;
		}
		else if (tid.kind == TKIND_RECORD)
		{
			hr = typeLib->GetTypeInfo(i, &typeInfo);
			if (FAILED(hr)) continue;
			hr = Com::Assistant::ReadRecord(typeInfo, tid);
			if (FAILED(hr)) continue;
		}
		else if (tid.kind == TKIND_MODULE)
		{
			continue;
		}
		else if (tid.kind == TKIND_INTERFACE)
		{
			continue;
		}
		else if (tid.kind == TKIND_ALIAS)
		{
			continue;
		}
		else if (tid.kind == TKIND_UNION)
		{
			continue;
		}
		else if (tid.kind == TKIND_MAX)
		{
			continue;
		}
		out_data.tid.push_back(tid);
		typeInfo = NULL;
	}
	typeLib = NULL;
	//__________________________________________________________________ Update funcParam.descrUserDefined
	const int count = (int)out_data.tid.size();
	int funcCount = 0;
	int paramCount = 0;
	int j, k;
	list<Com::FuncInfo>::iterator p;
	for (i = 0; i < count; i++)
	{
		if (out_data.tid[i].kind != TKIND_DISPATCH) continue;
		funcCount = (int)out_data.tid[i].funcList.size();
		for (j = 0, p = out_data.tid[i].funcList.begin(); j < funcCount; j++, p++)
		{
			//______________________________________________________ Update isNameValidForProperty
			p->isNameValidForProperty = (Com::Assistant::IsInterfaceName(out_data, p->name) == false);
			//______________________________________________________ Update function returnType
			if (p->returnType.typeKindLink == TKIND_COCLASS)
			{
				Com::Assistant::FindNameFromClsid(out_data, p->returnType.iidLink, p->returnType.descrLink);
				p->returnType.isValid = out_data.IsNameValid(p->returnType.descrLink);
			}
			else if (p->returnType.datatype == VT_USERDEFINED || p->returnType.datatype == (VT_USERDEFINED | VT_BYREF))
			{
				Com::Assistant::FindNameFromIid(out_data, p->returnType.iidLink, p->returnType.descrLink);
				p->returnType.isValid = out_data.IsNameValid(p->returnType.descrLink);
			}
			paramCount = (int)p->param.size();
			for (k = 0; k < paramCount; k++)
			{
				//______________________________________________________ Update function parameters
				if (p->param[k].typeKindLink == TKIND_COCLASS)
				{
					Com::Assistant::FindNameFromClsid(out_data, p->param[k].iidLink, p->param[k].descrLink);
					p->param[k].isValid = out_data.IsNameValid(p->param[k].descrLink);
				}
				else if (p->param[k].datatype == VT_USERDEFINED || p->param[k].datatype == (VT_USERDEFINED | VT_BYREF))
				{
					Com::Assistant::FindNameFromIid(out_data, p->param[k].iidLink, p->param[k].descrLink);
					p->param[k].isValid = out_data.IsNameValid(p->param[k].descrLink);
				}
			}
		}
	}
	return S_OK;
}

HRESULT Assistant::ReadTypeLibFromProgID(const wchar_t* progID, Com::TypeLibData& out_data)
{
	out_data.Clear();
	Com::Boot boot;
	HRESULT hr;
	//_________________________________________________________________  Create IDispatchPtr
	IDispatchPtr dispatch;
	hr = dispatch.CreateInstance(progID, NULL, CLSCTX_ALL);
	if (FAILED(hr)) return hr;
	//_________________________________________________________________ Get ITypeInfoPtr
	UINT typeInfoCount = 0;
	hr = dispatch->GetTypeInfoCount(&typeInfoCount);
	if (FAILED(hr)) return hr;
	if (typeInfoCount == 0) return S_OK;
	//
	ITypeInfoPtr typeInfo;
	hr = dispatch->GetTypeInfo(0, LOCALE_SYSTEM_DEFAULT, &typeInfo);
	if (FAILED(hr)) return hr;
	//_________________________________________________________________ Get ITypeLibPtr
	ITypeLibPtr typeLib;
	UINT index = 0;
	hr = typeInfo->GetContainingTypeLib(&typeLib, &index);
	if (FAILED(hr)) return hr;
	return GetTypeLibData(typeLib, out_data);
}

bool Assistant::FindNameFromIid(TypeLibData& typeLibData, REFIID iid, wstring& out_name)
{
	if (iid == GUID_NULL) return false;
	out_name.clear();
	const int count = (int)typeLibData.tid.size();
	int funcCount = 0;
	int i;
	for (i = 0; i < count; i++)
	{
		if (typeLibData.tid[i].kind != TKIND_DISPATCH) continue;
		if (typeLibData.tid[i].iid == iid)
		{
			out_name = typeLibData.tid[i].name;
			return true;
		}
	}
	return false;
}

bool Assistant::IsInterfaceName(TypeLibData& typeLibData, const wstring& name)
{
	const int countTid = (int)typeLibData.tid.size();
	for (int i = 0; i < countTid; i++)
	{
		if (typeLibData.tid[i].kind != TKIND_DISPATCH) continue;
		if (typeLibData.tid[i].name == name) return true;
	}
	return false;
}

bool Assistant::IsCoClassName(TypeLibData& typeLibData, const wstring& name)
{
	const int countTid = (int)typeLibData.tid.size();
	for (int i = 0; i < countTid; i++)
	{
		if (typeLibData.tid[i].kind != TKIND_COCLASS) continue;
		if (typeLibData.tid[i].name == name) return true;
	}
	return false;
}

bool Assistant::IsComLibraryInstalled(const wchar_t* clsidString)
{
	::CoInitialize(NULL);
	bool ok = false;
	IUnknownPtr unknown;
	try
	{
		unknown.CreateInstance(clsidString, NULL, CLSCTX_INPROC_SERVER);
		ok = (unknown != NULL);
		unknown = NULL;
	}
	catch (_com_error ex)
	{
		ok = false;
	}
	::CoUninitialize();
	return ok;
}

bool Assistant::FindNameFromClsid(TypeLibData& typeLibData, REFCLSID clsid, wstring& out_name)
{
	if (clsid == GUID_NULL) return false;
	out_name.clear();
	const int countTid = (int)typeLibData.tid.size();
	int funcCount = 0;
	int i;
	int indexCoClass = -1;
	//_________________________________________________________ Find COCLASS
	for (i = 0; i < countTid; i++)
	{
		if (typeLibData.tid[i].kind != TKIND_COCLASS) continue;
		if (typeLibData.tid[i].iid == clsid)
		{
			indexCoClass = i;
			break;
		}
	}
	if (indexCoClass == -1) return false;
	//_________________________________________________________ Find Default Interface IID
	if (typeLibData.tid[indexCoClass].classList.size() == 0) return false;
	list<Com::ClassInfo>::iterator p = typeLibData.tid[indexCoClass].classList.begin();
	list<Com::ClassInfo>::const_iterator pend = typeLibData.tid[indexCoClass].classList.end();
	for (; p != pend; p++)
	{
		if (p->isDefault == true)
		{
			//____________________________ Try to find in tid
			for (i = 0; i < countTid; i++)
			{
				if (typeLibData.tid[i].kind != TKIND_DISPATCH) continue;
				if (p->clsid == typeLibData.tid[i].iid)
				{
					out_name = typeLibData.tid[i].name;
					return true;
				}
			}	
		}
	}
	return false;
}

HRESULT Assistant::ReadCoClass(ITypeInfoPtr typeInfo, Com::TypeInfoData& tid)
{
	tid.iid = GUID_NULL;
	tid.classList.clear();
	//
	HRESULT hr;
	//_______________________________________________________________ TYPEATTR
	TYPEATTR* typeAttr = NULL;
	hr = typeInfo->GetTypeAttr(&typeAttr);
	if (FAILED(hr)) return hr;
	if (typeAttr->typekind != TKIND_COCLASS)
	{
		typeInfo->ReleaseTypeAttr(typeAttr);
		return E_INVALIDARG; // Imposible to get here
	}
	tid.iid = typeAttr->guid;
	const int count = typeAttr->cImplTypes;

	int flags;
	HREFTYPE hRefType;
	ITypeInfoPtr classTypeInfo;
	TYPEATTR* classTypeAttr = NULL;
	Com::ClassInfo ci;
	//
	for (int i = 0; i< count; i++)
	{
		ci.Clear();
		//
		hr = typeInfo->GetImplTypeFlags(i, &flags);
		if (FAILED(hr)) continue;
		//
		if ((flags & IMPLTYPEFLAG_FDEFAULT) == 0)
		{
			ci.isDefault = false;
		}
		else
		{
			ci.isDefault = true;
		}
		//
		hr = typeInfo->GetRefTypeOfImplType(i, &hRefType);
		if (FAILED(hr)) continue;
		//
		hr = typeInfo->GetRefTypeInfo(hRefType, &classTypeInfo);
		if (FAILED(hr)) continue;
		//
		hr = classTypeInfo->GetTypeAttr(&classTypeAttr);
		if (FAILED(hr)) continue;
		//
		ci.typeKind = classTypeAttr->typekind;
		ci.clsid = classTypeAttr->guid;
		//
		classTypeInfo->ReleaseTypeAttr(classTypeAttr);
		//
		tid.classList.push_back(ci);
	}
	typeInfo->ReleaseTypeAttr(typeAttr);
	return S_OK;
}

HRESULT Assistant::ReadRecord(ITypeInfoPtr typeInfo, Com::TypeInfoData& tid)
{
	tid.iid = GUID_NULL;
	tid.enumList.clear();
	//
	HRESULT hr;
	//_______________________________________________________________ TYPEATTR
	TYPEATTR* typeAttr = NULL;
	hr = typeInfo->GetTypeAttr(&typeAttr);
	if (FAILED(hr)) return hr;
	if (typeAttr->typekind != TKIND_RECORD)
	{
		typeInfo->ReleaseTypeAttr(typeAttr);
		return E_INVALIDARG; // Imposible to get here
	}
	tid.iid = typeAttr->guid;
	const int varCount = typeAttr->cVars;
//	return S_OK;
//	VARDESC* vardesc = NULL;
//	DISPID memid;
////	VARIANT* value;
//	VARTYPE varType;
//	_variant_t vtValue;
//	double y = 10;
//	for (int i = 0; i < varCount; i++)
//	{
//		hr = typeInfo->GetVarDesc(i, &vardesc);
//		if (SUCCEEDED(hr))
//		{
//			if (vardesc->varkind == VAR_PERINSTANCE)
//			{
//				memid = vardesc->memid;
//				varType = vardesc->elemdescVar.tdesc.vt;
//				//value = (VARIANT*)(vardesc->lpvarValue + (byte)vardesc->oInst);
//				//value = (VARIANT*)(vardesc->lpvarValue);
//
//				vtValue.Clear();
//				vtValue.vt = varType;
//				if (varType == VT_EMPTY)
//				{
//					y = 10;
//				}
//				else if (varType == VT_NULL)
//				{
//					y = 10;
//				}
//				else if (varType == VT_BSTR)
//				{
//					//vtValue.bVal = value->bVal;
//				}
//				else if (varType == VT_PTR)
//				{
//					y = 10;
//					//vtValue.bVal = value->bVal;
//				}
//				else if (varType == VT_CARRAY)
//				{
//					y = 10;
//					//vtValue.bVal = value->bVal;
//				}
//				else if (varType == VT_UI1)
//				{
//					y = 10;
//					//vtValue.bVal = value->bVal;
//				}
//				else if (varType == VT_UI2)
//				{
//					y = 10;
//					//vtValue.uiVal = value->uiVal;
//				}
//				else if (varType == VT_UI4)
//				{
//					y = 10;
//					//vtValue.ulVal = vardesc->lpvarValue->ulVal;//value->ulVal;
//					//vtValue.ulVal  = vardesc->elemdescVar.tdesc.
//				}
//				else if (varType == VT_I8)
//				{
//					y = 10;
//					//vtValue.llVal = value->llVal;
//				}
//				else if (varType == VT_UI8)
//				{
//					y = 10;
//					//vtValue.ullVal = value->ullVal;
//				}
//
//				//vtValue = value;
//				//ITypeInfoPtr typeInfoOther;
//				//hr = typeInfoUserDefined->GetRefTypeInfo(vardesc->elemdescVar.tdesc.hreftype, &typeInfoOther);
//				//if (FAILED(hr)) return hr;
//				//_bstr_t name;
//				//hr = typeInfoOther->GetDocumentation(MEMBERID_NIL, &name.GetBSTR(), NULL, NULL, NULL);
//				////
//				//TYPEATTR* typeAttr2 = NULL;
//				//hr = typeInfoOther->GetTypeAttr(&typeAttr2);
//				////if (FAILED(hr))
//				////{
//				////	typeInfoOther->ReleaseTypeAttr(typeAttr2);
//				////	return hr;
//				////}
//				//typeInfoOther->ReleaseTypeAttr(typeAttr2);
//			}
//			else if (vardesc->varkind == VAR_CONST)
//			{
//
//			}
//		}
//		typeInfo->ReleaseVarDesc(vardesc);
//	}
	typeInfo->ReleaseTypeAttr(typeAttr);
	return S_OK;
}

HRESULT Assistant::ReadEnum(ITypeInfoPtr typeInfo, Com::TypeInfoData& tid)
{
	tid.iid = GUID_NULL;
	tid.enumList.clear();
	//
	HRESULT hr;
	//_______________________________________________________________ TYPEATTR
	TYPEATTR* typeAttr = NULL;
	hr = typeInfo->GetTypeAttr(&typeAttr);
	if (typeAttr->typekind != TKIND_ENUM)
	{
		typeInfo->ReleaseTypeAttr(typeAttr);
		return E_INVALIDARG; // Imposible to get here
	}
	tid.iid = typeAttr->guid;
	const int varCount = typeAttr->cVars;
	//
	VARDESC* vardesc = NULL;
	DISPID memid;
	_bstr_t name;
	Com::Enum comenum;
	for (int i = 0; i < varCount; i++)
	{
		hr = typeInfo->GetVarDesc(i, &vardesc);
		if (SUCCEEDED(hr))
		{
			if (vardesc->varkind == VAR_CONST)
			{
				memid = vardesc->memid;
				comenum.value = vardesc->lpvarValue;
				hr = typeInfo->GetDocumentation(memid, &name.GetBSTR(), NULL, NULL, NULL);
				if (SUCCEEDED(hr))
				{
					if (name.length() > 0)
					{
						comenum.name = name;
						tid.enumList.push_back(comenum);
					}
				}
			}
		}
		typeInfo->ReleaseVarDesc(vardesc);
	}
	typeInfo->ReleaseTypeAttr(typeAttr);
	return S_OK;
}

HRESULT Assistant::ReadParamInfo(ITypeInfoPtr typeInfo, TYPEDESC& typedesc, Com::FuncParam& param)
{
	if (typedesc.vt == VT_SAFEARRAY)
	{
		param.datatype = (typedesc.lptdesc->vt) | VT_ARRAY;
	}
	else if (typedesc.vt == VT_PTR)
	{
		param.datatype = (typedesc.lptdesc->vt) | VT_BYREF;
		GetUserDefinedInfo(typeInfo, typedesc.lptdesc->hreftype, param);
	}
	else if (typedesc.vt == VT_CARRAY)
	{
		param.datatype = (typedesc.lpadesc->tdescElem.vt) | VT_BYREF;
	}
	else if (typedesc.vt == VT_USERDEFINED || typedesc.vt == (VT_USERDEFINED | VT_BYREF))
	{
		param.datatype = typedesc.vt;
		GetUserDefinedInfo(typeInfo, typedesc.hreftype, param);
	}
	else
	{
		param.datatype = typedesc.vt;
	}
	return S_OK;
}

HRESULT Assistant::ReadDispatch(ITypeInfoPtr typeInfo, Com::TypeInfoData& tid)
{
	//_______________________________________________________________ Be sure to return clean values
	tid.iid = GUID_NULL;
	tid.funcList.clear();
	//
	HRESULT hr;
	//_______________________________________________________________ TYPEATTR
	TYPEATTR* typeAttr = NULL;
	hr = typeInfo->GetTypeAttr(&typeAttr);
	if (FAILED(hr)) return hr;
	if (typeAttr->typekind != TKIND_DISPATCH)
	{
		typeInfo->ReleaseTypeAttr(typeAttr);
		return E_INVALIDARG; // Imposible to get here
	}
	//
	const int methodCount = typeAttr->cFuncs;
	const int varCount = typeAttr->cVars;
	tid.iid = typeAttr->guid;

	const int dispInfoCount = methodCount + 2 * varCount;
	int i;
	unsigned int j, k;
	FUNCDESC* funcDesc = NULL;
	Com::FuncInfo fi;
	unsigned int count;
	_bstr_t funcName;
	unsigned int paramCount;
	WORD paramType = 0;
	wchar_t * descr = NULL;
	BSTR paramName[32];
	UINT maxParamName = 32;
	UINT paramNameCount = 0;
	_bstr_t bstrHelpString;

	for (i = 0; i < methodCount; i++)
	{
		fi.Clear();
		//_____________________________________________ Function Description
		hr = typeInfo->GetFuncDesc(i, &funcDesc);
		if (FAILED(hr))
		{
			fi.name = Com::Exception::GetErrorDescr(hr);
			continue;
		}
		//_____________________________________________ Function Name
		hr = typeInfo->GetNames(funcDesc->memid, &funcName.GetBSTR(), 1, &count);
		if (Com::Assistant::Copy(hr, funcName, fi.name) == false)
		{
			typeInfo->ReleaseFuncDesc(funcDesc);
			continue;
		}
		//______________________________________________ Help string
		hr = typeInfo->GetDocumentation(funcDesc->memid, NULL, &bstrHelpString.GetBSTR(), NULL, NULL);
		Com::Assistant::Copy(hr, bstrHelpString, fi.helpString);
		//______________________________________________ Additional Information
		fi.dispatch_type = funcDesc->invkind;
		fi.memid = funcDesc->memid;
		fi.numOptionalParameters = funcDesc->cParamsOpt;
		paramCount = funcDesc->cParams;
		if (paramCount > 0)
		{
			fi.param.resize(paramCount);
		}
		else
		{
			fi.param.clear();
		}
		fi.callConv = funcDesc->callconv;
		//_________________________________________________________ Return Type
		hr = ReadParamInfo(typeInfo, funcDesc->elemdescFunc.tdesc, fi.returnType);
		//________________________________________________________________________________________ PARAMS
		//__________________________________________________________________ param type
		for (j = 0; j < paramCount; j++)
		{
			hr = ReadParamInfo(typeInfo, funcDesc->lprgelemdescParam[j].tdesc, fi.param[j]);
			if (FAILED(hr)) continue;
		}
		//_________________________________________________________________ param name
		for (k = 0; k < maxParamName; k++) paramName[k] = NULL;
		if (SUCCEEDED(typeInfo->GetNames(funcDesc->memid, paramName, maxParamName, &paramNameCount)) == true)
		{
			if (paramNameCount == paramCount)
			{
				for (k = 0; k < paramNameCount; k++)
				{
					if (paramName[k] != NULL) fi.param[k].name = paramName[k];
				}
			}
			else if (paramNameCount - 1 == paramCount)
			{
				for (k = 0; k < paramCount; k++)
				{
					if (paramName[k+1] != NULL) fi.param[k].name = paramName[k+1];
					//_snwprintf_s(fi.param[k].name, 32, _TRUNCATE, L"%s", paramName[k + 1]);
				}
			}
			for (k = 0; k < paramNameCount; k++) ::SysFreeString(paramName[k]);
		}
		tid.funcList.push_back(fi);
		typeInfo->ReleaseFuncDesc(funcDesc);
	}
	tid.funcList.sort();
	typeInfo->ReleaseTypeAttr(typeAttr);
	return S_OK;
}

HRESULT Assistant::ImportComLibraryFromProgID(const wchar_t* path, const wchar_t* progID, wstring& out_libName)
{
	Com::TypeLibData typeLibData;
	HRESULT hr = Com::Assistant::ReadTypeLibFromProgID(progID, typeLibData);
	if (FAILED(hr)) return hr;
	out_libName = typeLibData.name;
	typeLibData.progID = progID;
	return Com::Assistant::ImportComLibrary(path, typeLibData);
}

HRESULT Assistant::ImportComLibraryFromFile(const wchar_t* path, const wchar_t* filename, wstring& out_libName)
{
	Com::TypeLibData typeLibData;
	HRESULT hr = Com::Assistant::ReadTypeLibFromFile(filename, typeLibData);
	if (FAILED(hr)) return hr;
	out_libName = typeLibData.name;
	typeLibData.progID = filename;
	return Com::Assistant::ImportComLibrary(path, typeLibData);
}

HRESULT Assistant::ImportComLibrary(const wchar_t* path, Com::TypeLibData& typeLibData)
{
	// In future versions, it will be considered to use this variable to import the library using Smart Pointers
	const bool earlyBinding = false;
	wstring safeLibName(typeLibData.name);
	Sys::TextAssistant::ReplaceChar(safeLibName, ' ', '_');
	//__________________________________________________________________ Create short filenames
	wchar_t filenameHeader[256];
	_snwprintf_s(filenameHeader, 256, _TRUNCATE, L"%s.h", safeLibName.c_str());
	//
	wchar_t filenameSource[256];
	_snwprintf_s(filenameSource, 256, _TRUNCATE, L"%s.cpp", safeLibName.c_str());
	//__________________________________________________________________  Get Date
	wstring dateString;
	Sys::Time st;
	Sys::Convert::DateToString(st, L"ddd',' MMM dd yyyy", dateString);
	//__________________________________________________________________  Get Time
	wstring timeString;
	Sys::Convert::TimeToString(st, L"hh':'mm':'ss tt", timeString);
	//__________________________________________________________________  Header
	wstring headerContent;
	headerContent = L"#pragma once  //__________________________________________";
	headerContent += filenameHeader;
	headerContent += L"\r\n\r\n// Wintempla Com::Assistant::ImportComLibrary running on ";
	headerContent += dateString;
	headerContent += L" ";
	headerContent += timeString;
	headerContent += L"\r\n// ProgID: ";
	headerContent += typeLibData.progID;
	headerContent += L"\r\n// Description: ";
	headerContent += typeLibData.description;
	headerContent += L"\r\n// Help File: ";
	headerContent += typeLibData.helpFile;
	headerContent += L"\r\n\r\nnamespace ";
	headerContent += typeLibData.name;
	headerContent += L"{\r\n\r\n";
	//__________________________________________________________________  Source
	wstring sourceContent;
	sourceContent = L"#include \"stdafx.h\"//__________________________________________";
	sourceContent += filenameSource;
	sourceContent += L"\r\n#include \"";
	sourceContent += filenameHeader;
	sourceContent += L"\"\r\nnamespace ";
	sourceContent += typeLibData.name;
	sourceContent += L"{\r\n\r\n";

	//_________________________________________________________________ Empty Class Declarations
	const unsigned int count = (int)typeLibData.tid.size();
	unsigned int i;
	wstring sname;
	for (i = 0; i < count; i++)
	{
		if (typeLibData.tid[i].kind == TKIND_DISPATCH)
		{
			headerContent += L"class ";
			Com::Assistant::CreateClassName(typeLibData.tid[i].name, sname);
			headerContent += sname;
			headerContent += L";\r\n";
		}
	}
	//_________________________________________________________________ TKIND_ENUM Loop
	for (i = 0; i < count; i++)
	{
		if (typeLibData.tid[i].kind != TKIND_ENUM) continue;
		headerContent += L"//________________________________________________________";
		headerContent += typeLibData.tid[i].name;
		headerContent += L"\r\n";
		//
		Com::Assistant::RenderEnumText(typeLibData.tid[i], headerContent);
	}
	//_________________________________________________________________ TKIND_DISPATCH Loop
	for (i = 0; i < count; i++)
	{
		if (typeLibData.tid[i].kind != TKIND_DISPATCH) continue;
		headerContent += L"//________________________________________________________";
		headerContent += typeLibData.tid[i].name;
		headerContent += L"\r\n";
		//
		sourceContent += L"//________________________________________________________";
		sourceContent += typeLibData.tid[i].name;
		sourceContent += L"\r\n";
		//
		Com::Assistant::RenderFuncText(typeLibData.name.c_str(), earlyBinding, false, typeLibData.tid[i], headerContent, sourceContent);
	}
	//__________________________________________________________________ Create long filenames
	_snwprintf_s(filenameHeader, 256, _TRUNCATE, L"%s\\%s.h", path, safeLibName.c_str());
	_snwprintf_s(filenameSource, 256, _TRUNCATE, L"%s\\%s.cpp", path, safeLibName.c_str());
	//__________________________________________________________________ Create header file
	string tmp;
	headerContent += L"}\r\n"; // namespace end
	Com::Assistant::ReplaceNameConflicts(headerContent);
	Sys::Convert::WstringToString(headerContent, tmp);
	if (Sys::FileAssistant::TextSave(filenameHeader, tmp) == false) return E_ACCESSDENIED;
	//__________________________________________________________________ Create source file
	sourceContent += L"}\r\n"; // namespace end
	Com::Assistant::ReplaceNameConflicts(sourceContent);
	Sys::Convert::WstringToString(sourceContent, tmp);
	if (Sys::FileAssistant::TextSave(filenameSource, tmp) == false) return E_ACCESSDENIED;
	return S_OK;
}

void Assistant::CreateClassName(const wstring& input, wstring& output)
{
	output.clear();
	const int len = (int)input.length();
	if (len == 0) return;
	output = input;
	if (input[0] == '_')
	{
		for (int i = 0; i < len - 1; i++)
		{
			output[i] = input[i + 1];
		}
		output[len - 1] = 'X';
	}
}

void Assistant::RenderFuncText(const wchar_t* nameSpace, bool earlyBinding, bool isIDispatch, TypeInfoData& typeInfoData, wstring& headerContent, wstring& sourceContent)
{
	wstring sname;
	Com::Assistant::CreateClassName(typeInfoData.name, sname);
	if (sname.empty() == true) return;
	//
	wstring text;
	//__________________________________________________________________ class
	wstring iidText;
	Sys::Convert::ClsidToString(typeInfoData.iid, iidText);
	headerContent += L"// {";
	headerContent += iidText;
	headerContent += L"}\r\n";
	//
	Sys::Format(text, L"class %s : public Com::Object\r\n{\r\npublic:\r\n\t%s();\r\n\t~%s();\r\n", sname.c_str(), sname.c_str(), sname.c_str());
	headerContent += text;
	//_____________________ Copy Constructor
	Sys::Format(text, L"\t%s(const Com::Object& init){ Com::Object::Private_Copy(init); }\r\n", sname.c_str());
	headerContent += text;
	//_____________________ operator=
	Sys::Format(text, L"\t%s& operator=(const Com::Object& init){ Com::Object::Private_Copy(init); return *this; }\r\n", sname.c_str());
	headerContent += text;
	//__________________________________________________________________ Constructor and destructor
	Sys::Format(text, L"%s::%s()\r\n{\r\n}\r\n\r\n", sname.c_str(), sname.c_str());
	sourceContent += text;
	//
	Sys::Format(text, L"%s::~%s()\r\n{\r\n}\r\n\r\n", sname.c_str(), sname.c_str());
	sourceContent += text;
	//__________________________________________________________________ Render Functions
	list<Com::FuncInfo>::iterator pfi;
	list<Com::FuncInfo>::const_iterator fiend = typeInfoData.funcList.end();
	for (pfi = typeInfoData.funcList.begin(); pfi != fiend; pfi++)
	{
		//isValid = pfi->AreParametersValid();
		//______________________ Property
		pfi->RenderProperty(nameSpace, earlyBinding, isIDispatch, typeInfoData.funcList, headerContent);
		//______________________ Declaration
		pfi->RenderFuncDeclaration(nameSpace, earlyBinding, isIDispatch, true, headerContent);
		pfi->RenderFuncDeclaration(nameSpace, earlyBinding, isIDispatch, false, headerContent);
		//______________________ Definition
		pfi->RenderFuncDefinition(nameSpace, earlyBinding, isIDispatch, sname.c_str(), true, sourceContent);
		pfi->RenderFuncDefinition(nameSpace, earlyBinding, isIDispatch, sname.c_str(), false, sourceContent);
	}
	headerContent += L"};\r\n\r\n"; // classname end
}

void Assistant::RenderEnumText(TypeInfoData& typeInfoData, wstring& headerContent)
{
	const unsigned int count = (int)typeInfoData.enumList.size();
	if (count == 0) return; // Dont render empty enums
	//_______________________________________________________________ Begin
	headerContent += L"enum ";
	headerContent += typeInfoData.name;
	headerContent += L"\r\n{\r\n";
	//_______________________________________________________________ One item enum
	if (count == 1) headerContent += L"//";
	//_______________________________________________________________ Loop
	wstring text;
	wstring value;
	list<Com::Enum>::iterator p;
	list<Com::Enum>::const_iterator enumEnd = typeInfoData.enumList.end();
	int i;
	for (i = 0, p = typeInfoData.enumList.begin(); p != enumEnd; p++, i++)
	{
		Sys::Convert::ToString(p->value, value);
		if (i == count - 1)
		{
			Sys::Format(text, L"\t%s = %s\r\n", p->name.c_str(), value.c_str());
		}
		else
		{
			Sys::Format(text, L"\t%s = %s,\r\n", p->name.c_str(), value.c_str());
		}
		headerContent += text;
	}
	//_______________________________________________________________ End
	headerContent += L"};\r\n\r\n";
}

HRESULT Assistant::CreateClassFiles(const wchar_t* name, IDispatchPtr dispatch, const wchar_t* nameSpace)
{
	wstring text;
	string tmp;
	//__________________________________________________________________ Get Functions and Enum List
	Com::TypeInfoData tid;
	HRESULT hr = Com::Assistant::GetTypeInfoData(dispatch, tid);
	if (FAILED(hr))
	{
		Com::Exception ex(hr, L"Com::Object::CreateClassFiles");
		throw ex;
		return hr;
	}
	//__________________________________________________________________ Compute className
	wchar_t className[32];
	_snwprintf_s(className, 32, _TRUNCATE, L"%s", name);
	Sys::TextAssistant::ReplaceChar(className, '.', '_');
	Sys::TextAssistant::ReplaceChar(className, ' ', '_');
	//__________________________________________________________________ Create filenames
	wchar_t filenameHeader[256];
	_snwprintf_s(filenameHeader, 256, _TRUNCATE, L"%s_%s.h", nameSpace, className);
	//
	wchar_t filenameSource[256];
	_snwprintf_s(filenameSource, 256, _TRUNCATE, L"%s_%s.cpp", nameSpace, className);
	//__________________________________________________________________  Header
	wstring headerContent;
	headerContent = L"#pragma once  //__________________________________________";
	headerContent += filenameHeader;
	headerContent += L"\r\n\r\nnamespace ";
	headerContent += nameSpace;
	//_________________ class, constructor, destructor
	Sys::Format(text, L"{\r\n\r\nclass %s : public Com::Object\r\n{\r\npublic:\r\n\t%s();\r\n\t~%s();\r\n", className, className, className);
	headerContent += text;
	//_____________________ operator=
	Sys::Format(text, L"\t%s& operator =(const Com::Object& init){ Com::Object::Private_Copy(init); return *this; }\r\n", className);
	headerContent += text;
	//__________________________________________________________________  Source
	wstring sourceContent;
	sourceContent = L"#include \"stdafx.h\"//__________________________________________";
	sourceContent += filenameSource;
	sourceContent += L"\r\n#include \"";
	sourceContent += filenameHeader;
	sourceContent += L"\"\r\nnamespace ";
	sourceContent += nameSpace;
	sourceContent += L"{\r\n\r\n";
	//
	Sys::Format(text, L"%s::%s()\r\n{\r\n}\r\n\r\n", className, className);
	sourceContent += text;
	//
	Sys::Format(text, L"%s::~%s()\r\n{\r\n}\r\n\r\n", className, className);
	sourceContent += text;

	list<Com::FuncInfo>::iterator pfi;
	list<Com::FuncInfo>::const_iterator fiend = tid.funcList.end();

	//__________________________________________________________________ Render Functions
	for (pfi = tid.funcList.begin(); pfi != fiend; pfi++)
	{
		//______________________ Property
		pfi->RenderProperty(nameSpace, false, true, tid.funcList, headerContent);
		//______________________ Declaration
		pfi->RenderFuncDeclaration(nameSpace, false, true, true, headerContent);
		pfi->RenderFuncDeclaration(nameSpace, false, true, false, headerContent);
		//______________________ Definition
		pfi->RenderFuncDefinition(nameSpace, false, true, className, true, sourceContent);
		pfi->RenderFuncDefinition(nameSpace, false, true, className, false, sourceContent);
	}
	//__________________________________________________________________ Create header file
	headerContent += L"};\r\n\r\n}\r\n";
	Com::Assistant::ReplaceNameConflicts(headerContent);
	Sys::Convert::WstringToString(headerContent, tmp);
	if (Sys::FileAssistant::TextSave(filenameHeader, tmp) == false)
	{
		Com::Exception ex(E_ACCESSDENIED, L"Com::Object::CreateClassFiles:: Unable to create header file");
		throw ex;
		return hr;
	}
	//__________________________________________________________________ Create source file
	sourceContent += L"}\r\n";
	Com::Assistant::ReplaceNameConflicts(sourceContent);
	Sys::Convert::WstringToString(sourceContent, tmp);
	if (Sys::FileAssistant::TextSave(filenameSource, tmp) == false)
	{
		Com::Exception ex(E_ACCESSDENIED, L"Com::Object::CreateClassFiles:: Unable to create source file");
		throw ex;
		return hr;
	}
	return S_OK;
}

// Return -1 on error
int Assistant::GetProgInfo(vector<Com::ProgInfo>& info, bool controlsOnly)
{
	//________________________________________________ Open HKCR\CLSID
	Sys::RegistryKey keyClsid;
	if (keyClsid.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_READ) == false) return -1; //KEY_READ
	//________________________________________________ Local Variables
	int i = 0;
	Com::ProgInfo pi;
	wchar_t buffer[512];
	Sys::RegistryKey keyMain;
	Sys::RegistryKey keyProgID;
	Sys::RegistryKey keyViProgID;
	Sys::RegistryKey keyControl;
	//__________________________________________________________________ Enumerate
	for (i = 0; ; i++)
	{
		if (keyClsid.Enumerate(i, buffer, 512) == false) break;
		if (wcscmp(buffer, L"CLSID") == 0) continue;
		pi.clsid = buffer;
		//_______________________________________  HKCR\CLSID\{clsid}
		_snwprintf_s(buffer, 512, _TRUNCATE, L"CLSID\\%s", pi.clsid.c_str());
		if (keyMain.Open(HKEY_CLASSES_ROOT, buffer, KEY_READ) == false) continue;
		if (keyMain.ReadStringValue(NULL, buffer, 512) == true)
		{
			if (wcslen(buffer) > 0)
			{
				pi.descr = buffer;
			}
			else
			{
				pi.descr.clear();
			}
		}
		//______________________________________ HKCR\CLSID\{clsid}\ProgID
		_snwprintf_s(buffer, 512, _TRUNCATE, L"CLSID\\%s\\ProgID", pi.clsid.c_str());
		if (keyProgID.Open(HKEY_CLASSES_ROOT, buffer, KEY_READ) == false) continue;
		if (keyProgID.ReadStringValue(NULL, buffer, 512) == false) continue;
		if (wcslen(buffer) == 0) continue;
		pi.ProgID = buffer;
		//______________________________________ HKCR\CLSID\{clsid}\VersionIndependentProgID
		_snwprintf_s(buffer, 512, _TRUNCATE, L"CLSID\\%s\\VersionIndependentProgID", pi.clsid.c_str());
		if (keyViProgID.Open(HKEY_CLASSES_ROOT, buffer, KEY_READ) == true)
		{
			if (keyViProgID.ReadStringValue(NULL, buffer, 512) == true)
			{
				if (wcslen(buffer) > 0)
				{
					pi.VersionIndependentProgID = buffer;
				}
				else
				{
					pi.VersionIndependentProgID.clear();
				}
			}
		}
		else
		{
			pi.VersionIndependentProgID.clear();
		}
		//______________________________________ HKCR\CLSID\{clsid}\Control
		if (controlsOnly == true)
		{
			_snwprintf_s(buffer, 512, _TRUNCATE, L"CLSID\\%s\\Control", pi.clsid.c_str());
			if (keyControl.Open(HKEY_CLASSES_ROOT, buffer, KEY_READ) == true) info.push_back(pi);
		}
		else
		{
			info.push_back(pi);
		}
	}
	std::sort(info.begin(), info.end());
	return (int)info.size();
}

HRESULT Assistant::GetUserDefinedInfo(ITypeInfoPtr typeInfo, HREFTYPE hreftype, Com::FuncParam& param)
{
	//________________________________________________________________ Be sure to return clean values
	param.typeKindLink = TKIND_DISPATCH;
	param.iidLink = GUID_NULL;
	//
	HRESULT hr;
	ITypeInfoPtr typeInfoUserDefined;
	hr = typeInfo->GetRefTypeInfo(hreftype, &typeInfoUserDefined);
	if (FAILED(hr)) return hr;

	_bstr_t name;
	hr = typeInfoUserDefined->GetDocumentation(MEMBERID_NIL, &name.GetBSTR(), NULL, NULL, NULL);
	if (SUCCEEDED(hr))
	{
		if (name.length() == 0)
		{
			param.descrLink.clear();
		}
		else
		{
			param.descrLink = name;
		}
	}
	else
	{
		param.descrLink.clear();
	}
	//_______________________________________________________________ TYPEATTR
	TYPEATTR* typeAttr = NULL;
	hr = typeInfoUserDefined->GetTypeAttr(&typeAttr);
	if (FAILED(hr))
	{
		typeInfoUserDefined->ReleaseTypeAttr(typeAttr);
		return hr;
	}
	param.iidLink = typeAttr->guid;
	param.typeKindLink = typeAttr->typekind;
	typeInfoUserDefined->ReleaseTypeAttr(typeAttr);
	return S_OK;
//	if (typeAttr->typekind == TKIND_RECORD)
//	{
//		const int varCount = typeAttr->cVars;
//		VARDESC* vardesc = NULL;
//		DISPID memid;
////		VARIANT* value;
//		VARTYPE varType;
//		_variant_t vtValue;
//		double y = 10;
//		for (int i = 0; i < varCount; i++)
//		{
//			hr = typeInfoUserDefined->GetVarDesc(i, &vardesc);
//			if (SUCCEEDED(hr))
//			{
//				if (vardesc->varkind == VAR_PERINSTANCE)
//				{
//					memid = vardesc->memid;
//					varType = vardesc->elemdescVar.tdesc.vt;
//					//value = (VARIANT*)(vardesc->lpvarValue + (byte)vardesc->oInst);
//					//value = (VARIANT*)(vardesc->lpvarValue);
//
//					vtValue.Clear();
//					vtValue.vt = varType;
//					if (varType == VT_EMPTY)
//					{
//						y = 10;
//					}
//					else if (varType == VT_NULL)
//					{
//						y = 10;
//					}
//					else if (varType == VT_BSTR)
//					{
//						//vtValue.bVal = value->bVal;
//					}
//					else if (varType == VT_PTR)
//					{
//						y = 10;
//						//vtValue.bVal = value->bVal;
//					}
//					else if (varType == VT_CARRAY)
//					{
//						y = 10;
//						//vtValue.bVal = value->bVal;
//					}
//					else if (varType == VT_UI1)
//					{
//						y = 10;
//						//vtValue.bVal = value->bVal;
//					}
//					else if (varType == VT_UI2)
//					{
//						y = 10;
//						//vtValue.uiVal = value->uiVal;
//					}
//					else if (varType == VT_UI4)
//					{
//						y = 10;
//						//vtValue.ulVal = vardesc->lpvarValue->ulVal;//value->ulVal;
//						//vtValue.ulVal  = vardesc->elemdescVar.tdesc.
//					}
//					else if (varType == VT_I8)
//					{
//						y = 10;
//						//vtValue.llVal = value->llVal;
//					}
//					else if (varType == VT_UI8)
//					{
//						y = 10;
//						//vtValue.ullVal = value->ullVal;
//					}
//		
//					//vtValue = value;
//					//ITypeInfoPtr typeInfoOther;
//					//hr = typeInfoUserDefined->GetRefTypeInfo(vardesc->elemdescVar.tdesc.hreftype, &typeInfoOther);
//					//if (FAILED(hr)) return hr;
//					//_bstr_t name;
//					//hr = typeInfoOther->GetDocumentation(MEMBERID_NIL, &name.GetBSTR(), NULL, NULL, NULL);
//					////
//					//TYPEATTR* typeAttr2 = NULL;
//					//hr = typeInfoOther->GetTypeAttr(&typeAttr2);
//					////if (FAILED(hr))
//					////{
//					////	typeInfoOther->ReleaseTypeAttr(typeAttr2);
//					////	return hr;
//					////}
//					//typeInfoOther->ReleaseTypeAttr(typeAttr2);
//				}
//				else if (vardesc->varkind == VAR_CONST)
//				{
//
//				}
//			}
//			typeInfo->ReleaseVarDesc(vardesc);
//		}
//	}
//	//if (typeAttr->typekind == TKIND_ENUM)
//	//{
//	//	hr = ReadEnum(typeInfoUserDefined, param.enumList);
//	//	if (FAILED(hr))
//	//	{
//	//		typeInfoUserDefined->ReleaseTypeAttr(typeAttr);
//	//		typeInfoUserDefined = NULL;
//	//		return false;
//	//	}
//	//}
//	typeInfoUserDefined->ReleaseTypeAttr(typeAttr);
//	typeInfoUserDefined = NULL;
//	return S_OK;
}

HRESULT Assistant::GetTypeInfoData(IDispatchPtr dispatch, Com::TypeInfoData& tid)
{
	UINT typeInfoCount = 0;
	HRESULT hr;
	//_________________________________________________________________ GetTypeInfoCount
	hr = dispatch->GetTypeInfoCount(&typeInfoCount); // this function returns: 0 or 1
	if (FAILED(hr) == true)
	{
		throw(Com::Exception(hr, L"Com::Assistant::GetFuncInfo.dispatch->GetTypeInfoCount"));
		return hr;
	}
	if (typeInfoCount == 0) return S_OK; // Type information is not available
	//_______________________________________________________________ Get ITypeInfo
	ITypeInfoPtr typeInfo;
	hr = dispatch->GetTypeInfo(0, LOCALE_SYSTEM_DEFAULT, &typeInfo);
	if (FAILED(hr) == true) //return S_OK;
	{
		throw(Com::Exception(hr, L"Com::Assistant::GetFuncInfo.dispatch->GetTypeInfo"));
		return hr;
	}
	return Com::Assistant::ReadDispatch(typeInfo, tid);
}

HRESULT Assistant::GetTypeInfoText(const wchar_t* name, IDispatchPtr dispatch, list<wstring>& result)
{
	Com::TypeInfoData tid;
	HRESULT hr = Com::Assistant::GetTypeInfoData(dispatch, tid);
	if (FAILED(hr) == true)
	{
		result.clear();
		return hr;
	}
	result.resize(tid.funcList.size() + 1);

	list<wstring>::iterator pr = result.begin();
	int paramCount;
	int requiredCount;
	int i;

	//_________________________________________________________________ Insert the Object name at the top of the list
	*pr = name;
	*pr += L" - Optional parameters are enclosed in [ ]";
	pr++;
	//_________________________________________________________________ Insert Functions
	list<Com::FuncInfo>::iterator pfi = tid.funcList.begin();
	list<Com::FuncInfo>::const_iterator fiend = tid.funcList.end();
	for (; pfi != fiend; pfi++, pr++)
	{
		*pr = Com::FuncInfo::GetFuncTypeText(pfi->dispatch_type);
		*pr += L"\t";
		//
		*pr += pfi->name;
		*pr += L"(";
		paramCount = (int)pfi->param.size();
		requiredCount = paramCount - pfi->numOptionalParameters;
		for (i = 0; i < paramCount; i++)
		{
			if (i >= requiredCount) *pr += L"[";
			*pr += Com::FuncInfo::GetParamTypeText(pfi->param[i].datatype, true);
			*pr += L" ";
			*pr += pfi->param[i].name;
			if (i >= requiredCount) *pr += L"]";
			if (i != paramCount - 1) *pr += L", ";
		}
		if (pfi->returnType.datatype == VT_EMPTY || pfi->returnType.datatype == VT_NULL || pfi->returnType.datatype == VT_VOID)
		{
			*pr += L")";
		}
		else
		{
			*pr += L") returns ";
			*pr += Com::FuncInfo::GetParamTypeText(pfi->returnType.datatype, true);
		}
	}
	return S_OK;
}

bool Assistant::GetTypeInfoData(HWND hWnd, const wchar_t* progId, Com::TypeInfoData& tid)
{
	Com::Boot boot;
	HRESULT hr;
	try
	{
		IDispatchPtr dispatch;
		hr = dispatch.CreateInstance(progId, NULL, CLSCTX_ALL);
		if (FAILED(hr)) return false;
		hr = Com::Assistant::GetTypeInfoData(dispatch, tid);
	}
	catch (Com::Exception excep)
	{
		wchar_t text[512];
		excep.GetErrorText(text, 512);
		::MessageBox(hWnd, text, L"Container::GetFuncInfo", MB_OK | MB_ICONERROR);
		return false;
	}
	return true;
}

//___________________________________________________________________ Property
Property::Property()
{
}

Property::Property(const wstring& name, const wstring& value)
{
	this->name = name;
	this->value = value;
}

Property::~Property()
{
}

//___________________________________________________________________ PersistPropertyBag
PersistPropertyBag::PersistPropertyBag()
{
	refCount = 0;
	properties = NULL;
}

HRESULT PersistPropertyBag::Create(vector<Property>& properties, IUnknownPtr& unknown)
{
	IPersistPropertyBagPtr persistPropertyBagPtr(unknown);
	IPersistPropertyBag2Ptr persistPropertyBag2Ptr(unknown);
	HRESULT hr;
	this->properties = &properties;

	if (persistPropertyBag2Ptr != NULL)
	{
		hr = persistPropertyBag2Ptr->InitNew();
		if (FAILED(hr)) 
		{
			this->properties = NULL;
			return hr;
		}
		//
		hr = persistPropertyBag2Ptr->Load(this, NULL);
		persistPropertyBag2Ptr = NULL;
		if (FAILED(hr)) 
		{
			this->properties = NULL;
			return hr;
		}
	} 
	else if (persistPropertyBagPtr != NULL)
	{
		hr = persistPropertyBagPtr->InitNew();
		if (FAILED(hr)) 
		{
			this->properties = NULL;
			return hr;
		}
		//
		hr = persistPropertyBagPtr->Load(this, NULL);
		persistPropertyBagPtr = NULL;
		if (FAILED(hr)) 
		{
			this->properties = NULL;
			return hr;
		}
	}
	
	return S_OK;
}

PersistPropertyBag::~PersistPropertyBag()
{
}

//_____________________________________________________________ IUnknown
STDMETHODIMP_ (ULONG) PersistPropertyBag::AddRef()
{
	refCount++;
	return refCount;
}

STDMETHODIMP_(ULONG) PersistPropertyBag::Release()
{
	refCount--;
	return refCount;
}

STDMETHODIMP PersistPropertyBag::QueryInterface(REFIID iid, void** ppvObject)
{
	*ppvObject = NULL;

	if (iid == IID_IPropertyBag) *ppvObject = (IPropertyBag*)this;
	else if (iid == IID_IPropertyBag2) *ppvObject = (IUnknown*)(IPropertyBag2*)this;

	if (*ppvObject)
	{
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

//__________________________________________ IPropertyBag
STDMETHODIMP PersistPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
	if (properties == NULL) return E_POINTER;
	if (pVar == NULL) return E_POINTER;
	vector<Property>& prop(*properties);
	const size_t count = prop.size();
	size_t i;

	for (i = 0; i<count; i++) 
	{
		if (_wcsicmp(pszPropName, prop[i].name.c_str()) == 0) break;
	}
	if (i>=count) return E_INVALIDARG;

	switch(pVar->vt)
	{
	case VT_EMPTY:
	case VT_BSTR:
		V_VT(pVar)= VT_BSTR;
		V_BSTR(pVar) = ::SysAllocString(prop[i].value.c_str());
		break;
	case VT_BOOL:
		V_VT(pVar) = VT_BOOL;
		V_BOOL(pVar) = (( _wcsicmp(L"true", prop[i].value.c_str()) == 0 ) ? VARIANT_TRUE : VARIANT_FALSE );
		break;
	case VT_I2:
	case VT_UI2:
		{
		V_VT(pVar) = pVar->vt;
		V_UI2(pVar) = (unsigned short)wcstoul(prop[i].value.c_str(), NULL, 0);
		}
		break;
	case VT_I4:
	case VT_UI4:
	case VT_INT:
	case VT_UINT:
		{
		V_VT(pVar) = pVar->vt;
		V_UINT(pVar) = (unsigned int)wcstoul(prop[i].value.c_str(), NULL, 0);
		}
		break;
	case VT_R4:
		V_VT(pVar) = VT_R4;
		V_R4(pVar) = (float)wcstod(prop[i].value.c_str(), NULL);
		break;
	case VT_R8:
		V_VT(pVar) = VT_R8;
		V_R8(pVar) = (double)wcstod(prop[i].value.c_str(), NULL);
		break;
	default:
		return E_INVALIDARG;
	}
	 return S_OK;
}

STDMETHODIMP PersistPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
	return E_NOTIMPL;
}

//__________________________________________ IPropertyBag2         
STDMETHODIMP PersistPropertyBag::Read(ULONG cProperties, PROPBAG2 *pPropBag, IErrorLog *pErrLog, VARIANT *pvarValue, HRESULT *phrError)
{
	if (pPropBag==NULL) return E_INVALIDARG;
	if (pvarValue==NULL) return E_INVALIDARG;
	vector<Property>& prop(*properties);
	const size_t count = prop.size();

	PROPBAG2* p = NULL;
	HRESULT hr;
	for (size_t i = 0; i <count; ++i)
	{
		p = pPropBag + i;
		V_VT(pvarValue) = p->vt;
		hr = Read(p->pstrName, pvarValue + i, pErrLog);
		if (phrError != NULL ) 
		{
			phrError[i] = SUCCEEDED(hr) ? hr : DISP_E_PARAMNOTFOUND;
		}
	}
	return S_OK;
}

STDMETHODIMP PersistPropertyBag::Write(ULONG cProperties, PROPBAG2 *pPropBag, VARIANT *pvarValue)
{
	return E_NOTIMPL;
}

STDMETHODIMP PersistPropertyBag::CountProperties(ULONG *pcProperties)
{
	*pcProperties = 0;
	if (properties) 
	{
		*pcProperties = (ULONG)properties->size();
	}
	return S_OK;
}

STDMETHODIMP PersistPropertyBag::GetPropertyInfo(ULONG iProperty, ULONG cProperties, PROPBAG2 *pPropBag, ULONG *pcProperties)
{
	if (pPropBag==NULL) return E_INVALIDARG;
	if (pcProperties==NULL) return E_INVALIDARG;
	vector<Property>& prop(*properties);
	const size_t count = prop.size();
	if (iProperty >= count) return E_INVALIDARG;

	PROPBAG2* p = NULL;
	size_t i = 0;

	for (i = iProperty; i < (iProperty + cProperties) && i < count; ++i)
	{
		p = pPropBag + (i - iProperty);
		memset(p, 0, sizeof(PROPBAG2));
		p->dwType = PROPBAG2_TYPE_DATA;
		p->vt = VT_BSTR;
		p->cfType = CF_TEXT;
		p->dwHint = iProperty;
		p->pstrName = ::SysAllocString(prop[i].name.c_str());
	}
	*pcProperties = (ULONG)(i - iProperty);
	return S_OK;
}

STDMETHODIMP PersistPropertyBag::LoadObject(LPCOLESTR pstrName, DWORD dwHint, IUnknown *pUnkObject, IErrorLog *pErrLog)
{
	return E_NOTIMPL;
}

//____________________________________________________ Exeption
Exception::Exception()
{
	_hr = S_OK;
	_argError = -1;
	::memset(&_excepInfo, 0, sizeof(EXCEPINFO));
}

Exception::Exception(HRESULT hr, wchar_t* info)
{
	_hr = hr;
	_argError = -1;
	_info = info;
	Sys::TextAssistant::Replace(_info, L"->", L".", true);
	::memset(&_excepInfo, 0, sizeof(EXCEPINFO));
}

Exception::Exception(HRESULT hr, wchar_t* info, EXCEPINFO excepInfo, int argError)
{
	_hr = hr;
	_argError = argError;
	_info = info;
	Sys::TextAssistant::Replace(_info, L"->", L".", true);
	::memcpy(&_excepInfo, &excepInfo, sizeof(EXCEPINFO));
}

Exception::Exception(const Exception& init)
{
	_hr = init._hr;
	_argError = init._argError;
	_info = init._info;
	::memcpy(&_excepInfo, &init._excepInfo, sizeof(EXCEPINFO));
}

Exception::~Exception(void)
{
}

void Exception::ThrowNullPointer(const wchar_t* info)
{
	_hr = E_POINTER;
	_argError = -1;
	_info = info;
	Sys::TextAssistant::Replace(_info, L"->", L".", false);
	::memset(&_excepInfo, 0, sizeof(EXCEPINFO));
	throw(*this);
}

void Exception::ok(const wchar_t* info, HRESULT hr)
{
	if (FAILED(hr) == false) return;
	_hr = hr;
	_argError = -1;
	_info = info;
	Sys::TextAssistant::Replace(_info, L"->", L".", false);
	::memset(&_excepInfo, 0, sizeof(EXCEPINFO));
	throw(*this);
}

void Exception::GetErrorText(_com_error& input_error, wchar_t* buffer, int buffer_len)
{
	HRESULT hr = input_error.Error();
	if (SUCCEEDED(hr))
	{
		buffer[0] = '\0';
		return;
	}
	wchar_t *errorDescr = Com::Exception::GetErrorDescr(hr);

	_snwprintf_s(buffer, buffer_len, _TRUNCATE, 
				L"%s\r\nErrorMessage:%s\r\n\r\nHelpContext: %d\r\nDescription: %s\r\nHelpFile: %s\r\nSource: %s", 
				errorDescr,
				input_error.ErrorMessage(), input_error.HelpContext(), 
				(const wchar_t*)input_error.Description(),
				(const wchar_t*)input_error.HelpFile(), 
				(const wchar_t*)input_error.Source());
}

void Exception::Display(HWND hWnd, const wchar_t* caption)
{
	wchar_t text[1024];
	GetErrorText(text, 1024);
	::MessageBox(hWnd, text, caption, MB_OK | MB_ICONERROR);
}

void Exception::GetErrorText(wchar_t* buffer, int buffer_len)
{
	if (SUCCEEDED(_hr))
	{
		buffer[0] = '\0';
		return;
	}

	if(_hr == DISP_E_EXCEPTION)
	{
		//if (_argError >= 0)
		//{
		//	_snwprintf_s(buffer, buffer_len, _TRUNCATE, 
		//		L"%s raised an exception\r\n\r\nSource: %s\r\nDescription: %s\r\nHelp File: %s\r\n\r\nError in argument: %d", 
		//			_info, _excepInfo.bstrSource, _excepInfo.bstrDescription, _excepInfo.bstrSource, _argError);
		//}
		//else
		//{
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, 
				L"%s raised an exception\r\n\r\nSource: %s\r\nDescription: %s\r\nHelp File: %s\r\nCode: %d\r\nHelp Context: %d", 
				_info.c_str(), _excepInfo.bstrSource, _excepInfo.bstrDescription, _excepInfo.bstrSource, _excepInfo.wCode, _excepInfo.dwHelpContext);
		//}
		return;
	}
	else
	{
		wchar_t *errorDescr = Com::Exception::GetErrorDescr(_hr);
		wchar_t* lpMsgBuf;
		::FormatMessageW(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, 
			_hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(wchar_t*)&lpMsgBuf, 0, NULL);
		if (_hr == DISP_E_PARAMNOTFOUND || _hr == DISP_E_TYPEMISMATCH)
		{
			if (_argError < 0) // When the error is negative the parameter is counted in reverse order
			{
				_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"%s\r\n%s\r\n\r\n%s\r\nIncorrect Parameter (counting from the end): %d", _info.c_str(), errorDescr, lpMsgBuf, abs(_argError)-1);
			}
			else
			{
				_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"%s\r\n%s\r\n\r\n%s\r\nIncorrect Parameter: %d", _info.c_str(), errorDescr, lpMsgBuf, _argError);
			}
		}
		else
		{
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"%s\r\n%s\r\n\r\n%s", _info.c_str(), errorDescr, lpMsgBuf);
		}
		::LocalFree( lpMsgBuf );
	}
}

wchar_t* Exception::GetErrorDescr(HRESULT hr)
{
	switch (hr)
	{
	case DISP_E_BADPARAMCOUNT:
		return L"The number of elements provided to DISPPARAMS is different from the number of arguments accepted by the method or property.";
	case DISP_E_BADVARTYPE:
		return L"One of the arguments in rgvarg is not a valid variant type. ";
	case DISP_E_EXCEPTION:
		return L"The application raised an exception.";
	case DISP_E_MEMBERNOTFOUND:
		return L"The requested member does not exist, or the call to Invoke tried to set the value of a read-only property. ";
	case DISP_E_NONAMEDARGS:
		return L"This implementation of IDispatch does not support named arguments.";
	case DISP_E_OVERFLOW:
		return L"One of the arguments in rgvarg could not be coerced to the specified type.";
	case DISP_E_PARAMNOTFOUND:
		return L"One of the parameter DISPIDs does not correspond to a parameter on the method. In this case, puArgErr should be set to the first argument that contains the error.";// Arguments are stored in in reverse order, so the first parameter is the one with the highest index in the array.";
	case DISP_E_TYPEMISMATCH:
		return L"One or more of the arguments could not be coerced.";// The index within rgvarg of the first parameter with the incorrect type is returned in the puArgErr parameter. ";//Arguments are stored in reverse order, so the first parameter is the one with the highest index in the array.";
	case DISP_E_UNKNOWNINTERFACE:
		return L"The interface identifier passed in riid is not IID_NULL.";
	case DISP_E_UNKNOWNLCID:
		return L"The member being invoked interprets string arguments according to the LCID, and the LCID is not recognized. If the LCID is not needed to interpret arguments, this error should not be returned.";
	case DISP_E_PARAMNOTOPTIONAL:
		return L"A required parameter was omitted";
	case CO_E_CLASSSTRING:
		return L"The registered CLSID for the ProgID is invalid.";
	case REGDB_E_WRITEREGDB:
		return L"An error occurred writing the CLSID to the registry.";
	case E_OUTOFMEMORY:
		return L"Ran out of memory.";
	case E_INVALIDARG:
		return L"One or more arguments are invalid.";
	case E_NOINTERFACE:
		return L"No such interface supported.";
	case E_POINTER:
		return L"Invalid pointer.";
	case E_HANDLE:
		return L"Invalid handle.";
	case E_ABORT:
		return L"Operation aborted.";
	case E_ACCESSDENIED:
		return L"General access denied error.";
	case E_PENDING:
		return L"The data necessary to complete this operation is not yet available.";
	case SELFREG_E_TYPELIB:
		return L"A COM server was not able to modify Windows registry to create the keys for the respective type library (*.tlb)";
	case SELFREG_E_CLASS:
		return L"A COM server was not able to modify Windows registry to create the keys for the respective COM class";
	case DISP_E_UNKNOWNNAME:
		return L"Unknown name.";
	case DISP_E_BADINDEX:
		return L"Invalid index.";
	case DISP_E_ARRAYISLOCKED:
		return L"Memory is locked.";
	case DISP_E_BADCALLEE:
		return L"Invalid callee.";
	case DISP_E_NOTACOLLECTION:
		return L"Does not support a collection.";
	case DISP_E_DIVBYZERO:
		return L"Division by zero.";
	case DISP_E_BUFFERTOOSMALL:
		return L"Buffer too small";
	case TYPE_E_BUFFERTOOSMALL:
		return L"Buffer too small.";
	case TYPE_E_FIELDNOTFOUND:
		return L"Field name not defined in the record.";
	case TYPE_E_INVDATAREAD:
		return L"Old format or invalid type library.";
	case TYPE_E_UNSUPFORMAT:
		return L"Old format or invalid type library.";
	case TYPE_E_REGISTRYACCESS:
		return L"There was an error accessing the system registration database.";
	case TYPE_E_LIBNOTREGISTERED:
		return L"The type library was not found in the system registration database.";
	case TYPE_E_UNDEFINEDTYPE:
		return L"Bound to unknown type.";
	case TYPE_E_QUALIFIEDNAMEDISALLOWED:
		return L"Qualified name disallowed.";
	case TYPE_E_INVALIDSTATE:
		return L"Invalid forward reference, or reference to uncompiled type.";
	case TYPE_E_WRONGTYPEKIND:
		return L"Type mismatch.";
	case TYPE_E_ELEMENTNOTFOUND:
		return L"Element not found.";
	case TYPE_E_AMBIGUOUSNAME:
		return L"Ambiguous name.";
	case TYPE_E_NAMECONFLICT:
		return L"Name already exists in the library.";
	case TYPE_E_UNKNOWNLCID:
		return L"Unknown LCID.";
	case TYPE_E_DLLFUNCTIONNOTFOUND:
		return L"Function not defined in specified DLL.";
	case TYPE_E_BADMODULEKIND:
		return L"Wrong module kind for the operation.";
	case TYPE_E_SIZETOOBIG:
		return L"Size may not exceed 64K.";
	case TYPE_E_DUPLICATEID:
		return L"Duplicate ID in inheritance hierarchy.";
	case TYPE_E_INVALIDID:
		return L"Incorrect inheritance depth in standard OLE hmember.";
	case TYPE_E_TYPEMISMATCH:
		return L"Type mismatch.";
	case TYPE_E_OUTOFBOUNDS:
		return L"Invalid number of arguments.";
	case TYPE_E_IOERROR:
		return L"I/O Error.";
	case TYPE_E_CANTCREATETMPFILE:
		return L"Error creating unique tmp file.";
	case TYPE_E_CANTLOADLIBRARY:
		return L"Error loading type library/DLL.";
	case TYPE_E_INCONSISTENTPROPFUNCS:
		return L"Inconsistent property functions.";
	case TYPE_E_CIRCULARTYPE:
		return L"Circular dependency between types/modules.";
	case 0x800706ba:
		return L"The RPC server is unavailable. Terminate all pending specific processes before trying again. When using DCOM: an antivirus software or a firewall may be producing the error.";
	}
	return L"Unknown error";
}

void Exception::Display(HWND hWnd, _com_error& input_error, const wchar_t* caption)
{
	wchar_t text[1024];
	Com::Exception::GetErrorText(input_error, text, 1024);
	::MessageBox(hWnd, text, caption, MB_OK | MB_ICONERROR);
}

//____________________________________________________ Object
Object::Object(void)
{
	_clsid = GUID_NULL;
	name[0] = '\0';
	_checkParameters = false;
}

Object::Object(const Object& init) // Copy constructor
{
	_clsid = GUID_NULL;
	name[0] = '\0';
	_checkParameters = false;
	Private_Copy(init);
}

Object::Object(IDispatch* init)
{
	_clsid = GUID_NULL;
	name[0] = '\0';
	_checkParameters = false;
	dispatch = init;
}

Object::~Object(void)
{
	Destroy(true);
}

Object& Object::operator=(const Com::Object& init)
{
	Destroy(true);
	Private_Copy(init);
	return *this;
}

void Object::CopyFromVariant(const _variant_t& init)
{
	int n = init.pdispVal->AddRef();
	dispatch = init.pdispVal;
	_snwprintf_s(this->name, 32, _TRUNCATE, L"Unknown");// We do not get this information from the _variant_t
	_checkParameters = true; // We do not get this information from the _variant_t
	HRESULT hr = GetFuncBasicInfo();
	if (FAILED(hr))
	{
		wchar_t text[1024];
		_snwprintf_s(text, 1024, _TRUNCATE, L"%s.GetFuncBasicInfo", name);
		Destroy(true);
		throw(Com::Exception(hr, text));
	}
	_clsid = GUID_NULL; // We do not get this information from the _variant_t
}

Object::Object(const _variant_t& init)
{
	_clsid = GUID_NULL;
	name[0] = '\0';
	_checkParameters = false;
	//
	CopyFromVariant(init);
}

Object& Object::operator=(const _variant_t& init)
{
	Destroy(true);
	CopyFromVariant(init);
	return *this;
}

void Object::Private_Copy(const Com::Object& init)
{
	this->dispatch = init.dispatch;
	this->funcBasicInfo = init.funcBasicInfo;
	this->_clsid = init._clsid;
	_snwprintf_s(this->name, 32, _TRUNCATE, L"%s", init.name);
	this->_checkParameters = init._checkParameters;
}

HRESULT Object::CreateClassFiles(const wchar_t* nameSpace)
{
	return Com::Assistant::CreateClassFiles(name, dispatch, nameSpace);
}

const wchar_t* Object::GetObjectName()
{
	return name;
}

HRESULT Object::CreateInstance(const wchar_t* progID, bool checkParameters) // progID may be a ProgId or {string}
{
	return CreateInstance(progID, checkParameters, CLSCTX_ALL);
}

HRESULT Object::CreateInstance(const wchar_t* progID, bool checkParameters, DWORD clsContext) // progID may be a ProgId or {string}
{
	name[0] = '\0';
	CLSID clsid;
	HRESULT hr;
	if (progID[0] == L'{')
	{
		hr = CLSIDFromString(const_cast<LPWSTR> (progID), &clsid);
	}
	else
	{
		hr = ::CLSIDFromProgID(progID, &clsid);
	}
	
	if (FAILED(hr)) 
	{
		throw(Com::Exception(hr, (wchar_t*)progID));
		return hr;
	}
	_snwprintf_s(name, 32, _TRUNCATE, L"%s", progID);
	return CreateInstance(clsid, checkParameters, clsContext);
}

HRESULT Object::CreateInstance(CLSID clsid, bool checkParameters)
{
	return CreateInstance(clsid, checkParameters, CLSCTX_ALL);
}

HRESULT Object::CreateInstance(CLSID clsid, bool checkParameters, DWORD clsContext)
{
	Destroy(false);
	HRESULT hr;

	//_________________________________________ Try to get progID, if missing
	if (name[0] == '\0') 
	{
		//name[0] = '\0';
		LPOLESTR tmp;
		hr = ::ProgIDFromCLSID(clsid, &tmp);
		if (FAILED(hr))
		{
			Destroy(true);
			throw(Com::Exception(hr, L"CreateInstance.ProgIDFromCLSID"));
			return hr;
		}
		_snwprintf_s(name, 32, _TRUNCATE, L"%s", tmp);
		::CoTaskMemFree(tmp);
	}

	wchar_t text[64];
	//_______________________________________________________________________ Get IDispatch
	hr = dispatch.CreateInstance(clsid, NULL, clsContext);
	if (FAILED(hr) == true) 
	{
		_snwprintf_s(text, 64, _TRUNCATE, L"%s.CreateInstance.IDispatch", name);
		Destroy(true);
		throw(Com::Exception(hr, text));
		return hr;
	}

	_clsid = clsid;

	if (checkParameters == true)
	{
		hr = GetFuncBasicInfo();
		if (FAILED(hr) == true)
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%s.CreateInstance.GetFuncBasicInfo", name);
			Destroy(true);
			throw(Com::Exception(hr, text));
			return hr;
		}
	}

	_checkParameters = checkParameters;

	return hr;
}

HRESULT Object::RefreshFuncInfo()
{
	const HRESULT hr = GetFuncBasicInfo();
	wchar_t text[64];
	if (FAILED(hr) == true)
	{
		_snwprintf_s(text, 64, _TRUNCATE, L"%s.RefreshFuncInfo.GetFuncBasicInfo", name);
		Destroy(true);
		throw(Com::Exception(hr, text));
		return hr;
	}
	_checkParameters = true;
	return hr;
}

void Object::GetFuncText(wchar_t* name, int dispath_type, int parameterIndex, wstring& result)
{
	Com::TypeInfoData tid;

	HRESULT hr = Com::Assistant::GetTypeInfoData(dispatch, tid);
	list<Com::FuncInfo>::iterator p = tid.funcList.begin();
	const list<Com::FuncInfo>::iterator pend = tid.funcList.end();

	for( ; p != pend; p++)
	{
		if (p->name == name && p->dispatch_type == dispath_type) break;
	}
	if (p == pend)
	{
		result.clear();
		return;
	}
	result = Com::FuncInfo::GetFuncTypeText(p->dispatch_type);
	result += L"    ";
	result += name;
	result += L"(";
	const int paramCount = (int)p->param.size();
	if (parameterIndex >= 0) parameterIndex = (paramCount -1) - parameterIndex;
	const int requiredCount = paramCount - p->numOptionalParameters;;
	for(int i = 0; i < paramCount; i++)
	{
		if (0 <= parameterIndex && i == parameterIndex) result += L"\r\n\r\nERROR";

		if (i >= requiredCount) result += L"["; 
		result += Com::FuncInfo::GetParamTypeText(p->param[i].datatype, true);
		result += L" ";
		result += p->param[i].name;
		if (i >= requiredCount) result += L"]";
		if (0 <= parameterIndex && i == parameterIndex) result += L"\r\n\r\n";
		if (i != paramCount-1) result += L", ";
	}
	if (p->returnType.datatype == VT_EMPTY || p->returnType.datatype == VT_NULL || p->returnType.datatype == VT_VOID)
	{
		result += L")";
	}
	else
	{
		result += L") returns ";
		result += Com::FuncInfo::GetParamTypeText(p->returnType.datatype, true);
	}
}

HRESULT Object::GetFuncBasicInfo()
{
	funcBasicInfo.clear();
	UINT typeInfoCount = 0;
	HRESULT hr;
	wchar_t text[256];
	//_________________________________________________________________ GetTypeInfoCount
	hr = dispatch->GetTypeInfoCount(&typeInfoCount);
	if (FAILED(hr) == true) 
	{
		_snwprintf_s(text, 64, _TRUNCATE, L"%s.IDispatch.GetTypeInfoCount", name);
		throw(Com::Exception(hr, text));
		return hr;
	}

	ITypeInfoPtr typeInfo;
	hr = dispatch->GetTypeInfo(0, LOCALE_SYSTEM_DEFAULT, &typeInfo);
	if (FAILED(hr) == true) 
	{
		_snwprintf_s(text, 64, _TRUNCATE, L"%s.IDispatch.GetTypeInfo", name);
		throw(Com::Exception(hr, text));
		return hr;
	}

	TYPEATTR* typeAttr = NULL;
	hr = typeInfo->GetTypeAttr(&typeAttr);
	if (FAILED(hr) == true) 
	{
		_snwprintf_s(text, 64, _TRUNCATE, L"%s.IDispatch.ITypeInfo.GetTypeAttr", name);
		typeInfo->ReleaseTypeAttr(typeAttr);
		throw(Com::Exception(hr, text));
		return hr;
	}

	if (typeAttr->typekind != TKIND_DISPATCH)
	{
		typeInfo->ReleaseTypeAttr(typeAttr);
		return S_OK;
	}

	const int methodCount = typeAttr->cFuncs;
	const int varCount = typeAttr->cVars;
	const int dispInfoCount = methodCount + 2*varCount;
	int i; 
	unsigned int j;
	FUNCDESC* funcDesc = NULL;
	Com::FuncBasicInfo fbi;
	Com::InvokeInfo invokeInfo;
	unsigned int count;
	BSTR funcName;
	unsigned int paramCount;
	WORD paramType = 0;
	wchar_t * descr  = NULL;

	for(i = 0; i < methodCount; i++)
	{
		if (FAILED(typeInfo->GetFuncDesc(i, &funcDesc))) continue;
		funcName = NULL;
		if (FAILED(typeInfo->GetNames(funcDesc->memid, &funcName, 1, &count)))
		{
			typeInfo->ReleaseFuncDesc(funcDesc);
			continue;
		}
		//_snwprintf_s(fi.name, 32, _TRUNCATE, L"%s", funcName);
		fbi.dispatch_type = funcDesc->invkind;
		fbi.memid = funcDesc->memid;
		fbi.numOptionalParameters = funcDesc->cParamsOpt;
		paramCount = funcDesc->cParams;
		if (paramCount > 0)
		{
			fbi.paramType.resize(paramCount);
		}
		else
		{
			fbi.paramType.clear();
		}
		fbi.returnType = funcDesc->elemdescFunc.tdesc.vt;

		//________________________________________________________________________________________ PARAMS
		//__________________________________________________________________ param type
		for(j = 0; j<paramCount; j++)
		{
			if (funcDesc->lprgelemdescParam[j].tdesc.vt == VT_SAFEARRAY)
			{
				fbi.paramType[j] = (funcDesc->lprgelemdescParam[j].tdesc.lptdesc->vt) | VT_ARRAY;
			}
			else if (funcDesc->lprgelemdescParam[j].tdesc.vt==VT_PTR)
			{
				fbi.paramType[j] = (funcDesc->lprgelemdescParam[j].tdesc.lptdesc->vt) | VT_BYREF;
			}
			else
			{
				fbi.paramType[j] = funcDesc->lprgelemdescParam[j].tdesc.vt;
			}
		}
		invokeInfo.name = (wchar_t*)funcName;
		invokeInfo.dispatch_type = fbi.dispatch_type;
		funcBasicInfo[invokeInfo] = fbi;
		typeInfo->ReleaseFuncDesc(funcDesc);
		::SysFreeString(funcName);
	}
	typeInfo->ReleaseTypeAttr(typeAttr);
	return S_OK;
}

HRESULT Object::Invoke(wchar_t* name, Com::Param& param, Com::Object& returnedObject, WORD flags)
{
	param.PrepareInvoke(flags);
	HRESULT hr;
	returnedObject.Destroy(true);
	wchar_t text[1024];
	int paramCount = -1;
	
	//____________________________________________________________________ Get DISPID
	DISPID dispid;
	if (funcBasicInfo.empty() == true)
	{
		hr = this->dispatch->GetIDsOfNames(IID_NULL, &name, 1, LOCALE_USER_DEFAULT, &dispid);
		if (FAILED(hr) == true)
		{
			_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.GetIDsOfNames", this->name, name);
			returnedObject.Destroy(true);
			throw(Com::Exception(hr, text));
			return hr;
		}
	}
	else
	{
		Com::InvokeInfo invokeInfo;
		invokeInfo.name = name;
		invokeInfo.dispatch_type = flags;
		map<Com::InvokeInfo, Com::FuncBasicInfo>::iterator it = funcBasicInfo.find(invokeInfo);
		if (it == funcBasicInfo.end())
		{
			_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.GetIDsOfNames DISPID not found", this->name, name);
			returnedObject.Destroy(true);
			hr = DISP_E_MEMBERNOTFOUND;
			throw(Com::Exception(hr, text));
			return hr;
		}
		else
		{
			hr = CheckParam(name, flags, param, it->second, text, 1024);
			if (FAILED(hr) == true)
			{
				throw(Com::Exception(hr, text));
				return hr;
			}
			dispid = it->second.memid;
			paramCount = (int)it->second.paramType.size();
		}
	}

	EXCEPINFO excepInfo;
	UINT argError;
	VARIANT var;
	hr = this->dispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, flags,
		&param.dispparam, &var, &excepInfo, &argError);
	if (FAILED(hr) == true)
	{
		wstring funcText;
		GetFuncText(name, flags, argError, funcText);
		_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.Invoke\r\n\r\n%s\r\n", this->name, name, funcText.c_str());
			returnedObject.Destroy(true);
		if (funcBasicInfo.empty() == true)
		{
			//_____We report parameteres in the reverse order (We send a negative value minus one, so that we can display an appropriate message)
			int tmp = -abs((int)argError)-1;
			throw(Com::Exception(hr, text, excepInfo, tmp));
		}
		else
		{
			//_____We report parameteres in the correct order
			if (paramCount > 0) argError = (paramCount - 1) - (int)argError;
			throw(Com::Exception(hr, text, excepInfo, argError));
		}
		return hr;
		throw(Com::Exception(hr, text, excepInfo, argError));
		return hr;
	}
	int n = var.pdispVal->AddRef();
	returnedObject.dispatch = var.pdispVal;
	_snwprintf_s(returnedObject.name, 32, _TRUNCATE, L"%s", name);
	returnedObject._checkParameters = _checkParameters;
	if (_checkParameters == true)
	{
		hr = returnedObject.GetFuncBasicInfo();
		if (FAILED(hr) == true)
		{
			_snwprintf_s(text, 1024, _TRUNCATE, L"%s.GetFuncBasicInfo", name);
			Destroy(true);
			throw(Com::Exception(hr, text));
			return hr;
		}
	}
	return hr;
}

HRESULT Object::Invoke(wchar_t* name, Com::Param& param, _variant_t& returnedValue, WORD flags)
{
	param.PrepareInvoke(flags);
	HRESULT hr;
	returnedValue.Clear();
	wchar_t text[1024];
	int paramCount = -1;
	
	//____________________________________________________________________ Get DISPID
	DISPID dispid;
	if (funcBasicInfo.empty() == true)
	{
		hr = this->dispatch->GetIDsOfNames(IID_NULL, &name, 1, LOCALE_USER_DEFAULT, &dispid);
		if (FAILED(hr) == true)
		{
			_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.GetIDsOfNames", this->name, name);
			returnedValue.Clear();
			throw(Com::Exception(hr, text));
			return hr;
		}
	}
	else
	{
		Com::InvokeInfo invokeInfo;
		invokeInfo.name = name;
		invokeInfo.dispatch_type = flags;
		map<Com::InvokeInfo, Com::FuncBasicInfo>::iterator it = funcBasicInfo.find(invokeInfo);
		if (it == funcBasicInfo.end())
		{
			_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.GetIDsOfNames DISPID not found", this->name, name);
			returnedValue.Clear();
			hr = DISP_E_MEMBERNOTFOUND;
			throw(Com::Exception(hr, text));
			return hr;
		}
		else
		{
			hr = CheckParam(name, flags, param, it->second, text, 1024);
			if (FAILED(hr) == true)
			{
				throw(Com::Exception(hr, text));
				return hr;
			}
			dispid = it->second.memid;
			paramCount = (int)it->second.paramType.size();
		}
	}

	EXCEPINFO excepInfo;
	UINT argError;
	hr = this->dispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, flags,
		&param.dispparam, &returnedValue, &excepInfo, &argError);
	if (FAILED(hr) == true)
	{
		wstring funcText;
		GetFuncText(name, flags, argError, funcText);
		_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.Invoke\r\n\r\n%s\r\n", this->name, name, funcText.c_str());
			returnedValue.Clear();
		if (funcBasicInfo.empty() == true)
		{
			//_____We report parameteres in the reverse order (We send a negative value minus one, so that we can display an appropriate message)
			int tmp = -abs((int)argError)-1;
			throw(Com::Exception(hr, text, excepInfo, tmp));
		}
		else
		{
			//_____We report parameteres in the correct order
			if (paramCount > 0) argError = (paramCount - 1) - (int)argError;
			throw(Com::Exception(hr, text, excepInfo, argError));
		}
		return hr;
	}
	return hr;
}

HRESULT Object::Invoke(int paramCount, DISPID dispid, wchar_t* name, Com::Param& param, Com::Object& returnedObject, WORD flags)
{
	param.PrepareInvoke(flags);
	HRESULT hr;
	returnedObject.Destroy(true);
	wchar_t text[1024];

	EXCEPINFO excepInfo;
	UINT argError;
	VARIANT var;
	hr = this->dispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, flags,
		&param.dispparam, &var, &excepInfo, &argError);
	if (FAILED(hr) == true)
	{
		wstring funcText;
		GetFuncText(name, flags, argError, funcText);
		_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.Invoke\r\n\r\n%s\r\n", this->name, name, funcText.c_str());
		returnedObject.Destroy(true);
		if (funcBasicInfo.empty() == true)
		{
			//_____We report parameteres in the reverse order (We send a negative value minus one, so that we can display an appropriate message)
			int tmp = -abs((int)argError) - 1;
			throw(Com::Exception(hr, text, excepInfo, tmp));
		}
		else
		{
			//_____We report parameteres in the correct order
			if (paramCount > 0) argError = (paramCount - 1) - (int)argError;
			throw(Com::Exception(hr, text, excepInfo, argError));
		}
		return hr;
		throw(Com::Exception(hr, text, excepInfo, argError));
		return hr;
	}
	int n = var.pdispVal->AddRef();
	returnedObject.dispatch = var.pdispVal;
	_snwprintf_s(returnedObject.name, 32, _TRUNCATE, L"%s", name);
	returnedObject._checkParameters = _checkParameters;
	if (_checkParameters == true)
	{
		hr = returnedObject.GetFuncBasicInfo();
		if (FAILED(hr) == true)
		{
			_snwprintf_s(text, 1024, _TRUNCATE, L"%s.GetFuncBasicInfo", name);
			Destroy(true);
			throw(Com::Exception(hr, text));
			return hr;
		}
	}
	return hr;
}

HRESULT Object::Invoke(int paramCount, DISPID dispid, wchar_t* name, Com::Param& param, _variant_t& returnedValue, WORD flags)
{
	param.PrepareInvoke(flags);
	HRESULT hr;
	returnedValue.Clear();
	wchar_t text[1024];

	EXCEPINFO excepInfo;
	UINT argError;
	hr = this->dispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, flags,
		&param.dispparam, &returnedValue, &excepInfo, &argError);
	if (FAILED(hr) == true)
	{
		wstring funcText;
		GetFuncText(name, flags, argError, funcText);
		_snwprintf_s(text, 1024, _TRUNCATE, L"%s.%s.IDispatch.Invoke\r\n\r\n%s\r\n", this->name, name, funcText.c_str());
		returnedValue.Clear();
		if (funcBasicInfo.empty() == true)
		{
			//_____We report parameteres in the reverse order (We send a negative value minus one, so that we can display an appropriate message)
			int tmp = -abs((int)argError) - 1;
			throw(Com::Exception(hr, text, excepInfo, tmp));
		}
		else
		{
			//_____We report parameteres in the correct order
			if (paramCount > 0) argError = (paramCount - 1) - (int)argError;
			throw(Com::Exception(hr, text, excepInfo, argError));
		}
		return hr;
	}
	return hr;
}

HRESULT Object::CheckParam(wchar_t * name, int dispatch_type, Com::Param& param, Com::FuncBasicInfo& bfi, wchar_t *buffer, int buffer_len)
{
	buffer[0] = '\0';
	const int paramCount = (int)bfi.paramType.size();
	
	int i;
	const int requiredCount = paramCount - bfi.numOptionalParameters;
	const int requiredProvided = param.GetRequiredParamCount();
	//______________________________________________________________________________________________ Check number of parameters
	if (requiredProvided < requiredCount)
	{
		wstring funcHelp;
		GetFuncText(name, dispatch_type, -1, funcHelp);
		_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"%s.%s takes %d parameters, they were provided %d\r\n\r\n%s\r\n\r\n", 
			this->name, name, paramCount, param.dispparam.cArgs, funcHelp.c_str());
		return DISP_E_BADPARAMCOUNT;
	}
	
	//_____________________________________________________________________________________________ Check parameter type
	wchar_t * typeTextFunc = NULL;
	wchar_t * typeTextProvided = NULL;
	for(i = 0; i < paramCount; i ++)
	{
		if (i <= (int)param.dispparam.cArgs) break;
		if (bfi.paramType[i] == param[i].GetVARIANT().vt) continue;
		if ( (bfi.paramType[i] | VT_BYREF) == (param[i].GetVARIANT().vt | VT_BYREF) ) continue;
		if (bfi.paramType[i] == VT_EMPTY) continue;
		if (bfi.paramType[i] == VT_ERROR) continue;
		if (bfi.paramType[i] == VT_VOID) continue;
		//if (VT_VERSIONED_STREAM < bfi.paramType[i]) continue;
		//___________________________________________________________ TYPE MISMATCH
		{
			wstring funcHelp;
			typeTextFunc = Com::FuncInfo::GetParamTypeText(bfi.paramType[i], true);
			typeTextProvided = Com::FuncInfo::GetParamTypeText(param[i].GetVARIANT().vt, true);
			GetFuncText(name, dispatch_type, -1, funcHelp);
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"%s.%s cannot convert parameter %d from %s to %s\r\n\r\n%s\r\n\r\n", 
				this->name, name, i, typeTextProvided, typeTextFunc, funcHelp.c_str());
			return DISP_E_TYPEMISMATCH;
		}
	}
	return S_OK;
}

HRESULT Object::CheckParam(wchar_t * name, int dispatch_type, variant_t& input, Com::FuncBasicInfo& bfi, wchar_t *buffer, int buffer_len)
{
	buffer[0] = '\0';
	const int paramCount = (int)bfi.paramType.size();

	//______________________________________________________________________________________________ Check number of parameters
	if (paramCount != 1)
	{
		wstring funcHelp;
		GetFuncText(name, dispatch_type, -1, funcHelp);
		_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"%s.%s takes %d parameters\r\n\r\n%s\r\n\r\n", 
			this->name, name, paramCount, funcHelp.c_str());
		return DISP_E_BADPARAMCOUNT;
	}
	
	//_____________________________________________________________________________________________ Check parameter type
	wchar_t * typeTextFunc = NULL;
	wchar_t * typeTextProvided = NULL;

	if (bfi.paramType[0] == input.vt) return S_OK;
	if ((bfi.paramType[0] | VT_BYREF) == (input.vt | VT_BYREF) ) return S_OK;
	if (bfi.paramType[0] == VT_EMPTY) return S_OK;
	if (bfi.paramType[0] == VT_ERROR) return S_OK;
	if (bfi.paramType[0] == VT_VOID) return S_OK;

	//___________________________________________________________ TYPE MISMATCH
	wstring funcHelp;
	typeTextFunc = Com::FuncInfo::GetParamTypeText(bfi.paramType[0], true);
	typeTextProvided = Com::FuncInfo::GetParamTypeText(input.vt, true);
	GetFuncText(name, dispatch_type, -1, funcHelp);
	_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"%s.%s cannot convert parameter from %s to %s\r\n\r\n%s\r\n\r\n", 
		this->name, name, typeTextProvided, typeTextFunc, funcHelp.c_str());
	return DISP_E_TYPEMISMATCH;
}

//_________________________________________________________________________________________________________ GET
HRESULT Object::Get(wchar_t* name, Com::Param& param, _variant_t& returnedValue)
{
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, Com::Param& param, Com::Object& returnedObject)
{
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, Com::Object& returnedObject)
{
	Com::Param param;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t& returnedValue)
{
	Com::Param param;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t& returnedValue)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t& returnedValue)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t& returnedValue)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t& returnedValue)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t& returnedValue)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, Com::Object& returnedObject)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, Com::Object& returnedObject)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, Com::Object& returnedObject)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, Com::Object& returnedObject)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYGET);
}

HRESULT Object::Get(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5, Com::Object& returnedObject)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYGET);
}

//_________________________________________________________________________________________________________ PUT
HRESULT Object::Put(wchar_t* name, _variant_t input)
{
	Com::Param param(1);
	param[0] = input;
	_variant_t returnedValue;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, Com::Param& param, _variant_t& returnedValue)
{
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, Com::Param& param, Com::Object& returnedObject)
{
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t& returnedValue)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t& returnedValue)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t& returnedValue)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t& returnedValue)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t& returnedValue)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, Com::Object& returnedObject)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, Com::Object& returnedObject)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, Com::Object& returnedObject)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, Com::Object& returnedObject)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUT);
}

HRESULT Object::Put(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5, Com::Object& returnedObject)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUT);
}

//_________________________________________________________________________________________________________ PUTREF
HRESULT Object::PutRef(wchar_t* name, _variant_t input)
{
	Com::Param param(1);
	param[0] = input;
	_variant_t returnedValue;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, Com::Param& param, _variant_t& returnedValue)
{
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, Com::Param& param, Com::Object& returnedObject)
{
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t& returnedValue)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t& returnedValue)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t& returnedValue)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t& returnedValue)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t& returnedValue)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedValue, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, Com::Object& returnedObject)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, Com::Object& returnedObject)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, Com::Object& returnedObject)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, Com::Object& returnedObject)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUTREF);
}

HRESULT Object::PutRef(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5, Com::Object& returnedObject)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedObject, DISPATCH_PROPERTYPUTREF);
}

//_________________________________________________________________________________________________________ METHOD
HRESULT Object::Method(wchar_t* name, Com::Param& param, Com::Object& returnedObject)
{
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, Com::Param& param, _variant_t& returnedValue)
{
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, Com::Param& param)
{
	_variant_t returnedValue;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, Com::Object& returnedObject)
{
	Com::Param param;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t& returnedValue)
{
	Com::Param param;
	_variant_t returnedObject;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name)
{
	Com::Param param;
	_variant_t returnedValue;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

void Object::Release()
{
	Destroy(true);
}

void Object::Destroy(bool all)
{
	if (dispatch != NULL) dispatch = NULL;
	funcBasicInfo.clear();
	if (all == true) name[0] = '\0';
	_clsid = GUID_NULL;
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t& returnedValue)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t& returnedValue)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t& returnedValue)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t& returnedValue)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t& returnedValue)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t& returnedValue)
{
	Com::Param param(6);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t& returnedValue)
{
	Com::Param param(7);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t& returnedValue)
{
	Com::Param param(8);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t& returnedValue)
{
	Com::Param param(9);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t& returnedValue)
{
	Com::Param param(10);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t& returnedValue)
{
	Com::Param param(11);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t& returnedValue)
{
	Com::Param param(12);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t& returnedValue)
{
	Com::Param param(13);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t& returnedValue)
{
	Com::Param param(14);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t& returnedValue)
{
	Com::Param param(15);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t& returnedValue)
{
	Com::Param param(16);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t param17, _variant_t& returnedValue)
{
	Com::Param param(17);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[16] = param17;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}


HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t param17, _variant_t param18, _variant_t& returnedValue)
{
	Com::Param param(18);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[18] = param17;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t param17, _variant_t param18, _variant_t param19, _variant_t& returnedValue)
{
	Com::Param param(19);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[18] = param17;
	param[19] = param18;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
					_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
					_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
					_variant_t param16, _variant_t param17, _variant_t param18, _variant_t param19, _variant_t param20, 
					_variant_t& returnedValue)
{
	Com::Param param(20);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[18] = param17;
	param[19] = param18;
	param[20] = param19;
	return Invoke(name, param, returnedValue, DISPATCH_METHOD);
}
//
HRESULT Object::Method(wchar_t* name, _variant_t param1, Com::Object& returnedObject)
{
	Com::Param param(1);
	param[0] = param1;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, Com::Object& returnedObject)
{
	Com::Param param(2);
	param[0] = param1;
	param[1] = param2;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, Com::Object& returnedObject)
{
	Com::Param param(3);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, Com::Object& returnedObject)
{
	Com::Param param(4);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5, Com::Object& returnedObject)
{
	Com::Param param(5);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, Com::Object& returnedObject)
{
	Com::Param param(6);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, Com::Object& returnedObject)
{
	Com::Param param(7);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, Com::Object& returnedObject)
{
	Com::Param param(8);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, Com::Object& returnedObject)
{
	Com::Param param(9);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10, Com::Object& returnedObject)
{
	Com::Param param(10);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, Com::Object& returnedObject)
{
	Com::Param param(11);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, Com::Object& returnedObject)
{
	Com::Param param(12);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, Com::Object& returnedObject)
{
	Com::Param param(13);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, Com::Object& returnedObject)
{
	Com::Param param(14);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15, Com::Object& returnedObject)
{
	Com::Param param(15);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, Com::Object& returnedObject)
{
	Com::Param param(16);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t param17, Com::Object& returnedObject)
{
	Com::Param param(17);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[16] = param17;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t param17, _variant_t param18, Com::Object& returnedObject)
{
	Com::Param param(18);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[16] = param17;
	param[17] = param18;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t param17, _variant_t param18, _variant_t param19, Com::Object& returnedObject)
{
	Com::Param param(19);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[16] = param17;
	param[17] = param18;
	param[18] = param19;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

HRESULT Object::Method(wchar_t* name, _variant_t param1, _variant_t param2, _variant_t param3, _variant_t param4, _variant_t param5,
				_variant_t param6, _variant_t param7, _variant_t param8, _variant_t param9, _variant_t param10,
				_variant_t param11, _variant_t param12, _variant_t param13, _variant_t param14, _variant_t param15,
				_variant_t param16, _variant_t param17, _variant_t param18, _variant_t param19, _variant_t param20, Com::Object& returnedObject)
{
	Com::Param param(20);
	param[0] = param1;
	param[1] = param2;
	param[2] = param3;
	param[3] = param4;
	param[4] = param5;
	param[5] = param6;
	param[6] = param7;
	param[7] = param8;
	param[8] = param9;
	param[9] = param10;
	param[10] = param11;
	param[11] = param12;
	param[12] = param13;
	param[13] = param14;
	param[14] = param15;
	param[15] = param16;
	param[16] = param17;
	param[17] = param18;
	param[18] = param19;
	param[19] = param20;
	return Invoke(name, param, returnedObject, DISPATCH_METHOD);
}

//____________________________________________________ CoInstance
//CoInstance::CoInstance(void) 
//{
//}
//
//CoInstance::~CoInstance(void)
//{
//}
//
//HRESULT CoInstance::CreateInstance(CLSID clsid, bool checkParameters)
//{
//	return CreateInstance(clsid, checkParameters, CLSCTX_ALL);
//}
//
//HRESULT CoInstance::CreateInstance(CLSID clsid, bool checkParameters, DWORD clsContext)
//{
//	destroy(false);
//	HRESULT hr;
//
//	//_________________________________________ Try to get progID, if missing
//	if (name[0] == '\0') 
//	{
//		//name[0] = '\0';
//		LPOLESTR tmp;
//		hr = ::ProgIDFromCLSID(clsid, &tmp);
//		if (FAILED(hr))
//		{
//			destroy(true);
//			throw(Com::Exception(hr, L"CreateInstance.ProgIDFromCLSID"));
//			return hr;
//		}
//		_snwprintf_s(name, 32, _TRUNCATE, L"%s", tmp);
//		::CoTaskMemFree(tmp);
//	}
//
//	wchar_t text[64];
//	//_________________________________________ CoCreateInstance returns a pointer to an object that implements IUnknown
//	//hr = ::CoCreateInstance((CLSID)clsid, NULL, clsContext, IID_IUnknown, (void**)&unknown); 
//	//if (FAILED(hr) == true) 
//	//{
//	//	_snwprintf_s(text, 64, _TRUNCATE, L"%s.CreateInstance.IUnknown", name);
//	//	destroy(true);
//	//	throw(Com::Exception(hr, text));
//	//	return hr;
//	//}
//
//	//_________________________________________________________________________ Put an OLE compound document object into the running state
//	//hr = OleRun(unknown);
//	//if (FAILED(hr) == true) 
//	//{
//	//	_snwprintf_s(text, 64, _TRUNCATE, L"%s.CreateInstance.OleRun", name);
//	//	destroy(true);
//	//	throw(Com::Exception(hr, text));
//	//	return hr;
//	//}
//
//
//
//	 //if (SUCCEEDED(hr)) {
//  //      //            hr = pIUnknown->QueryInterface(GetIID(), reinterpret_cast<void**>(&m_pInterface));
//
//	//________________________________________ Get a pointer to an object that implements IDispatch
//	//hr = unknown->QueryInterface(IID_IDispatch, (void**)&dispatch);
//	//if (FAILED(hr) == true)
//	//{
//	//	_snwprintf_s(text, 64, _TRUNCATE, L"%s.CreateInstance.IDispatch", name);
//	//	destroy(true);
//	//	throw(Com::Exception(hr, text));
//	//	return hr;
//	//}
//	_clsid = clsid;
//
//	if (checkParameters == true)
//	{
//		hr = GetFuncBasicInfo();
//		if (FAILED(hr) == true)
//		{
//			_snwprintf_s(text, 64, _TRUNCATE, L"%s.CreateInstance.GetFuncBasicInfo", name);
//			destroy(true);
//			throw(Com::Exception(hr, text));
//			return hr;
//		}
//	}
//
//	_checkParameters = checkParameters;
//
//	return hr;
//}
//
//// It creates an instance from a ProgId or {string}
//HRESULT CoInstance::CreateInstance(const wchar_t* progID, bool checkParameters)
//{
//	return CreateInstance(progID, checkParameters, CLSCTX_ALL);
//}
//
//// It creates an instance from a ProgId or {string}
//HRESULT CoInstance::CreateInstance(const wchar_t* progID, bool checkParameters, DWORD clsContext)
//{
//	name[0] = '\0';
//	CLSID clsid;
//	HRESULT hr;
//	if (progID[0] == L'{')
//	{
//		hr = CLSIDFromString(const_cast<LPWSTR> (progID), &clsid);
//	}
//	else
//	{
//		hr = ::CLSIDFromProgID(progID, &clsid);
//	}
//
//	
//	if (FAILED(hr)) 
//	{
//		throw(Com::Exception(hr, (wchar_t*)progID));
//		return hr;
//	}
//	_snwprintf_s(name, 32, _TRUNCATE, L"%s", progID);
//	return CreateInstance(clsid, checkParameters, clsContext);
//}

//______________________________________________________________ CDispatchPtr 


} //__________________________________________________ namespace Com::End

namespace Sys //________________________________________ namespace Sys::Ini
{

//_____________________________________________________________________ Sys::IError
//_____________________________________________________________________ Sys::IColorMapDataProvider
//_____________________________________________________________________ Sys::Sample8
//_____________________________________________________________________ Sys::Sample16
//_____________________________________________________________________ Sys::FileInfo
//_____________________________________________________________________ Sys::HSLColor
//_____________________________________________________________________ Sys::ColorText
//_____________________________________________________________________ Sys::CharInfo
//_____________________________________________________________________ Sys::SocketStatus
SocketStatus::SocketStatus()
{
	Delete();
}

SocketStatus::~SocketStatus()
{
}

void SocketStatus::Delete()
{
	isError = false;
	isConnected = true;
	bytesTransferred = 0;
}

//_____________________________________________________________________ Sys::DriveInformation
//_____________________________________________________________________ Sys::IListFileDirectory
//_____________________________________________________________________ Sys::IListFileDirRecursive
//_____________________________________________________________________ Sys::ITextWriterA
//_____________________________________________________________________ Sys::ITextWriterW
//_____________________________________________________________________ Sys::IStorer
//_____________________________________________________________________ Sys::IChannel
//_____________________________________________________________________ Sys::IVisualStudio
//_____________________________________________________________________ Sys::IEnumerator
//_____________________________________________________________________ Sys::IWindow
//_____________________________________________________________________ Sys::IObject
//_____________________________________________________________________ Sys::IButton
//_____________________________________________________________________ Sys::ITextbox
//_____________________________________________________________________ Sys::IDateTime
//_____________________________________________________________________ Sys::IListBox
//_____________________________________________________________________ Sys::IListView
//_____________________________________________________________________ Sys::Format
//_____________________________________________________________________ Sys::DisplayLastError
//_____________________________________________________________________ Sys::GetLastErrorInformation
//_____________________________________________________________________ Sys::DisplayLastError
//_____________________________________________________________________ Sys::DisplayLastError
//_____________________________________________________________________ Sys::Point
//_____________________________________________________________________ Sys::Point16
//_____________________________________________________________________ Sys::PointF
//_____________________________________________________________________ Sys::Point2D
//_____________________________________________________________________ Sys::Point3D16
//_____________________________________________________________________ Sys::Point3D
//_____________________________________________________________________ Sys::PointInt3D
//_____________________________________________________________________ Sys::SphericalPoint
//_____________________________________________________________________ Sys::Line3D
//_____________________________________________________________________ Sys::Line16X
//_____________________________________________________________________ Sys::HorizontalLine
//_____________________________________________________________________ Sys::HorizontalLineList
//_____________________________________________________________________ Sys::Triangle3D
//_____________________________________________________________________ Sys::XmlAttribute
//XmlAttribute::XmlAttribute()
//{
//}
//
//XmlAttribute::XmlAttribute(const wstring& name, const wstring& value)
//{
//	this->name = name;
//	this->value = value;
//}
//
//XmlAttribute::~XmlAttribute()
//{
//}
//
//void XmlAttribute::Clear()
//{
//	name.clear();
//	value.clear();
//}

//_____________________________________________________________________ Sys::IirCoeff
IirCoeff::IirCoeff()
{
	Clear();
}

IirCoeff::~IirCoeff()
{
}

void IirCoeff::Clear()
{
	a = 0.0;
	b = 0.0;
	c = 0.0;
	d = 0.0;
}

IirCoeff::IirCoeff(const Sys::IirPolarCoeff& init)
{
	Clear();
	Copy(init);
}

Sys::IirCoeff& IirCoeff::operator=(const Sys::IirPolarCoeff& init)
{
	Copy(init);
	return *this;
}

void IirCoeff::Copy(const Sys::IirPolarCoeff& init)
{
	//___________________________________________________________ zeros
	double re = init.zeroR * cos(init.zeroAngle);
	a = -2.0*re; // a1 = - zero - (zero)* = -2 Re (zero)
	b = init.zeroR*init.zeroR; // a2 = (zero)(zero)* =  |z|^2
	//___________________________________________________________ poles
	re = init.poleR * cos(init.poleAngle);
	c = -2.0*re; // b1 = - pole - (pole)* = -2 Re (pole)
	d = init.poleR*init.poleR; // b2 = (pole)(pole)* =  |p|^2
}

//_____________________________________________________________________ Sys::IirPolarCoeff
IirPolarCoeff::IirPolarCoeff()
{
	Clear();
}

IirPolarCoeff::IirPolarCoeff(const Sys::IirCoeff& init)
{
	Clear();
	Copy(init);
}

IirPolarCoeff::~IirPolarCoeff()
{
}

void IirPolarCoeff::Clear()
{
	zeroR = 0.0; // alpha
	zeroAngle = 0.0; // alpha
	poleR = 0.0; // beta
	poleAngle = 0.0; // beta
}

Sys::IirPolarCoeff& IirPolarCoeff::operator=(const Sys::IirCoeff& init)
{
	Copy(init);
	return *this;
}

void IirPolarCoeff::Copy(const Sys::IirCoeff& init)
{
	double re, im;
	//___________________________________________________________ zeros
	re = -init.a/2.0; // a = - zero - (zero)* = -2 Re (zero) ;      Re(zero) = - a /  2
	im = sqrt(init.b - re*re); // a2 = (zero)(zero)* =  |z|^2;        Im(zero) = sqrt(b - re*re);
	//
	zeroR = sqrt(re*re + im*im);
	zeroAngle = atan2(im, re); // -pi <= angle < pi
	//___________________________________________________________ poles
	re = -init.c/2.0; // c = - pole - (pole)* = -2 Re (pole) ;      Re(pole) = - c /  2
	im = sqrt(init.d - re*re); // d= (pole)(pole)* =  |p|^2;        Im(pole) = sqrt(d - re*re);
	//
	poleR = sqrt(re*re + im*im);
	poleAngle = atan2(im, re); //  -pi <= angle < pi
}

//_____________________________________________________________________ Sys::FrequencyMagnitude

//_____________________________________________________________________ Sys::Bound2D
Bound2D::Bound2D()
{
	x = 0.0f;
	y = 0.0f;
	dx = 0.0f;
	dy = 0.0f;
}

Bound2D::~Bound2D()
{
}

bool Bound2D::DoIntersect(vector<Sys::Bound2D>& bounds1, vector<Sys::Bound2D>& bounds2)
{
	const int size1 = (int)bounds1.size();
	if (size1 == 0) return false;
	const int size2 = (int)bounds2.size();
	if (size2 == 0) return false;
	
	const vector<Sys::Bound2D>::iterator b1End = bounds1.end()-1;
	const vector<Sys::Bound2D>::iterator b2End = bounds2.end()-1;
	vector<Sys::Bound2D>::iterator b1, b2;
	for(b1 = bounds1.begin(); b1 != b1End; b1++)
	{
		for(b2 = bounds2.begin(); b2 != b2End; b2++)
		{
			if (Sys::Bound2D::DoIntersect(*b1, *(b1+1), *b2, *(b2+1)) == true) return true;
		}
	}
	return false;
}

bool Bound2D::DoIntersect(Sys::Bound2D& b1, Sys::Bound2D& b2, Sys::Bound2D& b3, Sys::Bound2D& b4)
{
	const float denominator = (b4.dy)*(b2.dx) - (b4.dx)*(b2.dy);//(y4-y3) * (x2-x1) - (x4-x3) * (y2-y1);
	const float dx = (b1.x - b3.x);
	const float dy = (b1.y - b3.y);
	const float numeratorA = (b4.dx)*dy - (b4.dy)*dx;// (x4-x3) * (y1-y3) - (y4-y3) * (x1-x3);
	const float numeratorB = (b2.dx)*dy - (b2.dy)*dx;//(x2-x1) * (y1-y3) - (y2-y1) * (x1-x3);
	const float zero = 0.00000000001f;

	//_______________________________ coincident
	if (fabs(numeratorA) < zero && fabs(numeratorB) < zero && fabs(denominator) < zero) return true;
	//_______________________________ parallel
	if (fabs(denominator) < zero) return false;
	//__________________________________ intersection along the the segments
	const float mA = numeratorA/denominator;
	const float mB = numeratorB/denominator;
	if (mA < 0 || mA > 1 || mB < 0 || mB > 1)  return false;
	return true;
}

bool Bound2D::DoIntersect(vector<Sys::Bound2D>& bounds1, vector<Sys::Bound2D>& bounds2, Sys::Point2D& out_intersection)
{
	const int size1 = (int)bounds1.size();
	if (size1 == 0) return false;
	const int size2 = (int)bounds2.size();
	if (size2 == 0) return false;
	
	const vector<Sys::Bound2D>::iterator b1End = bounds1.end()-1;
	const vector<Sys::Bound2D>::iterator b2End = bounds2.end()-1;
	vector<Sys::Bound2D>::iterator b1, b2;
	for(b1 = bounds1.begin(); b1 != b1End; b1++)
	{
		for(b2 = bounds2.begin(); b2 != b2End; b2++)
		{
			if (Sys::Bound2D::DoIntersect(*b1, *(b1+1), *b2, *(b2+1), out_intersection) == true) return true;
		}
	}
	return false;
}

bool Bound2D::DoIntersect(Sys::Bound2D& b1, Sys::Bound2D& b2, Sys::Bound2D& b3, Sys::Bound2D& b4, Sys::Point2D& out_intersection)
{
	out_intersection.x = 0.0f;
	out_intersection.y = 0.0f;

	const float denominator = (b4.dy)*(b2.dx) - (b4.dx)*(b2.dy);//(y4-y3) * (x2-x1) - (x4-x3) * (y2-y1);
	const float dx = (b1.x - b3.x);
	const float dy = (b1.y - b3.y);
	const float numeratorA = (b4.dx)*dy - (b4.dy)*dx;// (x4-x3) * (y1-y3) - (y4-y3) * (x1-x3);
	const float numeratorB = (b2.dx)*dy - (b2.dy)*dx;//(x2-x1) * (y1-y3) - (y2-y1) * (x1-x3);
	const float zero = 0.00000000001f;

	//_______________________________ coincident
	if (fabs(numeratorA) < zero && fabs(numeratorB) < zero && fabs(denominator) < zero)
	{
		out_intersection.x = (b1.x + b2.x) / 2.0f;
		out_intersection.y = (b1.y + b2.y) / 2.0f;
		return true;
	}

	//_______________________________ parallel
	if (fabs(denominator) < zero) return false;

	//__________________________________ intersection along the the segments
	const float mA = numeratorA/denominator;
	const float mB = numeratorB/denominator;
	if (mA < 0 || mA > 1 || mB < 0 || mB > 1)  return false;

	out_intersection.x = b1.x + mA * (b2.dx);
	out_intersection.y = b1.y + mA * (b2.dy);
	return true;
}

// Computes the shortest distance from the line segment p1-p2 to any of the the line segments in bounds
float Bound2D::ShortestDistance(Sys::Point2D& p1, Sys::Point2D& p2, vector<Sys::Bound2D>& bounds)
{
	float distance = (float)1.0e30;
	//
	Sys::Bound2D b1;
	b1.x = p1.x;
	b1.y = p1.y;
	b1.dx = 0.0f;
	b1.dy = 0.0f;
	//
	Sys::Bound2D b2;
	b2.x = p2.x;
	b2.y = p2.y;
	b2.dx = p2.x - p1.x;
	b2.dy = p2.y - p1.y;
	//
	const int size = (int)bounds.size();
	if (size == 0) return distance;
	
	const vector<Sys::Bound2D>::iterator bEnd = bounds.end()-1;
	vector<Sys::Bound2D>::iterator b;
	Sys::Point2D intersection;
	float currentDistance = 0.0f;
	for(b = bounds.begin(); b !=  bEnd; b++)
	{
		if (Sys::Bound2D::DoIntersect(b1, b2, *b, *(b+1), intersection) == true)
		{
			currentDistance = Sys::Bound2D::Distance(p1, intersection);
			if (currentDistance < distance) distance = currentDistance;
		}
	}
	return distance;
}

float Bound2D::Distance(Sys::Point2D& p1, Sys::Point2D& p2)
{
	const float dx = p1.x - p2.x;
	const float dy = p1.y - p2.y;
	return sqrt(dx*dx + dy*dy);
}

//_____________________________________________________________________ Sys::Point3D
//_____________________________________________________________________ Sys::PointInt3D
//_____________________________________________________________________ Sys::RotatedRectangle
RotatedRectangle::RotatedRectangle()
{
	p1.x = 0.0f;
	p1.y = 0.0f;
	//
	p2.x = 0.0f;
	p2.y = 0.0f;
	//
	p3.x = 0.0f;
	p3.y = 0.0f;
	//
	p4.x = 0.0f;
	p4.y = 0.0f;
}

RotatedRectangle::~RotatedRectangle()
{
}

bool RotatedRectangle::IsInsideRegion(const vector<Rectangle>& regionBig) const
{
	bool isInside = false;
	const int len = (int)regionBig.size();
	if (len == 0) return false;
	int i;
	//
	//________________________ Point1
	isInside = false;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(p1) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point2
	isInside = false;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(p2) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point3
	isInside = false;
	for(i = 0; i<len; i++)
	{	
		if (regionBig[i].IsInside(p3) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point4
	isInside = false;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(p4) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	return true;
}

//_____________________________________________________________________ Sys::Rectangle
Rectangle::Rectangle()
{
	left = 0.0f;
	top = 0.0f;
	right = 0.0f;
	bottom = 0.0f;
}

Rectangle::~Rectangle()
{
}

bool Rectangle::IsInside(const RotatedRectangle& rectSmall) const
{
	if (IsInside(rectSmall.p1) == false) return false;
	if (IsInside(rectSmall.p2) == false) return false;
	if (IsInside(rectSmall.p3) == false) return false;
	if (IsInside(rectSmall.p4) == false) return false;
	return true;
}

bool Rectangle::IsInside(const Sys::Point2D& point) const
{
	if (left < right)
	{
		if (point.x < left) return false;
		if (point.x > right) return false;
	}
	else
	{
		if (point.x < right) return false;
		if (point.x > left) return false;
	}
	if (top < bottom)
	{
		if (point.y < top) return false;
		if (point.y > bottom) return false;
	}
	else
	{
		if (point.y < bottom) return false;
		if (point.y > top) return false;
	}

	return true;
}

bool Rectangle::IsInside(const Rectangle& rectSmall) const
{
	Sys::Point2D point;
	//
	point.x = rectSmall.left;
	point.y = rectSmall.top;
	if (IsInside(point) == false) return false;
	//
	point.x = rectSmall.right;
	point.y = rectSmall.top;
	if (IsInside(point) == false) return false;
	//
	point.x = rectSmall.left;
	point.y = rectSmall.bottom;
	if (IsInside(point) == false) return false;
	//
	point.x = rectSmall.right;
	point.y = rectSmall.bottom;
	if (IsInside(point) == false) return false;
	//
	return true;
}

bool Rectangle::IsIntersected(const Rectangle& rect) const
{
	if (left<=rect.left)
	{
		if (right<rect.left) return false;
	}
	else
	{
		if (rect.right<left) return false;
	}

	if (top<=rect.top)
	{
		if (bottom<rect.top) return false;
	}
	else
	{
		if (rect.bottom<top) return false;
	}
	return true;
}

bool Rectangle::IsInsideRegion(const vector<Rectangle>& regionBig) const
{
	bool isInside = false;
	Sys::Point2D point;
	const int len = (int)regionBig.size();
	if (len == 0) return false;
	int i;
	//
	//________________________ Point1
	isInside = false;
	point.x = left;
	point.y = top;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point2
	isInside = false;
	point.x = right;
	point.y = top;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point3
	isInside = false;
	point.x = left;
	point.y = bottom;
	for(i = 0; i<len; i++)
	{	
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	//
	//________________________ Point4
	isInside = false;
	point.x = right;
	point.y = bottom;
	for(i = 0; i<len; i++)
	{
		if (regionBig[i].IsInside(point) == true)
		{
			isInside = true;
			break;
		}
	}
	if (isInside == false) return false;
	return true;
}

#ifdef WIN_GDI_PLUS_ON
//_____________________________________________________________________ Sys::ImageStream
ImageStream::ImageStream()
{
	m_nRefCount = 0;
	m_cb.HighPart = 0;
	m_cb.LowPart = 0;
	SYSTEMTIME st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &m_filetimeCreation);
	SystemTimeToFileTime(&st, &m_filetimeLastWrite);
	SystemTimeToFileTime(&st, &m_filetimeLastRead);
	data = NULL;
}

ImageStream::~ImageStream()
{
}

//BMP 
//GIF 
//JPEG 
//PNG 
//TIFF 
//GDI+ also has built-in decoders that support the following file types: 
//WMF 
//EMF 
//ICON 
int ImageStream::GetEncoderClsid(const wchar_t* format, CLSID* pClsid)
{
	UINT  num = 0;          // number of image encoders
	UINT  size = 0;         // size of the image encoder array in bytes

	Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;

	Gdiplus::GetImageEncodersSize(&num, &size);
	if(size == 0) return -1;  // Failure

	pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
	if(pImageCodecInfo == NULL) return -1;  // Failure

	GetImageEncoders(num, size, pImageCodecInfo);
	for(UINT j = 0; j < num; ++j)
	{
		if( wcscmp(pImageCodecInfo[j].MimeType, format) == 0 )
		{
			*pClsid = pImageCodecInfo[j].Clsid;
			free(pImageCodecInfo);
			return j;  // Success
		}    
	}
	free(pImageCodecInfo);
	return -1;  // Failure
}

IStream* ImageStream::CreateAllocator(string* data)
{
	ImageStream * pImgStream = new ImageStream();

	if (pImgStream!=NULL)
	{
		pImgStream->data = data;
		pImgStream->AddRef();
	}
	else
	{
		delete pImgStream;
	}
	return (IStream*)pImgStream;
}

STDMETHODIMP ImageStream::QueryInterface(REFIID riid, LPVOID FAR * ppvObject)
{
	*ppvObject = NULL;
	if (riid==IID_IUnknown) *ppvObject = (LPUNKNOWN)this;
	if (riid==IID_IStream) *ppvObject = (ImageStream*)this;
	if (*ppvObject==NULL) return E_NOINTERFACE;
	
	((LPUNKNOWN)*ppvObject)->AddRef();
	return S_OK;
}

STDMETHODIMP_ (ULONG) ImageStream::AddRef(void)
{
	return ++m_nRefCount;
}

STDMETHODIMP_ (ULONG) ImageStream::Release(void)
{
	--m_nRefCount;
	if (0L != m_nRefCount) return m_nRefCount;
	delete this;
	return 0L;
}

STDMETHODIMP ImageStream::Read (void *pv, ULONG cb, ULONG *pcbRead)
{
	SYSTEMTIME st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &m_filetimeLastRead);
	return S_OK;
}

STDMETHODIMP ImageStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
	*pcbWritten = cb;
	const int len = cb;
	const char* p = (const char*)pv;
	if (data != NULL)
	{
		data->append(p, len);
	}

	m_cb.LowPart+=(*pcbWritten);
	SYSTEMTIME st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &m_filetimeLastWrite);
	return S_OK;
}

STDMETHODIMP ImageStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
	return S_OK;
}

STDMETHODIMP ImageStream::SetSize(ULARGE_INTEGER libNewSize)
{
	return S_OK;
}

STDMETHODIMP ImageStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, 
		ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Commit(DWORD grfCommitFlags)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Revert()
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::LockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
		DWORD dwLockType)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
		DWORD dwLockType)
{
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
	m_sta.type = STGTY_STREAM;
	m_sta.atime = m_filetimeLastRead;
	m_sta.cbSize = m_cb;
	m_sta.clsid = CLSID_NULL; //No used
	m_sta.ctime = m_filetimeCreation;
	m_sta.grfLocksSupported = LOCK_WRITE;
	m_sta.grfMode = 0; // No used
	m_sta.grfStateBits = 0; // No used
	m_sta.mtime = m_filetimeLastWrite;
	m_sta.pwcsName = LPOLESTR("FILESTREAM");
	return E_NOINTERFACE;
}

STDMETHODIMP ImageStream::Clone(IStream **ppstm)
{
	return E_NOINTERFACE;
}
#endif

//_____________________________________________________________________ Sys::Buffer
Buffer::Buffer()
{
	Constructor();
}

Buffer::~Buffer()
{
	if (buffer != NULL) delete[] buffer;
}

void Buffer::GetText(string& out_text)
{
	out_text.assign(buffer, bytesUsed);
}

int Buffer::GetHttpHeadEndPosition()
{
	if (bytesUsed < 4) return -1;
	const size_t len = bytesUsed - 4;
	register size_t i;
	register char* p = buffer;
	for(i = 0; i <= len; i++, p++)
	{
		if (*p != '\r') continue;
		if (*(p+1) != '\n') continue;
		if (*(p+2) != '\r') continue;
		if (*(p+3) != '\n') continue;
		return (int)i;
	}
	return -1;
}

void Buffer::GetText(wstring& out_text, bool isUtf8)
{
	//___________________________________ Extract text
	string text;
	text.assign(buffer, bytesUsed);
	if (isUtf8 == true)
	{
		Sys::Convert::UTF8ToWstring(text, out_text);
	}
	else
	{
		Sys::Convert::StringToWstring(text, out_text);
	}
}

void Buffer::Constructor()
{
	buffer = NULL;
	readPosition = 0;
	bufferSize = 0;
	bytesUsed = 0;
	isError = false;
}

Buffer::Buffer(const Sys::Buffer& ini)
{
	Constructor();
	Copy(ini);
}

Buffer& Buffer::operator=(const Sys::Buffer& ini)
{
	Delete();
	Copy(ini);
	return *this;
}

void Buffer::Copy(const Sys::Buffer& ini)
{
	if (ini.buffer == NULL)
	{
		Delete();
		return;
	}
	buffer = new char[ini.bufferSize];
	if (buffer == NULL) return; // Memory problem unlikely
	readPosition = ini.readPosition;
	bufferSize = ini.bufferSize;
	bytesUsed = ini.bytesUsed;
	isError = ini.isError;
}

size_t Buffer::GetSize() const
{
	 return bytesUsed;
}

Buffer::operator char*()
{
	return buffer;
}

Buffer::operator const char*() const
{
	return buffer;
}

void Buffer::Delete()
{
	if (buffer != NULL) delete[] buffer;
	Constructor();
}

void Buffer::ResetRead()
{
	readPosition = 0;
}

int Buffer::GetRecommendeSize(int input)
{
	const double d = log10((double)input)/log10(2.0);
	if (d-(int)(d)==0) return input; // It is a power of two
	//_____________________________________ Find next power of two
	const int new_n = (int)(log10((double)input)/log10(2.0))+1;
	return (int)pow(2.0, new_n);

}

bool Buffer::Reserve(size_t size)
{
	Delete();
	if (size == 0) return true;
	const int newSize = GetRecommendeSize((int)size);
	buffer = new char[newSize];
	if (buffer == NULL) return false;
	bufferSize = newSize;
	bytesUsed = 0;
	return true;
}

bool Buffer::SetSize(size_t size)
{
	//__________________________________________ Just delete
	if (size <= 0)
	{
		Delete();
		return true;
	}
	readPosition = 0;
	isError = false;
	//_________________________________________ Nothing to do
	if (bytesUsed == size) return true;
	//_________________________________________ Create New Buffer
	if (bufferSize == 0 && buffer == NULL)
	{
		const int newSize = GetRecommendeSize((int)size);
		buffer = new char[newSize];
		if (buffer == NULL) return false;
		bufferSize = newSize;
		bytesUsed = size;
		return true;
	}
	//_________________________________________ Reduce size
	if (size < bufferSize)
	{
		bytesUsed = size;
		return true;
	}
	//________________________________________ Increase size
	if (size > bufferSize)
	{
		const int newSize = GetRecommendeSize((int)size);
		char* p = new char[newSize];
		if (p == NULL) return false;
		//___ copy
		::memcpy(p, buffer, bytesUsed);
		delete [] buffer;
		buffer = p;
		bytesUsed = size;
		return true;
	}
	return false;
}

bool Buffer::SaveToFile(const wchar_t* filename)
{
	//________________________________________________________________ Create File
	HANDLE hFile = ::CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	//________________________________________________________________ Write Content
	DWORD written;
	DWORD bytesToWrite;
	char* p = buffer;
	size_t totalBytes = bytesUsed;
	while (true)
	{
		bytesToWrite = ((int)totalBytes < 1024) ? (int)totalBytes : 1024;
		if (bytesToWrite == 0) break;
		if (::WriteFile(hFile, p, bytesToWrite, &written, NULL) == false)
		{
			if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
			return false;
		}
		if (written == 0) break;
		p += (size_t)written;
		totalBytes -= (size_t)written;
	}
	//________________________________________________________________ Close File
	if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	return true;
}

bool Buffer::SaveToFile(const wstring& filename)
{
	return SaveToFile(filename.c_str());
}

//bool Buffer::Create(Sys::IChannel& ichannel)
//{
//	//________________________________________________________________ Read Content
//	this->Delete();
//	char data[512];
//	int sent;
//	int  received = ichannel.Receive(data, 512);
//	//_______________________________ While
//	while (received != 0)
//	{
//		if (received == -1) return false;
//		//________________________ Send
//		sent = Send(data, received);
//		if (sent == -1) return false;
//		if (sent != received) return false;
//		//if (received < 512) return true;
//		//_________________________ Read
//		received = ichannel.Receive(data, 512);
//	}
//	return true;
//}

bool Buffer::CreateFromText(const char* in_text)
{
	Delete();
	if (in_text == NULL) return true;
	const size_t len = strlen(in_text);
	if (len == 0) return true;
	if (Reserve(len) == false) return false;
	::memcpy(buffer, in_text, len);
	bytesUsed = len;
	readPosition = 0;
	return true;
}

bool Buffer::CreateFromText(const string& in_text)
{
	return CreateFromText(in_text.c_str());
}

bool Buffer::Create(const Sys::Buffer& in_buffer, size_t position1, size_t position2)
{
	this->Delete();
	const int len = (int)(position2 - position1 + 1);
	if (len <= 0) return false;
	const size_t actualSize = GetRecommendeSize((size_t)len);
	buffer = new char[actualSize];
	if (buffer == NULL) return false;
	bufferSize = actualSize;
	::memcpy(buffer, in_buffer+position1, (size_t)len);
	bytesUsed = len;
	return true;
}

bool Buffer::CreateFromFile(const wchar_t* filename)
{
	this->Delete();
	//________________________________________________________________ Create File
	HANDLE hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	//________________________________________________________________ File Size
	DWORD highSize;
	const size_t fileBytes = (size_t)::GetFileSize(hFile, &highSize);
	const size_t actualSize = this->GetRecommendeSize((int)fileBytes);
	buffer = new char[actualSize];
	if (buffer == NULL) return false;
	bufferSize = actualSize;
	//________________________________________________________________ Read Content
	bytesUsed = 0;
	DWORD read = 0;
	char *p = buffer;

	while (true)
	{
		if (::ReadFile(hFile, p, 2048, &read, NULL) == false)
		{
			if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
			Delete();
			return false;
		}
		if (read == 0) break;
		bytesUsed += (size_t)read;
		p += (size_t)read;
	}
	//________________________________________________________________ Close File
	if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	return true;
}

bool Buffer::CreateFromFile(const wstring& filename)
{
	return CreateFromFile(filename.c_str());
}

//_____________________________________________________ Sys::Storer
int Buffer::Read(void *out_buffer, int bufferSizeInBytes)
{
	if (readPosition >= bytesUsed) return 0;
	const int count = MINIMUM(bufferSizeInBytes, (int)bytesUsed-(int)readPosition);
	const char * p = buffer + readPosition;
	::memcpy(out_buffer, (void*)p, count);
	readPosition += count;
	return count;
}

int Buffer::Write(const void* in_buffer, int bufferSizeInBytes)
{
	readPosition = 0;// Reset reading position so you never reach end of file while writting
	if (bufferSizeInBytes == 0) return 0;
	if (in_buffer == NULL) return 0;

	if (CheckMemory(bufferSizeInBytes) == true)
	{
		char * p = buffer + bytesUsed;
		::memcpy(p, in_buffer, bufferSizeInBytes);
		bytesUsed += bufferSizeInBytes;
		return bufferSizeInBytes;
	}
	isError = true;
	return -1;
}

//____________________________________________________ Sys::IChannel
int Buffer::Receive(char *out_buffer, int bufferSizeInBytes)
{
	return Read((void*)out_buffer, bufferSizeInBytes);
}

int Buffer::Send(const char* in_buffer, int bufferSizeInBytes)
{
	return Write((const void*)in_buffer, bufferSizeInBytes);
}

bool Buffer::CheckMemory(unsigned int size)
{
	//_____________________________________________ Compute new buffer size, if neccesary
	bool increaseBufferSize = false;
	while (bufferSize<bytesUsed + size)
	{
		if (bufferSize == 0) bufferSize = 512;
		bufferSize *= 2;
		increaseBufferSize = true;
	}
	//_____________________________________________ Increase buffer size, then copy
	if (increaseBufferSize == true)
	{
		char* p = new char[bufferSize];
		if (p == NULL) return false;
		//___ copy
		if (bytesUsed > 0) ::memcpy(p, buffer, bytesUsed);
		if (buffer !=NULL) delete [] buffer;
		buffer = p;
	}
	return true;
}

//It returns true, if current position is at the end
bool Buffer::Feof()
{
	return (bytesUsed <= readPosition);
}

//It returns true, if error
bool Buffer::Ferror()
{
	return isError;
}

//_____________________________________________________________________ Sys::Stopwatch


DWORD Performance::data[16];
bool Performance::firstTime = true;
//_____________________________________________________________________ Sys::Performance
Performance::Performance(int index)
{
	//____________________________________________ Set all data in zero
	if (firstTime == true)
	{
		for(int i = 0; i < 16; i++) data[i] = 0;
		firstTime = false;
	}
	//____________________________________________ Store initial time
	if (0 <= index && index < 16)
	{
		this->index = index;
		initialTime = ::GetTickCount();
	}
	else
	{
		this->index = -1;
		initialTime = 0;
	}
}

Performance::~Performance()
{
	if (index < 0) return;
	data[index] += (::GetTickCount() - initialTime);
}

void Performance::Display(HWND hWnd)
{
	//____________________________________ Compute Total
	double total = 0.0;
	int i;
	int count = 0;
	for(i = 0; i < 16; i++)
	{
		if (data[i] == 0) continue;
		count++;
		total += (double)(data[i]);
	}
	//____________________________________ Compute Text
	wstring text;
	wchar_t tx[64];
	for(i = 0; i < 16; i++)
	{
		if (data[i] == 0) continue;
		_snwprintf_s(tx, 64, _TRUNCATE, L"%d: %f %%\r\n", i, 100.0*data[i]/total);
		text += tx;
	}
	::MessageBox(hWnd, text.c_str(), L"Performance", MB_OK | MB_ICONINFORMATION);
}

//__________________________________________ Sys::Pipe
Pipe::Pipe(void)
{
	handleRead = INVALID_HANDLE_VALUE;
	handleWrite = INVALID_HANDLE_VALUE;
}

Pipe::~Pipe(void)
{
	ReadClose();
	WriteClose();
}

bool Pipe::Create()
{
	SECURITY_ATTRIBUTES securityAttributes;
	securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	securityAttributes.lpSecurityDescriptor = NULL;
	securityAttributes.bInheritHandle = TRUE;
	return Create(securityAttributes);
}

bool Pipe::Create(SECURITY_ATTRIBUTES& securityAttributes)
{
	 //____________________________________________________________ Close previous pipe
	 ReadClose();
	WriteClose();
	//_____________________________________________________________
	securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	return (::CreatePipe(&handleRead, &handleWrite, &securityAttributes, 0) != 0);
}

void Pipe::ReadClose()
{
	if (handleRead != INVALID_HANDLE_VALUE)
	{
		::CloseHandle(handleRead);
		handleRead = INVALID_HANDLE_VALUE;
	}
}

void Pipe::WriteClose()
{
	if (handleWrite != INVALID_HANDLE_VALUE)
	{
		::CloseHandle(handleWrite);
		handleWrite = INVALID_HANDLE_VALUE;
	}
}

bool Pipe::IsReadOpen()
{
	return (handleRead != INVALID_HANDLE_VALUE);
}

bool Pipe::IsWriteOpen()
{
	return (handleWrite != INVALID_HANDLE_VALUE);
}

HANDLE Pipe::GetReadHandle()
{
	return handleRead;
}

HANDLE Pipe::GetWriteHandle()
{
	return handleWrite;
}

bool Pipe::Write(LPCVOID lpBuffer, DWORD nNumbOfBytesToWrite, LPDWORD lpNumbOfBytesWritten)
{
	return (::WriteFile(handleWrite, lpBuffer, nNumbOfBytesToWrite, lpNumbOfBytesWritten, NULL) != 0);
}

bool Pipe::Read(LPVOID lpBuffer, DWORD nNumbOfBytesToRead, LPDWORD lpNumbOfBytesRead)
{
	return (::ReadFile(handleRead, lpBuffer, nNumbOfBytesToRead, lpNumbOfBytesRead, NULL) != 0);
}

//________________________________________ Process
Process::Process(void)
{
	processInformation.hThread = NULL;
	processInformation.hProcess = NULL;
}

Process::~Process(void)
{
	CloseProcessHandles();
}

bool Process::Terminate(UINT returnCode)
{
	if (processInformation.hProcess != NULL)
	{
		return (::TerminateProcess(processInformation.hProcess, returnCode) != 0);
	}
	return 0;
}

bool Process::OpenFile(const wchar_t* filename)
{
	::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	const bool ok = (::ShellExecuteW(NULL, L"open", filename, NULL, NULL, SW_SHOW)>(HANDLE)32);
	::CoUninitialize();
	return ok;
}

bool Process::OpenFile(HWND hWnd, const wchar_t* filename)
{
	::CoInitializeEx(hWnd, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	const bool ok = (::ShellExecuteW(NULL, L"open", filename, NULL, NULL, SW_SHOW)>(HANDLE)32);
	::CoUninitialize();
	return ok;
}

bool Process::OpenFile(const wchar_t* filename, const wchar_t* workingDirectory)
{
	::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	const bool ok = (ShellExecuteW(NULL, L"open", filename, NULL, workingDirectory, SW_SHOW)>(HANDLE)32);
	::CoUninitialize();
	return ok;
}

bool Process::OpenFile(const wstring& filename)
{
	return OpenFile(filename.c_str());
}

bool Process::OpenFile(const wstring& filename, const wstring& workingDirectory)
{
	return OpenFile(filename.c_str(), workingDirectory.c_str());
}

bool Process::PrintFile(const wchar_t* filename)
{
	::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	const bool ok = (ShellExecuteW(NULL, L"print", filename, NULL, NULL, SW_SHOW)>(HANDLE)32);
	::CoUninitialize();
	return ok;
}

bool Process::PrintFile(const wchar_t* filename, const wchar_t* workingDirectory)
{
	::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	const bool ok = (ShellExecuteW(NULL, L"print", filename, NULL, workingDirectory, SW_SHOW)>(HANDLE)32);
	::CoUninitialize();
	return ok;
}

bool Process::PrintFile(const wstring& filename)
{
	return PrintFile(filename.c_str());
}

bool Process::PrintFile(const wstring& filename, const wstring& workingDirectory)
{
	return PrintFile(filename.c_str(), workingDirectory.c_str());
}

HWND Process::OpenInternetExplorer(const wchar_t* url)
{
	HWND hWnd = NULL;
	IWebBrowser2* browser = NULL;

	if (FAILED(OleInitialize(NULL)))
	{
		::MessageBox(NULL,  L"Unable to initialize ActiveX ", L"RunProgram::OpenInternetExplorer", MB_ICONERROR);
		return NULL;
	}

	if (FAILED(CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_SERVER, IID_IWebBrowser2, (void**)&browser)))
	{
		::MessageBox(NULL,  L"Unable to create ActiveX ", L"RunProgram::OpenInternetExplorer", MB_ICONERROR);
		return NULL;
	}
	browser->get_HWND((SHANDLE_PTR*)&hWnd);

	if (hWnd==NULL)
	{
		::MessageBox(NULL,  L"Unable to get Window Handle", L"RunProgram::OpenInternetExplorer", MB_ICONERROR);
	}
	//m_browser->put_ToolBar(0); //Hide toolbar
	//SetWindowLongPtr(m_hWnd, GWL_STYLE, WS_BORDER); //Hide system bar
	//m_browser->put_StatusBar(VARIANT_FALSE); //Hide status bar
	ShowWindow(hWnd, SW_SHOW);

	VARIANT ve;
	VARIANT vtUrl;

	BSTR a = SysAllocString(url);
	vtUrl.vt =  VT_BSTR;
	vtUrl.bstrVal = a;

	ve.vt = VT_ERROR;
	ve.scode = DISP_E_PARAMNOTFOUND;

	if (FAILED(browser->Navigate2(&vtUrl, &ve, &ve, &ve, &ve)))
	{
		::MessageBox(NULL,  L"Unable to navigate", L"RunProgram::OpenInternetExplorer", MB_ICONERROR);
	}
	SysFreeString(a);

	if (browser) browser->Release();

	return hWnd;
}

HWND Process::OpenInternetExplorer(const wstring& url)
{
	return Sys::Process::OpenInternetExplorer(url.c_str());
}

bool Process::Execute(const wchar_t* programName, bool standardInput, const wchar_t* workingDirectory, const RECT& rectWindow, wstring& output)
{
	if (this->Execute(programName, standardInput, workingDirectory, rectWindow) == false) return false;
	char text[1024];
	DWORD dwRead;
	output.clear();
	string tmp;

	//WaitForInputIdle(processInformation.hProcess, 2000);

	while(pipeStandardOutput.Read(text, 1023, &dwRead) == true && dwRead != 0)
	{
		text[dwRead] = '\0';
		tmp += text;
	}
	pipeStandardInput.WriteClose();
	pipeStandardOutput.ReadClose();
	Sys::Convert::StringToWstring(tmp, output);
	return true;
}

bool Process::NonOutputExecute(const wchar_t* programName, const wchar_t* workingDirectory, const RECT& rectWindow)
{
	if (this->ExecuteWithNoPipes(programName, workingDirectory, rectWindow) == false) return false;
	WaitForSingleObject(processInformation.hProcess, INFINITE);
	CloseProcessHandles();
	return true;
}

bool Process::NonOutputExecute(const wchar_t* programName, bool standardInput, const wchar_t* workingDirectory, const RECT& rectWindow)
{
	if (this->Execute(programName, standardInput, workingDirectory, rectWindow) == false) return false;
	char text[1024];
	DWORD dwRead;
	while(pipeStandardOutput.Read(text, 1023, &dwRead) == true && dwRead != 0)
	{
		text[dwRead] = '\0';
	}
	pipeStandardInput.WriteClose();
	pipeStandardOutput.ReadClose();
	CloseProcessHandles();
	return true;
}

bool Process::Execute(const wstring& programName, wstring& output)
{
	return Execute(programName.c_str(), output);
}

bool Process::Execute(const wchar_t* programName, wstring& output)
{
	RECT rect = {0, 0, 0, 0};
	if (this->Execute(programName, false, NULL, rect) == false) return false;
	char text[1024];
	DWORD dwRead;
	output.clear();
	string tmp;
	while(pipeStandardOutput.Read(text, 1023, &dwRead) == true && dwRead != 0)
	{
		text[dwRead] = '\0';
		tmp += text;
	}
	pipeStandardOutput.ReadClose();
	Sys::Convert::StringToWstring(tmp, output);
	CloseProcessHandles();
	return true;
}

void Process::CloseProcessHandles()
{
	if (processInformation.hThread != NULL)
	{
		::CloseHandle(processInformation.hThread);
		processInformation.hThread = NULL;
	}
	if (processInformation.hProcess != NULL)
	{
		::CloseHandle(processInformation.hProcess);
		processInformation.hProcess = NULL;
	}
}

bool Process::ExecuteWithNoPipes(const wchar_t* programName, const wchar_t* workingDirectory, const RECT& rectWindow)
{
	CloseProcessHandles();
	if (programName == NULL) return false;
	const size_t len = wcslen(programName);
	if (len == 0) return false;
	//_________________________________________________ STARTUPINFO
	::memset(&startupInfo, 0, sizeof(STARTUPINFO));
	startupInfo.cb = sizeof(STARTUPINFO);
	const bool showWindow = (rectWindow.left != rectWindow.right && rectWindow.top != rectWindow.bottom);
	if (showWindow)
	{
		startupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION;
		startupInfo.dwX = rectWindow.left;
		startupInfo.dwY = rectWindow.top;
		startupInfo.dwXSize = (rectWindow.right - rectWindow.left);
		startupInfo.dwYSize = (rectWindow.bottom - rectWindow.top);
	}
	else
	{
		startupInfo.dwFlags = STARTF_USESHOWWINDOW;
	}
	startupInfo.hStdError = GetStdHandle(STD_ERROR_HANDLE);
	startupInfo.wShowWindow = showWindow ? SW_SHOWNORMAL : SW_HIDE;
	//
	wchar_t* text = new wchar_t[len+1]; // We copy the command because the string will be modified
	_snwprintf_s(text, len+1, _TRUNCATE, L"%s", programName);
	//________________________________________________________ Standard Output
	startupInfo.hStdOutput = NULL;
	//________________________________________________________ Standard Input
	startupInfo.hStdInput = NULL;
	//_________________________________________________ PROCESS_INFORMATION
	::memset(&processInformation, 0, sizeof(PROCESS_INFORMATION));
	const bool ok = (::CreateProcess(NULL, text, NULL, NULL, TRUE, 0, NULL, workingDirectory, &startupInfo, &processInformation)!=0);
	//
	if (text != NULL) delete[] text;
	return ok;
}

bool Process::Execute(const wchar_t* programName, bool standardInput, const wchar_t* workingDirectory, const RECT& rectWindow)
{
	CloseProcessHandles();
	if (programName == NULL) return false;
	const size_t len = wcslen(programName);
	if (len == 0) return false;
	//_________________________________________________ STARTUPINFO
	 ::memset(&startupInfo, 0, sizeof(STARTUPINFO));
	 startupInfo.cb = sizeof(STARTUPINFO);
	 const bool showWindow = (rectWindow.left != rectWindow.right && rectWindow.top != rectWindow.bottom);
	 if (showWindow)
	 {
		 startupInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION;
		 startupInfo.dwX = rectWindow.left;
		 startupInfo.dwY = rectWindow.top;
		 startupInfo.dwXSize = (rectWindow.right - rectWindow.left);
		 startupInfo.dwYSize = (rectWindow.bottom - rectWindow.top);
	 }
	 else
	 {
		 startupInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
	 }
	 startupInfo.hStdError = GetStdHandle(STD_ERROR_HANDLE);
	startupInfo.wShowWindow = showWindow ? SW_SHOWNORMAL : SW_HIDE;
	//
	wchar_t* text = new wchar_t[len+1]; // We copy the command because the string will be modified
	_snwprintf_s(text, len+1, _TRUNCATE, L"%s", programName);
	//________________________________________________________ Standard Output
	if (pipeStandardOutput.Create() == false) return false;
	startupInfo.hStdOutput = pipeStandardOutput.GetWriteHandle();
	//________________________________________________________ Standard Input
	startupInfo.hStdInput = NULL;
	if (standardInput == true)
	{
		if (pipeStandardInput.Create() == false) return false;
		startupInfo.hStdInput = pipeStandardInput.GetReadHandle();
	}
	//_________________________________________________ PROCESS_INFORMATION
	::memset(&processInformation, 0, sizeof(PROCESS_INFORMATION));
	const bool ok = (::CreateProcess(NULL, text, NULL, NULL, TRUE, 0, NULL, workingDirectory, &startupInfo, &processInformation)!=0);
	//
	pipeStandardInput.ReadClose();
	pipeStandardOutput.WriteClose();
	//
	if (text != NULL) delete [] text;
	return ok;
}

const wchar_t* Process::GetErrorDesc(HINSTANCE result)
{
	if (result>(HINSTANCE)32) return L"No error";

	switch((unsigned long long)result)
	{
	case 0L: return L"The operating system is out of memory or resources.";
	case ERROR_FILE_NOT_FOUND: return L"The specified file was not found.";
	case ERROR_PATH_NOT_FOUND: return L"The specified path was not found.";
	case ERROR_BAD_FORMAT: return L"The .exe file is invalid (non-Win32 .exe or error in .exe image).";
	case SE_ERR_ACCESSDENIED: return L"The operating system denied access to the specified file. ";
	case SE_ERR_ASSOCINCOMPLETE: return L"The file name association is incomplete or invalid.";
	case SE_ERR_DDEBUSY: return L"The DDE transaction could not be completed because other DDE transactions were being processed. ";
	case SE_ERR_DDEFAIL: return L"The DDE transaction failed.";
	case SE_ERR_DDETIMEOUT: return L"The DDE transaction could not be completed because the request timed out.";
	case SE_ERR_DLLNOTFOUND: return L"The specified DLL was not found.";
	//case SE_ERR_FNF: return L"The specified file was not found.";
	case SE_ERR_NOASSOC: return L"There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.";
	case SE_ERR_OOM: return L"There was not enough memory to complete the operation.";
	//case SE_ERR_PNF: return L"The specified path was not found.";
	case SE_ERR_SHARE: return L"A sharing violation occurred.";
	}
	return L"Unknown error";
}

//__________________________________________________________________ Sys::Install
Install::Install(void)
{
	buffer[0]='\0';
}

Install::~Install(void)
{
}

const wchar_t* Install::GetCurrentDirectory_(void)
{
	buffer[0]='\0';
	if (::GetCurrentDirectory(SYS_INSTBUFF, buffer)!=0) return buffer;
	return NULL;
}

bool Install::RemoveShortcut(const wchar_t* productName)
{
	wchar_t shortcutFilename[SYS_INSTBUFF];

	_snwprintf_s(shortcutFilename, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.lnk", GetStartupMenuProgramsPath(), productName);
	shortcutFilename[SYS_INSTBUFF-1]='\0';
	//
	return (::DeleteFile(shortcutFilename)!=0);
}

bool Install::ApplicationFolder(Sys::Install::ProductInfo& pi, Sys::IError& error, bool isInstall)
{
	const wchar_t *programFilesPath = this->GetDestinationDirectory(pi.productName);
	if (programFilesPath==NULL) return false;

	bool ok = false;

	if (isInstall)
	{
		ok = (::CreateDirectoryW(programFilesPath, NULL)!=0);
	}
	else
	{
		ok = (::RemoveDirectoryW(programFilesPath)!=0);
	}
	error.ReportError(!ok,  (wchar_t*)programFilesPath);

	return true;
}

bool Install::ApplicationShortcut(Sys::Install::ProductInfo& pi, Sys::IError& error, bool isInstall)
{
	wchar_t programPath[SYS_INSTBUFF];
	wchar_t shortcutFilename[SYS_INSTBUFF];
	wchar_t workingDirectory[SYS_INSTBUFF];
	const	wchar_t *programFilesPath = this->GetDestinationDirectory(pi.productName);
	if (programFilesPath==NULL) return false;

	_snwprintf_s(workingDirectory, SYS_INSTBUFF, _TRUNCATE, L"%s\\", programFilesPath);
	workingDirectory[SYS_INSTBUFF-1]='\0';

	//************************************ Create shortcut for start menu
	_snwprintf_s(programPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.exe", programFilesPath, pi.productName);
	programPath[SYS_INSTBUFF-1]='\0';
	//
	_snwprintf_s(shortcutFilename, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.lnk", GetStartupMenuProgramsPath(), pi.productName);
	shortcutFilename[SYS_INSTBUFF-1]='\0';
	//
	bool ok = false;
	if (isInstall)
	{
		ok = Sys::Install::CreateShortCut(programPath, pi.description, shortcutFilename, workingDirectory, NULL, 0); 
	}
	else
	{
		ok = Sys::Install::RemoveShortcut(pi.productName);
	}
	error.ReportError(ok,  (wchar_t*)programFilesPath);
	return true;
}

// pszFileExt and pi.objectType are required only to associated a file extension with the program
// i.e. InstallSoftware(true, L"Stevens", L"Protect", L"1.0", L".enc", L"EncryptedFile");
// Use ONLY numbers in the version
bool Install::InstallSoftware(Sys::Install::ProductInfo& pi, Sys::IError& ierror)
{
	bool ok = true;
	//ok &= CreateApplicationFolderAndShortcut(pi, ierror); 
	//{
	//	::MessageBox(hWnd,  L"The application folder couldn't be created", L"Install", MB_OK | MB_ICONERROR);
	//	ok = false;
	//}
	ok &= InstallSoftware1(pi, ierror, true);
	ok &= InstallSoftware2(pi, ierror, true);
	ok &= InstallSoftware3(pi, ierror, true);
	//ok &= InstallSoftware4(pi, ierror, true, );

	if (pi.fileExtension != NULL && pi.objectType != NULL)
	{
		ok &= InstallSoftware5(pi, ierror, true);
		ok &= InstallSoftware6(pi, ierror, true);
	}
	//CopyRemoverToWindowsFolder(pi.productName);
	return ok;
}

// ProductNameRemove.exe must be distributed with the product packet and copy to the windows folder
//bool Install::CopyRemoverToWindowsFolder(const wchar_t* productName)
//{
//	//****************************************************ProductNameRemove.exe destination path
//	::GetEnvironmentVariable(L"windir", buffer, SYS_INSTBUFF);
//	wchar_t destinationRemoverPath[SYS_INSTBUFF];
//	_snwprintf_s(destinationRemoverPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%sRemove.exe", buffer, productName); 
//
//	//****************************************************ProductNameRemove.ex_ source path
//	wchar_t removerSourcePath[SYS_INSTBUFF];
//	if (::GetCurrentDirectory(SYS_INSTBUFF, _TRUNCATE, buffer)==0) return false;
//	_snwprintf_s(removerSourcePath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%sRemove.ex_", buffer, productName); 
//	//
//
//	return (::CopyFile(removerSourcePath, destinationRemoverPath, FALSE)!=0);
//}

wchar_t* Install::CopyFileToWindowsFolder(Sys::Install::ProductInfo&pi, HINSTANCE hInst, int resourceId, const wchar_t* destinationFile)
{
	::GetEnvironmentVariable(L"windir", buffer, SYS_INSTBUFF);
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", buffer, destinationFile); 
	//

	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resourceId), L"BIN");
	if (hrsrc==NULL) return L"Unable to find resource";;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return L"Unable to load resource";
	DWORD dwSize = SizeofResource(hInst, hrsrc)+1; 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	BYTE * data = new BYTE[dwSize];
	if (data==NULL)
	{
		::FreeResource(hResource);
		return L"No enough memory to load resource";
	}
	::CopyMemory(data, dataResource, dwSize);
	::FreeResource(hResource);

	DWORD dwWritten;

	HANDLE hFile = ::CreateFile(destinationFileFullPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (data) delete [] data;
		Sys::GetLastErrorInformation(buffer, SYS_INSTBUFF);
		return buffer;
	}
	
	//_____________________________________________ Write Data
	::WriteFile(hFile, dataResource, dwSize, &dwWritten, NULL);
	if (dwSize!=dwWritten)
	{
		if (data) delete [] data;
		if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
		return L"Unable to write file header";
	}
	
	if (data) delete [] data;
	return NULL;
}

// Destination file must not include path
wchar_t *Install::CopyFileToApplicationFolder(Sys::Install::ProductInfo&pi, HINSTANCE hInst, int resourceId, const wchar_t* destinationFile)
{
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return L"Unable to get destination directory";

	//
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", applicationPath, destinationFile);
	destinationFileFullPath[SYS_INSTBUFF-1]='\0';

	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resourceId), L"BIN");
	if (hrsrc==NULL) return L"Unable to find resource";;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return L"Unable to load resource";
	DWORD dwSize = SizeofResource(hInst, hrsrc)+1; 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	BYTE * data = new BYTE[dwSize];
	if (data==NULL)
	{
		::FreeResource(hResource);
		return L"No enough memory to load resource";
	}
	::CopyMemory(data, dataResource, dwSize);
	::FreeResource(hResource);

	DWORD dwWritten;

	HANDLE hFile = ::CreateFile(destinationFileFullPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (data) delete [] data;
		Sys::GetLastErrorInformation(buffer, SYS_INSTBUFF);
		return buffer;
	}
	
	//_____________________________________________ Write Data
	::WriteFile(hFile, dataResource, dwSize, &dwWritten, NULL);
	if (dwSize!=dwWritten)
	{
		if (data) delete [] data;
		if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
		return L"Unable to write file header";
	}
	
	if (data) delete [] data;
	return NULL;
}

wchar_t * Install::CopyDeleteFile(HINSTANCE hInst, int resource_id, const wchar_t* destinationFile, Sys::IError& ierror, bool isInstall)
{
	wchar_t * error = NULL;
	bool ok = false;
	if (isInstall)
	{
		error = this->CopyFileTo(hInst, resource_id, destinationFile);
		ok = (error==NULL);
	}
	else
	{
		ok = (::DeleteFileW(destinationFile)!=0);
		if (ok==false) error = L"Unable to delete file";
	}
	ierror.ReportError(!ok, (wchar_t*)destinationFile);
	return error;
}

// The Destination file must include path
wchar_t * Install::CopyFileTo(HINSTANCE hInst, int resource_id, const wchar_t* destinationFile)
{
	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resource_id), L"BIN");
	if (hrsrc==NULL) return L"Unable to find resource";

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return L"Unable to load resource";
	DWORD dwSize = SizeofResource(hInst, hrsrc); 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	BYTE * data = new BYTE[dwSize];
	if (data==NULL)
	{
		::FreeResource(hResource);
		return L"No enough memory to load resource";
	}
	::CopyMemory(data, dataResource, dwSize);
	::FreeResource(hResource);

	DWORD dwWritten;

	HANDLE hFile = ::CreateFile(destinationFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		if (data) delete [] data;
		Sys::GetLastErrorInformation(buffer, SYS_INSTBUFF);
		return buffer;
	}
	
	//_____________________________________________ Write Data
	::WriteFile(hFile, dataResource, dwSize, &dwWritten, NULL);
	if (dwSize!=dwWritten)
	{
		if (data) delete [] data;
		if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
		return L"Unable to write file header";
	}
	
	if (data) delete [] data;
	if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	return NULL;
}

// Files must not include paths
bool Install::CopyFileToApplicationFolder(Sys::Install::ProductInfo& pi, const wchar_t* sourceFile, const wchar_t* destinationFile)
{
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;
	wchar_t currentDirectory[SYS_INSTBUFF];
	if (::GetCurrentDirectory(SYS_INSTBUFF, currentDirectory)==0) return false;
	//
	wchar_t sourceFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(sourceFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", currentDirectory, sourceFile);
	sourceFileFullPath[SYS_INSTBUFF-1]='\0';
	//
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", applicationPath, destinationFile);
	destinationFileFullPath[SYS_INSTBUFF-1]='\0';

	return (::CopyFile(sourceFileFullPath, destinationFileFullPath, FALSE)!=0);
}

bool Install::DeleteFileFromApplicationFolder(Sys::Install::ProductInfo& pi, const wchar_t* destinationFile)
{
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;
	//
	wchar_t destinationFileFullPath[SYS_INSTBUFF];
	_snwprintf_s(destinationFileFullPath, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", applicationPath, destinationFile);
	destinationFileFullPath[SYS_INSTBUFF-1]='\0';

	return (::DeleteFile(destinationFileFullPath)!=0);
}

bool Install::RegistrySetStringValue(HKEY hkey, PCTSTR pszValueName, PCTSTR pszString)
{
	int nDataSize = sizeof(wchar_t)*(lstrlen(pszString) + 1);
	return (RegSetValueEx(hkey, pszValueName, 0, REG_SZ, (PBYTE)pszString, nDataSize)==ERROR_SUCCESS);
}

// hkey:  HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, ..
// i.e., key2.ReadString(HKEY_LOCAL_MACHINE, "SOFTWARE\\selo", "descr"
const wchar_t* Install::RegistryReadString(HKEY hkey, LPCTSTR pszPathAndName, LPCTSTR pszValueName)
{
	HKEY hKey;
	unsigned long nDataSize;
	unsigned long nDataType;
	DWORD dwResult = 0;
	bool bOk = false;
	DWORD keySize= SYS_INSTBUFF;
	
	buffer[0] = '\0';

	if (RegOpenKeyEx(hkey, pszPathAndName, 0, KEY_ALL_ACCESS, &hKey)==ERROR_SUCCESS)
	{
		nDataSize=254;
		bOk = (RegQueryValueEx(hKey, pszValueName, NULL, &nDataType, (LPBYTE)&buffer, &keySize)
			== ERROR_SUCCESS);
		RegCloseKey(hKey);
		if (bOk == false) return NULL;
	}
	return buffer;
}

// pszFileExt and pi.objectType are required only to remove an associated file extension with the program
bool Install::RemoveSoftware(Sys::Install::ProductInfo& pi, Sys::IError& ierror)
{
	bool bOk = true;
	bOk &= InstallSoftware1(pi, ierror, false);
	bOk &= InstallSoftware2(pi, ierror, false);
	bOk &= InstallSoftware3(pi, ierror, false);
	bOk &= InstallSoftware6(pi, ierror, false);

	if (pi.fileExtension != NULL && pi.objectType != NULL)
	{
		bOk &= InstallSoftware5(pi, ierror, false);
		bOk &= InstallSoftware6(pi, ierror, false);
	}
	bOk &= RemoveShortcut(pi.productName);
	return bOk;
}

 //Installs ..SOFTWARE\CompanyName\ProductName\\Version
bool Install::InstallSoftware1(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\%s\\%s\\%d.%d", pi.companyName, 
			pi.productName, pi.versionMayor, pi.versionMinor);
		key.Create(sz);
	}
	else
	{
		//*************************************************************************open
		key.Open(L"SOFTWARE");

		//*************************************************************************delete Version
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s\\%d.%d", pi.companyName, 
			pi.productName, pi.versionMayor, pi.versionMinor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Product Name
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", pi.companyName, pi.productName);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Company Name
		key.DeleteSubkey(pi.companyName);
	}
	return true;
}


// Installs ..SOFTWARE\\Classes\\Applications\\Product.exe\\shell\\Open\\command
//    (default,  RG_SZ, Full path\\Program.exe)
bool Install::InstallSoftware2(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);

	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{

		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\Applications\\%s.exe\\shell\\Open\\command", 
			pi.productName);
		key.Create(sz);

		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%s.exe\" \"%%1\"", applicationPath, pi.productName);
		key.Set(L"", sz);
	}
	else
	{
		//*************************************************************************open
		key.Open(L"SOFTWARE\\Classes\\Applications");

		//*************************************************************************delete command
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe\\shell\\Open\\command", pi.productName);
		sz[SYS_INSTBUFF-1]='\0';
		key.DeleteSubkey(sz);

		//*************************************************************************delete Open
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe\\shell\\Open", pi.productName);
		key.DeleteSubkey(sz);

		//*************************************************************************delete shell
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe\\shell", pi.productName);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Product.exe
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.exe", pi.productName);
		key.DeleteSubkey(sz);
	}

	return true;
}

/* Returns C:\\Program Files\\Application\\  */
const wchar_t* Install::GetDestinationDirectory(const wchar_t* productName)
{
	HKEY hKey;
	unsigned long nDataSize;
	unsigned long nDataType;
	DWORD dwResult = 0;
	bool bOk = false;
	DWORD keySize= SYS_INSTBUFF;
	wchar_t destinationDir[SYS_INSTBUFF];
	
	buffer[0] = '\0';

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\", 0, KEY_ALL_ACCESS, &hKey)==ERROR_SUCCESS)
	{
		nDataSize=254;
		bOk = (RegQueryValueEx(hKey, L"ProgramFilesDir", NULL, &nDataType, (LPBYTE)&destinationDir, &keySize)
			== ERROR_SUCCESS);
		RegCloseKey(hKey);
		if (bOk == false) return NULL;
	}
	_snwprintf_s(buffer, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", destinationDir, productName);
	buffer[SYS_INSTBUFF-1]='\0';
	return buffer;
}

// Installs ..SOFTWARE\\Classes\\.ext\\
//    (default,  RG_SZ, ProductName.ObjectType.Version)
bool Install::InstallSoftware5(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s", pi.fileExtension);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d", pi.productName, pi.objectType, pi.versionMayor);
		key.Set(L"", sz);
	}
	else
	{
		key.Open(L"SOFTWARE\\Classes");
		key.DeleteSubkey(pi.fileExtension);
		key.DeleteSubkey(L"");
	}

	return true;
}

// Installs 
//  ..SOFTWARE\\Classes\\ProductName.ObjectType.Version\\shell\\Open\\command
//    (default,  RG_SZ, Full path\\Program.exe)
//
//  ..SOFTWARE\\Classes\\ProductName.ObjectType.Version\\DefaultIcon
//    (default,  RG_SZ, Full path\\Program.exe,0)
bool Install::InstallSoftware6(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{
		//************************************************************************************ shell
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s.%s.%d\\shell\\Open\\command", pi.productName,
			pi.objectType, pi.versionMayor);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%s.exe\" \"%%1\"", applicationPath, pi.productName);
		key.Set(L"", sz);

		//************************************************************************************ DefaultIcon
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s.%s.%d\\DefaultIcon", pi.productName,
			pi.objectType, pi.versionMayor);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.exe,%d", applicationPath, pi.productName, pi.objectIconIndex);
		key.Set(L"", sz);

		//************************************************************************************ Description
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Classes\\%s.%s.%d", pi.productName, pi.objectType, pi.versionMayor);
		key.Open(sz);
		key.Set(L"", pi.objectDescription);
	}
	else
	{
		key.Open(L"SOFTWARE\\Classes");

		//*************************************************************************delete command
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\shell\\Open\\command", pi.productName, 
			pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Open
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\shell\\Open", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete shell
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\shell", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete DefaultIcon
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d\\DefaultIcon", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);

		//*************************************************************************delete Product.exe
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s.%s.%d", pi.productName, pi.objectType, pi.versionMayor);
		key.DeleteSubkey(sz);
	}

	return true;
}

// Installs ..SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Program.exe\\
//    (default,  RG_SZ, Full path\\Program.exe)
//    (Path,  RG_SZ, Full path)
bool Install::InstallSoftware3(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall)
{
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);
	wchar_t sz[SYS_INSTBUFF];
	const wchar_t * applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\%s.exe", 
			pi.productName);
		key.Create(sz);
		//
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s.exe", applicationPath, pi.productName);
		key.Set(L"", sz);
		//
		key.Set(L"Path", (wchar_t *)applicationPath);
	}
	else
	{
		wchar_t executableName[SYS_INSTBUFF];

		_snwprintf_s(executableName, SYS_INSTBUFF, _TRUNCATE, L"%s.exe", pi.productName);
		executableName[SYS_INSTBUFF-1]='\0';

		//*************************************************************************open
		key.Open(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths");

		//*************************************************************************delete Program.exe
		key.DeleteSubkey(executableName);
	}
	return true;
}

bool Install::CreateShortCut(const wchar_t* destinationFilename,  const wchar_t* description, 
							 const wchar_t* shortcutFilename, const wchar_t* workingDirectory, const wchar_t* filenameIco_exe, int iIcon)
{ 
	bool ok = false;
	IShellLink* pShellLink = NULL;
	IPersistFile* pPersistFile = NULL;
	::CoInitialize(NULL);
	HRESULT hr = ::CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink,
		(void**)&pShellLink);
	if (SUCCEEDED(hr))
	{
		hr = pShellLink->QueryInterface(IID_IPersistFile, (void**)&pPersistFile);
		if (SUCCEEDED(pShellLink->SetPath(destinationFilename)))
		{
			if (SUCCEEDED(pShellLink->SetDescription(description)))
			{
				if (SUCCEEDED(pShellLink->SetWorkingDirectory(workingDirectory)))
				{
					if (filenameIco_exe != NULL)
					{
						if (SUCCEEDED(pShellLink->SetIconLocation(filenameIco_exe, iIcon)))
						{
							ok = false;
						}
					}

					if (SUCCEEDED(pPersistFile->Save(shortcutFilename, TRUE)))
					{
						ok = true;
					}
				}
			}
		}
	}

	if (pPersistFile) pPersistFile->Release();
	if (pShellLink) pShellLink->Release();
	::CoUninitialize();
	return ok;
}

bool Install::CanAccessRegistry()
{
	bool ok = false;
	HKEY hKey;
	unsigned long nDataSize;
	unsigned long nDataType;
	DWORD dwResult = 0;
	DWORD keySize= SYS_INSTBUFF;
	
	buffer[0] = '\0';

	ok = (::RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\", 0, KEY_ALL_ACCESS, &hKey)==ERROR_SUCCESS);
	if (ok == false) return false;

	nDataSize=254;
	ok = (::RegQueryValueEx(hKey, L"ProgramFilesDir", NULL, &nDataType, (LPBYTE)&buffer, &keySize) == ERROR_SUCCESS);
	::RegCloseKey(hKey);
	return ok;
}

const wchar_t* Install::GetProgramFilesPath(void)
{
	// puedes usar el registro HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/ProgramFilesDir
	// puedes usar el registro HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Explorer/ShellFolders
	//wchar_t * variableName = L"ProgramFiles";
	//int n = ::GetEnvironmentVariable(variableName, NULL, 0);
	//::GetEnvironmentVariable(variableName, this->buffer, SYS_INSTBUFF);

	return this->RegistryReadString(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\",
		L"ProgramFilesDir");
}

const wchar_t* Install::GetWindowsFolder()
{
	if (::GetWindowsDirectoryW(buffer, SYS_INSTBUFF)==0) return NULL;
	//if (::GetEnvironmentVariableW(L"windir", this->buffer, SYS_INSTBUFF)==0) return NULL;
	return buffer;
}

const wchar_t* Install::GetDesktopPath(void)
{
	return this->RegistryReadString(HKEY_LOCAL_MACHINE, 
		L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		L"Common Desktop");
}

const wchar_t* Install::GetMyDocumentsPath(void)
{
	return this->RegistryReadString(HKEY_LOCAL_MACHINE, 
		L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		L"Personal");
}

const wchar_t* Install::GetStartupMenuProgramsPath(void)
{
	return this->RegistryReadString(HKEY_LOCAL_MACHINE, 
		L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		L"Common Programs");
}

// It creates
//HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsCurrentVersion\Uninstall\ProductName
//REG_SZ	DisplayIcon "C:\Program Files\ProductName\ProductName.exe",0
//REG_SZ	DisplayName ProductName
//REG_SZ	DisplayVersion 1.0
//REG_SZ	HelpLink http://www.fimee.ugto.mx
//REG_SZ	UninstallString "C:\Windows\RemoveProductName"
bool Install::InstallSoftware4(Sys::Install::ProductInfo& pi, Sys::IError& ierror, bool isInstall, const wchar_t* fileNameIco_exe, int iIcon)
{
	wchar_t sz[SYS_INSTBUFF];
	Sys::Key key(HKEY_LOCAL_MACHINE, ierror);
	const wchar_t* applicationPath = this->GetDestinationDirectory(pi.productName);
	if (applicationPath==NULL) return false;

	if (isInstall)
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s", 
			pi.productName);
		key.Create(sz);
		//_______________________________DisplayIcon "C:\Program Files\ProductName\ProductName.exe",0
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%s\",%d", applicationPath, fileNameIco_exe, iIcon);
		key.Set(L"DisplayIcon", sz);
		//_______________________________ DisplayName
		key.Set( L"DisplayName", pi.productName);
		//DisplayVersion 1.0
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"%d.%d", pi.versionMayor, pi.versionMinor);
		key.Set(L"DisplayVersion", sz);

		if (pi.helpLink)  //HelpLink http://www.fimee.ugto.mx
		{	
			key.Set(L"HelpLink",pi.helpLink);
		}

		//UninstallString "C:\Windows\ProdutNameRemove"
		wchar_t destPath[SYS_INSTBUFF];
		::GetEnvironmentVariable(L"windir", destPath, SYS_INSTBUFF);
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"\"%s\\%sRemove.exe\"", destPath, pi.productName);
		key.Set(L"UninstallString", sz);
		//
		key.Set(L"Publisher", pi.companyName);
	}
	else
	{
		_snwprintf_s(sz, SYS_INSTBUFF, _TRUNCATE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s", 
			pi.productName);
		key.Open(sz);

		//*************************************************************************delete DisplayIcon
		key.DeleteSubkey(L"DisplayIcon");

		//*************************************************************************delete DisplayName
		key.DeleteSubkey(L"DisplayName");

		//*************************************************************************delete DisplayVersion
		key.DeleteSubkey(L"DisplayVersion");

		//*************************************************************************delete HelpLink
		key.DeleteSubkey(L"HelpLink");

		//*************************************************************************delete UninstallString
		key.DeleteSubkey(L"UninstallString");

		//*******************************delete SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ProductName
		key.Open(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
		key.DeleteSubkey(pi.productName);
	}

	return true;
}

//_____________________________________________________________________ Sys::RegistryKey
RegistryKey::RegistryKey()
{
	_hkey = NULL;
}

RegistryKey::~RegistryKey()
{
	if (_hkey !=NULL) ::RegCloseKey(_hkey);
}

bool RegistryKey::OpenClasesRoot(REGSAM access)
{
	return Open(HKEY_CLASSES_ROOT, NULL, access);
}

bool RegistryKey::Open(HKEY parentKey, const wchar_t* keyName, REGSAM access)
{
	Close();
	return (::RegOpenKeyEx(parentKey, keyName, 0, access, &_hkey) == ERROR_SUCCESS);
}

bool RegistryKey::Open(Sys::RegistryKey& parentKey, const wchar_t* keyName, REGSAM access)
{
	Close();
	return (::RegOpenKeyEx(parentKey._hkey, keyName, 0, access, &_hkey) == ERROR_SUCCESS);
}

bool RegistryKey::CreateSubKey(const wchar_t* childKeyName, REGSAM access, Sys::RegistryKey& out_subKey)
{
	out_subKey.Close();
	return (::RegCreateKeyEx(_hkey, childKeyName, 0, NULL,
			REG_OPTION_NON_VOLATILE, access, NULL, &out_subKey._hkey, NULL) == ERROR_SUCCESS);
}

bool RegistryKey::Close()
{
	if (_hkey == NULL) return true;
	const bool ok = (::RegCloseKey(_hkey) == ERROR_SUCCESS);
	_hkey = NULL;
	return ok;
}

//bool RegistryKey::ReadStringValueDirect(HKEY root, const wchar_t* subkeyName, const wchar_t* valueName, wchar_t* buffer, unsigned long buffer_size)
//{
//	unsigned long flags = RRF_RT_REG_SZ;
//	unsigned long dataType = 0;
//	const bool ok = (::RegGetValue(root, subkeyName, valueName, flags, &dataType, (LPBYTE)&buffer, &buffer_size) == ERROR_SUCCESS);
//	if (dataType != REG_SZ) return false;
//	return ok;
//}

bool RegistryKey::ReadStringValue(const wchar_t* name, wchar_t* buffer, unsigned long buffer_size)
{
	if (_hkey == NULL) return false;
	unsigned long dataType = REG_SZ;
	//_______________________________________ Be sure to return a clean value
	if (buffer_size > 0) buffer[0] = '\0';
	//
	const bool ok = (::RegQueryValueEx(_hkey, name, NULL, &dataType, (LPBYTE)buffer, &buffer_size) == ERROR_SUCCESS);
	if (dataType != REG_SZ) return false;
	buffer[buffer_size] = '\0';
	return ok;
}

bool RegistryKey::SetValue(const wchar_t* name, const wchar_t* value)
{
	if (_hkey==NULL) return false;
	return (::RegSetValueEx(_hkey, name, 0, REG_SZ, (PBYTE)value, sizeof(wchar_t)*((int)wcslen(value) + 1)) == ERROR_SUCCESS);
}

bool RegistryKey::SetValue(const wchar_t* name, const DWORD value)
{
	if (_hkey==NULL) return false;
	return (::RegSetValueEx(_hkey, name, 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD)) == ERROR_SUCCESS);
}

bool RegistryKey::DeleteSubKey(const wchar_t* name)
{
	if (_hkey==NULL) return false;
	return (::RegDeleteKeyW(_hkey, name) == ERROR_SUCCESS);
}

bool RegistryKey::Enumerate(int index, wchar_t* buffer, DWORD buffer_size)
{
	if (_hkey==NULL) return false;
	if (buffer_size > 0) buffer[0] = '\0';
	return (RegEnumKeyEx(_hkey, (DWORD)index, buffer, &buffer_size, NULL, NULL, NULL, NULL)== ERROR_SUCCESS);
}

//_____________________________________________________________________ Sys::Key
Key::Key(HKEY type, Sys::IError& ierror)
{
	this->type = type;
	this->hkey = NULL;
	this->name[0]='\0';
	this->ierror = &ierror;
}

Key::Key(HKEY type)
{
	this->type = type;
	this->hkey = NULL;
	this->name[0]='\0';
	this->ierror = NULL;
}

Key::~Key(void)
{
	::RegCloseKey(hkey);
}

bool Key::Create(wchar_t* name)
{
	this->Close();
	bool ok = (::RegCreateKeyEx(type, name, 0, NULL,
			REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL) == ERROR_SUCCESS);
	if (ierror != NULL) ierror->ReportError(!ok, name);
	lstrcpyn(this->name, name, SYS_INSTBUFF);
	this->name[SYS_INSTBUFF-1]='\0';
	return ok;
}

bool Key::Open(wchar_t* name)
{
	return Open(name, KEY_ALL_ACCESS);
}

bool Key::Open(wchar_t* name, REGSAM access)
{
	this->Close();
	bool ok = (::RegOpenKeyEx(type, name, 0, access, &hkey) == ERROR_SUCCESS);
	if (ierror) ierror->ReportError(!ok, name);
	lstrcpyn(this->name, name, SYS_INSTBUFF);
	this->name[SYS_INSTBUFF-1]='\0';
	return ok;
}

wchar_t* Key::ReadStringValue(const wchar_t* valueName)
{
	unsigned long dataSize = SYS_INSTBUFF;
	unsigned long dataType = 0;
	DWORD keySize= SYS_INSTBUFF;
	
	name[0] = '\0';

	bool ok = (::RegQueryValueEx(hkey, valueName, NULL, &dataType, (LPBYTE)&name, &dataSize) == ERROR_SUCCESS);
	if (dataType != REG_SZ) return NULL;
	if (ierror) ierror->ReportError(!ok, name);
	if (ok) return name;
	return NULL;
}

bool Key::Close()
{
	bool ok = true;
	this->name[0]='\0';
	if (hkey != NULL)
	{
		ok = (::RegCloseKey(hkey) == ERROR_SUCCESS);
		hkey = NULL;
	}
	return ok;
}

bool Key::Set(wchar_t* name, wchar_t* value)
{
	if (hkey==NULL) return false;
	bool ok = (::RegSetValueEx(hkey, name, 0, REG_SZ, (PBYTE)value, sizeof(wchar_t)*(lstrlen(value) + 1)) == ERROR_SUCCESS);

	if (name==NULL) name = L"(default)";
	if (lstrlen(name)<=0) name = L"(default)";
	wchar_t caption[SYS_INSTBUFF];
	_snwprintf_s(caption, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", this->name, name);
	if (ierror) ierror->ReportError(!ok, caption);
	return ok;
}

bool Key::Set(wchar_t* name, DWORD value)
{
	if (hkey==NULL) return false;
	bool ok = (::RegSetValueEx(hkey, name, 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD)) == ERROR_SUCCESS);

	if (name==NULL) name = L"(default)";
	if (lstrlen(name)<=0) name = L"(default)";
	wchar_t caption[SYS_INSTBUFF];
	_snwprintf_s(caption, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", this->name, name);
	if (ierror) ierror->ReportError(!ok, caption);
	return ok;
}

bool Key::DeleteSubkey(wchar_t* name)
{
	if (hkey==NULL) return false;
	bool ok = (::RegDeleteKeyW(hkey, name) == ERROR_SUCCESS);
	ok = true;

	if (name==NULL) name = L"(default)";
	if (lstrlen(name)<=0) name = L"(default)";
	wchar_t caption[SYS_INSTBUFF];
	_snwprintf_s(caption, SYS_INSTBUFF, _TRUNCATE, L"%s\\%s", this->name, name);
	if (ierror) ierror->ReportError(!ok, caption);
	return ok;
}

// wchar_t * name;
// int i = 0;
// do
//{
//		name = key.Enumerate(i++);
//}
//while(name != NULL);
wchar_t* Key::Enumerate(int index)
{
	name[0] = '\0';
	DWORD lpcbName=SYS_INSTBUFF;

	if (RegEnumKeyEx(hkey, (DWORD)index, name, &lpcbName, NULL, NULL, NULL, NULL)== ERROR_SUCCESS)//&fTime) == ERROR_SUCCESS)
	{
		return name;
	}
	return NULL;
}

//_____________________________________________________________________ Sys::FileDirectoy
bool FileDirectory::IsDirectory(_tfinddata_t& fd)
{
	if (fd.attrib & _A_SUBDIR) return true;
	return false;
}

// Matches file and folder patterns using the Wildcards: * and ?
// '*' matches any sequence of zero or more characters
// '?' matches exactly one character unless that character is a period ('.')
bool FileDirectory::WildcardMatch(wchar_t* pattern, wchar_t* input) 
{
	wchar_t* s;
	wchar_t* p;
	bool star = false;
	bool repeat = false;

	while(true)
	{
		repeat = false;
		for (s = input, p = pattern; *s != '\0'; s++, p++) 
		{
			if (*p == '?')
			{
				if (*s == '.')
				{
					if (star == false) return false;
					input++;
					repeat = true;
					break;
				}
			}
			else if (*p == '*')
			{
				star = true;
				input = s, pattern = p;
				pattern++;
				if (*pattern == '\0') return true;
				repeat = true;
				break;
			}
			else
			{
				if (*s != *p)
				{
					if (star == false) return false;
					input++;
					repeat = true;
					break;
				}
			}
		}
		if (repeat == true) continue;
		break;
	}
	if (*p == '*') p++;
	return (*p == '\0');
}

bool FileDirectory::CreateFolder(const wchar_t* pathName)
{
	return (::CreateDirectory(pathName, NULL) != 0);
}


//You cannot specify target attributes (such as _A_RDONLY) by which to limit the find operation. 
//This attribute is returned in the attrib field of the _finddata_t structure and can have the following
//values (defined in IO.H). Users should not rely on these being the only values possible for 
//the attrib field. 
//
//_A_ARCH 
//Archive. Set whenever the file is changed, and cleared by the BACKUP command. Value: 0x20. 
//_A_HIDDEN 
//Hidden file. Not normally seen with the DIR command, unless the /AH option is used. 
//Returns information about normal files as well as files with this attribute. Value: 0x02. 
//_A_NORMAL 
//Normal. File has no other attributes set, and can be read or written to without restriction. 
//Value: 0x00. 
//_A_RDONLY 
//Read-only. File cannot be opened for writing, and a file with the same name cannot 
//be created. Value: 0x01. 
//_A_SUBDIR 
//Subdirectory. Value: 0x10. 
//_A_SYSTEM 
//System file. Not normally seen with the DIR command, unless the /A or /A:S option 
//is used. Value: 0x04. 
//GetFileList(L"c:\\*.txt", this) -> gets the files with name *.txt 
int FileDirectory::GetFileList(const wchar_t* path, Sys::IListFileDirectory* ilfd)
{
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;

	sequence=_tfindfirst((wchar_t*)path, &item);
	if (sequence!=-1)
	{
		count++;
		if (ilfd->Enumerate(item)==false) 
		{
			_findclose(sequence);
			return count;
		}
		while(_tfindnext(sequence, &item)==0)
		{
			count++;
			if (ilfd->Enumerate(item)==false)
			{
				_findclose(sequence);
				return count;
			}
		}
	}
	_findclose(sequence);
	return count;
}

// path = L"C:\\Documents\\*.*
// use the macros ISFOLDER(x), ISFILE(x) and EXCLUDE_FILE(x)
int FileDirectory::GetFileList(const wchar_t* path, vector<_tfinddata_t>& out_filelist)
{
	struct _tfinddata_t item;
	intptr_t sequence = 0;
	intptr_t result = 0;
	int count = 0;

	for(sequence =_tfindfirst(path, &item), result = 0; result == 0; result = _tfindnext(sequence, &item))
	{
		if (sequence == -1) break;
		count++;
		out_filelist.push_back(item);
	}
	_findclose(sequence);
	return count;
}

int FileDirectory::GetFileListRecursive(const wchar_t* path, const wchar_t* filter, Sys::IListFileDirRecursive* ilfd)
{
	struct _tfinddata_t item;
	intptr_t sequence = 0;
	intptr_t result = 0;
	int count = 0;
	wstring currentPath;
	wstring nextPath;
	//______________________________________ First we search for files in the current folder
	Sys::Format(currentPath, L"%s\\%s", path, filter);
	for(sequence =_tfindfirst(currentPath.c_str(), &item), result = 0; result == 0; result = _tfindnext(sequence, &item))
	{
		if (sequence == -1) break;
		if (ISFOLDER(item) == true) continue;
		count++;
		if (ilfd->Enumerate(path, item)==false) 
		{
			_findclose(sequence);
			return count;
		}
	}
	_findclose(sequence);
	//______________________________________ Get search for folders
	Sys::Format(currentPath, L"%s\\*.*", path);
	for(sequence =_tfindfirst(currentPath.c_str(), &item), result = 0; result == 0; result = _tfindnext(sequence, &item))
	{
		if (sequence == -1) break;
		if (ISFILE(item) == true) continue;
		if (EXCLUDE_FILE(item) == true) continue;
		//__________________ Enumerate the sub directory
		count++;
		if (ilfd->Enumerate(path, item)==false) 
		{
			_findclose(sequence);
			return count;
		}
		//__________________ Recursion
		Sys::Format(nextPath, L"%s\\%s", path, item.name);
		count += Sys::FileDirectory::GetFileListRecursive(nextPath.c_str(), filter, ilfd);
	}
	_findclose(sequence);
	return count;
}

int FileDirectory::GetFileListRecursive(const wchar_t* path, const wchar_t* filter, vector<Sys::FileInfo>& fileList)
{
	//struct _tfinddata_t item;
	intptr_t sequence = 0;
	intptr_t result = 0;
	int count = 0;
	wstring currentPath;
	wstring nextPath;
	FileInfo fi;
	//______________________________________ First we search for files in the current folder
	Sys::Format(currentPath, L"%s\\%s", path, filter);
	for(sequence =_tfindfirst(currentPath.c_str(), &fi.findData), result = 0; result == 0; result = _tfindnext(sequence, &fi.findData))
	{
		if (sequence == -1) break;
		if (ISFOLDER(fi.findData) == true) continue;
		count++;
		fi.path = path;
		fileList.push_back(fi);
	}
	//______________________________________ Get search for folders
	Sys::Format(currentPath, L"%s\\*.*", path);
	for(sequence =_tfindfirst(currentPath.c_str(), &fi.findData), result = 0; result == 0; result = _tfindnext(sequence, &fi.findData))
	{
		if (sequence == -1) break;
		if (EXCLUDE_FILE(fi.findData)) continue;
		if (ISFILE(fi.findData) == true) continue;
		Sys::Format(nextPath, L"%s\\%s", path, fi.findData.name);
		count += Sys::FileDirectory::GetFileListRecursive(nextPath.c_str(), filter, fileList);
	}
	_findclose(sequence);
	return count;
}

// Deletes an empty or non-empty folder
bool FileDirectory::DeleteFolder(const wchar_t* folder)
{	
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;
	wstring next;
	wstring text;
	//______________________________________ First we search for files and folders in the current folder
	Sys::Format(next, L"%s\\*.*", folder);
	sequence=_tfindfirst(next.c_str(), &item);
	if (sequence == -1) 
	{
		_findclose(sequence);
		text = L"\\\\?\\";
		text += folder;
		::SetFileAttributes(text.c_str(), FILE_ATTRIBUTE_NORMAL);
		::RemoveDirectory(text.c_str());
		return false;
	}
	do
	{
		Sys::Format(next, L"%s\\%s", folder, item.name);
		if (Sys::FileDirectory::IsDirectory(item)==true) 
		{
			if (wcscmp(item.name, L".")==0) continue;
			if (wcscmp(item.name, L"..")==0) continue;	
			FileDirectory::DeleteFolder(next.c_str());
		}
		else
		{
			text = L"\\\\?\\";
			text += next;
			::SetFileAttributes(text.c_str(), FILE_ATTRIBUTE_NORMAL);
			::DeleteFile(text.c_str());
		}
	}
	while(_tfindnext(sequence, &item)==0);
	_findclose(sequence);
	//___________________________________________________________ Delete Itself
	text = L"\\\\?\\";
	text += folder;
	::SetFileAttributes(text.c_str(), FILE_ATTRIBUTE_NORMAL);
	::RemoveDirectory(text.c_str());
	return true;
}

bool FileDirectory::IsDriveAvailable(wchar_t drive)
{
	//____________________________________________ Method 1
	//DWORD available = ::GetLogicalDrives();
	//drive = toupper(drive);
	//DWORD one = 1;
	//DWORD mask = one<< (drive - 'A');
	//return (available & mask) != 0;

	//____________________________________________ Method 2
	//wchar_t buffer[64];
	//::GetLogicalDriveStrings(64, buffer);
	//for(int i = 0; i < 63; i++)
	//{
	//	if (buffer[i] == '\0' && buffer[i+1]=='\0') break;
	//	if (buffer[i] == ':') continue;
	//	if (buffer[i] == '\\') continue;
	//	if (buffer[i] == '\0') continue;
	//	if (buffer[i] == drive) return true;
	//}
	//return false;

	//____________________________________________ Method 3
	//\\MyServer\MyShare as "\\MyServer\MyShare\", or the C drive as "C:\".
	wchar_t text[4];
	text[0] = drive;
	text[1] = ':';
	text[2] = '\\';
	text[3] = '\0';
	wchar_t name[MAX_PATH];
	wchar_t type[MAX_PATH];  //The function returns: L"NTFS", L"FAT", L"FAT32",...
	DWORD serialNumber; // A number asigned when the drive was formatted
	DWORD maximumComponentLen; // Maximum name length
	DWORD fileSystemFlags; // The function returns: 
	DWORD result = ::GetVolumeInformation(text, name, MAX_PATH, &serialNumber, &maximumComponentLen, &fileSystemFlags, type, MAX_PATH);
	return (result != 0);
}

void FileDirectory::GetDrivesInformation(vector<Sys::DriveInformation>& output)
{
	wchar_t text[4];
	text[1] = ':';
	text[2] = '\\';
	text[3] = '\0';
	Sys::DriveInformation di;

	output.clear();
	for(di.id = 'C'; di.id <= 'Z'; di.id++)
	{
		text[0] = di.id;
		di.name[0] = '\0';
		di.type[0] = '\0';
		di.serialNumber = 0;
		di.maximumComponentLen = 0;
		di.fileSystemFlags = 0;
		::GetVolumeInformation(text, di.name, MAX_PATH, &di.serialNumber, &di.maximumComponentLen, &di.fileSystemFlags, di.type, MAX_PATH);
		//if (::GetVolumeInformation(text, di.name, MAX_PATH, &di.serialNumber, &di.maximumComponentLen, &di.fileSystemFlags, di.type, MAX_PATH) == 0)
		//{
		//	di.name[0] = '\0';
		//	di.type[0] = '\0';
		//	di.serialNumber = 0;
		//	di.maximumComponentLen = 0;
		//	di.fileSystemFlags = 0;
		//}
		output.push_back(di);
	}
}

//bool FileAssistant::IsFolderAvailabe(const wchar_t* path)
//{
//	try
//	{
//		wchar_t tmp[1024];
//		_snwprintf_s(tmp, 1024, _TRUNCATE, L"%s\\*.*", path);
//		_tfinddata_t fd;
//		return (_tfindfirst(tmp, &fd) != -1);
//	}
//	catch(...)
//	{
//		return false;
//	}
//	return false;
//}

// i.e. CopyFolderStructure(L"C:\\Data", L"D:\\Data");
bool FileDirectory::CopyFolderStructure(const wchar_t* sourcePath, const wchar_t* destinationPath)
{
	::CreateDirectoryW(destinationPath, NULL);
	struct _tfinddata_t item;
	intptr_t sequence=0;
	int count = 0;
	wchar_t nextSourcePath[1024];
	wchar_t nextDestinationPath[1024];
	//______________________________________ First we search for files and folders in the current folder
	_snwprintf_s(nextSourcePath, 1024, _TRUNCATE, L"%s\\*.*", sourcePath);
	sequence=_tfindfirst(nextSourcePath, &item);
	if (sequence == -1) return false;
	do
	{
		if (Sys::FileDirectory::IsDirectory(item)==true) 
		{
			if (wcscmp(item.name, L".")==0) continue;
			if (wcscmp(item.name, L"..")==0) continue;
			_snwprintf_s(nextSourcePath, 1024, _TRUNCATE, L"%s\\%s", sourcePath, item.name);
			_snwprintf_s(nextDestinationPath, 1024, _TRUNCATE, L"%s\\%s", destinationPath, item.name);
			FileDirectory::CopyFolderStructure(nextSourcePath, nextDestinationPath);
		}
	}
	while(_tfindnext(sequence, &item)==0);
	return true;
}

//_____________________________________________________________________ Sys::Time
Time::Time()
{
	::GetLocalTime(this);
}

Time::Time(SYSTEMTIME st)
{
	wYear = st.wYear;
	wMonth = st.wMonth;
	wDayOfWeek = st.wDayOfWeek;
	wDay = st.wDay;
	wHour = st.wHour;
	wMinute = st.wMinute;
	wSecond = st.wSecond;
	wMilliseconds = st.wMilliseconds;
}

Time::~Time()
{
}

Sys::Time Time::Now()
{
	Sys::Time tmp;
	return tmp;
}

Time::Time(const Sys::Time& init)
{
	wYear = init.wYear;
	wMonth = init.wMonth;
	wDayOfWeek = init.wDayOfWeek;
	wDay = init.wDay;
	wHour = init.wHour;
	wMinute = init.wMinute;
	wSecond = init.wSecond;
	wMilliseconds = init.wMilliseconds;
}

Time& Time::operator=(const Sys::Time& init)
{
	wYear = init.wYear;
	wMonth = init.wMonth;
	wDayOfWeek = init.wDayOfWeek;
	wDay = init.wDay;
	wHour = init.wHour;
	wMinute = init.wMinute;
	wSecond = init.wSecond;
	wMilliseconds = init.wMilliseconds;
	return *this;
}

void Time::SetToLocalTime()
{
	::GetLocalTime(this);
}

void Time::SetToUtcTime()
{
	::GetSystemTime(this);
}

void Time::Set(int day, int month, int year, int hour, int minute, int second, int milliseconds)
{
	this->wYear = year;
	this->wMonth = month;
	this->wDayOfWeek = 0;
	this->wDay = day;
	this->wHour = hour;
	this->wMinute = minute;
	this->wSecond = second;
	this->wMilliseconds = milliseconds;
	//__________________________________________ Try to fill wDayOfWeek
	FILETIME ft; 
	::SystemTimeToFileTime(this, &ft ); 
	::FileTimeToSystemTime(&ft, this); 
}

double Time::GetSeconds() const //Since January 1, 1601.
{
	FILETIME ft;
	SYSTEMTIME st = *this;
	if (::SystemTimeToFileTime(&st, &ft) == 0) return -9.99e300; // Error
	//__________________________________
	ULARGE_INTEGER nano100;
	nano100.HighPart = ft.dwHighDateTime;
	nano100.LowPart = ft.dwLowDateTime;
	//__int64 * nano100 = (__int64 *)&ft;
	//return (*nano100)/(double)10000000.0;
	return nano100.QuadPart/(double)(10000000.0);
}

Sys::Time& Time::AddSeconds(double seconds)
{
	FILETIME ft;
	::SystemTimeToFileTime(this, &ft);
	ULARGE_INTEGER nano100;
	nano100.HighPart = ft.dwHighDateTime;
	nano100.LowPart = ft.dwLowDateTime;
	//__int64 * nano100 = (__int64 *)&ft;
	//(*nano100) += (__int64)(seconds*10000000);
	nano100.QuadPart += (__int64)(seconds*10000000);
	ft.dwHighDateTime = nano100.HighPart;
	ft.dwLowDateTime = nano100.LowPart;
	::FileTimeToSystemTime (&ft, this); 
	return *this;
}

Sys::Time& Time::AddMinutes(double minutes)
{
	return AddSeconds(minutes*60.0);
}

Sys::Time& Time::AddHours(double hours)
{
	return AddSeconds(hours*3600.0);
}

Sys::Time& Time::AddDays(double days)
{
	return AddSeconds(days*86400);
}

bool Time::operator==(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)==0);
}

bool Time::operator!=(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)!=0);
}

bool Time::operator<(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)==-1);
}

bool Time::operator<=(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)<=0);
}

bool Time::operator>(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)==1);
}

bool Time::operator>=(const Sys::Time& st) const
{
	FILETIME ft1, ft2;
	::SystemTimeToFileTime(this, &ft1);
	::SystemTimeToFileTime(&st, &ft2);
	return (::CompareFileTime(&ft1, &ft2)>=0);
}

//_____________________________________________________________________ Sys::SqlTime
SqlTime::SqlTime()
{
	//year = 0;
	//month = 0;
	//day = 0;
	//hour = 0;
	//minute = 0;
	//second = 0;
	//milliseconds = 0;
	year = systime.wYear;
	month = systime.wMonth;
	day = systime.wDay;
	hour = systime.wHour;
	minute = systime.wMinute;
	second = systime.wSecond;
	milliseconds = systime.wMilliseconds;
}
	
SqlTime::~SqlTime()
{
} 

SqlTime::operator Sys::Time&()
{
	systime.wYear = year;
	systime.wMonth = month;
	systime.wDayOfWeek = 0;
	systime.wDay = day;
	systime.wHour = hour;
	systime.wMinute = minute;
	systime.wSecond = second;
	systime.wMilliseconds = milliseconds;
	return systime;
}

//_____________________________________________________________________ Sys::IDateTime

//_____________________________________________________________________ Sys::LowResStopwatch
LowResStopwatch::LowResStopwatch()
{
	Start();
}

LowResStopwatch::~LowResStopwatch()
{
}

void LowResStopwatch::Start()
{
	start.SetToLocalTime();
}

double LowResStopwatch::GetSeconds()
{
	Sys::Time now;
	return now.GetSeconds() - start.GetSeconds();
}
//_____________________________________________ EMail

#ifdef WIN_SOCKETS_SUPPORT

//_____________________________________________________________________ Sys::SecurityCertificate
SecurityCertificate::SecurityCertificate()
{
	certContext = NULL;
}

SecurityCertificate::~SecurityCertificate()
{
	Clear();
}

void SecurityCertificate::Clear()
{
	if (certContext != NULL)
	{
		CertFreeCertificateContext(certContext);
		certContext = NULL; 
	}
}

const wchar_t* SecurityCertificate::GetErrorDesc(int error)
{
	switch(error)
	{
	case CERT_E_EXPIRED: return L"A required certificate is not within its validity period when verifying against the current system clock or the timestamp in the signed file. CERT_E_EXPIRED";
	case CERT_E_VALIDITYPERIODNESTING: return L"The validity periods of the certification chain do not nest correctly. CERT_E_VALIDITYPERIODNESTING";
	case CERT_E_ROLE: return L"A certificate that can only be used as an end-entity is being used as a CA or visa versa. CERT_E_ROLE";
	case CERT_E_PATHLENCONST: return L"A path length constraint in the certification chain has been violated. CERT_E_PATHLENCONST";
	case CERT_E_CRITICAL: return L"A certificate contains an unknown extension that is marked 'critical'. CERT_E_CRITICAL";
	case CERT_E_PURPOSE: return L"A certificate being used for a purpose other than the ones specified by its CA. CERT_E_PURPOSE";
	case CERT_E_ISSUERCHAINING: return L"A parent of a given certificate in fact did not issue that child certificate. CERT_E_ISSUERCHAINING";
	case CERT_E_MALFORMED: return L"A certificate is missing or has an empty value for an important field, such as a subject or issuer name. CERT_E_MALFORMED";
	case CERT_E_UNTRUSTEDROOT: return L"A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider. CERT_E_UNTRUSTEDROOT";
	case CERT_E_CHAINING: return L"A certificate chain could not be built to a trusted root authority. CERT_E_CHAINING";
	case TRUST_E_FAIL: return L"Generic trust failure. TRUST_E_FAIL";
	case CERT_E_REVOKED: return L"A certificate was explicitly revoked by its issuer. CERT_E_REVOKED";
	case CERT_E_UNTRUSTEDTESTROOT: return L"The certification path terminates with the test root which is not trusted with the current policy settings. CERT_E_UNTRUSTEDTESTROOT";
	case CERT_E_REVOCATION_FAILURE: return L"The revocation process could not continue - the certificate(s) could not be checked. CERT_E_REVOCATION_FAILURE";
	case CERT_E_CN_NO_MATCH: return L"The certificate's CN name does not match the passed value. CERT_E_CN_NO_MATCH";
	case CERT_E_WRONG_USAGE: return L"The certificate is not valid for the requested usage. CERT_E_WRONG_USAGE";
	case TRUST_E_EXPLICIT_DISTRUST: return L"The certificate was explicitly marked as untrusted by the user. TRUST_E_EXPLICIT_DISTRUST";
	case CERT_E_UNTRUSTEDCA: return L"A certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider. CERT_E_UNTRUSTEDCA";
	case CERT_E_INVALID_POLICY: return L"The certificate has invalid policy. CERT_E_INVALID_POLICY";
	case CERT_E_INVALID_NAME: return L"The certificate has an invalid name. The name is not included in the permitted list or is explicitly excluded. CERT_E_INVALID_NAME";
	}
	return L"The error information is provided";
}

void SecurityCertificate::GetDisplayInfo(bool isLocal, wstring& out_displayInfo)
{
	out_displayInfo.clear();
	wchar_t name[1024];

	//__________________________________________________________ Leaf name
	if(CertNameToStr(certContext->dwCertEncodingType, &certContext->pCertInfo->Subject, 
		CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG, name, 1024) == 0)
	{
		_snwprintf_s(name, 1024, _TRUNCATE, L"ERROR 0x%x while getting the subject name\r\n", GetLastError());
		out_displayInfo += name;
	}
	else
	{
		if(isLocal == true)
		{
			out_displayInfo += L"Client subject: ";
		}
		else	
		{
			out_displayInfo += L"Server subject: ";
		}
		out_displayInfo += name;
		out_displayInfo += L"\r\n";
	}
	
	//____________________________________________________________________ Issuer name
	if(CertNameToStr(certContext->dwCertEncodingType, &certContext->pCertInfo->Issuer,
			CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG, name, 1024 ) == 0)
	{
		_snwprintf_s(name, 1024, _TRUNCATE, L"ERROR 0x%x while getting the issuer name\r\n", GetLastError());
		out_displayInfo += name;
	}
	else
	{
		if(isLocal == true)	
		{
			out_displayInfo += L"Client issuer: ";
		}
		else	
		{
			out_displayInfo += L"Server issuer: ";
		}
		out_displayInfo += name;
		out_displayInfo += L"\r\n\r\n";
	}

    //___________________________________________________________________________ Certificate Chain
	PCCERT_CONTEXT pIssuerCert;
	DWORD dwVerificationFlags;
	PCCERT_CONTEXT pCurrentCert = certContext;
	while(pCurrentCert != NULL)
	{
		dwVerificationFlags = 0;
		pIssuerCert = CertGetIssuerCertificateFromStore(certContext->hCertStore, pCurrentCert, NULL, &dwVerificationFlags );
		if(pIssuerCert == NULL)
		{
			if(pCurrentCert != certContext) CertFreeCertificateContext(pCurrentCert);
			break;
		}

		//_____________________________________________________________________ Subject
		if(CertNameToStr( pIssuerCert->dwCertEncodingType, &pIssuerCert->pCertInfo->Subject,
			CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG, name, 1024)  == 0)
		{
			_snwprintf_s(name, 1024, _TRUNCATE, L"ERROR 0x%x while getting the subject name\r\n", GetLastError());
			out_displayInfo += name;
		}
		else
		{	
			out_displayInfo += L"CA subject: ";
			out_displayInfo += name;
			out_displayInfo += L"\r\n";
		}

		//_____________________________________________________________________ Issuer
		if(CertNameToStr(pIssuerCert->dwCertEncodingType, &pIssuerCert->pCertInfo->Issuer,
		CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG, name, 1024) == 0)
		{
			_snwprintf_s(name, 1024, _TRUNCATE, L"ERROR 0x%x while getting the issuer name\r\n", GetLastError());
			out_displayInfo += name;
		}
		else
		{
			out_displayInfo += L"CA issuer: ";
			out_displayInfo += name;
			out_displayInfo += L"\r\n\r\n";
		}

		if(pCurrentCert != certContext) CertFreeCertificateContext(pCurrentCert);
		pCurrentCert = pIssuerCert;
		pIssuerCert = NULL;
	}
}


int SecurityCertificate::Verify(const wchar_t* serverName, DWORD certFlags)
{
	if(certContext == NULL) return CERT_E_CHAINING;

    //_______________________________________________________________Build Certificate Chain.
	CERT_CHAIN_PARA chainPara;
	PCCERT_CHAIN_CONTEXT pChainContext = NULL;
	LPSTR rgszUsages[3]  = {	szOID_PKIX_KP_SERVER_AUTH, 
												szOID_SERVER_GATED_CRYPTO, 
												szOID_SGC_NETSCAPE
											};
	DWORD cUsages  = 3;

    ZeroMemory(&chainPara, sizeof(CERT_CHAIN_PARA));
    chainPara.cbSize = sizeof(CERT_CHAIN_PARA);
    chainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
    chainPara.RequestedUsage.Usage.cUsageIdentifier     = cUsages;
    chainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgszUsages;

    if (CertGetCertificateChain( NULL, certContext,NULL, certContext->hCertStore, &chainPara, 0, NULL, &pChainContext ) == FALSE)
    {
        return S_FALSE;
    }

    //____________________________________________________________________Validate certificate chain.
	HTTPSPolicyCallbackData  polHttps;
	CERT_CHAIN_POLICY_PARA  policyPara;
	CERT_CHAIN_POLICY_STATUS policyStatus;
    ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    polHttps.fdwChecks  = certFlags;
    polHttps.pwszServerName = (wchar_t*)serverName;

    memset(&policyPara, 0, sizeof(CERT_CHAIN_POLICY_PARA));
    policyPara.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);
    policyPara.pvExtraPolicyPara = &polHttps;

    memset(&policyStatus, 0, sizeof(CERT_CHAIN_POLICY_STATUS));
    policyStatus.cbSize = sizeof(CERT_CHAIN_POLICY_STATUS);

    if(CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_SSL, pChainContext, &policyPara, &policyStatus ) == FALSE)
    {
		 if(pChainContext != NULL) CertFreeCertificateChain(pChainContext);
        return S_FALSE;
    }
	if(pChainContext != NULL) CertFreeCertificateChain(pChainContext);
    if(policyStatus.dwError != 0) return policyStatus.dwError;
    return S_OK;
}


//_____________________________________________________________________ SecuritySupportProvider
SecuritySupportProvider::SecuritySupportProvider()
{
	securityFunctionTable = ::InitSecurityInterface();
	hCertStore = NULL;
	isCredHandleValid = false;
	isCtxtHandleValid = false;
	inputOutputBuffer = NULL;
	inputOutputBufferLength = 0;
}

SecuritySupportProvider::~SecuritySupportProvider()
{
	Clear();
}

int SecuritySupportProvider::Send(Sys::IChannel& ichannel, const char* data)
{
	return Send(ichannel, data, strlen(data));
}

// http://msdn.microsoft.com/en-us/library/aa375378(VS.85).aspx
// The encrypted message is encrypted in place, overwriting the original contents of its buffer
int SecuritySupportProvider::Send(Sys::IChannel& ichannel, const char* data, int dataLength) 
{
	PBYTE pbMessage = inputOutputBuffer + sizes.cbHeader;
	//_______________________________________________________________ Check if we can send this much data
	if (dataLength > (int)sizes.cbMaximumMessage) return SOCKET_ERROR;
	//
	_snprintf_s((char*)(inputOutputBuffer+sizes.cbHeader), sizes.cbMaximumMessage, _TRUNCATE, "%s", data);
	//____________________________________________________________________ Buffers
	SecBuffer buffers[4]; 
	buffers[0].pvBuffer  = inputOutputBuffer; 
	buffers[0].cbBuffer = sizes.cbHeader;
	buffers[0].BufferType  = SECBUFFER_STREAM_HEADER;

	buffers[1].pvBuffer     = pbMessage;
	buffers[1].cbBuffer     = dataLength;
	buffers[1].BufferType   = SECBUFFER_DATA;
                                                                                            
	buffers[2].pvBuffer     = pbMessage + dataLength;
	buffers[2].cbBuffer     = sizes.cbTrailer;
	buffers[2].BufferType   = SECBUFFER_STREAM_TRAILER;

	buffers[3].pvBuffer     = SECBUFFER_EMPTY;
	buffers[3].cbBuffer     = SECBUFFER_EMPTY;
	buffers[3].BufferType   = SECBUFFER_EMPTY;

	//________________________________________________________________ message
	SecBufferDesc message;  
	message.ulVersion  = SECBUFFER_VERSION;
	message.cBuffers = 4;
	message.pBuffers = buffers;
	SECURITY_STATUS status = securityFunctionTable->EncryptMessage(&ctxtHandle, 0, &message, 0); 
	if (FAILED(status)) return SOCKET_ERROR;
	//________________________________________________________________ Send the encrypted data to the server
	return ichannel.Send((char*)inputOutputBuffer,  buffers[0].cbBuffer + buffers[1].cbBuffer + buffers[2].cbBuffer);
}

int SecuritySupportProvider::ReceiveCode(Sys::IChannel& ichannel)
{
	string data;
	SECURITY_STATUS status = Receive(ichannel, data);
	if (status != SEC_E_OK) return -1;
	return ExtractCode(data);
}

int SecuritySupportProvider::ReceiveCode(Sys::IChannel& ichannel, string& response)
{
	response.clear();
	SECURITY_STATUS status = Receive(ichannel, response);
	if (status != SEC_E_OK) return -1;
	return ExtractCode(response);
}

int SecuritySupportProvider::ExtractCode(const string& data)
{
	const int len = data.size();
	char cnumber[6];
	cnumber[0] = '\0';
	int i = 0, j = 0;
	for(i = 0; i<len; i++)
	{
		if (Sys::TextAssistant::IsDigit((unsigned char)data[i]) == true)
		{
			cnumber[j++] = data[i];
			if (j >= 6 -1)
			{
				cnumber[j] = '\0';
				break;
			}
		}
		else if (Sys::TextAssistant::IsSeparator((unsigned char)data[i]) == true)
		{
			cnumber[j] = '\0';
			break;
		}
	}
	return atoi(cnumber);
}

// http://msdn.microsoft.com/en-us/library/ms740121(VS.85).aspx
// http://msdn.microsoft.com/en-us/library/aa375211(VS.85).aspx
// The encrypted message is decrypted in the inputOutputBuffer
SECURITY_STATUS SecuritySupportProvider::Receive(Sys::IChannel& ichannel, string& data)
{
	SecBuffer extraData;
	SecBuffer *pDataBuffer, *pExtraBuffer;
	SecBufferDesc message;
	SecBuffer buffers[4];

	DWORD cbData;
	DWORD length;
	PBYTE buff;
	//char* tmp;
	int i;
	//__________________________________________________  Read data from server until done.
	DWORD cbIoBuffer = 0;
	SECURITY_STATUS status = SEC_E_OK;
	while(true) // Read some data.
	{
		if( cbIoBuffer == 0 || status == SEC_E_INCOMPLETE_MESSAGE ) // get the data
		{
			cbData = ichannel.Receive((char*)(inputOutputBuffer + cbIoBuffer), inputOutputBufferLength - cbIoBuffer);
			//cbData = recv(Socket, (char*)(pbIoBuffer + cbIoBuffer), cbIoBufferLength - cbIoBuffer, 0);
			if(cbData == SOCKET_ERROR)
			{
				status = SEC_E_INTERNAL_ERROR;
				break;
			}
			else if(cbData == 0) // Server disconnected.
			{
				if (cbIoBuffer != 0)
				{
					return SEC_E_INTERNAL_ERROR;
				}
				else
				{
					break; // All Done
				}
			}
			else // success
			{
				//printf("%d bytes of (encrypted) application data received\n", cbData);
				// if(fVerbose) { PrintHexDump(cbData, pbIoBuffer + cbIoBuffer); printf("\n"); }
				cbIoBuffer += cbData;
			}
		}

		//______________________________________________________ Decrypt the received data. 
		buffers[0].pvBuffer  = 	inputOutputBuffer;
		buffers[0].cbBuffer  = cbIoBuffer;
		buffers[0].BufferType   = SECBUFFER_DATA;
		buffers[1].BufferType   = SECBUFFER_EMPTY;
		buffers[2].BufferType   = SECBUFFER_EMPTY;
		buffers[3].BufferType   = SECBUFFER_EMPTY;

		message.ulVersion  = SECBUFFER_VERSION;
		message.cBuffers = 4; 
		message.pBuffers = buffers; 
		status = securityFunctionTable->DecryptMessage(&ctxtHandle, &message, 0, NULL);
		if(status == SEC_I_CONTEXT_EXPIRED ) break;
		//      if( scRet == SEC_E_INCOMPLETE_MESSAGE - Input buffer has partial encrypted record, read more
		if (status != SEC_E_OK && status != SEC_I_RENEGOTIATE && status != SEC_I_CONTEXT_EXPIRED ) 
		{
			//printf("**** DecryptMessage "); 
			//DisplaySECError((DWORD)scRet);
			//return scRet; 
			return status;
		}

		//_____________________________________________Locate data and (optional) extra buffers.
		pDataBuffer  = NULL;
		pExtraBuffer = NULL;
		for(i = 1; i < 4; i++)
		{
			if( pDataBuffer  == NULL && buffers[i].BufferType == SECBUFFER_DATA  ) pDataBuffer  = &buffers[i];
            if( pExtraBuffer == NULL && buffers[i].BufferType == SECBUFFER_EXTRA ) pExtraBuffer = &buffers[i];
		}

		//
		//// Display the decrypted data.
		if(pDataBuffer != NULL)
		{
			length = pDataBuffer->cbBuffer;
			if(length != 0) // check if last two chars are CR LF
			{
				buff = (PBYTE)(pDataBuffer->pvBuffer);
				data.assign((char*)buff, length);
				//tmp = (char*)buff;
				//printf("Decrypted data: %d bytes", length); PrintText( length, buff );
				//if(fVerbose) { PrintHexDump(length, buff); printf("\n"); }
				if( buff[length-2] == 13 && buff[length-1] == 10 ) break;
			}
		}

		//__________________________________________________Move any "extra" data to the input buffer.
		if(pExtraBuffer != NULL)
		{
			MoveMemory(inputOutputBuffer, pExtraBuffer->pvBuffer, pExtraBuffer->cbBuffer);
			cbIoBuffer = pExtraBuffer->cbBuffer;
		}
		else
		{
			cbIoBuffer = 0;
		}

		//_____________________________________________ The server wants to perform another handshake sequence.
		if(status == SEC_I_RENEGOTIATE) 
		{
			//printf("Server requested renegotiate!\n");
			status = ClientHandshakeLoop(ichannel, extraData);
			if (status != SEC_E_OK) return status;

			if(extraData.pvBuffer != 0) // Move any "extra" data to the input buffer.
			{
				MoveMemory(inputOutputBuffer, extraData.pvBuffer, extraData.cbBuffer);
				cbIoBuffer = extraData.cbBuffer;
			}
		}
	} // Loop till CRLF is found at the end of the data

	return SEC_E_OK;
}


SECURITY_STATUS SecuritySupportProvider::GetCertificate(Sys::SecurityCertificate& certificate)
{
	certificate.Clear();
	return securityFunctionTable->QueryContextAttributes(&ctxtHandle, SECPKG_ATTR_REMOTE_CERT_CONTEXT, (PVOID)&certificate.certContext);
}

void SecuritySupportProvider::Clear()
{
	inputOutputBufferLength = 0;
	if (inputOutputBuffer != NULL)
	{
		LocalFree(inputOutputBuffer);
		inputOutputBuffer = NULL;
	}
	if (isCtxtHandleValid == true)
	{
		securityFunctionTable->DeleteSecurityContext(&ctxtHandle);
		isCtxtHandleValid = false;
	}
	//
	if (isCredHandleValid == true)
	{
		securityFunctionTable->FreeCredentialsHandle(&credHandle);
		isCredHandleValid = false;
	}
	//
	if(hCertStore != NULL) CertCloseStore(hCertStore, 0);
	hCertStore = NULL;
}

SECURITY_STATUS SecuritySupportProvider::CreateCredentials(DWORD protocol)
{
	return CreateCredentials(NULL, protocol, 0);
}

SECURITY_STATUS SecuritySupportProvider::CreateCredentials(DWORD protocol, ALG_ID keyExchange)
{
	return CreateCredentials(NULL, protocol, keyExchange);
}

SECURITY_STATUS SecuritySupportProvider::CreateCredentials(const wchar_t* username, DWORD protocol, ALG_ID keyExchange)   
{
	Clear();
	if (securityFunctionTable == NULL) return SEC_E_CANNOT_INSTALL;
	//_________________________________________________________ Open the "MY" certificate store. Windows has 4 stores: MY, CA, ROOT, SPC. 
	if(hCertStore == NULL)
	{
		hCertStore = CertOpenSystemStore(0, L"MY");
		if (hCertStore == NULL) return SEC_E_NO_CREDENTIALS;
	}

    //_________________________________________________________ Find a client certificate
	PCCERT_CONTEXT certContext = NULL;
	if (username != NULL)
	{
		certContext = CertFindCertificateInStore( hCertStore,
		X509_ASN_ENCODING, // dwCertEncodingType
		0, // dwFindFlags
		CERT_FIND_SUBJECT_STR, // dwFindType
		username,  // *pvFindPara
		NULL );  // pPrevCertContext

		if(certContext == NULL) return SEC_E_NO_CREDENTIALS;
	}

	//__________________________________________________________________________ SCHANNEL_CRED
	SCHANNEL_CRED schannelCred;
	::memset(&schannelCred, 0, sizeof(SCHANNEL_CRED));
    schannelCred.dwVersion  = SCHANNEL_CRED_VERSION;
    if(certContext != NULL)
    {
        schannelCred.cCreds     = 1;
        schannelCred.paCred     = &certContext;
    }
    schannelCred.grbitEnabledProtocols = protocol; //SP_PROT_TLS1, SP_PROT_PCT1, SP_PROT_SSL2, SP_PROT_SSL3

	DWORD supportedAlgs = 0;
    ALG_ID rgbSupportedAlgs[16];

    if(keyExchange != 0) rgbSupportedAlgs[supportedAlgs++] = keyExchange;

    if(supportedAlgs != 0)
    {
        schannelCred.cSupportedAlgs    = supportedAlgs;
        schannelCred.palgSupportedAlgs = rgbSupportedAlgs;
    }
    schannelCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;

    // Verity the server certificate manually. Applications running on Windows 2000 and later
    // the InitializeSecurityContext function will validate the server certificate automatically without setting this flag
    schannelCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;

    //_______________________________________________________________________ Create credential.
	TimeStamp timeStampExpiry;
    SECURITY_STATUS status = securityFunctionTable->AcquireCredentialsHandle( NULL,                 // Name of principal    
                 UNISP_NAME,         // MICROSOFT_KERBEDOS_NAME, NTLMSP_NAME, NEGOSSP_NAME, UNISP_NAME
                 SECPKG_CRED_OUTBOUND, // SECPKG_CRED_INBOUND, SECPKG_CRED_OUTBOUND, SECPKG_CRED_BOTH
                 NULL,  // Pointer to logon ID
                 &schannelCred,  // Package specific data
                 NULL, // Pointer to GetKey() func
                 NULL,   // Value to pass to GetKey()
                 &credHandle, // (out) Cred Handle
                 &timeStampExpiry);          // (out) Lifetime (optional)

    if(certContext != NULL) CertFreeCertificateContext(certContext);

    return status;
}

SECURITY_STATUS SecuritySupportProvider::ClientHandshake(Sys::IChannel& ichannel, const wchar_t* serverName)
{
	//__________________________________________________ Be sure ctxtHandle is NULL
	if (isCtxtHandleValid == true)
	{
		securityFunctionTable->DeleteSecurityContext(&ctxtHandle);
		isCtxtHandleValid = false;
	}

    DWORD outFlags;
    TimeStamp timeStampExpiry;
	DWORD flags = ISC_REQ_SEQUENCE_DETECT   | ISC_REQ_REPLAY_DETECT     | ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    | ISC_REQ_ALLOCATE_MEMORY   | ISC_REQ_STREAM;

    //__________________________________________________ Output buffers
	SecBufferDesc outBuffer;
	SecBuffer outBuffers[1];
    outBuffers[0].pvBuffer   = NULL;
    outBuffers[0].BufferType = SECBUFFER_TOKEN;
    outBuffers[0].cbBuffer   = 0;

    outBuffer.cBuffers  = 1;
    outBuffer.pBuffers  = outBuffers;
    outBuffer.ulVersion = SECBUFFER_VERSION;

    SECURITY_STATUS status = securityFunctionTable->InitializeSecurityContext(&credHandle, NULL, (wchar_t*)serverName, flags,
                 0, SECURITY_NATIVE_DREP, NULL, 0, &ctxtHandle, &outBuffer, &outFlags, &timeStampExpiry);

	if (status != SEC_I_CONTINUE_NEEDED) return status;

    //________________________________________________________________ send response to server
    if(outBuffers[0].cbBuffer != 0 && outBuffers[0].pvBuffer != NULL)
    {
		int bytesSent = ichannel.Send((const char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer);
        //cbData = send( Socket, (const char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer, 0 );
        if(bytesSent == SOCKET_ERROR || bytesSent == 0 )
        {
            securityFunctionTable->FreeContextBuffer(outBuffers[0].pvBuffer);
            securityFunctionTable->DeleteSecurityContext(&ctxtHandle);
			isCtxtHandleValid = false;
            return SEC_E_INTERNAL_ERROR;
        }
		//if(fVerbose) { PrintHexDump(cbData, OutBuffers[0].pvBuffer); printf("\n"); }
        securityFunctionTable->FreeContextBuffer(outBuffers[0].pvBuffer); // Free output buffer.
        outBuffers[0].pvBuffer = NULL;
    }

	SecBuffer extraData;
	status = ClientHandshakeLoop(ichannel, extraData);
	if (status != SEC_E_OK) return status;
	//____________________________________________________ Memory allocation for inputOutputBuffer;
	return CreateInputOutputBuffer();
}

SECURITY_STATUS SecuritySupportProvider::CreateInputOutputBuffer()
{
	//____________________________________________________________________________________ Memory Release
	if (inputOutputBuffer != NULL)
	{
		::LocalFree(inputOutputBuffer);
		inputOutputBuffer = NULL;
	}
	inputOutputBufferLength = 0;
    //___________________________________________________________________ Compute input output buffer size
    SECURITY_STATUS  status = securityFunctionTable->QueryContextAttributes(&ctxtHandle, SECPKG_ATTR_STREAM_SIZES, &sizes );
	if (status != SEC_E_OK) return status;
	//
    inputOutputBufferLength = sizes.cbHeader  +  sizes.cbMaximumMessage  +  sizes.cbTrailer;
    inputOutputBuffer  = (PBYTE)LocalAlloc(LMEM_FIXED, inputOutputBufferLength);
    if (inputOutputBuffer == NULL)  return SEC_E_INTERNAL_ERROR;
	return SEC_E_OK;
}

SECURITY_STATUS SecuritySupportProvider::ClientHandshakeLoop(Sys::IChannel& ichannel, SecBuffer& extraData)
{
	DWORD flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY | ISC_RET_EXTENDED_ERROR | ISC_REQ_ALLOCATE_MEMORY   | ISC_REQ_STREAM;
   //____________________________________________________________________________________ Memory Allocation
	if (inputOutputBuffer != NULL)
	{
		::LocalFree(inputOutputBuffer);
		inputOutputBuffer = NULL;
	}
	inputOutputBufferLength = 0;
	inputOutputBuffer = (PUCHAR)LocalAlloc(LMEM_FIXED, WSOCK_IO_BUFFER_SIZE);
	if (inputOutputBuffer == NULL) return SEC_E_INTERNAL_ERROR;
	inputOutputBufferLength = WSOCK_IO_BUFFER_SIZE;
	bool doRead = true;

	//____________________________________________________________Loop until the handshake is finished or an error occurs.
	SECURITY_STATUS status = SEC_I_CONTINUE_NEEDED;
	DWORD total = 0;
	int numBytes;
	SecBufferDesc inBuffer;
	SecBuffer inBuffers[2];
	SecBufferDesc outBuffer;
	SecBuffer outBuffers[1];
	DWORD outFlags;
	TimeStamp timeStampExpiry;

	while( status == SEC_I_CONTINUE_NEEDED || status == SEC_E_INCOMPLETE_MESSAGE || status == SEC_I_INCOMPLETE_CREDENTIALS) 
	{
		if(total == 0 || status == SEC_E_INCOMPLETE_MESSAGE) // Read data from server.
		{
			if(doRead == true)
			{
				numBytes = ichannel.Receive((char*)(inputOutputBuffer + total), WSOCK_IO_BUFFER_SIZE - total);
				//cbData = recv(Socket, (char*)(IoBuffer + cbIoBuffer), IO_BUFFER_SIZE - cbIoBuffer, 0 );
				if(numBytes == SOCKET_ERROR)
				{
					status = SEC_E_INTERNAL_ERROR;
					break;
				}
				else if(numBytes == 0)
				{
					status = SEC_E_INTERNAL_ERROR;
					break;
				}
				total += numBytes;
			}
			else
			{
				doRead = true;
			}
		}
		//____________________________________________________________________ Input buffers
		inBuffers[0].pvBuffer = inputOutputBuffer;
		inBuffers[0].cbBuffer = total;
		inBuffers[0].BufferType = SECBUFFER_TOKEN;

		inBuffers[1].pvBuffer = NULL;
		inBuffers[1].cbBuffer  = 0;
		inBuffers[1].BufferType = SECBUFFER_EMPTY;

		inBuffer.cBuffers = 2;
		inBuffer.pBuffers = inBuffers;
		inBuffer.ulVersion = SECBUFFER_VERSION;

		//____________________________________________________________________ Output buffers
		outBuffers[0].pvBuffer  = NULL;
		outBuffers[0].BufferType= SECBUFFER_TOKEN;
		outBuffers[0].cbBuffer  = 0;

		outBuffer.cBuffers = 1;
		outBuffer.pBuffers  = outBuffers;
		outBuffer.ulVersion  = SECBUFFER_VERSION;

		//___________________________________________________________ InitializeSecurityContext.
		status = securityFunctionTable->InitializeSecurityContext(&credHandle, &ctxtHandle, NULL, flags, 
			0, SECURITY_NATIVE_DREP, &inBuffer, 0, NULL, &outBuffer, &outFlags, &timeStampExpiry);

		if(status == SEC_E_OK || status== SEC_I_CONTINUE_NEEDED || FAILED(status) && (outFlags & ISC_RET_EXTENDED_ERROR))
		{
			if(outBuffers[0].cbBuffer != 0 && outBuffers[0].pvBuffer != NULL)
			{
				numBytes = ichannel.Send((const char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer);
				//cbData = send(Socket, (const char*)OutBuffers[0].pvBuffer, OutBuffers[0].cbBuffer, 0 );
				if(numBytes == SOCKET_ERROR || numBytes == 0)
				{
					securityFunctionTable->FreeContextBuffer(outBuffers[0].pvBuffer);
					securityFunctionTable->DeleteSecurityContext(&ctxtHandle);
					isCtxtHandleValid = false;
					return SEC_E_INTERNAL_ERROR;
				}
				//___________________________________________Free output buffer.
				securityFunctionTable->FreeContextBuffer(outBuffers[0].pvBuffer);
				outBuffers[0].pvBuffer = NULL;
			}
		}

		if (status == SEC_E_INCOMPLETE_MESSAGE) continue; // we need to read more data from the server and try again.
		if(status == SEC_E_OK) // Handshake completed successfully.
		{
			//         // If the "extra" buffer contains data, this is encrypted application
			//         // protocol layer stuff. It needs to be saved. The application layer
			//         // will later decrypt it with DecryptMessage.
			//         printf("Handshake was successful\n");

			if(inBuffers[1].BufferType == SECBUFFER_EXTRA)
			{
				extraData.pvBuffer = LocalAlloc( LMEM_FIXED, inBuffers[1].cbBuffer );
				if(extraData.pvBuffer == NULL) return SEC_E_INTERNAL_ERROR;

				MoveMemory(extraData.pvBuffer, inputOutputBuffer + (total - inBuffers[1].cbBuffer), inBuffers[1].cbBuffer );

				extraData.cbBuffer   = inBuffers[1].cbBuffer;
				extraData.BufferType = SECBUFFER_TOKEN;
			}
			else
			{
				extraData.pvBuffer   = NULL;
				extraData.cbBuffer   = 0;
				extraData.BufferType = SECBUFFER_EMPTY;
			}
			break; // Bail out to quit
		}

		if (FAILED(status)) return status; //{ printf("**** Error 0x%x returned by InitializeSecurityContext (2)\n", scRet); break; }
		if (status == SEC_I_INCOMPLETE_CREDENTIALS) // Server just requested client authentication. 
		{
			// The server has requested client authentication and the credential supplied didn't contain a client certificate.
			// This function will read the list of trusted certificate
			// authorities ("issuers") that was received from the server
			// and attempt to find a suitable client certificate that
			// was issued by one of these. If this function is successful, 
			// then we will connect using the new certificate. Otherwise,
			// we will attempt to connect anonymously (using our current credentials).
			GetNewClientCredentials();
			doRead = false;
			status = SEC_I_CONTINUE_NEEDED;
			continue;
		}

		// Copy any leftover data from the "extra" buffer, and go around again.
		if (inBuffers[1].BufferType == SECBUFFER_EXTRA )
		{
			MoveMemory(inputOutputBuffer, inputOutputBuffer + (total - inBuffers[1].cbBuffer), inBuffers[1].cbBuffer );
			total = inBuffers[1].cbBuffer;
		}
		else
		{
			total = 0;
		}
	}

	//_____________________________________________Delete the security context in the case of a fatal error.
	if (FAILED(status))	
	{
		securityFunctionTable->DeleteSecurityContext(&ctxtHandle);
		isCtxtHandleValid = false;
	}
	if (inputOutputBuffer != NULL)
	{
		LocalFree(inputOutputBuffer);
		inputOutputBuffer = NULL;
	}
	return status;
}

void SecuritySupportProvider::GetNewClientCredentials()
{
	////______________________________________________________ Clear previous credHandle
	//if (isCredHandleValid == true)
	//{
	//	securityFunctionTable->FreeCredentialsHandle(&credHandle);
	//	isCredHandleValid = false;
	//}
	//
    PCCERT_CONTEXT certContext;
    TimeStamp timeStampExpiry;

    //____________________________________________________________________ Get list of trusted issuers from schannel
	SecPkgContext_IssuerListInfoEx  issuerListInfo;
    SECURITY_STATUS status = securityFunctionTable->QueryContextAttributes(&ctxtHandle, SECPKG_ATTR_ISSUER_LIST_EX, (PVOID)&issuerListInfo );
	if(status != SEC_E_OK) return;

    //____________________________________________________________________ Enumerate the client certificates
	CERT_CHAIN_FIND_BY_ISSUER_PARA findByIssuerPara;
    ZeroMemory(&findByIssuerPara, sizeof(CERT_CHAIN_FIND_BY_ISSUER_PARA));

    findByIssuerPara.cbSize = sizeof(CERT_CHAIN_FIND_BY_ISSUER_PARA);
    findByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    findByIssuerPara.dwKeySpec = 0;
    findByIssuerPara.cIssuer   = issuerListInfo.cIssuers;
    findByIssuerPara.rgIssuer  = issuerListInfo.aIssuers;

    PCCERT_CHAIN_CONTEXT chainContext = NULL;

	SCHANNEL_CRED schannelCred;
	CredHandle  newCreds;
    while(true)
    { 
        chainContext = CertFindChainInStore(hCertStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_CHAIN_FIND_BY_ISSUER,
                                              &findByIssuerPara,
                                              chainContext);
        if(chainContext == NULL) return;

        // _______________________________________________________________ get leaf certificate context
        certContext = chainContext->rgpChain[0]->rgpElement[0]->pCertContext;

		// Create schannel credential.
		schannelCred.dwVersion = SCHANNEL_CRED_VERSION;
		schannelCred.cCreds = 1;
		schannelCred.paCred = &certContext;

        status = securityFunctionTable->AcquireCredentialsHandle(  NULL,                   // Name of principal
                                  UNISP_NAME,           // Name of package
                                  SECPKG_CRED_OUTBOUND,   // Flags indicating use
                                  NULL,                   // Pointer to logon ID
                                  &schannelCred,          // Package specific data
                                  NULL,                   // Pointer to GetKey() func
                                  NULL,                   // Value to pass to GetKey()
                                  &newCreds,                // (out) Cred Handle
                                 &timeStampExpiry );            // (out) Lifetime (optional)

		if(status != SEC_E_OK) continue;
		//_______________________________________ OK
        securityFunctionTable->FreeCredentialsHandle(&credHandle); // Destroy previous credentials.
        credHandle = newCreds;
    }
}

void SecuritySupportProvider::GetConnectionInfo(wstring& out_connectionInfo)
{
    SecPkgContext_ConnectionInfo connectionInfo;
	wchar_t text[256];

    const SECURITY_STATUS status = securityFunctionTable->QueryContextAttributes(&ctxtHandle, SECPKG_ATTR_CONNECTION_INFO, (PVOID)&connectionInfo );
    if(status != SEC_E_OK)
	{ 
		out_connectionInfo = GetErrorDescr(status);
		return;
	}
	//___________________________________________________ Protocol
    switch(connectionInfo.dwProtocol)
    {
	case SP_PROT_TLS1_CLIENT:
		out_connectionInfo = L"Protocol: TLS1\r\n";
		break;
	case SP_PROT_SSL3_CLIENT:
		out_connectionInfo = L"Protocol: SSL3\r\n";
		break;
	case SP_PROT_PCT1_CLIENT:
		out_connectionInfo = L"Protocol: PCT\r\n";
		break;
	case SP_PROT_SSL2_CLIENT:
		out_connectionInfo = L"Protocol: SSL2\r\n";
		break;
	default:
		_snwprintf_s(text, 256, _TRUNCATE, L"Protocol: 0x%x\r\n", connectionInfo.dwProtocol);
		out_connectionInfo += text;
    }
	//___________________________________________________ Cipher
    switch(connectionInfo.aiCipher)
    {
	case CALG_RC4: 
		out_connectionInfo += L"Cipher: RC4\r\n";
		break;
	case CALG_3DES: 
		out_connectionInfo += L"Cipher: Triple DES\r\n";
		break;
	case CALG_RC2: 
		out_connectionInfo += L"Cipher: RC2\r\n";
		break;
	case CALG_DES: 
	case CALG_CYLINK_MEK:
		out_connectionInfo += L"Cipher: DES\r\n";
		break;
	case CALG_SKIPJACK: 
		out_connectionInfo += L"Cipher: Skipjack\r\n";
		break;
	default: 
		_snwprintf_s(text, 256, _TRUNCATE, L"Cipher: 0x%x\r\n", connectionInfo.aiCipher);
		out_connectionInfo += text;
    }
	_snwprintf_s(text, 256, _TRUNCATE, L"Cipher strength: %d\r\n", connectionInfo.dwCipherStrength);
	out_connectionInfo += text;
	//__________________________________________________________ Hash
    switch(connectionInfo.aiHash)
    {
	case CALG_MD5: 
		out_connectionInfo += L"Hash: MD5\r\n";
		break;
	case CALG_SHA: 
		out_connectionInfo += L"Hash: SHA\r\n";
		break;
	default: 
		_snwprintf_s(text, 256, _TRUNCATE, L"Hash: 0x%x\r\n", connectionInfo.aiHash);
		out_connectionInfo += text;
    }

	_snwprintf_s(text, 256, _TRUNCATE, L"Hash strength: %d\r\n", connectionInfo.dwHashStrength);
	out_connectionInfo += text;

	//___________________________________________________________ Key exchange
    switch(connectionInfo.aiExch)
    {
	case CALG_RSA_KEYX: 
	case CALG_RSA_SIGN: 
		out_connectionInfo += L"Key exchange: RSA\r\n";
		break;
	case CALG_KEA_KEYX: 
		out_connectionInfo += L"Key exchange: KEA\r\n";
		break;
	case CALG_DH_EPHEM:
		out_connectionInfo += L"Key exchange: DH Ephemeral\r\n";
		break;
	default:
		_snwprintf_s(text, 256, _TRUNCATE, L"Key exchange: 0x%x\r\n", connectionInfo.aiExch);
		out_connectionInfo += text;
    }
	_snwprintf_s(text, 256, _TRUNCATE, L"Key exchange strength: %d", connectionInfo.dwExchStrength);
	out_connectionInfo += text;
}

SECURITY_STATUS SecuritySupportProvider::DisconnectFromServer(Sys::IChannel& ichannel)
{
	//_______________________________________________ Notify schannel that we are about to close the connection.
	DWORD dwType = SCHANNEL_SHUTDOWN; 
	 //_______________________________________________ Output buffers
	SecBufferDesc outBuffer;
	SecBuffer     outBuffers[1];

	outBuffers[0].pvBuffer   = &dwType;
	outBuffers[0].BufferType = SECBUFFER_TOKEN;
	outBuffers[0].cbBuffer   = sizeof(DWORD);

	outBuffer.cBuffers  = 1;
	outBuffer.pBuffers  = outBuffers;
	outBuffer.ulVersion = SECBUFFER_VERSION;

	//______________________________________________ ApplyControlToken
	SECURITY_STATUS status = securityFunctionTable->ApplyControlToken(&ctxtHandle, &outBuffer);
	if (FAILED(status)) return status;

	//_______________________________________________ Build an SSL close notify message
	TimeStamp timeStampExpiry;
	DWORD outFlags;
	DWORD flags = ISC_REQ_SEQUENCE_DETECT   |
	ISC_REQ_REPLAY_DETECT     |
	ISC_REQ_CONFIDENTIALITY   |
	ISC_RET_EXTENDED_ERROR    |
	ISC_REQ_ALLOCATE_MEMORY   |
	ISC_REQ_STREAM;

	outBuffers[0].pvBuffer   = NULL;
	outBuffers[0].BufferType = SECBUFFER_TOKEN;
	outBuffers[0].cbBuffer   = 0;

	outBuffer.cBuffers  = 1;
	outBuffer.pBuffers  = outBuffers;
	outBuffer.ulVersion = SECBUFFER_VERSION;

	status = securityFunctionTable->InitializeSecurityContext(&credHandle, &ctxtHandle, NULL, flags,
				0, SECURITY_NATIVE_DREP, NULL, 0, &ctxtHandle, &outBuffer, &outFlags, &timeStampExpiry);

	if (FAILED(status)) return status;

	DWORD cbData;
	PBYTE pbMessage = (PBYTE)outBuffers[0].pvBuffer;
	DWORD cbMessage = outBuffers[0].cbBuffer;

	//____________________________________________ Send the close notify message to the server.
	if (pbMessage != NULL && cbMessage != 0)
	{
		cbData = ichannel.Send((char*)pbMessage, cbMessage);
		if(cbData == SOCKET_ERROR || cbData == 0) return SEC_E_INTERNAL_ERROR;
	}

	return status;
}

const wchar_t* SecuritySupportProvider::GetErrorDescr(SECURITY_STATUS status)
{
	switch(status)
	{
	case SEC_E_INVALID_HANDLE: return L"The handle specified is invalid. SEC_E_INVALID_HANDLE.";
	case SEC_E_UNSUPPORTED_FUNCTION: return L"The function requested is not supported. SEC_E_UNSUPPORTED_FUNCTION.";
	case SEC_E_TARGET_UNKNOWN: return L"The specified target is unknown or unreachable. SEC_E_TARGET_UNKNOWN.";
	case SEC_E_INTERNAL_ERROR: return L"The Local Security Authority cannot be contacted. SEC_E_INTERNAL_ERROR.";
	case SEC_E_SECPKG_NOT_FOUND: return L"The requested security package does not exist. SEC_E_SECPKG_NOT_FOUND.";
	case SEC_E_NOT_OWNER: return L"The caller is not the owner of the desired credentials. SEC_E_NOT_OWNER.";
	case SEC_E_CANNOT_INSTALL: return L"The security package failed to initialize, and cannot be installed. SEC_E_CANNOT_INSTALL.";
	case SEC_E_INVALID_TOKEN: return L"The token supplied to the function is invalid. SEC_E_INVALID_TOKEN.";
	case SEC_E_CANNOT_PACK: return L"The security package is not able to marshall the logon buffer, so the logon attempt has failed. SEC_E_CANNOT_PACK.";
	case SEC_E_QOP_NOT_SUPPORTED: return L"The per-message Quality of Protection is not supported by the security package. SEC_E_QOP_NOT_SUPPORTED.";
	case SEC_E_NO_IMPERSONATION: return L"The security context does not allow impersonation of the client. SEC_E_NO_IMPERSONATION.";
	case SEC_E_LOGON_DENIED: return L"The logon attempt failed. SEC_E_LOGON_DENIED.";
	case SEC_E_UNKNOWN_CREDENTIALS: return L"The credentials supplied to the package were not recognized. SEC_E_UNKNOWN_CREDENTIALS.";
	case SEC_E_NO_CREDENTIALS: return L"No credentials are available in the security package. SEC_E_NO_CREDENTIALS.";
	case SEC_E_MESSAGE_ALTERED: return L"The message or signature supplied for verification has been altered. SEC_E_MESSAGE_ALTERED.";
	case SEC_E_OUT_OF_SEQUENCE: return L"The message supplied for verification is out of sequence. SEC_E_OUT_OF_SEQUENCE.";
	case SEC_E_NO_AUTHENTICATING_AUTHORITY: return L"No authority could be contacted for authentication. SEC_E_NO_AUTHENTICATING_AUTHORITY.";
	case SEC_I_CONTINUE_NEEDED: return L"The function completed successfully, but must be called again to complete the context. SEC_I_CONTINUE_NEEDED.";
	case SEC_I_COMPLETE_NEEDED: return L"The function completed successfully, but CompleteToken must be called. SEC_I_COMPLETE_NEEDED.";
	case SEC_I_COMPLETE_AND_CONTINUE: return L"The function completed successfully, but both CompleteToken and this function must be called to complete the context. SEC_I_COMPLETE_AND_CONTINUE.";
	case SEC_I_LOCAL_LOGON: return L"The logon was completed, but no network authority was available. The logon was made using locally known information. SEC_I_LOCAL_LOGON.";
	case SEC_E_BAD_PKGID: return L"The requested security package does not exist. SEC_E_BAD_PKGID.";
	case SEC_E_CONTEXT_EXPIRED: return L"The context has expired and can no longer be used. SEC_E_CONTEXT_EXPIRED.";
	case SEC_I_CONTEXT_EXPIRED: return L"The context has expired and can no longer be used. SEC_I_CONTEXT_EXPIRED.";
	case SEC_E_INCOMPLETE_MESSAGE: return L"The supplied message is incomplete. The signature was not verified.. SEC_E_INCOMPLETE_MESSAGE.";
	case SEC_E_INCOMPLETE_CREDENTIALS: return L"The credentials supplied were not complete, and could not be verified. The context could not be initialized.. SEC_E_INCOMPLETE_CREDENTIALS.";
	case SEC_E_BUFFER_TOO_SMALL: return L"The buffers supplied to a function was too small. SEC_E_BUFFER_TOO_SMALL.";
	case SEC_I_INCOMPLETE_CREDENTIALS: return L"The credentials supplied were not complete, and could not be verified. Additional information can be returned from the context. SEC_I_INCOMPLETE_CREDENTIALS.";
	case SEC_I_RENEGOTIATE: return L"The context data must be renegotiated with the peer. SEC_I_RENEGOTIATE.";
	case SEC_E_WRONG_PRINCIPAL: return L"The target principal name is incorrect. SEC_E_WRONG_PRINCIPAL.";
	case SEC_I_NO_LSA_CONTEXT: return L"There is no LSA mode context associated with this context. SEC_I_NO_LSA_CONTEXT.";
	case SEC_E_TIME_SKEW: return L"The clocks on the client and server machines are skewed. SEC_E_TIME_SKEW.";
	case SEC_E_UNTRUSTED_ROOT: return L"The certificate chain was issued by an authority that is not trusted. SEC_E_UNTRUSTED_ROOT.";
	case SEC_E_ILLEGAL_MESSAGE: return L"The message received was unexpected or badly formatted. SEC_E_ILLEGAL_MESSAGE.";
	case SEC_E_CERT_UNKNOWN: return L"An unknown error occurred while processing the certificate. SEC_E_CERT_UNKNOWN.";
	case SEC_E_CERT_EXPIRED: return L"The received certificate has expired. SEC_E_CERT_EXPIRED.";
	case SEC_E_ENCRYPT_FAILURE: return L"The specified data could not be encrypted. SEC_E_ENCRYPT_FAILURE.";
	case SEC_E_DECRYPT_FAILURE: return L"The specified data could not be decrypted. SEC_E_DECRYPT_FAILURE.";
	case SEC_E_ALGORITHM_MISMATCH: return L"The client and server cannot communicate, because they do not possess a common algorithm.. SEC_E_ALGORITHM_MISMATCH.";
	case SEC_E_SECURITY_QOS_FAILED: return L"The security context could not be established due to a failure in the requested quality of service (e.g. mutual authentication or delegation).. SEC_E_SECURITY_QOS_FAILED.";
	case SEC_E_UNFINISHED_CONTEXT_DELETED: return L"A security context was deleted before the context was completed. This is considered a logon failure.. SEC_E_UNFINISHED_CONTEXT_DELETED.";
	case SEC_E_NO_TGT_REPLY: return L"The client is trying to negotiate a context and the server requires user-to-user but didn't send a TGT reply.. SEC_E_NO_TGT_REPLY.";
	case SEC_E_NO_IP_ADDRESSES: return L"Unable to accomplish the requested task because the local machine does not have any IP addresses.. SEC_E_NO_IP_ADDRESSES.";
	case SEC_E_WRONG_CREDENTIAL_HANDLE: return L"The supplied credential handle does not match the credential associated with the security context.. SEC_E_WRONG_CREDENTIAL_HANDLE.";
	case SEC_E_CRYPTO_SYSTEM_INVALID: return L"The crypto system or checksum function is invalid because a required function is unavailable.. SEC_E_CRYPTO_SYSTEM_INVALID.";
	case SEC_E_MAX_REFERRALS_EXCEEDED: return L"The number of maximum ticket referrals has been exceeded. SEC_E_MAX_REFERRALS_EXCEEDED.";
	case SEC_E_MUST_BE_KDC: return L"The local machine must be a Kerberos KDC (domain controller) and it is not. SEC_E_MUST_BE_KDC.";
	case SEC_E_STRONG_CRYPTO_NOT_SUPPORTED: return L"The other end of the security negotiation is requires strong crypto but it is not supported on the local machine.. SEC_E_STRONG_CRYPTO_NOT_SUPPORTED.";
	case SEC_E_TOO_MANY_PRINCIPALS: return L"The KDC reply contained more than one principal name. SEC_E_TOO_MANY_PRINCIPALS.";
	case SEC_E_NO_PA_DATA: return L"Expected to find PA data for a hint of what etype to use, but it was not found. SEC_E_NO_PA_DATA.";
	case SEC_E_PKINIT_NAME_MISMATCH: return L"The client certificate does not contain a valid UPN, or does not match the client name in the logon request. Please contact your administrator.. SEC_E_PKINIT_NAME_MISMATCH.";
	case SEC_E_SMARTCARD_LOGON_REQUIRED: return L"Smartcard logon is required and was not used. SEC_E_SMARTCARD_LOGON_REQUIRED.";
	case SEC_E_SHUTDOWN_IN_PROGRESS: return L"A system shutdown is in progress. SEC_E_SHUTDOWN_IN_PROGRESS.";
	case SEC_E_KDC_INVALID_REQUEST: return L"An invalid request was sent to the KDC. SEC_E_KDC_INVALID_REQUEST.";
	case SEC_E_KDC_UNABLE_TO_REFER: return L"The KDC was unable to generate a referral for the service requested.. SEC_E_KDC_UNABLE_TO_REFER.";
	case SEC_E_KDC_UNKNOWN_ETYPE: return L"The encryption type requested is not supported by the KDC. SEC_E_KDC_UNKNOWN_ETYPE.";
	case SEC_E_UNSUPPORTED_PREAUTH: return L"An unsupported preauthentication mechanism was presented to the Kerberos package.. SEC_E_UNSUPPORTED_PREAUTH.";
	case SEC_E_DELEGATION_REQUIRED: return L"The requested operation cannot be completed. The computer must be trusted for delegation and the current user account must be configured to allow delegation.. SEC_E_DELEGATION_REQUIRED.";
	case SEC_E_BAD_BINDINGS: return L"Client's supplied SSPI channel bindings were incorrect. SEC_E_BAD_BINDINGS.";
	case SEC_E_MULTIPLE_ACCOUNTS: return L"The received certificate was mapped to multiple accounts. SEC_E_MULTIPLE_ACCOUNTS.";
	case SEC_E_NO_KERB_KEY: return L" SEC_E_NO_KERB_KEY. SEC_E_NO_KERB_KEY.";
	case SEC_E_CERT_WRONG_USAGE: return L"The certificate is not valid for the requested usage. SEC_E_CERT_WRONG_USAGE.";
	case SEC_E_DOWNGRADE_DETECTED: return L"The system cannot contact a domain controller to service the authentication request. Please try again later. SEC_E_DOWNGRADE_DETECTED.";
	case SEC_E_SMARTCARD_CERT_REVOKED: return L"The smartcard certificate used for authentication has been revoked. Please contact your system administrator. There may be additional information in the event log.. SEC_E_SMARTCARD_CERT_REVOKED.";
	case SEC_E_ISSUING_CA_UNTRUSTED: return L"An untrusted certificate authority was detected while processing the smartcard certificate used for authentication. Please contact your system administrator.. SEC_E_ISSUING_CA_UNTRUSTED.";
	case SEC_E_REVOCATION_OFFLINE_C: return L"The revocation status of the smartcard certificate used for authentication could not be determined. Please contact your system administrator.. SEC_E_REVOCATION_OFFLINE_C.";
	case SEC_E_PKINIT_CLIENT_FAILURE: return L"The smartcard certificate used for authentication was not trusted. Please contact your system administrator.. SEC_E_PKINIT_CLIENT_FAILURE.";
	case SEC_E_SMARTCARD_CERT_EXPIRED: return L"The smartcard certificate used for authentication has expired. Please contact your system administrator.. SEC_E_SMARTCARD_CERT_EXPIRED.";
	case SEC_E_NO_S4U_PROT_SUPPORT: return L"The Kerberos subsystem encountered an error. A service for user protocol request was made against a domain controller which does not support service for user.. SEC_E_NO_S4U_PROT_SUPPORT.";
	case SEC_E_CROSSREALM_DELEGATION_FAILURE: return L"An attempt was made by this server to make a Kerberos constrained delegation request for a target outside of the server's realm. This is not supported, and indicates a misconfiguration on this server's allowed to delegate to list. Please contact your administrator.. SEC_E_CROSSREALM_DELEGATION_FAILURE.";
	case SEC_E_REVOCATION_OFFLINE_KDC: return L"The revocation status of the domain controller certificate used for smartcard authentication could not be determined. There is additional information in the system event log. Please contact your system administrator.. SEC_E_REVOCATION_OFFLINE_KDC.";
	case SEC_E_ISSUING_CA_UNTRUSTED_KDC: return L"An untrusted certificate authority was detected while processing the domain controller certificate used for authentication. There is additional information in the system event log. Please contact your system administrator.. SEC_E_ISSUING_CA_UNTRUSTED_KDC.";
	case SEC_E_KDC_CERT_EXPIRED: return L"The domain controller certificate used for smartcard logon has expired. Please contact your system administrator with the contents of your system event log.. SEC_E_KDC_CERT_EXPIRED.";
	case SEC_E_KDC_CERT_REVOKED: return L"The domain controller certificate used for smartcard logon has been revoked. Please contact your system administrator with the contents of your system event log.. SEC_E_KDC_CERT_REVOKED.";
	case SEC_I_SIGNATURE_NEEDED: return L"A signature operation must be performed before the user can authenticate. SEC_I_SIGNATURE_NEEDED.";
	case SEC_E_INVALID_PARAMETER: return L"One or more of the parameters passed to the function was invalid. SEC_E_INVALID_PARAMETER.";
	case SEC_E_DELEGATION_POLICY: return L"Client policy does not allow credential delegation to target server. SEC_E_DELEGATION_POLICY.";
	case SEC_E_POLICY_NLTM_ONLY: return L"Client policy does not allow credential delegation to target server with NLTM only authentication. SEC_E_POLICY_NLTM_ONLY.";
	case SEC_I_NO_RENEGOTIATION: return L"The recipient rejected the renegotiation request. SEC_I_NO_RENEGOTIATION.";
	case SEC_E_NO_CONTEXT: return L"The required security context does not exist. SEC_E_NO_CONTEXT.";
	case SEC_E_PKU2U_CERT_FAILURE: return L"The PKU2U protocol encountered an error while attempting to utilize the associated certificates. SEC_E_PKU2U_CERT_FAILURE.";
	case SEC_E_MUTUAL_AUTH_FAILED: return L"The identity of the server computer could not be verified. SEC_E_MUTUAL_AUTH_FAILED.";
	//case SEC_I_MESSAGE_FRAGMENT: return L"The returned buffer is only a fragment of the message.  More fragments need to be returned. SEC_I_MESSAGE_FRAGMENT.";
	//case SEC_E_ONLY_HTTPS_ALLOWED: return L"Only https scheme is allowed. SEC_E_ONLY_HTTPS_ALLOWED.";
	//case SEC_I_CONTINUE_NEEDED_MESSAGE_OK: return L"The function completed successfully, but must be called again to complete the context.  Early start can be used. SEC_I_CONTINUE_NEEDED_MESSAGE_OK.";
	}
	return L"No error information is provided";
}

//_____________________________________________________________________ Sys::Socket
int Socket::objectCount  = 0;
WSADATA Socket::wsadata;

Socket::Socket()
{
	if (objectCount == 0)
	{
		if (WSAStartup(MAKEWORD(2, 1), &wsadata)!=0)
		{
			throw L"WSAStartup error";
		}
	}
	objectCount++;
	hsocket = INVALID_SOCKET;
	_error = -1;
	_portNumber = -1;
}

int Socket::GetPortNumber()
{
	return _portNumber;
}

void Socket::Attach(SOCKET& inputSocket, unsigned int port)
{
	Disconnect();
	_portNumber = port;
	hsocket = inputSocket;
}

//Socket::Socket(const Socket& init) // Copy constructor
//{
//	Constructor();
//	hsocket = init.hsocket;
//	isCopy = true;
//}

//Socket& Socket::operator =(const Socket& init) //Operator =
//{
//	//Destructor();
//	hsocket = init.hsocket;
//	isCopy = true;
//	return *this;
//}

//int Socket::ConnectProxyServer(const wchar_t* proxiServerName, unsigned short proxiPort)
//{
//	//____________________________________________________ Check server name
//	_error = -1;
//	//
//	if (proxiServerName == NULL)
//	{
//		_error = WSOCKERR_NULL_SERVERNAME;
//		return SOCKET_ERROR;
//	}
//	string server_name;
//	Sys::Convert::WstringToString(proxiServerName, server_name);
//
//	LPHOSTENT lpHostEntry=gethostbyname(server_name.c_str());
//	if (lpHostEntry==NULL)
//	{
//		_error = WSOCKERR_DNS_CANNOT_SOLVE_NAME;
//		return SOCKET_ERROR;
//	}
//
//	SOCKADDR_IN sa;
//	sa.sin_family=AF_INET;
//	sa.sin_port=ntons(proxiPort);
//	sa.sin_addr=*((LPIN_ADDR)*lpHostEntry->h_addr_list);
//	return Connect(sa);
//
//	  //if(fUseProxy)
//   // {
//   //     BYTE  pbMessage[200]; 
//   //     DWORD cbMessage;
//
//   //     // Build message for proxy server
//   //     strcpy(pbMessage, "CONNECT ");
//   //     strcat(pbMessage, pszServerName);
//   //     strcat(pbMessage, ":");
//   //      _itoa(iPortNumber, pbMessage + strlen(pbMessage), 10);
//   //     strcat(pbMessage, " HTTP/1.0\r\nUser-Agent: webclient\r\n\r\n");
//   //     cbMessage = (DWORD)strlen(pbMessage);
//
//   //     // Send message to proxy server
//   //     if(send(Socket, pbMessage, cbMessage, 0) == SOCKET_ERROR)
//   //     {
//   //       printf("**** Error %d sending message to proxy!\n", WSAGetLastError());
//   //                 DisplayWinSockError( WSAGetLastError() );
//   //                 return WSAGetLastError();
//   //     }
//
//   //     // Receive message from proxy server
//   //     cbMessage = recv(Socket, pbMessage, 200, 0);
//   //     if(cbMessage == SOCKET_ERROR)
//   //     {
//   //       printf("**** Error %d receiving message from proxy\n", WSAGetLastError());
//   //                 DisplayWinSockError( WSAGetLastError() );
//   //                 return WSAGetLastError();
//   //     }
//   //     // this sample is limited but in normal use it 
//   //     // should continue to receive until CR LF CR LF is received
//   // }
//}

int Socket::Connect(const wstring& serverName, unsigned short port)
{
	return Connect(serverName.c_str(), port);
}

int Socket::Connect(const wchar_t* serverName, unsigned short port)
{
	//ADDRINFOW hints;
	//ZeroMemory( &hints, sizeof(hints) );
	//hints.ai_family = AF_UNSPEC;
	//hints.ai_socktype = SOCK_STREAM;
	//hints.ai_protocol = IPPROTO_TCP;

	//ADDRINFOW *result = NULL;
	//SOCKADDR_IN sa;

	//if (GetAddrInfoW(L"www.yahoo.com", L"80", &hints, &result) != 0) return L"Socket::Connect unable to get address info";
	//for(ADDRINFOW *ptr = result; ptr != NULL ; ptr = ptr->ai_next) 
	//{
	//	switch (ptr->ai_family) 
	//	{
	//	case AF_UNSPEC:
	//		break;
	//	case AF_INET: //(IPv4)
	//		sa.sin_addr = *((LPIN_ADDR)*ptr->ai_addr);
	//		break;
	//	case AF_INET6://(IPv6)
	//		break;
	//	}
	//}
	//FreeAddrInfoW(result);
	//____________________________________________________ Check server name
	_error = -1;
	//
	if (serverName == NULL)
	{
		_error = WSOCKERR_NULL_SERVERNAME;
		return SOCKET_ERROR;
	}
	string server_name;
	Sys::Convert::WstringToString(serverName, server_name);

	LPHOSTENT lpHostEntry=gethostbyname(server_name.c_str());
	if (lpHostEntry==NULL)
	{
		_error = WSOCKERR_DNS_CANNOT_SOLVE_NAME;
		return SOCKET_ERROR;
	}

	SOCKADDR_IN sa;
	sa.sin_family=AF_INET;
	sa.sin_port=htons(port);
	sa.sin_addr=*((LPIN_ADDR)*lpHostEntry->h_addr_list);
	return Connect(sa);
}

//Connect((unsigned short)80), L"66.94.230.44", )
int Socket::Connect(unsigned short port, const wchar_t* ipAddress)
{
	_error = -1;
	//
	SOCKADDR_IN sa;
	IN_ADDR ia;
	string ip_address;
	Sys::Convert::WstringToString(ipAddress, ip_address);
	unsigned long uia = inet_addr(ip_address.c_str());
	
	if (uia == INADDR_NONE)
	{
		_error = WSOCKERR_INVALID_IP_ADDRESS;
		return SOCKET_ERROR;
	}

	ia.S_un.S_addr = uia;
	sa.sin_family=AF_INET;
	sa.sin_port=htons(port);
	sa.sin_addr=ia;
	return Connect(sa);
}

int Socket::Connect(SOCKADDR_IN& sockAddr)
{
	Disconnect();
	hsocket = (SOCKET)socket(AF_INET, SOCK_STREAM, 0);
	if (hsocket==INVALID_SOCKET) return SOCKET_ERROR;
	const int result = ::connect(hsocket, (PSOCKADDR)&sockAddr, sizeof(SOCKADDR_IN));
	if (result == SOCKET_ERROR) return SOCKET_ERROR;
	_portNumber = (int)ntohs(sockAddr.sin_port);
	return result;
}

void Socket::Disconnect()
{
	if (hsocket != INVALID_SOCKET)
	{
		::shutdown(hsocket, SD_BOTH);
		::closesocket(hsocket);
		hsocket = INVALID_SOCKET;
	}
	_error = -1;
	_portNumber = -1;
}
	
SOCKET Socket::Accept()
{
	return ::accept(hsocket, 0, 0);
}

void Socket::ShutdownSend()
{
	::shutdown(hsocket, SD_SEND);
}

void Socket::ShutdownReceive()
{
	::shutdown(hsocket, SD_RECEIVE);
}

void Socket::ShutdownBoth()
{
	::shutdown(hsocket, SD_BOTH);
}

Socket::~Socket(void)
{
	Disconnect();
	objectCount--;
	if (objectCount == 0) WSACleanup();
}

const wchar_t* Socket::GetLastErrorDesc()
{
	const int error = WSAGetLastError();

	if (WSAEINTR <= error && error <= WSA_IPSEC_NAME_POLICY_ERROR)
	{
		return GetErrorDescr(error);
	}
	switch(_error)
	{
	case WSOCKERR_NULL_SERVERNAME: return L"Name is NULL";
	case WSOCKERR_DNS_CANNOT_SOLVE_NAME: return L"Name cannot be resolved by DNS";
	case WSOCKERR_INVALID_IP_ADDRESS: return L"Invalid IP Address";
	}
	return L"No error information is available";
}

char* Socket::GetStatus()
{
	return wsadata.szSystemStatus;
}
	
char* Socket::GetVersion()
{
	return wsadata.szDescription;
}

//void Socket::GetAddressInfo()
//{
//	addrinfo info;
//
//	info.ai_addr = 0;
//	info.ai_addrlen = 0;
//	info.ai_canonname = 0;
//	info.ai_family = PF_INET; // IPV4
//	//::getaddrinfo(
//}

// Returns IP of host, NULL if error
LPHOSTENT Socket::GetHostByName(const wchar_t* serverName)
{
	string server_name;
	Sys::Convert::WstringToString(serverName, server_name);
	return ::gethostbyname(server_name.c_str());
}

// Returns IP of host, NULL if error
LPSTR Socket::GetIpAddressByName(const wchar_t* serverName)
{
	string server_name;
	Sys::Convert::WstringToString(serverName, server_name);

	LPHOSTENT p = ::gethostbyname(server_name.c_str());
	if (p==NULL) return NULL;
	return inet_ntoa( *(LPIN_ADDR) * (p->h_addr_list));
}

// Returns port number for the service in host format
// ServiceName: telnet, ftp, mail, http
int Socket::GetServicePortByName(const wchar_t* serviceName)
{
	string service_name;
	Sys::Convert::WstringToString(serviceName, service_name);
	LPSERVENT lpServEntry=getservbyname(service_name.c_str(), 0);
	int port; 

	if (lpServEntry==NULL)
	{
		if (wcscmp(serviceName, L"telnet") == 0)	port= IPPORT_TELNET;
		if (wcscmp(serviceName, L"echo") == 0) 	port= IPPORT_ECHO;
		if (wcscmp(serviceName, L"discard") == 0)	port= IPPORT_DISCARD;
		if (wcscmp(serviceName, L"systat") == 0)	port= IPPORT_SYSTAT;
		if (wcscmp(serviceName, L"daytime") == 0)	port= IPPORT_DAYTIME;
		if (wcscmp(serviceName, L"netstat") == 0)	port= IPPORT_NETSTAT;
		if (wcscmp(serviceName, L"ftp") == 0)	port= IPPORT_FTP;
		if (wcscmp(serviceName, L"smtp") == 0)	port= IPPORT_SMTP;
		if (wcscmp(serviceName, L"timeserver") == 0)	port= IPPORT_TIMESERVER;
		if (wcscmp(serviceName, L"nameserver") == 0)	port= IPPORT_NAMESERVER;
		if (wcscmp(serviceName, L"whois") == 0)	port= IPPORT_WHOIS;
		if (wcscmp(serviceName, L"mtp") == 0)	port= IPPORT_MTP;
		if (wcscmp(serviceName, L"http") == 0)	port= 80;
	}
	else
	{
		port=ntohs(lpServEntry->s_port);
	}
	return port;
}

//int Socket::Send(char *textToSend, bool removeReturn, bool addCtrl)
//{
//	//	SO_MAX_MSG_SIZE
//	if (textToSend == NULL) return 0;
//	char szData[512];
//	strncpy_s(szData, textToSend, 512);
//	szData[512-1]='\0';
//
//	if (removeReturn) RemoveReturn(szData);
//
//	//****************************************************** CTRL
//	if (addCtrl)  strcat_s(szData, "\r\n");
//
//	return send(hsocket, szData, (int)strlen(szData), 0);// == INVALID_SOCKET)
//}

void Socket::SendLargeBlock(Sys::SocketStatus& out_socketStatus, const char *data, int totalBytes, const int blockSize)
{
	out_socketStatus.Delete();
	if (totalBytes == 0) return;
	int bytesSent = 0;
	int result;

	while(totalBytes > 0)
	{
		if (totalBytes <= blockSize)
		{
			result = ::send(hsocket, data+bytesSent, totalBytes, 0);
		}
		else
		{
			result = ::send(hsocket, data+bytesSent, blockSize, 0);
		}
		if (result == SOCKET_ERROR)
		{
			out_socketStatus.isError = true;
			return;
		}
		if (result == SOCKET_DISCONNECTED)
		{
			out_socketStatus.isConnected = false;
			break;
		}
		out_socketStatus.bytesTransferred += abs(result);
		totalBytes -= abs(result);
		bytesSent += abs(result);
	}
}

// BE AWARE that this function will send data until the NULL character is found
int Socket::Send(const char *buffer)
{
	//The WSASend function sends data on a connected socket using overlapped I/O
	const int result = ::send(hsocket, buffer, strlen(buffer), 0);
	if (result == 0) return SOCKET_DISCONNECTED;
	return result;
}

int Socket::GetMaxMessageSize()
{
	int optlen = sizeof(int);
	int optval = 0;
	if (::getsockopt(hsocket, SOL_SOCKET, SO_MAX_MSG_SIZE, (char*)&optval, &optlen) == SOCKET_ERROR)
	{
		return -1;
	}
	return optval;
}

int Socket::Send(const char *buffer, int bufferSize, int flags)
{
	const int result = ::send(hsocket, buffer, bufferSize, flags);
	if (result == 0) return SOCKET_DISCONNECTED;
	return result;
}

//_____________________________________________________________________ Sys::IChannel
int Socket::Send(const char* in_buffer, int bufferSizeInBytes)
{
	const int count = send(hsocket, in_buffer, bufferSizeInBytes, 0);
	if (count == SOCKET_ERROR) return -1;
	return count;
}

int Socket::Receive(char* out_buffer, int bufferSizeInBytes)
{
	const int count = ::recv(hsocket, out_buffer, bufferSizeInBytes, 0);
	if (count == SOCKET_ERROR) return -1;
	return count;
}

//_____________________________________________________________________ Sys::IStorer
int Socket::Read(void *out_buffer, int bufferSizeInBytes)
{
	const int count = ::recv(hsocket, (char*)out_buffer, bufferSizeInBytes, 0);
	if (count == SOCKET_ERROR) return -1;
	return count;
}

int Socket::Write(const void* in_buffer, int bufferSizeInBytes)
{
	const int count = ::send(hsocket, (const char*)in_buffer, bufferSizeInBytes, 0);
	if (count == SOCKET_ERROR) return -1;
	return count;
}

void Socket::RemoveReturn(char* text)
{
	if (text==NULL) return;

	int i=0;
	int j=0;
	bool bOk=false;
	char last;
	const int len = (int)strlen(text);

	for (i=0; i<len; i++)
	{
		switch(text[i])
		{
		case '\r':
			break;
		case '.':
			if (last=='\n')
			{
				text[j++]='.';
				last='.';
				text[j++]='.';
				last='.';
			}
			else
			{
				text[j++]='.';
				last='.';
			}
			break;
		default:
			text[j++]=text[i];
			last=text[i];
		}
	}
	text[j]='\0';
}

int Socket::ReceiveCodeAsync()
{
	char buffer[512];
	if (::recv(hsocket, buffer, 511, MSG_PEEK)<=0) return -1;
	const int bytes = ::recv(hsocket, buffer, 511, 0);
	if (bytes == 0) return -1;
	buffer[bytes] = '\0';
	//________________________________________ See if there is another line
	//while (buffer[3] == '-')
	//{
	//	bytes = ::recv(hsocket, buffer, 511, 0);
	//	if (bytes == 0) return -1;
	//	buffer[bytes] = '\0';
	//}

	const int len = strlen(buffer);
	char cnumber[6];
	cnumber[0] = '\0';
	int i = 0, j = 0;
	for(i = 0; i<len; i++)
	{
		if (Sys::TextAssistant::IsDigit((unsigned char)buffer[i]) == true)
		{
			cnumber[j++] = buffer[i];
			if (j >= 6 -1)
			{
				cnumber[j] = '\0';
				break;
			}
		}
		else if (Sys::TextAssistant::IsSeparator((unsigned char)buffer[i]) == true)
		{
			cnumber[j] = '\0';
			break;
		}
	}

	return atoi(cnumber);
}

int Socket::ReceiveCode()
{
	char buffer[512];
	int bytes = ::recv(hsocket, buffer, 511, 0);
	if (bytes == 0) return -1;
	buffer[bytes] = '\0';
	//________________________________________ See if there is another line
	while (buffer[3] == '-')
	{
		bytes = ::recv(hsocket, buffer, 511, 0);
		if (bytes == 0) return -1;
		buffer[bytes] = '\0';
	}

	const int len = strlen(buffer);
	char cnumber[6];
	cnumber[0] = '\0';
	int i = 0, j = 0;
	for(i = 0; i<len; i++)
	{
		if (Sys::TextAssistant::IsDigit((unsigned char)buffer[i]) == true)
		{
			cnumber[j++] = buffer[i];
			if (j >= 6 -1)
			{
				cnumber[j] = '\0';
				break;
			}
		}
		else if (Sys::TextAssistant::IsSeparator((unsigned char)buffer[i]) == true)
		{
			cnumber[j] = '\0';
			break;
		}
	}

	//int code = atoi(cnumber);
	//if (code == 334)
	//{
	//	string tmp;
	//	Sys::Convert::Base64BitDecode((const char*)buffer+4, tmp);
	//}

	return atoi(cnumber);
}

int Socket::Receive(char* buffer, int bufferSize, int flags)
{
	const int result = ::recv(hsocket, buffer, bufferSize, flags);
	if (result == 0) return SOCKET_DISCONNECTED;
	return result;
}

void Socket::ReceiveLine(Sys::SocketStatus& out_socketStatus, string& output)
{
	out_socketStatus.Delete();
	output.clear();
	//________________________________________
	char c;
	int result;
	while (true) 
	{
		result = ::recv(hsocket, &c, 1, 0) ;
		if (result == SOCKET_ERROR)
		{
			out_socketStatus.isError = true;
			return;
		}
		if (result == SOCKET_DISCONNECTED)
		{
			out_socketStatus.isConnected = false;
			break;
		}
		if (c == '\n')
		{
			if (output.length() == 0) return;
			if (output[0] == '\r')
			{
				output.clear();
				return;
			}
			out_socketStatus.bytesTransferred = (int)output.length();
			return; // OK
		}
		if (c != '\r') output += c;  
   }
	out_socketStatus.bytesTransferred = (int)output.length();
}

const wchar_t* Socket::GetErrorDescr(WORD error)
{
	switch(error)
	{
	case WSAEINTR: return L"WSAEINTR. A blocking operation was interrupted by a call to WSACancelBlockingCall.";
	case WSAEBADF: return L"WSAEBADF. The file handle supplied is not valid.";
	case WSAEACCES: return L"WSAEACCES. An attempt was made to access a socket in a way forbidden by its access permissions.";
	case WSAEFAULT: return L"WSAEFAULT. The system detected an invalid pointer address in attempting to use a pointer argument in a call.";
	case WSAEINVAL: return L"WSAEINVAL. An invalid argument was supplied.";
	case WSAEMFILE: return L"WSAEMFILE. Too many open sockets.";
	case WSAEWOULDBLOCK: return L"WSAEWOULDBLOCK. A non-blocking socket operation could not be completed immediately.";
	case WSAEINPROGRESS: return L"WSAEINPROGRESS. A blocking operation is currently executing.";
	case WSAEALREADY: return L"WSAEALREADY. An operation was attempted on a non-blocking socket that already had an operation in progress.";
	case WSAENOTSOCK: return L"WSAENOTSOCK. An operation was attempted on something that is not a socket.";
	case WSAEDESTADDRREQ: return L"WSAEDESTADDRREQ. A required address was omitted from an operation on a socket.";
	case WSAEMSGSIZE: return L"WSAEMSGSIZE. A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself.";
	case WSAEPROTOTYPE: return L"WSAEPROTOTYPE. A protocol was specified in the socket function call that does not support the semantics of the socket type requested.";
	case WSAENOPROTOOPT: return L"WSAENOPROTOOPT. An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.";
	case WSAEPROTONOSUPPORT: return L"WSAEPROTONOSUPPORT. The requested protocol has not been configured into the system, or no implementation for it exists.";
	case WSAESOCKTNOSUPPORT: return L"WSAESOCKTNOSUPPORT. The support for the specified socket type does not exist in this address family.";
	case WSAEOPNOTSUPP: return L"WSAEOPNOTSUPP. The attempted operation is not supported for the type of object referenced.";
	case WSAEPFNOSUPPORT: return L"WSAEPFNOSUPPORT. The protocol family has not been configured into the system or no implementation for it exists.";
	case WSAEAFNOSUPPORT: return L"WSAEAFNOSUPPORT. An address incompatible with the requested protocol was used.";
	case WSAEADDRINUSE: return L"WSAEADDRINUSE. Only one usage of each socket address (protocol/network address/port) is normally permitted.";
	case WSAEADDRNOTAVAIL: return L"WSAEADDRNOTAVAIL. The requested address is not valid in its context.";
	case WSAENETDOWN: return L"WSAENETDOWN. A socket operation encountered a dead network.";
	case WSAENETUNREACH: return L"WSAENETUNREACH. A socket operation was attempted to an unreachable network.";
	case WSAENETRESET: return L"WSAENETRESET. The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.";
	case WSAECONNABORTED: return L"WSAECONNABORTED. An established connection was aborted by the software in your host machine.";
	case WSAECONNRESET: return L"WSAECONNRESET. An existing connection was forcibly closed by the remote host.";
	case WSAENOBUFS: return L"WSAENOBUFS. An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.";
	case WSAEISCONN: return L"WSAEISCONN. A connect request was made on an already connected socket.";
	case WSAENOTCONN: return L"WSAENOTCONN. A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.";
	case WSAESHUTDOWN: return L"WSAESHUTDOWN. A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call.";
	case WSAETOOMANYREFS: return L"WSAETOOMANYREFS. Too many references to some kernel object.";
	case WSAETIMEDOUT: return L"WSAETIMEDOUT. A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.";
	case WSAECONNREFUSED: return L"WSAECONNREFUSED. No connection could be made because the target machine actively refused it.";
	case WSAELOOP: return L"WSAELOOP. Cannot translate name.";
	case WSAENAMETOOLONG: return L"WSAENAMETOOLONG. Name component or name was too long.";
	case WSAEHOSTDOWN: return L"WSAEHOSTDOWN. A socket operation failed because the destination host was down.";
	case WSAEHOSTUNREACH: return L"WSAEHOSTUNREACH. A socket operation was attempted to an unreachable host.";
	case WSAENOTEMPTY: return L"WSAENOTEMPTY. Cannot remove a directory that is not empty.";
	case WSAEPROCLIM: return L"WSAEPROCLIM. A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.";
	case WSAEUSERS: return L"WSAEUSERS. Ran out of quota.";
	case WSAEDQUOT: return L"WSAEDQUOT. Ran out of disk quota.";
	case WSAESTALE: return L"WSAESTALE. File handle reference is no longer available.";
	case WSAEREMOTE: return L"WSAEREMOTE. Item is not available locally.";
	case WSASYSNOTREADY: return L"WSASYSNOTREADY. WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.";
	case WSAVERNOTSUPPORTED: return L"WSAVERNOTSUPPORTED. The Windows Sockets version requested is not supported.";
	case WSANOTINITIALISED: return L"WSANOTINITIALISED. Either the application has not called WSAStartup, or WSAStartup failed.";
	case WSAEDISCON: return L"WSAEDISCON. Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence.";
	case WSAENOMORE: return L"WSAENOMORE. No more results can be returned by WSALookupServiceNext.";
	case WSAECANCELLED: return L"WSAECANCELLED. A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.";
	case WSAEINVALIDPROCTABLE: return L"WSAEINVALIDPROCTABLE. The procedure call table is invalid.";
	case WSAEINVALIDPROVIDER: return L"WSAEINVALIDPROVIDER. The requested service provider is invalid.";
	case WSAEPROVIDERFAILEDINIT: return L"WSAEPROVIDERFAILEDINIT. The requested service provider could not be loaded or initialized.";
	case WSASYSCALLFAILURE: return L"WSASYSCALLFAILURE. A system call has failed.";
	case WSASERVICE_NOT_FOUND: return L"WSASERVICE_NOT_FOUND. No such service is known.The service cannot be found in the specified name space.";
	case WSATYPE_NOT_FOUND: return L"WSATYPE_NOT_FOUND. The specified class was not found.";
	case WSA_E_NO_MORE: return L"WSA_E_NO_MORE. No more results can be returned by WSALookupServiceNext.";
	case WSA_E_CANCELLED: return L"WSA_E_CANCELLED. A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.";
	case WSAEREFUSED: return L"WSAEREFUSED. A database query failed because it was actively refused.";
	case WSAHOST_NOT_FOUND: return L"WSAHOST_NOT_FOUND. No such host is known.";
	case WSATRY_AGAIN: return L"WSATRY_AGAIN. This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.";
	case WSANO_RECOVERY: return L"WSANO_RECOVERY. A non-recoverable error occurred during a database lookup.";
	case WSANO_DATA: return L"WSANO_DATA. The requested name is valid, but no data of the requested type was found.";
	case WSA_QOS_RECEIVERS: return L"WSA_QOS_RECEIVERS. At least one reserve has arrived.";
	case WSA_QOS_SENDERS: return L"WSA_QOS_SENDERS. At least one path has arrived.";
	case WSA_QOS_NO_SENDERS: return L"WSA_QOS_NO_SENDERS. There are no senders.";
	case WSA_QOS_NO_RECEIVERS: return L"WSA_QOS_NO_RECEIVERS. There are no receivers.";
	case WSA_QOS_REQUEST_CONFIRMED: return L"WSA_QOS_REQUEST_CONFIRMED. Reserve has been confirmed.";
	case WSA_QOS_ADMISSION_FAILURE: return L"Error due to lack of resources.";
	case WSA_QOS_POLICY_FAILURE: return L"WSA_QOS_POLICY_FAILURE. Rejected for administrative reasons - bad credentials.";
	case WSA_QOS_BAD_STYLE: return L"WSA_QOS_BAD_STYLE. Unknown or conflicting style.";
	case WSA_QOS_BAD_OBJECT: return L"WSA_QOS_BAD_OBJECT. Problem with some part of the filterspec or providerspecific buffer in general.";
	case WSA_QOS_TRAFFIC_CTRL_ERROR: return L"WSA_QOS_TRAFFIC_CTRL_ERROR. Problem with some part of the flowspec.";
	case WSA_QOS_GENERIC_ERROR: return L"WSA_QOS_GENERIC_ERROR. General QOS error.";
	case WSA_QOS_ESERVICETYPE: return L"WSA_QOS_ESERVICETYPE. An invalid or unrecognized service type was found in the flowspec.";
	case WSA_QOS_EFLOWSPEC: return L"WSA_QOS_EFLOWSPEC. An invalid or inconsistent flowspec was found in the QOS structure.";
	case WSA_QOS_EPROVSPECBUF: return L"WSA_QOS_EPROVSPECBUF. Invalid QOS provider-specific buffer.";
	case WSA_QOS_EFILTERSTYLE: return L"WSA_QOS_EFILTERSTYLE. An invalid QOS filter style was used.";
	case WSA_QOS_EFILTERTYPE: return L"WSA_QOS_EFILTERTYPE. An invalid QOS filter type was used.";
	case WSA_QOS_EFILTERCOUNT: return L"WSA_QOS_EFILTERCOUNT. An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR.";
	case WSA_QOS_EOBJLENGTH: return L"WSA_QOS_EOBJLENGTH. An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer.";
	case WSA_QOS_EFLOWCOUNT: return L"WSA_QOS_EFLOWCOUNT. An incorrect number of flow descriptors was specified in the QOS structure.";
	case WSA_QOS_EUNKOWNPSOBJ: return L"WSA_QOS_EUNKOWNPSOBJ. An unrecognized object was found in the QOS provider-specific buffer.";
	case WSA_QOS_EPOLICYOBJ: return L"WSA_QOS_EPOLICYOBJ. An invalid policy object was found in the QOS provider-specific buffer.";
	case WSA_QOS_EFLOWDESC: return L"WSA_QOS_EFLOWDESC. An invalid QOS flow descriptor was found in the flow descriptor list.";
	case WSA_QOS_EPSFLOWSPEC: return L"WSA_QOS_EPSFLOWSPEC. An invalid or inconsistent flowspec was found in the QOS provider specific buffer.";
	case WSA_QOS_EPSFILTERSPEC: return L"WSA_QOS_EPSFILTERSPEC. An invalid FILTERSPEC was found in the QOS provider-specific buffer.";
	case WSA_QOS_ESDMODEOBJ: return L"WSA_QOS_ESDMODEOBJ. An invalid shape discard mode object was found in the QOS provider specific buffer.";
	case WSA_QOS_ESHAPERATEOBJ: return L"WSA_QOS_ESHAPERATEOBJ. An invalid shaping rate object was found in the QOS provider-specific buffer.";
	case WSA_QOS_RESERVED_PETYPE: return L"WSA_QOS_RESERVED_PETYPE. A reserved policy element was found in the QOS provider-specific buffer.";
	case WSA_SECURE_HOST_NOT_FOUND: return L"WSA_SECURE_HOST_NOT_FOUND. No such host is known securely.";
	case WSA_IPSEC_NAME_POLICY_ERROR: return L"WSA_IPSEC_NAME_POLICY_ERROR. Name based IPSEC policy could not be added.";
	//
	//case 10004: return L"Interrupted function call. This error is returned when a socket is closed or a process is terminated, on a pending Winsock operation for that socket.";
	//case 10013: return L"Permission denied. An attempt was made to access a socket in a way forbidden by its access permissions.";
	//case 10014: return L"Bad address. The system detected an invalid pointer address in attempting to use a pointer argument of a call. This error occurs if an application passes an invalid pointer value, or if the length of the buffer is too small. For instance, if the length of an argument, which is a sockaddr structure, is smaller than the sizeof(SOCKADDR).";
	//case 10022: return L"Invalid argument. Some invalid argument was supplied (for example, specifying an invalid level to the setsockopt (Windows Sockets) function). In some instances, it also refers to the current state of the socket  for instance, calling accept (Windows Sockets) on a socket that is not listening. ";
	//case 10024: return L"Invalid argument. Some invalid argument was supplied (for example, specifying an invalid level to the setsockopt (Windows Sockets) function). In some instances, it also refers to the current state of the socket  for instance, calling accept (Windows Sockets) on a socket that is not listening. ";
	//case 10035: return L"Resource temporarily unavailable. This error is returned from operations on nonblocking sockets that cannot be completed immediately, for example recv when no data is queued to be read from the socket. It is a nonfatal error, and the operation should be retried later. It is normal for WSAEWOULDBLOCK to be reported as the result from calling connect (Windows Sockets) on a nonblocking SOCK_STREAM socket, since some time must elapse for the connection to be established. ";
	//case 10036: return L"Operation now in progress. A blocking operation is currently executing. Windows Sockets only allows a single blocking operation  per task or thread  to be outstanding, and if any other function call is made (whether or not it references that or any other socket) the function fails with the WSAEINPROGRESS error. ";
	//case 10037: return L"Operation already in progress. An operation was attempted on a nonblocking socket with an operation already in progress  that is, calling connect a second time on a nonblocking socket that is already connecting, or canceling an asynchronous request (WSAAsyncGetXbyY) that has already been canceled or completed. ";
	//case 10038: return L"Socket operation on nonsocket. An operation was attempted on something that is not a socket. Either the socket handle parameter did not reference a valid socket, or for the select function, a member of an fd_set structure was not valid. ";
	//case 10039: return L"Destination address required. A required address was omitted from an operation on a socket. For example, this error is returned if sendto is called with the remote address of ADDR_ANY. ";
	//case 10040: return L"Message too long. A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram was smaller than the datagram itself. ";
	//case 10041: return L"Protocol wrong type for socket. A protocol was specified in the socket function call that does not support the semantics of the socket type requested. For example, the ARPA Internet UDP protocol cannot be specified with a socket type of SOCK_STREAM. ";
	//case 10042: return L"Bad protocol option. An unknown, invalid or unsupported option or level was specified in a getsockopt (Windows Sockets) or setsockopt (Windows Sockets) call. ";
	//case 10043: return L"Protocol not supported. The requested protocol has not been configured into the system, or no implementation for it exists. For example, a socket call requests a SOCK_DGRAM socket, but specifies a stream protocol. ";
	//case 10044: return L"Socket type not supported. The support for the specified socket type does not exist in this address family. For example, the optional type SOCK_RAW might be selected in a socket call, and the implementation does not support SOCK_RAW sockets at all. Also, this error code maybe returned for SOCK_RAW if the caller application is not trusted.";
	//case 10045: return L"Operation not supported. The attempted operation is not supported for the type of object referenced. Usually this occurs when a socket descriptor to a socket that cannot support this operation is trying to accept a connection on a datagram socket. ";
	//case 10046: return L"Protocol family not supported. The protocol family has not been configured into the system or no implementation for it exists. This message has a slightly different meaning from WSAEAFNOSUPPORT. However, it is interchangeable in most cases, and all Windows Sockets functions that return one of these messages also specify WSAEAFNOSUPPORT. ";
	//case 10047: return L"Address family not supported by protocol family. An address incompatible with the requested protocol was used. All sockets are created with an associated address family (that is, AF_INET for Internet protocols) and a generic protocol type (that is, SOCK_STREAM). This error is returned if an incorrect protocol is explicitly requested in the socket call, or if an address of the wrong family is used for a socket, for example, in sendto. ";
	//case 10048: return L"Address already in use. Typically, only one usage of each socket address (protocol/IP address/port) is permitted. This error occurs if an application attempts to bind a socket to an IP address/port that has already been used for an existing socket, or a socket that was not closed properly, or one that is still in the process of closing. For server applications that need to bind multiple sockets to the same port number, consider using setsockopt (Windows Sockets)(SO_REUSEADDR). Client applications usually need not call bind at all  connect chooses an unused port automatically. When bind is called with a wildcard address (involving ADDR_ANY), a WSAEADDRINUSE error could be delayed until the specific address is committed. This could happen with a call to another function later, including connect, listen, WSAConnect, or WSAJoinLeaf. ";
	//case 10049: return L"Cannot assign requested address. The requested address is not valid in its context. This normally results from an attempt to bind to an address that is not valid for the local machine. This can also result from connect (Windows Sockets), sendto, WSAConnect, WSAJoinLeaf, or WSASendTo when the remote address or port is not valid for a remote machine (for example, address or port 0). ";
	//case 10050: return L"Network is down. A socket operation encountered a dead network. This could indicate a serious failure of the network system (that is, the protocol stack that the Windows Sockets DLL runs over), the network interface, or the local network itself. ";
	//case 10051: return L"Network is unreachable. A socket operation was attempted to an unreachable network. This usually means the local software knows no route to reach the remote host.";
	//case 10052: return L"Network dropped connection on reset. The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress. It can also be returned by setsockopt (Windows Sockets) if an attempt is made to set SO_KEEPALIVE on a connection that has already failed. ";
	//case 10053: return L"Software caused connection abort. An established connection was aborted by the software in your host machine, possibly due to a data transmission time-out or protocol error. ";
	//case 10054: return L"Connection reset by peer. An existing connection was forcibly closed by the remote host. This normally results if the peer application on the remote host is suddenly stopped, the host is rebooted, or the remote host uses a hard close (see setsockopt (Windows Sockets) for more information on the SO_LINGER option on the remote socket.) This error may also result if a connection was broken due to keep-alive activity detecting a failure while one or more operations are in progress. Operations that were in progress fail with WSAENETRESET. Subsequent operations fail with WSAECONNRESET. ";
	//case 10055: return L"No buffer space available. An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.";
	//case 10056: return L"Socket is already connected. A connect request was made on an already-connected socket. Some implementations also return this error if sendto is called on a connected SOCK_DGRAM socket (for SOCK_STREAM sockets, the to parameter in sendto is ignored) although other implementations treat this as a legal occurrence. ";
	//case 10057: return L"Socket is not connected. A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using sendto) no address was supplied. Any other type of operation might also return this error  for example, setsockopt (Windows Sockets) setting SO_KEEPALIVE if the connection has been reset.";
	//case 10058: return L"Cannot send after socket shutdown. A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call. By calling shutdown a partial close of a socket is requested, which is a signal that sending or receiving, or both have been discontinued. ";
	//case 10060: return L"Connection timed out. A connection attempt failed because the connected party did not properly respond after a period of time, or the established connection failed because the connected host has failed to respond. ";
	//case 10061: return L"Connection refused. No connection could be made because the target machine actively refused it. This usually results from trying to connect to a service that is inactive on the foreign host  that is, one with no server application running. ";
	//case 10064: return L"Host is down. A socket operation failed because the destination host is down. A socket operation encountered a dead host. Networking activity on the local host has not been initiated. These conditions are more likely to be indicated by the error WSAETIMEDOUT. ";
	//case 10065: return L"No route to host. A socket operation was attempted to an unreachable host. See WSAENETUNREACH.";
	//case 10067: return L"Too many processes. A Windows Sockets implementation may have a limit on the number of applications that can use it simultaneously. WSAStartup may fail with this error if the limit has been reached. ";
	//case 10091: return L"Network subsystem is unavailable. This error is returned by WSAStartup if the Windows Sockets implementation cannot function at because the underlying system it uses to provide network services is currently unavailable. Users should check: That the appropriate Windows Sockets DLL file is in the current path. That they are not trying to use more than one Windows Sockets implementation simultaneously. If there is more than one Winsock DLL on your system, be sure the first one in the path is appropriate for the network subsystem currently loaded. The Windows Sockets implementation documentation to be sure all necessary components are currently installed and configured correctly.";
	//case 10092: return L"Winsock.dll version out of range. The current Windows Sockets implementation does not support the Windows Sockets specification version requested by the application. Check that no old Windows Sockets DLL files are being accessed. ";
	//case 10093: return L"Successful WSAStartup not yet performed. Either the application has not called WSAStartup or WSAStartup failed. The application may be accessing a socket that the current active task does not own (that is, trying to share a socket between tasks), or WSACleanup has been called too many times. ";
	//case 10101: return L"Graceful shutdown in progress. Returned by WSARecv and WSARecvFrom to indicate that the remote party has initiated a graceful shutdown sequence. ";
	//case 10109: return L"Class type not found. The specified class was not found. ";
	//case 11001: return L"Host not found. No such host is known. The name is not an official host name or alias, or it cannot be found in the database(s) being queried. This error may also be returned for protocol and service queries, and means that the specified name could not be found in the relevant database. ";
	//case 11002: return L"Nonauthoritative host not found. This is usually a temporary error during host name resolution and means that the local server did not receive a response from an authoritative server. A retry at some time later may be successful. ";
	//case 11003: return L"This is a nonrecoverable error. This indicates some sort of nonrecoverable error occurred during a database lookup. This may be because the database files (for example, BSD-compatible HOSTS, SERVICES, or PROTOCOLS files) could not be found, or a DNS request was returned by the server with a severe error. ";
	//case 11004: return L"Valid name, no data record of requested type. The requested name is valid and was found in the database, but it does not have the correct associated data being resolved for. ";
	}
	return L"No error information is available";
}

Socket::operator SOCKET() 
{
	return hsocket;
}

wchar_t* Socket::ConnectAsync(HWND hWnd, const wchar_t* serverName, unsigned short port)
{
	if (serverName == NULL) return L"Socket::ConnectAsync: server name is NULL";
	char *ipAddress = this->GetIpAddressByName(serverName);
	if (ipAddress == NULL) return L"Socket::ConnectAsync: IP address is NULL";
	wstring ip_address;
	Sys::Convert::StringToWstring(ipAddress, ip_address);

	return ConnectAsync(hWnd, port, ip_address.c_str());
}

// hWnd will receive a WM_SOCKETNOTIFY message when completion of the call
wchar_t* Socket::ConnectAsyncServer(HWND hWnd, unsigned short port, int numbClients)
{
	Disconnect();
	//__________________________________________ socket
	hsocket = (SOCKET)socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectAsyncServer: unable to create socket";

	//__________________________________________ bind
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_addr.s_addr  = INADDR_ANY;
	sa.sin_port = htons(port);
	if (::bind(hsocket, (PSOCKADDR)&sa, sizeof(SOCKADDR_IN))) return L"Socket::ConnectAsyncServer > Could not bind socket";


	//__________________________________________ listen
	if (::listen(hsocket, numbClients)) return L"Socket::ConnectAsyncServer: socket cannot listen";

	//__________________________________________ AsyncSelect
	int nError = WSAAsyncSelect (hsocket, hWnd, WM_SOCKETNOTIFY,
		FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE | FD_ACCEPT);
	if (nError ==SOCKET_ERROR) return L"Socket::ConnectAsyncServer: call to WSAAsyncSelect was not successful";

	//__________________________________________________________ accept
	//m_sockTmp = ::accept(hsocket, NULL, 0); // This will block
	::accept(hsocket, NULL, 0);
	if (WSAEWOULDBLOCK!=(nError=WSAGetLastError())) return L"Socket::ConnectAsyncServer: socket could not accept connection";

	//m_bConnected = true;  //We should wait for the Windows Message to set this flag
	return NULL;
}

// After calling this function, you must call Accept
// Accept will block until a new request is received
// Accept will return a new sockect that can be used to handle the request
// You may optionally Close the socket when it is not needed
wchar_t* Socket::StartServer(unsigned short port, int numbClients)
{
	Disconnect();
	//__________________________________________ socket
	//hsocket = (SOCKET)socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	hsocket = (SOCKET)socket(AF_INET, SOCK_STREAM, 0);
	//hsocket = (SOCKET)socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectSyncServer: unable to create socket";

	//__________________________________________ bind
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_addr.s_addr  = INADDR_ANY;
	sa.sin_port = htons(port);
	if (::bind(hsocket, (PSOCKADDR)&sa, sizeof(SOCKADDR_IN))) return L"Socket::ConnectSyncServer > Could not bind socket";
	//__________________________________________ listen
	if (::listen(hsocket, numbClients)) return L"Socket::ConnectSyncServer: socket cannot listen";
	return NULL;
}

// hWnd will receive a WM_SOCKETNOTIFY message when completion of the call
wchar_t* Socket::ConnectAsyncClient(HWND hWnd, unsigned short port, const wchar_t* ipAddress)
{
	Disconnect();
	//_________________________________________________________  socket
	hsocket = (SOCKET)socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectAsyncClient: unable to create socket";

	//________________________________________________________ AsyncSelect
	int nError = WSAAsyncSelect (hsocket, hWnd, WM_SOCKETNOTIFY,
		FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);
	if (nError ==SOCKET_ERROR) return L"Socket::ConnectAsyncClient : call to WSAAsyncSelect was not successful";

	//_______________________________________________________ Async connect
	string ip_address;
	Sys::Convert::WstringToString(ipAddress, ip_address);
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.S_un.S_addr = inet_addr(ip_address.c_str());
	connect(hsocket, (SOCKADDR*)&sa, sizeof(SOCKADDR_IN));
	if (WSAEWOULDBLOCK!=(nError=WSAGetLastError())) return L"Socket::ConnectAsyncServer: unable to connect asynchronously";

	//m_bConnected = true;  //We should wait for the Windows Message to set this flag
	return NULL;
}

// hWnd will receive a nMssg message when completion of the call
wchar_t* Socket::ConnectAsync(HWND hWnd, unsigned short port, const wchar_t* ipAddress)
{
	Disconnect();
	//______________________________________________ socket
	hsocket = (SOCKET)::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (hsocket == INVALID_SOCKET) return L"Socket::ConnectAsync: unable to create socket";

	//_____________________________________________AsyncSelect
	int nError = WSAAsyncSelect (hsocket, hWnd, WM_SOCKETNOTIFY,
		FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);
	if (nError ==SOCKET_ERROR) return L"Socket::ConnectAsync:: call to WSAAsyncSelect was not successful";

	//_____________________________________________ Async connect
	string ip_address;
	Sys::Convert::WstringToString(ipAddress, ip_address);
	SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.S_un.S_addr = inet_addr(ip_address.c_str());
	::connect(hsocket, (SOCKADDR*)&sa, sizeof(SOCKADDR_IN));
	if (WSAEWOULDBLOCK!=(nError=WSAGetLastError())) return L"Socket::ConnectAsync: unable to connect asynchronously";
	//m_bConnected = true;  //We should wait for the Windows Message to set this flag
	return NULL;
}

//LRESULT Socket::OnSocketNotify(HWND hWnd, WPARAM wParam, LPARAM lParam)
//{
//	WORD wEvent = WSAGETSELECTEVENT(lParam); // LOWORD
//	WORD wError = WSAGETSELECTERROR(lParam); // HIWORD
//
//	if (wError)
//	{
//		OnError(wEvent, wError, L"SocketAsync::OnSocketNotify error during processing:", 
//			Sys::SocketAsync::GetFdText(wEvent));
//		this->Close();
//		return FALSE;
//	}
//
//	switch(wEvent)
//	{
//	case FD_ACCEPT: 
//{
//	SOCKET sockTmp = (SOCKET)::accept(m_socket, NULL, 0);
//	closesocket(m_socket);
//	m_socket = sockTmp;
//	return TRUE;
//}
//		return OnFdAccept();
//	case FD_CONNECT: 
//		m_bConnected = true;
//		return OnFdConnect();
//	case FD_READ: 
//		return OnFdRead();
//	case FD_WRITE: 
//		return OnFdWrite();
//	case FD_CLOSE: 
//		m_bConnected = false;
//		m_socket = INVALID_SOCKET;
//		return OnFdClose();
//	}
//	return FALSE;
//}

// SOCKET_SECURITY_SETTINGS sss;
//sss.SecurityProtocol = SOCKET_SECURITY_PROTOCOL_DEFAULT;
//sss.SecurityFlags = SOCKET_SETTINGS_GUARANTEE_ENCRYPTION;
//int Socket::SecureTcpConnect(IN const struct sockaddr *serverAddr,
//                 IN ULONG serverAddrLen,
//                 IN const wchar_t * serverSPN,
//                 IN const SOCKET_SECURITY_SETTINGS * securitySettings,
//                 IN ULONG settingsLen)
///**
//Routine Description:
//
//    This routine creates a TCP client socket, securely connects to the 
//    specified server, sends & receives data from the server, and then closes 
//    the socket
//
//Arguments:
//
//    serverAddr - a pointer to the sockaddr structure for the server.
//
//    serverAddrLen - length of serverAddr in bytes
//
//    serverSPN - a NULL-terminated string representing the SPN 
//               (service principal name) of the server host computer
//
//    securitySettings - pointer to the socket security settings that should be
//                       applied to the connection
//
//    serverAddrLen - length of securitySettings in bytes
//
//Return Value:
//
//    Winsock error code indicating the status of the operation, or NO_ERROR if 
//    the operation succeeded.
//
//--*/
//{
//    int iResult = 0;
//    int sockErr = 0;
//    SOCKET sock = INVALID_SOCKET;
//
//    WSABUF wsaBuf = { 0 };
//    char *dataBuf = "12345678";
//    DWORD bytesSent = 0;
//    char recvBuf[RECV_DATA_BUF_SIZE] = { 0 };
//
//    DWORD bytesRecvd = 0;
//    DWORD flags = 0;
//    SOCKET_PEER_TARGET_NAME *peerTargetName = NULL;
//    DWORD serverSpnStringLen = (DWORD) wcslen(serverSPN);
//    DWORD peerTargetNameLen = sizeof (SOCKET_PEER_TARGET_NAME) +
//        (serverSpnStringLen * sizeof (wchar_t));
//
//    //-----------------------------------------
//    // Create a TCP socket
//    sock = WSASocket(serverAddr->sa_family,
//                     SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
//    if (sock == INVALID_SOCKET) {
//        iResult = WSAGetLastError();
//        wprintf(L"WSASocket returned error %ld\n", iResult);
//        goto cleanup;
//    }
//    //-----------------------------------------
//    // Turn on security for the socket.
//    sockErr = WSASetSocketSecurity(sock,
//                                   securitySettings, settingsLen, NULL, NULL);
//    if (sockErr == SOCKET_ERROR) {
//        iResult = WSAGetLastError();
//        wprintf(L"WSASetSocketSecurity returned error %ld\n", iResult);
//        goto cleanup;
//    }
//    //-----------------------------------------
//    // Specify the server SPN
//    peerTargetName = (SOCKET_PEER_TARGET_NAME *) HeapAlloc(GetProcessHeap(),
//                               HEAP_ZERO_MEMORY, peerTargetNameLen);
//    if (!peerTargetName) {
//        iResult = ERROR_NOT_ENOUGH_MEMORY;
//        wprintf(L"Out of memory\n");
//        goto cleanup;
//    }
//    // Use the security protocol as specified by the settings
//    peerTargetName->SecurityProtocol = securitySettings->SecurityProtocol;
//    // Specify the server SPN: This target name is meant to be specified by client applications to securely identify the peer that should be authenticated.
//    peerTargetName->PeerTargetNameStringLen = serverSpnStringLen;
//    RtlCopyMemory((BYTE *) peerTargetName->AllStrings,
//                  (BYTE *) serverSPN, serverSpnStringLen * sizeof (wchar_t)
//        );
//
//    sockErr = WSASetSocketPeerTargetName(sock,
//                                         peerTargetName,
//                                         peerTargetNameLen, NULL, NULL);
//    if (sockErr == SOCKET_ERROR) {
//        iResult = WSAGetLastError();
//        wprintf(L"WSASetSocketPeerTargetName returned error %ld\n", iResult);
//        goto cleanup;
//    }
//    //-----------------------------------------
//    // Connect to the server
//    sockErr = WSAConnect(sock,
//                         serverAddr, serverAddrLen, NULL, NULL, NULL, NULL);
//    if (sockErr == SOCKET_ERROR) {
//        iResult = WSAGetLastError();
//        wprintf(L"WSAConnect returned error %ld\n", iResult);
//        goto cleanup;
//    }
//    // At this point a secure connection must have been established.
//    wprintf(L"Secure connection established to the server\n");
//
//    //-----------------------------------------
//    // Send some data securely
//    wsaBuf.len = (ULONG) strlen(dataBuf);
//    wsaBuf.buf = dataBuf;
//    sockErr = WSASend(sock, &wsaBuf, 1, &bytesSent, 0, NULL, NULL);
//    if (sockErr == SOCKET_ERROR) {
//        iResult = WSAGetLastError();
//        wprintf(L"WSASend returned error %ld\n", iResult);
//        goto cleanup;
//    }
//    wprintf(L"Sent %d bytes of data to the server\n", bytesSent);
//
//    //-----------------------------------------
//    // Receive server's response securely
//    wsaBuf.len = RECV_DATA_BUF_SIZE;
//    wsaBuf.buf = recvBuf;
//    sockErr = WSARecv(sock, &wsaBuf, 1, &bytesRecvd, &flags, NULL, NULL);
//    if (sockErr == SOCKET_ERROR) {
//        iResult = WSAGetLastError();
//        wprintf(L"WSARecv returned error %ld\n", iResult);
//        goto cleanup;
//    }
//    wprintf(L"Received %d bytes of data from the server\n", bytesRecvd);
//
//  cleanup:
//    if (sock != INVALID_SOCKET) {
//        //This will trigger the cleanup of all IPsec filters and policies that
//        //were added for this socket. The cleanup will happen only after all
//        //outstanding data has been sent out on the wire.
//        closesocket(sock);
//    }
//    if (peerTargetName) {
//        HeapFree(GetProcessHeap(), 0, peerTargetName);
//    }
//    return iResult;
//}


#endif


//_____________________________________________________________________ Sys::Brushes
HBRUSH Brushes::WhiteBrush() 
{
	return (HBRUSH)::GetStockObject(WHITE_BRUSH);
}

HBRUSH Brushes::DkGrayBrush() 
{
	return (HBRUSH)::GetStockObject(DKGRAY_BRUSH);
}

HBRUSH Brushes::HollowBrush() 
{
	return (HBRUSH)::GetStockObject(HOLLOW_BRUSH);
}

HBRUSH Brushes::LtGrayBrush() 
{
	return (HBRUSH)::GetStockObject(LTGRAY_BRUSH);
}

HBRUSH Brushes::GrayBrush() 
{
	return (HBRUSH)::GetStockObject(GRAY_BRUSH);
}

HBRUSH Brushes::BlackBrush() 
{
	return (HBRUSH)::GetStockObject(BLACK_BRUSH);
}

HBRUSH Brushes::NullBrush() 
{
	return (HBRUSH)::GetStockObject(NULL_BRUSH);
}

//_____________________________________________________________________ Sys::Colors
COLORREF Colors::WindowColor() 
{
	return ::GetSysColor(COLOR_WINDOW);
}

COLORREF Colors::ActiveBorderColor() 
{
	return ::GetSysColor(COLOR_ACTIVEBORDER);
}

COLORREF Colors::ActiveCaptionColor() 
{
	return ::GetSysColor(COLOR_ACTIVECAPTION);
}

COLORREF Colors::AppWorkspaceColor() 
{
	return ::GetSysColor(COLOR_APPWORKSPACE);
}

COLORREF Colors::BackgroundColor() 
{
	return ::GetSysColor(COLOR_BACKGROUND);
}

COLORREF Colors::BtnFaceColor() 
{
	return ::GetSysColor(COLOR_BTNFACE);
}

COLORREF Colors::BtnShadowColor() 
{
	return ::GetSysColor(COLOR_BTNSHADOW);
}

COLORREF Colors::BtnTextColor() 
{
	return ::GetSysColor(COLOR_BTNTEXT);
}

COLORREF Colors::BtnHighLightColor() 
{
	return ::GetSysColor(COLOR_BTNHIGHLIGHT);
}

COLORREF Colors::ThreeDDkShadowColor() 
{
	return ::GetSysColor(COLOR_3DDKSHADOW);
}

COLORREF Colors::ThreeDLightColor() 
{
	return ::GetSysColor(COLOR_3DLIGHT);
}

COLORREF Colors::InfoTextColor() 
{
	return ::GetSysColor(COLOR_INFOTEXT);
}

COLORREF Colors::InfoBkColor() 
{
	return ::GetSysColor(COLOR_INFOBK);
}

COLORREF Colors::CaptionTextColor() 
{
	return ::GetSysColor(COLOR_CAPTIONTEXT);
}

COLORREF Colors::InactiveCaptionTextColor() 
{
	return ::GetSysColor(COLOR_INACTIVECAPTIONTEXT);
}

COLORREF Colors::GrayTextColor() 
{
	return ::GetSysColor(COLOR_GRAYTEXT);
}

COLORREF Colors::HighLightColor() 
{
	return ::GetSysColor(COLOR_HIGHLIGHT);
}

COLORREF Colors::HighLightTextColor() 
{
	return ::GetSysColor(COLOR_HIGHLIGHTTEXT);
}

COLORREF Colors::InactiveBorderColor() 
{
	return ::GetSysColor(COLOR_INACTIVEBORDER);
}

COLORREF Colors::InactiveCaptionColor() 
{
	return ::GetSysColor(COLOR_INACTIVECAPTION);
}

COLORREF Colors::MenuColor() 
{
	return ::GetSysColor(COLOR_MENU);
}

COLORREF Colors::MenuTextColor() 
{
	return ::GetSysColor(COLOR_MENUTEXT);
}

COLORREF Colors::ScrollbarColor() 
{
	return ::GetSysColor(COLOR_SCROLLBAR);
}

COLORREF Colors::WindowFrameColor() 
{
	return ::GetSysColor(COLOR_WINDOWFRAME);
}

COLORREF Colors::WindowTextColor() 
{
	return ::GetSysColor(COLOR_WINDOWTEXT);
}

COLORREF Colors::HotLightColor() 
{
	return ::GetSysColor(COLOR_HOTLIGHT);
}

COLORREF Colors::GradientActiveCatpionColor() 
{
	return ::GetSysColor(COLOR_GRADIENTACTIVECAPTION);
}

COLORREF Colors::GradientInactiveCaptionColor() 
{
	return ::GetSysColor(COLOR_GRADIENTINACTIVECAPTION);
}

//_____________________________________________________________________ Sys::Metrics
int Metrics::GetMinimizedWindowType()
{
	return ::GetSystemMetrics(SM_ARRANGE);
}

int Metrics::GetSystemStartedType()//0 Normal boot,1 Fail-safe boot, 2 Fail-safe with network boot
{
	return ::GetSystemMetrics(SM_CLEANBOOT);
}

int Metrics::GetMonitorCount()
{
	return ::GetSystemMetrics(SM_CMONITORS);
}

int Metrics::GetMouseButtonsCount()
{
	return ::GetSystemMetrics(SM_CMOUSEBUTTONS);
}

int Metrics::GetWindowBorderWidth()
{
	return ::GetSystemMetrics(SM_CXBORDER);
}

int Metrics::GetWindow3DBorderWidth()
{
	return ::GetSystemMetrics(SM_CXEDGE);
}

int Metrics::GetCursorWidth()
{
	return ::GetSystemMetrics(SM_CXCURSOR);
}

int Metrics::GetDoubleClickWidth()
{
	return ::GetSystemMetrics(SM_CXDOUBLECLK);
}

int Metrics::GetDragWidth()
{
	return ::GetSystemMetrics(SM_CXDRAG);
}

int Metrics::GetFixedFrameThickness()
{
	return ::GetSystemMetrics(SM_CXFIXEDFRAME);
}

int Metrics::GetFocusBorderWidth()
{
	return ::GetSystemMetrics(SM_CXFOCUSBORDER);
}

int Metrics::GetFullScreenWidth()
{
	return ::GetSystemMetrics(SM_CXFULLSCREEN);
}

int Metrics::GetScreenWidth()
{
	return ::GetSystemMetrics(SM_CXSCREEN);
}

int Metrics::GetHScrollWidth()
{
	return ::GetSystemMetrics(SM_CXHSCROLL);
}

int Metrics::GetHScrollThumbWidth()
{
	return ::GetSystemMetrics(SM_CXHTHUMB);
}

int Metrics::GetIconWidth()
{
	return ::GetSystemMetrics(SM_CXICON);
}

int Metrics::GetIconSpacingWidth()
{
	return ::GetSystemMetrics(SM_CXICONSPACING);
}

int Metrics::GetMaximinizedWindowWidth()
{
	return ::GetSystemMetrics(SM_CXMAXIMIZED);
}

int Metrics::GetMaxTrackWidth()
{
	return ::GetSystemMetrics(SM_CXMAXTRACK);
}

int Metrics::GetMenuCheckWidth()
{
	return ::GetSystemMetrics(SM_CXMENUCHECK);
}

int Metrics::GetMenuWidth()
{
	return ::GetSystemMetrics(SM_CXMENUSIZE);
}

int Metrics::GetMinWindowWidth()
{
	return ::GetSystemMetrics(SM_CXMIN);
}

int Metrics::GetMinimizedWindowWidth()
{
	return ::GetSystemMetrics(SM_CXMINIMIZED);
}

int Metrics::GetMinSpacingWidth()
{
	return ::GetSystemMetrics(SM_CXMINSPACING);
}

int Metrics::GetMinTrackWidth()
{
	return ::GetSystemMetrics(SM_CXMINTRACK);
}

//int Metrics::GetPaddedBorderWidth(){return ::GetSystemMetrics(SM_CXPADDEDBORDER);}
int Metrics::GetTitleBarButtonWidth()
{
	return ::GetSystemMetrics(SM_CXSIZE);
}

int Metrics::GetSizeFrameWidth()
{
	return ::GetSystemMetrics(SM_CXSIZEFRAME);
}

int Metrics::GetSmallIconWidth()
{
	return ::GetSystemMetrics(SM_CXSMICON);
}

int Metrics::GetSmallCaptionButtonWidth()
{
	return ::GetSystemMetrics(SM_CXSMSIZE);
}

int Metrics::GetVirtualScreenWidth()
{
	return ::GetSystemMetrics(SM_CXVIRTUALSCREEN);
}

int Metrics::GetVScrollWidth()
{
	return ::GetSystemMetrics(SM_CXVSCROLL);
}

int Metrics::GetWindowBorderHeight()
{
	return ::GetSystemMetrics(SM_CYBORDER);
}

int Metrics::GetWindow3DBorderHeight()
{
	return ::GetSystemMetrics(SM_CYEDGE);
}

int Metrics::GetCaptionHeight()
{
	return ::GetSystemMetrics(SM_CYCAPTION);
}

int Metrics::GetCursorHeight()
{
	return ::GetSystemMetrics(SM_CYCURSOR);
}

int Metrics::GetDlgFrameHeight()
{
	return ::GetSystemMetrics(SM_CYDLGFRAME);
}

int Metrics::GetDoubleClickHeight()
{
	return ::GetSystemMetrics(SM_CYDOUBLECLK);
}

int Metrics::GetDragHeight()
{
	return ::GetSystemMetrics(SM_CYDRAG);
}

int Metrics::GetFixedFrameHeight()
{
	return ::GetSystemMetrics(SM_CYFIXEDFRAME);
}

int Metrics::GetFocusBorderHeight()
{
	return ::GetSystemMetrics(SM_CYFOCUSBORDER);
}

int Metrics::GetFullScreenHeight()
{
	return ::GetSystemMetrics(SM_CYFULLSCREEN);
}

int Metrics::GetHScrollHeight()
{
	return ::GetSystemMetrics(SM_CYHSCROLL);
}

int Metrics::GetIconHeight()
{
	return ::GetSystemMetrics(SM_CYICON);
}

int Metrics::GetIconSpacingHeight()
{
	return ::GetSystemMetrics(SM_CYICONSPACING);
}

int Metrics::GetKanjiWindowHeight()
{
	return ::GetSystemMetrics(SM_CYKANJIWINDOW);
}

int Metrics::GetMaximinzedWindowHeight()
{
	return ::GetSystemMetrics(SM_CYMAXIMIZED);
}

int Metrics::GetMaxTrackHeight()
{
	return ::GetSystemMetrics(SM_CYMAXTRACK);
}

int Metrics::GetMenuHeight()
{
	return ::GetSystemMetrics(SM_CYMENU);
}

int Metrics::GetMenuCheckHeight()
{
	return ::GetSystemMetrics(SM_CYMENUCHECK);
}

int Metrics::GetMenuSizeHeight()
{
	return ::GetSystemMetrics(SM_CYMENUSIZE);
}

int Metrics::GetMinWindowHeight()
{
	return ::GetSystemMetrics(SM_CYMIN);
}

int Metrics::GetMinimizedWindowHeight()
{
	return ::GetSystemMetrics(SM_CYMINIMIZED);
}

int Metrics::GetMinSpacingHeight()
{
	return ::GetSystemMetrics(SM_CYMINSPACING);
}

int Metrics::GetMinTrackHeight()
{
	return ::GetSystemMetrics(SM_CYMINTRACK);
}

int Metrics::GetScreenHeight()
{
	return ::GetSystemMetrics(SM_CYSCREEN);
}

int Metrics::GetTitleBarHeight()
{
	return ::GetSystemMetrics(SM_CYSIZE);
}

int Metrics::GetSizeFrameHeight()
{
	return ::GetSystemMetrics(SM_CYSIZEFRAME);
}

int Metrics::GetSmallCaptionHeight()
{
	return ::GetSystemMetrics(SM_CYSMCAPTION);
}

int Metrics::GetSmallIconHeight()
{
	return ::GetSystemMetrics(SM_CYSMICON);
}

int Metrics::GetSmallCaptionButtonHeight()
{
	return ::GetSystemMetrics(SM_CYSMSIZE);
}

int Metrics::GetVirtualScreenHeight()
{
	return ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
}

int Metrics::GetVScrollHeight()
{
	return ::GetSystemMetrics(SM_CYVSCROLL);
}

int Metrics::GetVScroolThumbHeight()
{
	return ::GetSystemMetrics(SM_CYVTHUMB);
}

bool Metrics::IsShuttingDown()
{
	return (::GetSystemMetrics(SM_SHUTTINGDOWN)!=0);
}

void Metrics::GetTextMetricsFromDisplay(TEXTMETRIC& result)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	HFONT font = (HFONT)::GetStockObject(SYSTEM_FONT);
	HFONT tmp  = (HFONT)::SelectObject(hdc, font);
	::GetTextMetrics(hdc, &result);
	::SelectObject(hdc, tmp);
	::DeleteDC(hdc);
}

bool Metrics::GetLanguage(wchar_t* buffer, int buffer_size)
{
	//wchar_t buffer[64];
	return (::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILANGUAGE, buffer, buffer_size) != 0);
}

 bool Metrics::IsLanguage(wchar_t char2,wchar_t char3)
 {
	 wchar_t buffer[64];
	 if(::GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_ILANGUAGE,buffer,64) == 0) return false;
	 const size_t len = wcslen(buffer);
	 if(len != 4) return false;
	 if(buffer[2] != char2) return false;
	 if(buffer[3] != char3) return false;
	 return true;
 }

bool Metrics::IsEnglishLanguage()
{
	return Sys::Metrics::IsLanguage('0', '9');
}

bool Metrics::IsFrenchLanguage()
{
	return Sys::Metrics::IsLanguage('0','c');
}

bool Metrics::IsGermanLanguage()
{
	return Sys::Metrics::IsLanguage('0', '7');
}

bool Metrics::IsSpanishLanguage()
{
	return Sys::Metrics::IsLanguage('0', 'a');
}

void Metrics::GetTextMetricsFromDisplay(const wchar_t* fontname, int fontsize, TEXTMETRIC& result)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	HFONT font = ::CreateFont(-abs(fontsize), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, fontname);
	HFONT tmp  = (HFONT)::SelectObject(hdc, font);
	::GetTextMetrics(hdc, &result);
	::SelectObject(hdc, tmp);
	::DeleteObject(font);
	::DeleteDC(hdc);
}

void Metrics::GetTextMetricsFromDisplay(const wstring& fontname, int fontsize, TEXTMETRIC& result)
{
	Sys::Metrics::GetTextMetricsFromDisplay(fontname.c_str(), fontsize, result);
}
//_____________________________________________________________________ Sys::BinarySearch

//_____________________________________________________________________ Sys::Array

//_____________________________________________________________________ Sys::Matrix

//_____________________________________________________________________ Sys::GlobalMemory
GlobalMemory::GlobalMemory()
{
	hGlobal = NULL;
	lockCount = 0;
	freeMemory = true;
}

GlobalMemory::GlobalMemory(HGLOBAL hGlobal)
{
	this->hGlobal = hGlobal;
	lockCount = 0;
	freeMemory = false;
}

GlobalMemory::~GlobalMemory()
{
	for(int i = 0; i < lockCount; i++)
	{
		::GlobalUnlock(hGlobal);
	}
	if (freeMemory)
	{
		if (hGlobal != NULL) ::GlobalFree(hGlobal);
	}
}

bool GlobalMemory::Allocate(UINT uFlags, SIZE_T dwBytes)
{
	if (hGlobal != NULL) ::GlobalFree(hGlobal);
	hGlobal = GlobalAlloc(uFlags, dwBytes);
	if (hGlobal == NULL) return false;
	lockCount = 0;
	freeMemory = true;
	return true;
}

bool GlobalMemory::ReAllocate(SIZE_T dwBytes, UINT uFlags)
{
	hGlobal = ::GlobalReAlloc(hGlobal, dwBytes, uFlags);
	if (hGlobal == NULL) return false;
	freeMemory = true;
	return true;
}

void GlobalMemory::FreeMemory()
{
	if (hGlobal != NULL) ::GlobalFree(hGlobal);
	hGlobal = NULL;
}

LPVOID GlobalMemory::Lock()
{
	lockCount++;
	return ::GlobalLock(hGlobal);
}

int GlobalMemory::Unlock()
{
	lockCount--;
	return ::GlobalUnlock(hGlobal);
}

void GlobalMemory::DoNotFree()
{
	freeMemory = false;
}

HGLOBAL GlobalMemory::GetHandle()
{
	return hGlobal;
}

bool GlobalMemory::IsValid()
{
	return (hGlobal != NULL);
}

//_____________________________________________________________________ Sys::Grid
Grid::Grid()
{
	point = NULL;
	rotated = NULL;
	transformed = NULL;
	//drawPoint = NULL;
	_countX = 0;
	_countY = 0;
	_isRadial = false;
	type = GRAPHICS_TYPE_ANTIALISING_LINE;
}

Grid::~Grid()
{
	Delete();
}

int Grid::GetCountX() const
{
	return _countX;
}

int Grid::GetCountY() const
{
	return _countY;
}

void Grid::Delete()
{
	//____________________ Delete point
	if (point != NULL)
	{
		for(int i = 0; i < _countY; i++)
		{
			delete [] point[i];
		}
		delete [] point;
	}
	point = NULL;
	//____________________ Delete rotated
	if (rotated != NULL)
	{
		for(int i = 0; i < _countY; i++)
		{
			delete [] rotated[i];
		}
		delete [] rotated;
	}
	rotated = NULL;
	//____________________ Delete transformed
	if (transformed != NULL)
	{
		for(int i = 0; i < _countY; i++)
		{
			delete [] transformed[i];
		}
		delete [] transformed;
	}
	_countX = 0;
	_countY = 0;
	_isRadial = false;
}

bool Grid::InternalCreate(int countX, int countY)
{
	Delete();
	//_____________________________________________________ Memory Allocation
	point = new Sys::Point3D*[countY];
	if (point == NULL)
	{
		Delete();
		return false;
	}
	//
	rotated = new Sys::Point3D*[countY];
	if (rotated == NULL)
	{
		Delete();
		return false;
	}
	//
	transformed = new Sys::Point*[countY];
	if (transformed == NULL)
	{
		Delete();
		return false;
	}
	//
	int i;
	for(i = 0; i < countY; i++)
	{
		point[i] = NULL;
		rotated[i] = NULL;
		transformed[i] = NULL;
	}
	for(i = 0; i < countY; i++)
	{
		//___________________ point
		point[i] = new Sys::Point3D[countX];
		if (point[i] == NULL)
		{
			Delete();
			return false;
		}
		//___________________ rotated
		rotated[i] = new Sys::Point3D[countX];
		if (rotated[i] == NULL)
		{
			Delete();
			return false;
		}
		//___________________ transformed
		transformed[i] = new Sys::Point[countX];
		if (transformed[i] == NULL)
		{
			Delete();
			return false;
		}
	}
	_countX = countX;
	_countY = countY;
	return true;
}

bool Grid::Create(int countX, int countY)
{
	return Create(-GRAPHICS_MAX_VALUE, GRAPHICS_MAX_VALUE, countX, -GRAPHICS_MAX_VALUE, GRAPHICS_MAX_VALUE, countY);
}

bool Grid::Create(double minX, double maxX, int countX, double minY, double maxY, int countY)
{
	if (InternalCreate(countX, countY) == false) return false;
	_isRadial = false;
	//__________________________________________________ Set values of X and Y
	const double deltaX = (maxX - minX)/(countX-1);
	const double deltaY = (maxY - minY)/(countY-1);
	double x, y;
	int i, j;
	for(i = 0; i < countY; i++)
	{
		y = minY + i*deltaY;
		for(j = 0; j < countX; j++)
		{
			x = minX + j*deltaX;
			point[i][j].x = x;
			point[i][j].y = y;
			point[i][j].z = 0.0;
			point[i][j].draw = true;
			//
			rotated[i][j].x = 0.0;
			rotated[i][j].y = 0.0;
			rotated[i][j].z = 0.0;
			//
			transformed[i][j].x = 0;
			transformed[i][j].y = 0;
			//
			//drawPoint[i][j] = true;
		}
	}
	return true;
}

bool Grid::CreateRadial(int countAngle, int countR)
{
	return CreateRadial(0.0, 2.0*M_PI, 0.0, GRAPHICS_MAX_VALUE, countAngle, countR);
}


bool Grid::CreateRadial(double minAngle, double maxAngle, double minR, double maxR, int countAngle, int countR)
{
	if (InternalCreate(countAngle, countR) == false) return false;
	_isRadial = true;
	//__________________________________________________ Set values of angle and radius
	const double deltaAngle = (maxAngle - minAngle)/(countAngle-1);
	const double deltaR = (maxR - minR)/(countR-1);
	double x, y;
	double angle, radius;
	int i, j;
	for(i = 0; i < countR; i++)
	{
		radius = minR + i*deltaR;
		for(j = 0; j < countAngle; j++)
		{
			angle = minAngle + j*deltaAngle;
			//
			x = radius*cos(angle);
			y = radius*sin(angle);
			//
			point[i][j].x = x;
			point[i][j].y = y;
			point[i][j].z = 0.0;
			point[i][j].draw = true;
			//
			rotated[i][j].x = 0.0;
			rotated[i][j].y = 0.0;
			rotated[i][j].z = 0.0;
			//
			transformed[i][j].x = 0;
			transformed[i][j].y = 0;
			//
			//drawPoint[i][j] = true;
		}
	}
	return true;
}

int  Grid::GetObject3DCount()
{
	switch(type)
	{
	case GRAPHICS_TYPE_LINE:
	case GRAPHICS_TYPE_ANTIALISING_LINE:
		return (_countX-1)*_countY + _countX*(_countY-1);
	case GRAPHICS_TYPE_SOLID_TRIANGLE:
	case GRAPHICS_TYPE_ANTIALISING_TRIANGLE:
	case GRAPHICS_TYPE_GOURAUD_TRIANGLE:
		return 2*(_countX-1)*(_countY-1); // Two triangles for each quad
	}
	return 0;
}

//_____________________________________________________________________ Sys::Graphics
Graphics::Graphics()
{
	Constructor();
}

Graphics::Graphics(const Sys::Graphics& init)
{
	Constructor();
	Copy(init);
}

Sys::Graphics& Graphics::operator=(const Sys::Graphics& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Graphics::Delete()
{
	if (bits  != NULL) delete[] bits;
	bits = NULL;
	//
	if (hbitmap != NULL) ::DeleteObject(hbitmap);
	hbitmap = NULL;
	//
	if (hdc != NULL) ::DeleteDC(hdc);
	hdc = NULL;
	//
	width = 0;
	height = 0;
}

void Graphics::Copy(const Sys::Graphics& init)
{
	if (init.bits == NULL) return; // Nothing to do
	if (Create(init.width, init.height) == false) return; // Memory error
	const size_t byteCount = sizeof(unsigned __int32)*width*height;
	::memcpy(bits, init.bits, byteCount);
	if (init.hbitmap != NULL && init.hdc != NULL) CreateBitmap();
}

void Graphics::Constructor()
{
	bits = NULL;
	width = 0;
	height = 0;
	hbitmap = NULL;
	hdc = NULL;
}

Graphics::~Graphics()
{
	Delete();
}

void Graphics::GetInfo(int& width, int& height, HDC& hdc) const
{
	width = this->width;
	height = this->height;
	hdc = this->hdc;
}

void Graphics::CreateBitmap()
{
	if (hbitmap != NULL) ::DeleteObject(hbitmap);
	hbitmap = NULL;
	//
	if (hdc != NULL) ::DeleteDC(hdc);
	hdc = NULL;
	//_____________________________________________________ Create a Compatible bitmap
	HWND hWnd = ::GetDesktopWindow();
	HDC hdcDesktop = ::GetDC(hWnd);
	hbitmap = ::CreateCompatibleBitmap(hdcDesktop, width, height);
	//
	BITMAPINFO bmi;
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth  = width;
    bmi.bmiHeader.biHeight = height;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bmi.bmiHeader.biXPelsPerMeter = 0;
    bmi.bmiHeader.biYPelsPerMeter = 0;
    bmi.bmiHeader.biClrUsed = 0;
    bmi.bmiHeader.biClrImportant = 0;
	::SetDIBits(hdcDesktop, hbitmap, 0, height, bits, &bmi, DIB_RGB_COLORS);
	//
	hdc = ::CreateCompatibleDC(hdcDesktop);
	::SelectObject(hdc, hbitmap);
	//
	::ReleaseDC(hWnd, hdcDesktop);
}

bool Graphics::Create(int width, int height)
{
	if (this->width == width && this->height == height) return true; // Nothing to do
	if (bits  != NULL) delete[] bits;
	bits = new unsigned __int32[width*height];
	if (bits == NULL)
	{
		this->width = 0;
		this->height = 0;
		return false;
	}
	this->width = width;
	this->height = height;
	return true;
}

bool Graphics::CopyToClipboard(HWND hWnd) const
{
	//_____________________________________________________ Create a Compatible bitmap
	HDC hdc = ::GetDC(hWnd);
	HBITMAP hBitmap = ::CreateCompatibleBitmap(hdc, width, height);
	//
	BITMAPINFO bmi;
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth  = width;
    bmi.bmiHeader.biHeight = height;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bmi.bmiHeader.biXPelsPerMeter = 0;
    bmi.bmiHeader.biYPelsPerMeter = 0;
    bmi.bmiHeader.biClrUsed = 0;
    bmi.bmiHeader.biClrImportant = 0;
	::SetDIBits(hdc, hBitmap, 0, height, bits, &bmi, DIB_RGB_COLORS);
	::ReleaseDC(hWnd, hdc);
	//___________________________________________________ Copy the bitmap to the clipboard
	bool ok = false;
	if (OpenClipboard(hWnd) == TRUE)
		{
			if (EmptyClipboard() == TRUE)
			{
				ok = true;
				SetClipboardData(CF_BITMAP, hBitmap);
				CloseClipboard();
			}
		}
	return true;

}

// Remember that Red and Blue are exchanged
void Graphics::SetAllPixels(COLORREF color)
{
	const int len = width*height;
	for(int i = 0; i < len; i++) bits[i] = color;
}

int Graphics::GetWidth() const 
{
	return width;
}

int Graphics::GetHeight() const
{
	return height;
}

void Graphics::SetPixel(int x, int y, COLORREF color)
{
	if (x >= width) x = width-1;
	if (x < 0) x = 0;
	if (y >= height) y = height-1;
	if (y < 0) y = 0;
	bits[x + width*(height - y -1)] = color;
}

void Graphics::SetPixel(int x, int y, unsigned __int8& red, unsigned __int8& green, unsigned __int8& blue)
{
	bits[x + width*(height - y -1)] = RGBX(red, green, blue);
}

COLORREF Graphics::GetPixel(int x, int y) const
{
	return bits[x + width*(height - y -1)];
}

void Graphics::GetPixel(int x, int y, unsigned __int8& out_red, unsigned __int8& _out_green, unsigned __int8& _out_blue) const
{
	const int pos = x + width*(height - y -1);
	COLORREF color = bits[pos];
	out_red = GetRValueX(color);
	_out_green = GetGValueX(color);
	_out_blue = GetBValueX(color);
}

//int Graphics::GetColorIndex(double value)
//{
//	const int index = (int)(value* maxColorIndex+0.5);
//	if (index < 0) return 0;
//	if (index > maxColorIndex) return maxColorIndex;
//	return index;
//}

// Value must be in [0, 1]
//COLORREF Graphics::ToColor(double value)
//{
//	//return Sys::Convert::DoubleToColorRef(value, false, 5);
//	int index = (int)(value* maxColorIndex+0.5);
//	if (index < 0) index = 0;
//	if (index > maxColorIndex) index =  maxColorIndex;
//	return color[index];
//}

//// It creates a set of colors based on an array of basic colors
//// Use isStandardFormat = false for bitmaps
//// Use isStandardFormat = true for GDI
//bool Graphics::CreateColors(valarray<COLORREF>& basicColors, bool isStandardFormat)
//{
//	const int numColors = (basicColors.size()-1)*256;
//	maxColorIndex = numColors -1;
//	int index1;
//	int index2;
//	double ratio = 0.0;
//	int ired, igreen, iblue;
//	double red1, green1, blue1;
//	double red2, green2, blue2;
//	try
//	{
//		color.resize(numColors);
//	}
//	catch(std::bad_alloc& )
//	{
//		return false;
//	}
//	int i;
//	 for(i = 0; i < numColors; i++)
//	 {
//		index1 = i/256;
//		index2 = index1+1;
//		ratio = (i%256+0.5)/256.0;
//		//if (index1 < 0) index1 = 0;
//		//if (index2 < 0) index2 = 0;
//		if (index1 > maxColorIndex) index1 = maxColorIndex;
//		if (index2 > maxColorIndex) index2 = maxColorIndex;
//		//
//		red1 = GetRValue(basicColors[index1]);
//		red2 = GetRValue(basicColors[index2]);
//		//
//		green1 = GetGValue(basicColors[index1]);
//		green2 = GetGValue(basicColors[index2]);
//		//
//		blue1 = GetBValue(basicColors[index1]);
//		blue2 = GetBValue(basicColors[index2]);
//		//
//		ired = (int)(ratio*red2 + (1.0 - ratio)*red1 + 0.5);
//		igreen = (int)(ratio*green2 + (1.0 - ratio)*green1 + 0.5);
//		iblue = (int)(ratio*blue2 + (1.0 - ratio)*blue1 + 0.5);
//		//
//		if (ired < 0) ired = 0;
//		if (ired > 255) ired = 255;
//		//
//		if (igreen < 0) igreen = 0;
//		if (igreen > 255) igreen = 255;
//		//
//		if (iblue < 0) iblue = 0;
//		if (iblue > 255) iblue = 255;
//		//
//		if (isStandardFormat == true)
//		{
//			color[i] = RGB(ired, igreen, iblue);
//		}
//		else
//		{
//			color[i] = RGB(iblue, igreen, ired);
//		}
//	 }
//	 return true;
//}

// Bresenham's line drawing algorithm
void Graphics::BresenhamLine(int x1, int y1, int x2, int y2, COLORREF color) 
{
	/* Save half the line-drawing cases by swapping y1 with y2
	and x1 with x2 if y1 is greater than y2. As a result, deltaY
	is always > 0, and only the octant 0-3 cases need to be
	handled. */
	int tmp;
	if (y1 > y2) 
	{
		tmp = y1;
		y1 = y2;
		y2 = tmp;
		tmp = x1;
		x1 = x2;
		x2 = tmp;
	}

	/* Handle as four separate cases, for the four octants in which y2 is greater than y1 */
	int deltaX = x2 - x1; /* calculate the length of the line in each coordinate */
	const int deltaY = y2 - y1;
	if ( deltaX > 0 ) 
	{
		if ( deltaX > deltaY ) 
		{
			Octant0(x1, y1, deltaX, deltaY, 1, color);
		} 
		else 
		{
			Octant1(x1, y1, deltaX, deltaY, 1, color);
		}
	} 
	else 
	{
		deltaX = -deltaX; // abs(deltaX)
		if ( deltaX > deltaY ) 
		{
			Octant0(x1, y1, deltaX, deltaY, -1, color);
		} 
		else 
		{
			Octant1(x1, y1, deltaX, deltaY, -1, color);
		}
	}
}

// Draws a line in octant 0 or 3 ( |deltaX| >= deltaY ).
//  x1, y1: coordinates of start of the line
// directionX : 1 if line is drawn left to right, -1 if drawn right to left
// deltaX, deltaY length of the line (both > 0)
void Graphics::Octant0(int x1, int y1, int deltaX, int deltaY, int directionX, COLORREF color)
{
	const int deltaYx2 = deltaY * 2;
	const int deltaYx2MinusDeltaXx2 = deltaYx2 - (int) ( deltaX * 2 );
	int errorTerm = deltaYx2 - (int) deltaX;
	// ___________________________________Draw the line
	bits[x1 + width*(height - y1 -1)] = color; //SetPixel(x1, y1, color);
	while ( deltaX-- ) 
	{
		if ( errorTerm >= 0 ) 
		{
			y1++;
			errorTerm += deltaYx2MinusDeltaXx2; //Adjust the error term back down
		} 
		else
		{
			errorTerm += deltaYx2; // Add to the error term 
		}
		x1 += directionX; 
		bits[x1 + width*(height - y1 -1)] = color; //SetPixel(x1, y1, color);
	}
}

// Draws a line in octant 1 or 2 ( |deltaX| < deltaY ).
//  x1, y1: coordinates of start of the line
// directionX : 1 if line is drawn left to right, -1 if drawn right to left
// deltaX, deltaY length of the line (both > 0)
void Graphics::Octant1(int x1, int y1, int deltaX, int deltaY, int directionX, COLORREF color)
{

	const int deltaXx2 = deltaX * 2;
	const int deltaXx2MinusDeltaYx2 = deltaXx2 - (int) ( deltaY * 2 );
	int errorTerm = deltaXx2 - (int) deltaY;
	bits[x1 + width*(height - y1 -1)] = color; //SetPixel(x1, y1, color);
	while ( deltaY--) 
	{
		if ( errorTerm >= 0 ) 
		{
			x1 += directionX;
			errorTerm += deltaXx2MinusDeltaYx2; //Adjust the error termback down
		} 
		else 
		{
			errorTerm += deltaXx2;
		}
		y1++;
		bits[x1 + width*(height - y1 -1)] = color; //SetPixel(x1, y1, color);
	}
}

void Graphics::Line(__int16 x1, __int16 y1, __int16 x2, __int16 y2, COLORREF color)
{
	if (CohenSutherlandClipping(x1, y1, x2, y2) == true) LineUnclipped(x1, y1, x2, y2, color);
}

void Graphics::LineUnclipped(__int16 x1, __int16 y1, __int16 x2, __int16 y2, COLORREF color)
{
	//draw top to bottom, to reduce the number of cases  to
	//	handle, and to make lines between the same endpoints draw the same pixels
	int tmp;
	if (y1 > y2) 
	{
		tmp = y1;
		y1 = y2;
		y2 = tmp;
		tmp = x1;
		x1 = x2;
		x2 = tmp;
	}
	unsigned __int32 * pBits = bits + x1 + width*(height - y1 -1); //Point to the bitmap address first pixel to draw

	// Figure out whether were going left or right, and how far were going horizontally
	int xDelta;
	int xAdvance;
	if ((xDelta = x2 - x1) < 0)
	{
		xAdvance = -1;
		xDelta = -xDelta;
	}
	else
	{
		xAdvance = 1;
	}
	// Figure out how far were going vertically
	int yDelta = y2 - y1;
	// Special-case horizontal, vertical, and diagonal lines, for speed
	//	and to avoid nasty boundary conditions and division by 0
	int i;
	if (xDelta == 0) //_____________________________________ Vertical line
	{	
		for (i = 0; i <= yDelta; i++)
		{
			*pBits = color;
			pBits -= width;
		}
		return;
	}
	if (yDelta == 0) //_______________________________________ Horizontal line
	{	
		for (i = 0; i <= xDelta; i++)
		{
			*pBits = color;
			pBits += xAdvance;
		}
		return;
	}
	if (xDelta == yDelta)//__________________________________ Diagonal line
	{	
		for (i=0; i<=xDelta; i++)
		{
			*pBits = color;
			pBits += xAdvance - width;
		}
		return;
	}

	// Determine whether the line is X or Y major, and handle accordingly
	int wholeStep;
	int adjUp;
	int adjDown;
	int errorTerm;
	int initialPixelCount;
	int finalPixelCount;
	int runLength;
	if (xDelta >= yDelta)
	{
		/* X major line */
		/* Minimum # of pixels in a run in this line */
		wholeStep = xDelta / yDelta;
		/* Error term adjust each time Y steps by 1; used to tell when one
		extra pixel should be drawn as part of a run, to account for
		fractional steps along the X axis per 1-pixel steps along Y */
		adjUp = (xDelta % yDelta) * 2;
		/* Error term adjust when the error term turns over, used to factor
		out the X step made at that time */
		adjDown = yDelta * 2;
		/* Initial error term; reflects an initial step of 0.5 along the Y
		axis */
		errorTerm = (xDelta % yDelta) - (yDelta * 2);
		/* The initial and last runs are partial, because Y advances only 0.5
		for these runs, rather than 1. Divide one full run, plus the
		initial pixel, between the initial and last runs */
		initialPixelCount = (wholeStep / 2) + 1;
		finalPixelCount = initialPixelCount;
		/* If the basic run length is even and theres no fractional
		advance, we have one pixel that could go to either the initial
		or last partial run, which well arbitrarily allocate to the
		last run */
		if ((adjUp == 0) && ((wholeStep & 0x01) == 0))
		{
			initialPixelCount--;
		}
		/* If therere an odd number of pixels per run, we have 1 pixel that cant
		be allocated to either the initial or last partial run, so well add 0.5
		to error term so this pixel will be handled by the normal full-run loop */
		if ((wholeStep & 0x01) != 0)
		{
			errorTerm += yDelta;
		}
		/* Draw the first, partial run of pixels */
		DrawHorizontalRun(&pBits, xAdvance, initialPixelCount, color);
		/* Draw all full runs */
		for (i = 0; i < (yDelta-1); i++)
		{
			runLength = wholeStep; /* run is at least this long */
			/* Advance the error term and add an extra pixel if the error
			term so indicates */
			if ((errorTerm += adjUp) > 0)
			{
				runLength++;
				errorTerm -= adjDown; /* reset the error term */
			}
			/* Draw this scan lines run */
			DrawHorizontalRun(&pBits, xAdvance, runLength, color);
		}
		/* Draw the final run of pixels */
		DrawHorizontalRun(&pBits, xAdvance, finalPixelCount, color);
		return;
	}
	else
	{
		/* Y major line */
		/* Minimum # of pixels in a run in this line */
		wholeStep = yDelta / xDelta;
		/* Error term adjust each time X steps by 1; used to tell when 1 extra
		pixel should be drawn as part of a run, to account for
		fractional steps along the Y axis per 1-pixel steps along X */
		adjUp = (yDelta % xDelta) * 2;
		/* Error term adjust when the error term turns over, used to factor
		out the Y step made at that time */
		adjDown = xDelta * 2;
		/* Initial error term; reflects initial step of 0.5 along the X axis */
		errorTerm = (yDelta % xDelta) - (xDelta * 2);
		/* The initial and last runs are partial, because X advances only 0.5
		for these runs, rather than 1. Divide one full run, plus the
		initial pixel, between the initial and last runs */
		initialPixelCount = (wholeStep / 2) + 1;
		finalPixelCount = initialPixelCount;
		/* If the basic run length is even and theres no fractional advance, we
		have 1 pixel that could go to either the initial or last partial run,
		which well arbitrarily allocate to the last run */
		if ((adjUp == 0) && ((wholeStep & 0x01) == 0))
		{
			initialPixelCount--;
		}
		/* If there are an odd number of pixels per run, we have one pixel
		that cant be allocated to either the initial or last partial
		run, so well add 0.5 to the error term so this pixel will be
		handled by the normal full-run loop */
		if ((wholeStep & 0x01) != 0)
		{
			errorTerm += xDelta;
		}
		/* Draw the first, partial run of pixels */
		DrawVerticalRun(&pBits, xAdvance, initialPixelCount, color);
		/* Draw all full runs */
		for (i=0; i<(xDelta-1); i++)
		{
			runLength = wholeStep; /* run is at least this long */
			/* Advance the error term and add an extra pixel if the error
			term so indicates */
			if ((errorTerm += adjUp) > 0)
			{
				runLength++;
				errorTerm -= adjDown; /* reset the error term */
			}
			/* Draw this scan lines run */
			DrawVerticalRun(&pBits, xAdvance, runLength, color);
		}
		/* Draw the final run of pixels */
		DrawVerticalRun(&pBits, xAdvance, finalPixelCount, color);
		return;
	}
}

// Draws a horizontal run of pixels, then advances the bitmap pointer to
// the first pixel of the next run
void Graphics::DrawHorizontalRun(unsigned __int32** pBits, int xAdvance, int runLength, COLORREF color)
{
	int i;
	unsigned __int32 *workingScreenPtr = *pBits;
	for (i=0; i<runLength; i++)
	{
		*workingScreenPtr = color;
		workingScreenPtr += xAdvance;
	}
	workingScreenPtr -= width; // Advance to the next scan line
	*pBits = workingScreenPtr;
}

// Draws a vertical run of pixels, then advances the bitmap pointer to
// the first pixel of the next run.
void Graphics::DrawVerticalRun(unsigned __int32** pBits, int xAdvance, int runLength, COLORREF color)
{
	int i;
	unsigned __int32 *workingScreenPtr = *pBits;
	for (i=0; i<runLength; i++)
	{
		*workingScreenPtr = color;
		workingScreenPtr -= width;
	}
	workingScreenPtr += xAdvance; //Advance to the next column
	*pBits = workingScreenPtr;
}

bool Graphics::CohenSutherlandClipping(__int16& x1, __int16& y1, __int16& x2, __int16& y2)
{
	//_________________________________________CohenSutherland Clipping Algorithm
	const int xmax = width-1;
	const int ymax = height-1;
	//
	int code1 = COHEN_SUTHERLAND_INSIDE;
	if (x1 < 0) code1 |= COHEN_SUTHERLAND_LEFT;
	else if (x1 > xmax) code1 |= COHEN_SUTHERLAND_RIGHT;
	if (y1 < 0) code1 |= COHEN_SUTHERLAND_BOTTOM;
	else if (y1 > ymax) code1 |= COHEN_SUTHERLAND_TOP;
	//
	int code2 = COHEN_SUTHERLAND_INSIDE;
	if (x2 < 0) code2 |= COHEN_SUTHERLAND_LEFT;
	else if (x2 > xmax) code2 |= COHEN_SUTHERLAND_RIGHT;
	if (y2 < 0) code2 |= COHEN_SUTHERLAND_BOTTOM;
	else if (y2 > ymax) code2 |= COHEN_SUTHERLAND_TOP;

	bool accept = false;
	while (true) 
	{
		if (!(code1 | code2)) // Bitwise OR is 0. Trivially accept and get out of loop
		{ 
			accept = true;
			break;
		} 
		else if (code1 & code2) // Bitwise AND is not 0. Trivially reject and get out of loop
		{ 
			break;
		} 
		else 
		{
			// failed both tests, so calculate the line segment to clip
			// from an outside point to an intersection with clip edge
			double x, y;
 
			// At least one endpoint is outside the clip rectangle; pick it.
			int code = (code1 != COHEN_SUTHERLAND_INSIDE) ? code1 : code2;
 
			// Now find the intersection point;
			// use formulas y = y0 + slope * (x - x0), x = x0 + (1 / slope) * (y - y0)
			if (code & COHEN_SUTHERLAND_TOP) // point is above the clip rectangle
			{           
				x = x1 + (x2 - x1) * (ymax - y1) / (y2 - y1);
				y = ymax;
			} 
			else if (code & COHEN_SUTHERLAND_BOTTOM) // point is below the clip rectangle
			{ 
				x = x1 + (x2 - x1) * (-y1) / (y2 - y1);
				y = 0.0;
			} 
			else if (code & COHEN_SUTHERLAND_RIGHT) // point is to the right of clip rectangle
			{  
				y = y1 + (y2 - y1) * (xmax - x1) / (x2 - x1);
				x = xmax;
			} 
			else if (code & COHEN_SUTHERLAND_LEFT) // point is to the left of clip rectangle
			{   
				y = y1 + (y2 - y1) * (-x1) / (x2 - x1);
				x = 0.0;
			}
 
			// Now we move outside point to intersection point to clip and get ready for next pass
			if (code == code1) 
			{
				x1 = (int)x;
				y1 = (int)y;
				code1 = COHEN_SUTHERLAND_INSIDE;
				if (x1 < 0) code1 |= COHEN_SUTHERLAND_LEFT;
				else if (x1 > xmax) code1 |= COHEN_SUTHERLAND_RIGHT;
				if (y1 < 0) code1 |= COHEN_SUTHERLAND_BOTTOM;
				else if (y1 > ymax) code1 |= COHEN_SUTHERLAND_TOP;
			} 
			else 
			{
				x2 = (int)x;
				y2 = (int)y;
				code2 = COHEN_SUTHERLAND_INSIDE;
				if (x2 < 0) code2 |= COHEN_SUTHERLAND_LEFT;
				else if (x2 > xmax) code2 |= COHEN_SUTHERLAND_RIGHT;
				if (y2 < 0) code2 |= COHEN_SUTHERLAND_BOTTOM;
				else if (y2 > ymax) code2 |= COHEN_SUTHERLAND_TOP;
			}
		}
	}
	return accept;
}

void Graphics::DrawHorizontalLineList(HorizontalLineList& lineList, COLORREF color)
{
	vector<HorizontalLine>::iterator line = lineList.horizontalLine.begin();
	const int lineCount = (int)lineList.horizontalLine.size();
	unsigned __int32 * pBits = bits + width*(height - lineList.y_start -1);
	unsigned __int32 * p;
	int scan_width;
	int i, j;

	//Draw each horizontal line in turn, starting with the top one and advancing one line each time
	for(i = 0; i < lineCount; i++, line++)
	{
		scan_width = line->x_end - line->x_start +1;
		if (scan_width > 0)
		{
			//memset(pBits + line->x_start, color, width);
			p = pBits+line->x_start;
			for(j = 0; j < scan_width; j++, p++)
			{
				*p = color;
			}
		}
		pBits -= width; // point to next scan line start
	}
}

// Scan converts an edge from (x1,y1) to (x2,y2), not including the point at (x2,y2). 
//  If skipFirst == true, the point at (x1,y1) is not drawn, otherwise the point is not drawn
//  For each scan line, the pixel closest to the scanned edge without being to the left of the
// scanned edge is chosen
void Graphics::ScanEdge(int x1, int y1, int x2, int y2, bool set_x_start, bool skipFirst, vector<Sys::HorizontalLine>::iterator& line)
{
	//HorizontalLine* line = *edgePoint;
	const int deltaX = x2 - x1;
	const int edge_y_length = y2 - y1;
	const int yHeight = (skipFirst == true) ? edge_y_length-1 : edge_y_length;
	const int advanceAmt = (deltaX > 0) ? 1 : -1;
	int i;
	int errorTerm;
	if (edge_y_length <= 0) return;

	//Find out whether the edge is vertical, diagonal, X-major (mostly horizontal), or Y-major (mostly vertical)
	const int segmentWidth = abs(deltaX);
	if (segmentWidth == 0) // The edge is vertical; special-case by just storing the same x coordinate for every scan line
	{
		// Scan the edge for each scan line in turn
		for (i = 0; i < yHeight; i++, line++) 
		{
			// Store the X coordinate in the appropriate edge list
			if (set_x_start == true)
			{
				line->x_start = x1;
			}
			else
			{
				line->x_end = x1;
			}
		}
	} 
	else if (segmentWidth == edge_y_length) // The edge is diagonal; special-case by advancing the X coordinate 1 pixel for each scan line 
	{
		if (skipFirst == true) x1 += advanceAmt;// skip the first point if so indicated move 1 pixel to the left or right
	 
		for (i = 0; i < yHeight; i++, line++) 
		{
			// Store the X coordinate in the appropriate edge list
			if (set_x_start == true)
			{
				line->x_start = x1;
			}
			else
			{
				line->x_end = x1;
			}
			x1 += advanceAmt; // move 1 pixel to the left or right
		}
	} 
	else if (edge_y_length > segmentWidth) //Edge is closer to vertical than horizontal (Y-major)
	{
		if (segmentWidth >= 0)
		{
			errorTerm = 0; // initial error term going left->right
		}
		else
		{
			errorTerm = -edge_y_length + 1; // going right->left
		}
		if (skipFirst == true) 
		{ //skip the first point if so indicated 
			//Determine whether its time for the X coord to advance
			errorTerm += segmentWidth;
			if (errorTerm> 0) 
			{
				x1 += advanceAmt; // move 1 pixel to the left or right
				errorTerm -= edge_y_length; // advance errorTerm to next point
			}
		}
		//Scan the edge for each scan line in turn */
		for (i = 0; i < yHeight; i++, line++) 
		{
			//Store the X coordinate in the appropriate edge list */
			if (set_x_start == true)
			{
				line->x_start = x1;
			}
			else
			{
				line->x_end = x1;
			}
			//Determine whether its time for the X coord to advance;
			errorTerm += segmentWidth;
			if (errorTerm> 0) 
			{
				x1 += advanceAmt; // move 1 pixel to the left or right
				errorTerm -= edge_y_length; // advance ErrorTerm to correspond
			}
		}
	} 
	else 
	{
		// Edge is closer to horizontal than vertical (X-major)
		//Minimum distance to advance X each time	
		int XMajorAdvanceAmt = (segmentWidth / edge_y_length) * advanceAmt;
		//Error term advance for deciding when to advance X 1 extra
		int errorTermAdvance = segmentWidth % edge_y_length;
		if (deltaX >= 0)
		{
			errorTerm = 0; //initial error term going left->right
		}
		else
		{
			errorTerm = -edge_y_length + 1; //going right->left
		}
		if (skipFirst == true) 
		{ // skip the first point if so indicated
			x1 += XMajorAdvanceAmt; // move X minimum distance
			//Determine whether its time for X to advance one extra
			errorTerm += errorTermAdvance;
			if (errorTerm> 0) 
			{
				x1 += advanceAmt; // move X one more
				errorTerm -= edge_y_length; // advance ErrorTerm to correspond
			}
		}
		//Scan the edge for each scan line in turn
		for (i = 0; i < yHeight; i++, line++) 
		{
			//Store the X coordinate in the appropriate edge list */
			if (set_x_start == 1)
			{
				line->x_start = x1;
			}
			else
			{
				line->x_end = x1;
			}
			x1 += XMajorAdvanceAmt; // move X minimum distance
			//Determine whether its time for X to advance one extra */
			errorTerm += errorTermAdvance;
			if (errorTerm> 0) 
			{
				x1 += advanceAmt; //move X one more
				errorTerm -= edge_y_length; // advance errorTerm to correspond
			}
		}
	}
	//*edgePoint = line; //advance callers ptr
}

/* Color-fills a convex polygon. All vertices are offset by (XOffset,
YOffset). Convex means that every horizontal line drawn through
the polygon at any point would cross exactly two active edges
(neither horizontal lines nor zero-length edges count as active
edges; both are acceptable anywhere in the polygon), and that the
right & left edges never cross. (Its OK for them to touch, though,
so long as the right edge never crosses over to the left of the
left edge.) Nonconvex polygons wont be drawn properly. Returns 1
for success, 0 if memory allocation failed. */
bool Graphics::Polygon(vector<Sys::Point>& vertices, COLORREF color,int positionX, int positionY)
{
	const int length = (int)vertices.size();
	if (length <= 0) return true;
	Sys::HorizontalLineList horizontalLineList;

	int minIndexL = 0;
	int maxIndex = 0;
	int nextIndex;
	int previousIndex;
	int deltaXN;
	int deltaYN;
	int deltaXP;
	int deltaYP;
	int minPoint_y = vertices[0].y;
	int maxPoint_y = vertices[0].y;
	int i;

	for (i = 1; i < length; i++) 
	{
		if (vertices[i].y< minPoint_y)
		{
			minIndexL = i;
			minPoint_y= vertices[minIndexL].y; // new top
		}
		else if (vertices[i].y > maxPoint_y)
		{
			maxIndex = i;
			maxPoint_y = vertices[maxIndex].y; //new bottom
		}
	}
	if (minPoint_y == maxPoint_y) return true; // polygon is 0-height; avoid infinite loop below
	// Scan in ascending order to find the last top-edge point
	int minIndexR = minIndexL;
	while (vertices[minIndexR].y == minPoint_y)
	{
		minIndexR = (minIndexR + 1) % length;
	}
	minIndexR = (minIndexR - 1 + length) % length; // back up to last top-edge point
	// Now scan in descending order to find the first top-edge point
	while (vertices[minIndexL].y == minPoint_y)
	{
		minIndexL = (minIndexL - 1 + length) % length;
	}
	minIndexL = (minIndexL + 1) % length; // back up to first top-edge point

	// Figure out which direction through the vertex list from the top vertex is the left edge and which is the right
	int leftEdgeDir = -1; // assume left edge runs down thru vertex list
	const bool topIsFlat = (vertices[minIndexL].x != vertices[minIndexR].x);
	int tmp;
	if (topIsFlat == true) 
	{
		//If the top is flat, just see which of the ends is leftmost
		if (vertices[minIndexL].x > vertices[minIndexR].x) 
		{
			leftEdgeDir = 1; // left edge runs up through vertex list
			tmp = minIndexL; // swap the indices so MinIndexL
			minIndexL = minIndexR; // points to the start of the left
			minIndexR = tmp; // edge, similarly for MinIndexR
		}
	} 
	else 
	{
		// Point to the downward end of the first line of each of the two edges down from the top
		nextIndex = minIndexR;
		nextIndex = (nextIndex + 1) % length;
		previousIndex = minIndexL;
		previousIndex = (previousIndex - 1 + length) % length;
		//Calculate x and y lengths from the top vertex to the end of the first line down each edge; use those to compare slope and see which line is leftmost
		deltaXN = vertices[nextIndex].x - vertices[minIndexL].x;
		deltaYN = vertices[nextIndex].y - vertices[minIndexL].y;
		deltaXP = vertices[previousIndex].x - vertices[minIndexL].x;
		deltaYP = vertices[previousIndex].y - vertices[minIndexL].y;
		if (((long)deltaXN * deltaYP - (long)deltaYN * deltaXP) < 0L) 
		{
			leftEdgeDir = 1; // left edge runs up through vertex list
			tmp = minIndexL; // swap the indices so MinIndexL
			minIndexL = minIndexR; // points to the start of the left
			minIndexR = tmp; // edge, similarly for MinIndexR
		}
	}
	// Set the # of scan lines in the polygon, skipping the bottom edge and also skipping the top vertex if the top isnt flat because
	//in that case the top vertex has a right edge component, and set the top scan line to draw, which is likewise the second line of
	//the polygon unless the top is flat
	const int lineCount = (topIsFlat == true) ? maxPoint_y - minPoint_y : maxPoint_y - minPoint_y - 1;
	if (lineCount <= 0) return true; // theres nothing to draw, so were done
	
	horizontalLineList.y_start = (topIsFlat == true) ? positionY + minPoint_y : positionY + minPoint_y + 1;

	// Get memory in which to store the line list we generate
	try
	{
		horizontalLineList.horizontalLine.resize(lineCount);
	}
	catch(std::bad_alloc &)
	{
		return false;
	}
	// Scan the left edge and store the boundary points in the list
	// Initial pointer for storing scan converted left-edge coords
	vector<Sys::HorizontalLine>::iterator edgePoint = horizontalLineList.horizontalLine.begin();
	// Start from the top of the left edge
	int currentIndex = minIndexL;
	previousIndex = minIndexL;
	// Skip the first point of the first line unless the top is flat, if the top isnt flat, the top vertex is exactly on a right edge and it isnt drawn
	bool skipFirst = (topIsFlat == false);
	//Sys::HorizontalLine* ampEdgePointPtr;
	// Scan convert each line in the left edge from top to bottom
	do 
	{
		if (leftEdgeDir > 0)
		{
			currentIndex = (currentIndex + 1) % length;
		}
		else
		{
			currentIndex = (currentIndex - 1 + length) % length;
		}

		ScanEdge(vertices[previousIndex].x + positionX, vertices[previousIndex].y, vertices[currentIndex].x + positionX, 
			vertices[currentIndex].y, 1, skipFirst, edgePoint);
		previousIndex = currentIndex;
		skipFirst = false; // scan convert the first point from now on
	} 
	while (currentIndex != maxIndex);

	// Scan the right edge and store the boundary points in the list
	edgePoint = horizontalLineList.horizontalLine.begin();
	previousIndex = minIndexR;
	currentIndex = minIndexR;
	skipFirst = (topIsFlat == false);
	// Scan convert the right edge, top to bottom. X coordinates are adjusted 1 to the left, effectively causing scan conversion of
	//the nearest points to the left of but not exactly on the edge
	do
	{
		if (-leftEdgeDir > 0)
		{
			currentIndex = (currentIndex + 1) % length;
		}
		else
		{
			currentIndex = (currentIndex - 1 + length) % length;
		}
		ScanEdge(vertices[previousIndex].x + positionX- 1,vertices[previousIndex].y, vertices[currentIndex].x + positionX- 1,
		vertices[currentIndex].y, 0, skipFirst, edgePoint);
		previousIndex = currentIndex;
		skipFirst = false; // scan convert the first point from now on
	} 
	while (currentIndex != maxIndex);

	// Draw the line list representing the scan converted polygon
	DrawHorizontalLineList(horizontalLineList, color);
	return true;
}

void Graphics::DrawVerticalLine(double& start_y, double& end_y, int& x, unsigned char& start_red, unsigned char& start_green, unsigned char& start_blue,
		 unsigned char& end_red, unsigned char& end_green, unsigned char& end_blue)
{
	//register unsigned __int32 * p;
	//const int istart_x = (start_x < 0.0) ? 0: (int)floor(start_x);
	//const int iend_x = (int)floor(end_x);
	//const int deltaX = iend_x - istart_x+1;
	//if (deltaX <= 0.0) return; // nothing to do
	//const double deltaColorX = 255.0/deltaX;
	//int ialpha;
	//double alpha = 0.0;

	//register int x = (int)(start_x + 0.5);
	//p = bits + width*(height - y -1) + x;
	//for(; x <= iend_x; x++, p++, alpha += deltaColorX)
	//{
	//	ialpha = (int)alpha;
	//	if (ialpha > 255) ialpha = 255;
	//	*p = RGBX(mix[end_red][start_red][ialpha], mix[end_green][start_green][ialpha], mix[end_blue][start_blue][ialpha]);			
	//}
}

//_____________________________________________________________________ Sys::GraphicsX
int Sys::GraphicsX::_objectCount = 0;
unsigned __int8 *** Sys::GraphicsX::mix = NULL;

GraphicsX::GraphicsX()
{
	if (_objectCount == 0)
	{
		//______________________________________________ mix stores the combination of two colors for different combination rates 
		mix = new unsigned __int8**[256];
		int i, j, k;
		double level;
		__int8 value;
		for (i = 0; i < 256; i++)
		{
			mix[i] = new unsigned __int8*[256];
			for (j = 0; j < 256; j++)
			{
				mix[i][j] = new unsigned __int8[256];
				for (k = 0; k < 256; k++)
				{
					level = k/255.0;
					value = (unsigned __int8)(i*level + j*(1.0-level)+0.5);
					if (value > (unsigned __int8)255) value = (unsigned __int8)255;
					mix[i][j][k] = value;
				}
			}
		}
	}
	_objectCount++;
}

GraphicsX::~GraphicsX()
{
	_objectCount--;
	if (_objectCount == 0)
	{
		if (mix == NULL) return; // Impossible
		int i, j;
		for (i = 0; i < 256; i++)
		{
			for (j = 0; j < 256; j++)
			{
				if (mix[i][j] != NULL) delete[] mix[i][j];
			}
		}
		for (i = 0; i < 256; i++)
		{
			if (mix[i] != NULL) delete[] mix[i];
		}
		if (mix != NULL) delete[] mix;
	}
}

void GraphicsX::SetPixel(int x, int y, unsigned __int8& red, unsigned __int8& green, unsigned __int8& blue, unsigned __int8& alpha)
{
	const int pos = x + width*(height - y -1);
	bits[pos] = RGBX(mix[red][GetRValueX(bits[pos])][alpha], mix[green][GetGValueX(bits[pos])][alpha], mix[blue][GetBValueX(bits[pos])][alpha]);
}

void GraphicsX::WuLineUnclipped(__int16 x1, __int16 y1, __int16 x2, __int16 y2, COLORREF color)
{
	register unsigned __int32 * p;
	const __int16 numLevels = 256;
	const unsigned __int16 intensityBits = 8;
	//_________________ Make sure the line runs from top to bottom
	short tmp;
	if (y1 > y2)
	{
		tmp = y1;
		y1 = y2;
		y2 = tmp;
		//
		tmp = x1;
		x1 = x2;
		x2 = tmp;
	}

	bits[x1 + width*(height - y1 - 1)] = color;// First pixel, graphics.SetPixel(x1, y1, color);
	__int16 deltaX = x2 - x1;
	__int16 xDir;
	if (deltaX >= 0)
	{
		xDir = 1;
	}
	else
	{
		xDir = -1;
		deltaX = -deltaX; // make deltaX positive
	}
	__int16 deltaY = y2 - y1;
	if (deltaY == 0) //____________________________ Horizontal line
	{
		p = bits + x1 + width*(height - y1 - 1); //pos = x1 + width*(height - y1 - 1);
		while (deltaX-- != 0)
		{
			p += xDir; //pos += xDir; // x1 += xDir;
			*p = color; //bits[pos] = color;//bits[x1 + width*(height - y1 - 1)] = color; //graphics.SetPixel(x1, y1, color);
		}
		return;
	}
	if (deltaX == 0) //___________________________________ Vertical line
	{
		p = bits + x1 + width*(height - y1 - 1); //pos = x1 + width*(height - y1 - 1);
		do
		{
			p -= width; //pos -= width; //y1++;
			*p = color; //bits[pos] = color; //bits[x1 + width*(height - y1 -1)] = color; //graphics.SetPixel(x1, y1, color);
		}
		while (--deltaY != 0);
		return;
	}
	if (deltaX == deltaY) //________________________________ Diagonal line
	{
		p = bits + x1 + width*(height - y1 - 1); //pos = x1 + width*(height - y1 - 1);
		do
		{
			p += (xDir-width); //pos += (xDir-width); //x1 += xDir;y1++;
			*p = color; //bits[pos] = color; //bits[x1 + width*(height - y1 -1)] = color; //graphics.SetPixel(x1, y1, color);
		}
		while (--deltaY != 0);
		return;
	}
	//__________________________________ line is not horizontal, diagonal, or vertical
	const unsigned __int8 red = GetRValueX(color);
	const unsigned __int8 green = GetGValueX(color);
	const unsigned __int8 blue = GetBValueX(color);
	unsigned __int8 alpha;
	unsigned short errorAcc = 0;
	//int pos2;
	register unsigned __int32* p2;

	unsigned __int16 intensityShift = 16 - intensityBits; // # of bits by which to shift errorAcc to get intensity level
														  /* Mask used to flip all bits in an intensity weighting, producing the
														  result (1 - intensity weighting) */
	unsigned __int16 weightingComplementMask = numLevels - 1;

	unsigned __int16 errorAdj;
	unsigned __int16 errorAccTemp;
	unsigned __int16 weighting;

	if (deltaY > deltaX) //_______________________________________________  Y-major line
	{
		/* Y-major line; calculate 16-bit fixed-point fractional part of a
		pixel that X advances each time Y advances 1 pixel, truncating the
		result so that we won't overrun the endpoint along the X axis */
		//errorAdj = ((unsigned __int64) deltaX << 32) / (unsigned __int64) deltaY;
		errorAdj = ((unsigned long)deltaX << 16) / (unsigned long)deltaY;

		p = bits + x1 + width*(height - y1 -1); //pos = x1 + width*(height - y1 -1);
		while (--deltaY) // Draw all pixels other than the first and last
		{
			errorAccTemp = errorAcc; // remember currrent accumulated error
			errorAcc += errorAdj; //calculate error for next pixel
			if (errorAcc <= errorAccTemp)  //Overflow
			{
				p += xDir; //pos += xDir; 
						   //x1 += xDir;
			}
			p -= width; //pos -= width;
						//y1++;
			weighting = errorAcc >> intensityShift;
			//_______________________________________________
			alpha = (unsigned __int8)(weighting ^ weightingComplementMask);
			//pos = x1 + width*(height - y1 -1); //SetPixel(x1, y1, red, green, blue, alpha);
			//bits[pos] = RGBX(mix[red][GetRValueX(bits[pos])][alpha], mix[green][GetGValueX(bits[pos])][alpha], mix[blue][GetBValueX(bits[pos])][alpha]);
			*p = RGBX(mix[red][GetRValueX(*p)][alpha], mix[green][GetGValueX(*p)][alpha], mix[blue][GetBValueX(*p)][alpha]);
			//_______________________________________________
			alpha = (unsigned __int8)weighting;
			p2 = p + xDir; //pos2 = pos + xDir;
						   //pos = x1 + xDir + width*(height - y1 -1); //SetPixel(x1 + xDir, y1, red, green, blue, alpha);
						   //bits[pos2] = RGBX(mix[red][GetRValueX(bits[pos2])][alpha], mix[green][GetGValueX(bits[pos2])][alpha], mix[blue][GetBValueX(bits[pos2])][alpha]);
			*p2 = RGBX(mix[red][GetRValueX(*p2)][alpha], mix[green][GetGValueX(*p2)][alpha], mix[blue][GetBValueX(*p2)][alpha]);
		}
		bits[x2 + width*(height - y2 - 1)] = color; // Final pixel
		return;
	}

	//_______________________________________________________________________ X-major line
	/* Calculate 16-bit fixed-point fractional part of a
	pixel that Y advances each time X advances 1 pixel, truncating the
	result to avoid overrunning the endpoint along the X axis */
	errorAdj = ((unsigned long)deltaY << 16) / (unsigned long)deltaX;
	//errorAdj = ((unsigned __int64) deltaY << 32) / (unsigned __int64) deltaX;

	p = bits + x1 + width*(height - y1 -1); //pos = x1 + width*(height - y1 -1);
	while (--deltaX) // Draw all pixels other than the first and last
	{
		errorAccTemp = errorAcc; //remember currrent accumulated error
		errorAcc += errorAdj; // calculate error for next pixel
		if (errorAcc <= errorAccTemp) // Overflow
		{
			//y1++;
			p -= width; //pos -= width;
		}
		//x1 += xDir;
		p += xDir; //pos += xDir;

		weighting = errorAcc >> intensityShift;
		//____________________________________________________
		alpha = (unsigned __int8)(weighting ^ weightingComplementMask);
		//pos = x1 + width*(height - y1 -1); //SetPixel(x1, y1, red, green, blue, alpha);
		//bits[pos] = RGBX(mix[red][GetRValueX(bits[pos])][alpha], mix[green][GetGValueX(bits[pos])][alpha], mix[blue][GetBValueX(bits[pos])][alpha]);
		*p = RGBX(mix[red][GetRValueX(*p)][alpha], mix[green][GetGValueX(*p)][alpha], mix[blue][GetBValueX(*p)][alpha]);
		//____________________________________________________
		//
		alpha = (unsigned __int8)weighting;
		//pos = x1 + width*(height - y1 - 2); //SetPixel(x1, y1+1, red, green, blue, alpha);
		p2 = p - width; //pos2 = pos - width;
						//bits[pos2] = RGBX(mix[red][GetRValueX(bits[pos2])][alpha], mix[green][GetGValueX(bits[pos2])][alpha], mix[blue][GetBValueX(bits[pos2])][alpha]);	
		*p2 = RGBX(mix[red][GetRValueX(*p2)][alpha], mix[green][GetGValueX(*p2)][alpha], mix[blue][GetBValueX(*p2)][alpha]);
	}
	bits[x2 + width*(height - y2 -1)] = color; // Final pixel
}

//Gouraud Triangle
void GraphicsX::Triangle(int x1, int y1, COLORREF color1, int x2, int y2, COLORREF color2, int x3, int y3, COLORREF color3)
{
	//___________________________________________ Clip x1, y1
	if (x1 >= width) x1 = width-1;
	if (x1 < 0) x1 = 0;
	if (y1 >= height) y1 = height-1;
	if (y1 < 0) y1 = 0;
	//___________________________________________ Clip x2, y2
	if (x2 >= width) x2 = width-1;
	if (x2 < 0) x2 = 0;
	if (y2 >= height) y2 = height-1;
	if (y2 < 0) y2 = 0;
	//___________________________________________ Clip x3, y3
	if (x3 >= width) x3 = width-1;
	if (x3 < 0) x3 = 0;
	if (y3 >= height) y3 = height-1;
	if (y3 < 0) y3 = 0;
	//___________________________________________ Sort point such as y1 <= y2 <= y3
	int tmp;
	COLORREF tmpColor;
	if (y1 > y2)
	{
		tmp = x1;
		x1 = x2;
		x2 = tmp;
		//
		tmp = y1;
		y1 = y2;
		y2 = tmp;
		//
		tmpColor = color1;
		color1 = color2;
		color2 = tmpColor;
	}
	if (y1 > y3)
	{
		tmp = x1;
		x1 = x3;
		x3 = tmp;
		//
		tmp = y1;
		y1 = y3;
		y3 = tmp;
		//
		tmpColor = color1;
		color1 = color3;
		color3 = tmpColor;
	}
	if (y2 > y3)
	{
		tmp = x2;
		x2 = x3;
		x3 = tmp;
		//
		tmp = y2;
		y2 = y3;
		y3 = tmp;
		//
		tmpColor = color2;
		color2 = color3;
		color3 = tmpColor;
	}
	//_______________________________________________________ Extract colors
	const unsigned __int8 red1 = GetRValueX(color1);
	const unsigned __int8 green1 = GetGValueX(color1);
	const unsigned __int8 blue1 = GetBValueX(color1);
	//
	const unsigned __int8 red2 = GetRValueX(color2);
	const unsigned __int8 green2 = GetGValueX(color2);
	const unsigned __int8 blue2 = GetBValueX(color2);
	//
	const unsigned __int8 red3 = GetRValueX(color3);
	const unsigned __int8 green3 = GetGValueX(color3);
	const unsigned __int8 blue3 = GetBValueX(color3);
	//_______________________________________________________ Compute Y deltas
	const int dy1 = y2 - y1;
	const int dy2 = y3 - y1;
	const int dy3 = y3 - y2;
	//______________________________________________________ Compute X deltas
	double dx1 = 0.0;
	double dx2 = 0.0;
	double dx3 = 0.0;
	double dColor1 = 0.0;
	double dColor2 = 0.0;
	double dColor3 = 0.0;
	if (dy1 > 0)
	{
		dx1 = (x2 - x1)/(double)dy1;
		dColor1 = 255/(double)dy1;
	}
	if (dy2 > 0)
	{
		dx2 = (x3 - x1)/(double)dy2;
		dColor2 = 255/(double)dy2;
	}
	if (dy3 > 0)
	{
		dx3 = (x3 - x2)/(double)dy3;
		dColor3 = 255/(double)dy3;
	}
	//if (dx1 == 0 && dx2 == 0) return;
	//if (dx1 == 0 && dx3== 0) return;
	//if (dx2 == 0 && dx3 == 0) return;
	//______________________________________________________ Begin at the top vertex
	double start_x = x1;
	double end_x = x1;
	unsigned __int8 left_red = red1;
	unsigned __int8 left_green = green1;
	unsigned __int8 left_blue = blue1;
	double start_color_rate = 0.0;
	//
	unsigned __int8 right_red = red1;
	unsigned __int8 right_green = green1;
	unsigned __int8 right_blue = blue1;
	double end_color_rate = 0.0;
	//
	int y;
	//double alphaX = 0.0;
	//int alpha = 0;
	//double deltaX;
	//double dColorX;
	//int x;

	int rate;
	//int istart_x;
	//int iend_x;

	//__________________________________________________________________________________________________ Fill
	if (dy1 == 0)
	{
		//_______________________________P1*****P2
		//________________________________******
		//__________________________________P3
		if (x1 < x2)
		{
			start_x = x1;
			end_x = x2;
			for (y = y1; y <= y3; y++, start_x += dx2, end_x += dx3, start_color_rate += dColor2, end_color_rate += dColor3)
			{
				//____________________________ Compute left and right points
				//if (start_x < 0) break;
				//istart_x = (int)(start_x+0.5);
				//iend_x = (int)(end_x+0.5);
				//deltaX = iend_x - istart_x;//end_x - start_x;
				//if (deltaX <= 0.0) break;
				//dColorX = 255/deltaX;
				//____________________________ Update start color
				rate = (int)start_color_rate;
				if (rate > 255) rate = 255;
				//
				left_red = mix[red3][red1][rate];
				left_green = mix[green3][green1][rate];
				left_blue = mix[blue3][blue1][rate];
				//____________________________ Update end color
				rate = (int)end_color_rate;
				if (rate > 255) rate = 255;
				//
				right_red = mix[red3][red2][rate];
				right_green = mix[green3][green2][rate];
				right_blue = mix[blue3][blue2][rate];
				//___________________________ Draw horizontal line
				//x = istart_x;
				//p = bits + width*(height - y -1) + x;
				//alphaX = 0.0;
				//for(; x <= end_x; x++, p++, alphaX += dColorX)
				//{
				//	alpha = (int)alphaX;
				//	if (alpha > 255) alpha = 255;
				//	*p = RGBX(mix[end_red][start_red][alpha], mix[end_green][start_green][alpha], mix[end_blue][start_blue][alpha]);			
				//}
				DrawHorizontalLine(start_x, end_x, y, left_red, left_green, left_blue, right_red, right_green, right_blue);
			}
		}
		else
		{
			//_______________________________P2*****P1
			//________________________________******
			//__________________________________P3
			start_x = x2;
			end_x = x1;
			for (y = y1; y <= y3; y++, start_x += dx3, end_x += dx2, start_color_rate += dColor3, end_color_rate += dColor2)
			{
				////____________________________ Compute left and right points
				//if (start_x < 0) break;
				//istart_x = (int)(start_x+0.5);
				//iend_x = (int)(end_x+0.5);
				//deltaX = iend_x - istart_x;//end_x - start_x;
				//if (deltaX <= 0.0) break;
				//dColorX = 255/deltaX;
				//____________________________ Update start color
				rate = (int)start_color_rate;
				if (rate > 255) rate = 255;
				//
				left_red = mix[red3][red2][rate];
				left_green = mix[green3][green2][rate];
				left_blue = mix[blue3][blue2][rate];
				//____________________________ Update end color
				rate = (int)end_color_rate;
				if (rate > 255) rate = 255;
				//
				right_red = mix[red2][red1][rate];
				right_green = mix[green2][green1][rate];
				right_blue = mix[blue2][blue1][rate];
				//___________________________ Draw horizontal line
				//x = istart_x;
				//p = bits + width*(height - y -1) + x;
				//alphaX = 0.0;
				//for(; x <= end_x; x++, p++, alphaX += dColorX)
				//{
				//	alpha = (int)alphaX;
				//	if (alpha > 255) alpha = 255;
				//	*p = RGBX(mix[end_red][start_red][alpha], mix[end_green][start_green][alpha], mix[end_blue][start_blue][alpha]);			
				//}
				DrawHorizontalLine(start_x, end_x, y, left_red, left_green, left_blue, right_red, right_green, right_blue);
			}
		}
	}
	else if (dx1 > dx2)
	{
		//________________________________P1
		//________________________________**
		//________________________________***P2
		//________________________________**
		//________________________________P3
		start_color_rate = 0.0;
		for (y = y1; y < y2; y++, start_x += dx2, end_x += dx1, start_color_rate += dColor2, end_color_rate += dColor1)
		{
			//____________________________ Compute left and right points
			//istart_x = (int)(start_x+0.5);
			//iend_x = (int)(end_x+0.5);
			//deltaX = iend_x - istart_x;//end_x - start_x;
			//if (deltaX <= 0.0) continue;
			//dColorX = 255/deltaX;	
			//____________________________ Update start color
			rate = (int)start_color_rate;
			if (rate > 255) rate = 255;
			//
			left_red = mix[red3][red1][rate];
			left_green = mix[green3][green1][rate];
			left_blue = mix[blue3][blue1][rate];
			//____________________________ Update end color
			rate = (int)end_color_rate;
			if (rate > 255) rate = 255;
			//
			right_red = mix[red2][red1][rate];
			right_green = mix[green2][green1][rate];
			right_blue = mix[blue2][blue1][rate];
			//___________________________ Draw horizontal line
			//x = istart_x;
			//p = bits + width*(height - y -1) + x;
			//alphaX = 0.0;
			//for(; x <= end_x; x++, p++, alphaX += dColorX)
			//{
			//	alpha = (int)alphaX;
			//	if (alpha > 255) alpha = 255;
			//	*p = RGBX(mix[end_red][start_red][alpha], mix[end_green][start_green][alpha], mix[end_blue][start_blue][alpha]);			
			//}
			DrawHorizontalLine(start_x, end_x, y, left_red, left_green, left_blue, right_red, right_green, right_blue);
		}
		y = y2;
		end_x = x2;
		end_color_rate = 0;
		//
		for (y = y2; y <= y3; y++, start_x += dx2, end_x += dx3, start_color_rate += dColor2, end_color_rate += dColor3)
		{
			//____________________________ Compute left and right points
			//if (start_x < 0) break;
			//istart_x = (int)(start_x+0.5);
			//iend_x = (int)(end_x+0.5);
			//deltaX = iend_x - istart_x;//end_x - start_x;
			//if (deltaX <= 0.0) break;
			//dColorX = 255/deltaX;	
			//____________________________ Update start color
			rate = (int)start_color_rate;
			if (rate > 255) rate = 255;
			//
			left_red = mix[red3][red1][rate];
			left_green = mix[green3][green1][rate];
			left_blue = mix[blue3][blue1][rate];
			//____________________________ Update end color
			rate = (int)end_color_rate;
			if (rate > 255) rate = 255;
			//
			right_red = mix[red3][red2][rate];
			right_green = mix[green3][green2][rate];
			right_blue = mix[blue3][blue2][rate];
			//___________________________ Draw horizontal line
			//x = istart_x;
			//p = bits + width*(height - y -1) + x;
			//alphaX = 0.0;
			//for(; x <= end_x; x++, p++, alphaX += dColorX)
			//{
			//	alpha = (int)alphaX;
			//	if (alpha > 255) alpha = 255;
			//	*p = RGBX(mix[end_red][start_red][alpha], mix[end_green][start_green][alpha], mix[end_blue][start_blue][alpha]);			
			//}
			DrawHorizontalLine(start_x, end_x, y, left_red, left_green, left_blue, right_red, right_green, right_blue);
		}
	}
	else
	{
		//___________________________________P1
		//___________________________________**
		//________________________________P2***
		//___________________________________**
		//___________________________________P3
		start_color_rate = 0.0;
		for (y = y1 ; y < y2; y++, start_x += dx1, end_x += dx2, start_color_rate += dColor1, end_color_rate += dColor2)
		{
			//____________________________ Compute left and right points
			//istart_x = (int)(start_x+0.5);
			//iend_x = (int)(end_x+0.5);
			//deltaX = iend_x - istart_x;//end_x - start_x;
			//if (deltaX <= 0.0) continue;
			//dColorX = 255/deltaX;	
			//____________________________ Update start color
			rate = (int)start_color_rate;
			if (rate > 255) rate = 255;
			//
			left_red = mix[red2][red1][rate];
			left_green = mix[green2][green1][rate];
			left_blue = mix[blue2][blue1][rate];
			//____________________________ Update end color
			rate = (int)end_color_rate;
			if (rate > 255) rate = 255;
			//
			right_red = mix[red3][red1][rate];
			right_green = mix[green3][green1][rate];
			right_blue = mix[blue3][blue1][rate];
			//
			//x = (int)start_x;
			//p = bits + width*(height - y -1) + x;
			//alphaX = 0.0;
			////___________________________ Draw horizontal line
			//for(; x <= end_x; x++, p++, alphaX += dColorX)
			//{
			//	alpha = (int)alphaX;
			//	if (alpha > 255) alpha = 255;
			//	*p = RGBX(mix[end_red][start_red][alpha], mix[end_green][start_green][alpha], mix[end_blue][start_blue][alpha]);			
			//}
			DrawHorizontalLine(start_x, end_x, y, left_red, left_green, left_blue, right_red, right_green, right_blue);
		}
		start_x = x2;
		start_color_rate = 0;

		for (y = y2; y <= y3; y++, start_x += dx3, end_x += dx2, start_color_rate += dColor3, end_color_rate += dColor2)
		{
			//____________________________ Compute left and right points
			//if (start_x < 0) break;
			//istart_x = (int)(start_x+0.5);
			//iend_x = (int)(end_x+0.5);
			//deltaX = iend_x - istart_x;//end_x - start_x;
			//if (deltaX <= 0.0) break;
			//dColorX = 255/deltaX;	
			//____________________________ Update start color
			rate = (int)start_color_rate;
			if (rate > 255) rate = 255;
			//
			left_red = mix[red3][red2][rate];
			left_green = mix[green3][green2][rate];
			left_blue = mix[blue3][blue2][rate];
			//____________________________ Update end color
			rate = (int)end_color_rate;
			if (rate > 255) rate = 255;
			//
			right_red = mix[red3][red1][rate];
			right_green = mix[green3][green1][rate];
			right_blue = mix[blue3][blue1][rate];
			//___________________________ Draw horizontal line
			//x = (int)start_x;
			//p = bits + width*(height - y -1) + x;
			//alphaX = 0.0;
			//for(; x <= end_x; x++, p++, alphaX += dColorX)
			//{
			//	alpha = (int)alphaX;
			//	if (alpha > 255) alpha = 255;
			//	*p = RGBX(mix[end_red][start_red][alpha], mix[end_green][start_green][alpha], mix[end_blue][start_blue][alpha]);			
			//}
			DrawHorizontalLine(start_x, end_x, y, left_red, left_green, left_blue, right_red, right_green, right_blue);
		}
	}
}

void GraphicsX::DrawHorizontalLine(double& start_x, double& end_x, int& y, unsigned char& start_red, unsigned char& start_green, unsigned char& start_blue,
	unsigned char& end_red, unsigned char& end_green, unsigned char& end_blue)
{
	register unsigned __int32 * p;
	const int istart_x = (start_x < 0.0) ? 0: (int)floor(start_x);
	const int iend_x = (int)floor(end_x);
	const int deltaX = iend_x - istart_x+1;
	if (deltaX <= 0.0) return; // nothing to do
	const double deltaColorX = 255.0/deltaX;
	int ialpha;
	double alpha = 0.0;

	register int x = (int)(start_x + 0.5);
	p = bits + width*(height - y -1) + x;
	for (; x <= iend_x; x++, p++, alpha += deltaColorX)
	{
		ialpha = (int)alpha;
		if (ialpha > 255) ialpha = 255;
		*p = RGBX(mix[end_red][start_red][ialpha], mix[end_green][start_green][ialpha], mix[end_blue][start_blue][ialpha]);
	}
}

// With aliasing:  the alising is not perfect as the function does not know, if the line is a X-major or Y-major line
void GraphicsX::DrawHorizontalLine(double x1, double x2, int y, COLORREF color, unsigned __int8 red, unsigned __int8 green, unsigned __int8 blue)
{
	const int ix1 = (int)floor(x1);
	const int ix2 = (int)ceil(x2);
	const int scan_width = ix2 - ix1 + 1;
	if (scan_width <= 0) return;
	register unsigned __int32 * p = bits + width*(height - y -1) + (int)(ix1);
	register int j;

	//_______________________________________________________________ One point
	if (scan_width == 1)
	{
		*p = color;
		return;
	}
	else if (scan_width == 2)
	{
		*p = color;
		p++;
		*p = color;
	}
	//_______________________________________________________________ Several points
	const double alpha1Start = (x1 - ix1);
	const double alpha2Start = 1.0 - alpha1Start;
	const double alpha1End = (ix2 - x2);
	const double alpha2End = 1.0 - alpha1End;
	int alpha;
	for (j = 0; j < scan_width; j++, p++)
	{
		if (j == 0)
		{
			alpha = (int)(255*alpha2Start);
			if (alpha < 0) alpha = 0;
			*p = RGBX(mix[red][GetRValueX(*p)][alpha], mix[green][GetGValueX(*p)][alpha], mix[blue][GetBValueX(*p)][alpha]);
		}
		else if (j == scan_width -1)// && ix2 > x2)
		{
			alpha = (int)(255*alpha2End);
			if (alpha < 0) alpha = 0;
			*p = RGBX(mix[red][GetRValueX(*p)][alpha], mix[green][GetGValueX(*p)][alpha], mix[blue][GetBValueX(*p)][alpha]);
		}
		else
		{
			*p = color;
		}
	}
}

void GraphicsX::DrawVerticalLine(double y1, double y2, int x, COLORREF color, unsigned __int8 red, unsigned __int8 green, unsigned __int8 blue)
{
	const int iy1 = (int)floor(y1);
	const int iy2 = (int)ceil(y2);
	const int scan_height = iy2 - iy1 + 1;
	if (scan_height <= 0) return;
	register unsigned __int32 * p = bits + width*(height - iy1 -1) + x;
	register int j;

	//_______________________________________________________________ One point
	if (scan_height == 1)
	{
		*p = color;
		return;
	}
	//else if (scan_height == 2)
	//{
	//	*p = color;
	//	p-= width;
	//	*p = color;
	//}
	//_______________________________________________________________ Several points
	const double alpha1Start = (y1 - iy1);
	const double alpha2Start = 1.0 - alpha1Start;
	const double alpha1End = (iy2 - y2);
	const double alpha2End = 1.0 - alpha1End;
	int alpha;
	for (j = 0; j < scan_height; j++, p -= width)
	{
		if (j == 0)
		{
			alpha = (int)(255*alpha2Start);
			if (alpha < 0) alpha = 0;
			*p = RGBX(mix[red][GetRValueX(*p)][alpha], mix[green][GetGValueX(*p)][alpha], mix[blue][GetBValueX(*p)][alpha]);
		}
		else if (j == scan_height -1)
		{
			alpha = (int)(255*alpha2End);
			if (alpha < 0) alpha = 0;
			*p = RGBX(mix[red][GetRValueX(*p)][alpha], mix[green][GetGValueX(*p)][alpha], mix[blue][GetBValueX(*p)][alpha]);
		}
		else
		{
			*p = color;
		}
	}
}

void GraphicsX::Triangle(int x1, int y1, int x2, int y2, int x3, int y3, COLORREF color, bool aliasing)
{
	//___________________________________________ Clip x1, y1
	if (x1 >= width) x1 = width-1;
	if (x1 < 0) x1 = 0;
	if (y1 >= height) y1 = height-1;
	if (y1 < 0) y1 = 0;
	//___________________________________________ Clip x2, y2
	if (x2 >= width) x2 = width-1;
	if (x2 < 0) x2 = 0;
	if (y2 >= height) y2 = height-1;
	if (y2 < 0) y2 = 0;
	//___________________________________________ Clip x3, y3
	if (x3 >= width) x3 = width-1;
	if (x3 < 0) x3 = 0;
	if (y3 >= height) y3 = height-1;
	if (y3 < 0) y3 = 0;
	//___________________________________________ Sort point such as y1 <= y2 <= y3
	int tmp;
	if (y1 > y2)
	{
		tmp = x1;
		x1 = x2;
		x2 = tmp;
		//
		tmp = y1;
		y1 = y2;
		y2 = tmp;
	}
	if (y1 > y3)
	{
		tmp = x1;
		x1 = x3;
		x3 = tmp;
		//
		tmp = y1;
		y1 = y3;
		y3 = tmp;
	}
	if (y2 > y3)
	{
		tmp = x2;
		x2 = x3;
		x3 = tmp;
		//
		tmp = y2;
		y2 = y3;
		y3 = tmp;
	}
	//_______________________________________________________ Extract colors
	const unsigned __int8 red = GetRValueX(color);
	const unsigned __int8 green = GetGValueX(color);
	const unsigned __int8 blue = GetBValueX(color);
	//_______________________________________________________ Compute X deltas
	const int dx21 = x2 - x1;
	const int dx31= x3 - x1;
	const int dx32 = x3 - x2;
	//_______________________________________________________ Compute Y deltas
	const int dy21 = y2 - y1;
	const int dy31= y3 - y1;
	const int dy32 = y3 - y2;
	//_______________________________________________________ Compute dx/dy
	const double dxdy21 = (dy21 > 0) ? dx21/(double)dy21 : 0.0;
	const double dxdy31 = (dy31 > 0) ? dx31/(double)dy31 : 0.0;
	const double dxdy32 = (dy32 > 0) ? dx32/(double)dy32 : 0.0;
	//______________________________________________________ Begin at the top vertex
	double start_x = x1;
	double end_x = x1;
	int y;
	//if (dx1 == 0 && dx2 == 0) return;
	//if (dx1 == 0 && dx3== 0) return;
	//if (dx2 == 0 && dx3 == 0) return;
	//______________________________________________________ Fill

	if (dy21 == 0)
	{
		//_______________________________P1*****P2
		//________________________________******
		//__________________________________P3
		if (x1 < x2)
		{
			start_x = x1;
			end_x = x2;
			if (aliasing == true)
			{
				for (y = y1 ; y <= y3; y++, start_x += dxdy31, end_x += dxdy32)
				{
					DrawHorizontalLine(start_x, end_x, y, color, red, green, blue);
				}
			}
			else
			{
				for (y = y1 ; y <= y3; y++, start_x += dxdy31, end_x += dxdy32)
				{
					DrawHorizontalLine(start_x, end_x, y, color);
				}
			}
		}
		else
		{
			//_______________________________P2*****P1
			//________________________________******
			//__________________________________P3
			start_x = x2;
			end_x = x1;
			if (aliasing == true)
			{
				for (y = y1 ; y <= y3; y++, start_x += dxdy32, end_x += dxdy31)
				{
					if (start_x < 0) break;
					DrawHorizontalLine(start_x, end_x, y, color, red, green, blue);
				}
			}
			else
			{
				for (y = y1 ; y <= y3; y++, start_x += dxdy32, end_x += dxdy31)
				{
					if (start_x < 0) break;
					DrawHorizontalLine(start_x, end_x, y, color);
				}
			}
		}
	}
	else if (dxdy21 > dxdy31)
	{
		//________________________________P1
		//________________________________**
		//________________________________***P2
		//________________________________**
		//________________________________P3
		if (aliasing == true)
		{
			for (y = y1 ; y < y2; y++, start_x += dxdy31, end_x += dxdy21)
			{
				DrawHorizontalLine(start_x, end_x, y, color, red, green, blue);
			}
			end_x = x2;
			y = y2;
			for (; y <= y3; y++, start_x += dxdy31, end_x += dxdy32)
			{
				if (start_x < 0) break;
				DrawHorizontalLine(start_x, end_x, y, color, red, green, blue);
			}
		}
		else
		{
			for (y = y1 ; y < y2; y++, start_x += dxdy31, end_x += dxdy21)
			{
				DrawHorizontalLine(start_x, end_x, y, color);
			}
			end_x = x2;
			y = y2;
			for (; y <= y3; y++, start_x += dxdy31, end_x += dxdy32)
			{
				if (start_x < 0) break;
				DrawHorizontalLine(start_x, end_x, y, color);
			}
		}
	}
	else
	{
		//___________________________________P1
		//___________________________________**
		//________________________________P2***
		//___________________________________**
		//___________________________________P3
		if (aliasing == true)
		{
			for (y = y1 ; y < y2; y++, start_x += dxdy21, end_x += dxdy31)
			{
				DrawHorizontalLine(start_x, end_x, y, color, red, green, blue);
			}
			start_x = x2;
			y = y2;
			for (; y <= y3; y++, start_x += dxdy32, end_x += dxdy31)
			{
				if (start_x < 0) break;
				DrawHorizontalLine(start_x, end_x, y, color, red, green, blue);
			}
		}
		else
		{
			for (y = y1 ; y < y2; y++, start_x += dxdy21, end_x += dxdy31)
			{
				DrawHorizontalLine(start_x, end_x, y, color);
			}
			start_x = x2;
			y = y2;
			for (; y <= y3; y++, start_x += dxdy32, end_x += dxdy31)
			{
				if (start_x < 0) break;
				DrawHorizontalLine(start_x, end_x, y, color);
			}
		}
	}
	//if (aliasing == true)
	//{
	//	WuLineUnclipped(x1, y1, x2, y2, color);
	//	WuLineUnclipped(x2, y2, x3, y3, color);
	//	WuLineUnclipped(x1, y1, x3, y3, color);
	//}
}

void GraphicsX::DrawHorizontalLine(double x1, double x2, int y, COLORREF color)
{
	const int ix1 = (int)(x1 + 0.5);
	const int ix2 = (int)(x2 + 0.5);
	const int scan_width = ix2 - ix1 + 1;
	if (scan_width <= 0) return;
	register unsigned __int32 * p = bits + width*(height - y -1) + (int)(ix1);
	register int j;
	for (j = 0; j < scan_width; j++, p++)
	{
		*p = color;
	}
}

//You must use RGBX instead of RGB
void GraphicsX::WuLineCS(__int16 x1, __int16 y1, __int16 x2, __int16 y2, COLORREF color)
{
	if (CohenSutherlandClipping(x1, y1, x2, y2) == true) WuLineUnclipped(x1, y1, x2, y2, color);
}


//_____________________________________________________________________ Sys::Convert
Convert::Convert()
{
}

Convert::~Convert()
{
}

void Convert::HtmlToText(wstring& in_out)
{
	Sys::TextAssistant::Replace(in_out, L"&quot;", L"\"", true);
	Sys::TextAssistant::Replace(in_out, L"&amp;", L"&", true);
	Sys::TextAssistant::Replace(in_out, L"&lt;", L"<", true);
	Sys::TextAssistant::Replace(in_out, L"&gt;", L">", true);
	Sys::TextAssistant::Replace(in_out, L"&nbsp;", L" ", true);
	Sys::TextAssistant::Replace(in_out, L"&iexcl;", L"¡", true);
	Sys::TextAssistant::Replace(in_out, L"&iquest;", L"¿", true);
	 Sys::TextAssistant::Replace(in_out, L"&Agrave;", L"À", true);
	 Sys::TextAssistant::Replace(in_out, L"&Aacute;", L"Á", true);
	 Sys::TextAssistant::Replace(in_out, L"&Acirc;", L"Â", true);
	 Sys::TextAssistant::Replace(in_out, L"&Atilde;", L"Ã", true);
	 Sys::TextAssistant::Replace(in_out, L"&Auml;", L"Ä", true);
	 Sys::TextAssistant::Replace(in_out, L"&Aring;", L"Å", true);
	 Sys::TextAssistant::Replace(in_out, L"&AElig;", L"Æ", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ccedil;", L"Ç", true);
	 Sys::TextAssistant::Replace(in_out, L"&Egrave;", L"È", true);
	 Sys::TextAssistant::Replace(in_out, L"&Eacute;", L"É", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ecirc;", L"Ê", true);
	 Sys::TextAssistant::Replace(in_out, L"&Euml;", L"Ë", true);
	 Sys::TextAssistant::Replace(in_out, L"&Igrave;", L"Ì", true);
	 Sys::TextAssistant::Replace(in_out, L"&Iacute;", L"Í", true);
	 Sys::TextAssistant::Replace(in_out, L"&Icirc;", L"Î", true);
	 Sys::TextAssistant::Replace(in_out, L"&Iuml;", L"Ï", true);
	 Sys::TextAssistant::Replace(in_out, L"&ETH;", L"Ð", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ntilde;", L"Ñ", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ograve;", L"Ò", true);
	 Sys::TextAssistant::Replace(in_out, L"&Oacute;", L"Ó", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ocirc;", L"Ô", true);
	 Sys::TextAssistant::Replace(in_out, L"&Otilde;", L"Õ", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ouml;", L"Ö", true);
	 Sys::TextAssistant::Replace(in_out, L"&times;", L"×", true);
	 Sys::TextAssistant::Replace(in_out, L"&Oslash;", L"Ø", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ugrave;", L"Ù", true);
	 Sys::TextAssistant::Replace(in_out, L"&Uacute;", L"Ú", true);
	 Sys::TextAssistant::Replace(in_out, L"&Ucirc;", L"Û", true);
	 Sys::TextAssistant::Replace(in_out, L"&Uuml;", L"Ü", true);
	 Sys::TextAssistant::Replace(in_out, L"&Yacute;", L"Ý", true);
	 Sys::TextAssistant::Replace(in_out, L"&THORN;", L"Þ", true);
	 Sys::TextAssistant::Replace(in_out, L"&szlig;", L"ß", true);
	 Sys::TextAssistant::Replace(in_out, L"&agrave;", L"à", true);
	 Sys::TextAssistant::Replace(in_out, L"&aacut;e", L"á", true);
	 Sys::TextAssistant::Replace(in_out, L"&acirc;", L"â", true);
	 Sys::TextAssistant::Replace(in_out, L"&atilde;", L"ã", true);
	 Sys::TextAssistant::Replace(in_out, L"&auml;", L"ä", true);
	 Sys::TextAssistant::Replace(in_out, L"&aring;", L"å", true);
	 Sys::TextAssistant::Replace(in_out, L"&aelig;", L"æ", true);
	 Sys::TextAssistant::Replace(in_out, L"&ccedil;", L"ç", true);
	 Sys::TextAssistant::Replace(in_out, L"&egrave;", L"è", true);
	 Sys::TextAssistant::Replace(in_out, L"&eacute;", L"é", true);
	 Sys::TextAssistant::Replace(in_out, L"&ecirc;", L"ê", true);
	 Sys::TextAssistant::Replace(in_out, L"&euml;", L"ë", true);
	 Sys::TextAssistant::Replace(in_out, L"&igrave;", L"ì", true);
	 Sys::TextAssistant::Replace(in_out, L"&iacute;", L"í", true);
	 Sys::TextAssistant::Replace(in_out, L"&icirc;", L"î", true);
	 Sys::TextAssistant::Replace(in_out, L"&iuml;", L"ï", true);
	 Sys::TextAssistant::Replace(in_out, L"&eth;", L"ð", true);
	 Sys::TextAssistant::Replace(in_out, L"&ntilde;", L"ñ", true);
	 Sys::TextAssistant::Replace(in_out, L"&ograve;", L"ò", true);
	 Sys::TextAssistant::Replace(in_out, L"&oacute;", L"ó", true);
	 Sys::TextAssistant::Replace(in_out, L"&ocirc;", L"ô", true);
	 Sys::TextAssistant::Replace(in_out, L"&otilde;", L"õ", true);
	 Sys::TextAssistant::Replace(in_out, L"&ouml;", L"ö", true);
	 Sys::TextAssistant::Replace(in_out, L"&divide;", L"÷", true);
	 Sys::TextAssistant::Replace(in_out, L"&oslash;", L"ø", true);
	 Sys::TextAssistant::Replace(in_out, L"&ugrave;", L"ù", true);
	 Sys::TextAssistant::Replace(in_out, L"&uacute;", L"ú", true);
	 Sys::TextAssistant::Replace(in_out, L"&ucirc;", L"û", true);
	 Sys::TextAssistant::Replace(in_out, L"&uuml;", L"ü", true);
	 Sys::TextAssistant::Replace(in_out, L"&yacute;", L"ý", true);
	 Sys::TextAssistant::Replace(in_out, L"&thorn;", L"þ", true);
	 Sys::TextAssistant::Replace(in_out, L"&yuml;", L"ÿ", true);
	 Sys::TextAssistant::Replace(in_out, L"&#32;", L" ", true);
	Sys::TextAssistant::Replace(in_out, L"&#33;", L"!", true);
	Sys::TextAssistant::Replace(in_out, L"&#34;", L"\"", true);
	Sys::TextAssistant::Replace(in_out, L"&#35;", L"#", true);
	Sys::TextAssistant::Replace(in_out, L"& #36;", L"$", true);
	Sys::TextAssistant::Replace(in_out, L"&#37;", L"%", true);
	Sys::TextAssistant::Replace(in_out, L"&#38;", L"&", true);
	Sys::TextAssistant::Replace(in_out, L"&#39;", L"'", true);
	Sys::TextAssistant::Replace(in_out, L"& #40;", L"(", true);
	Sys::TextAssistant::Replace(in_out, L"&#41;", L")", true);
	Sys::TextAssistant::Replace(in_out, L"&#42;", L"*", true);
	Sys::TextAssistant::Replace(in_out, L"&#43;", L"+", true);
	Sys::TextAssistant::Replace(in_out, L"& #44;", L",", true);
	Sys::TextAssistant::Replace(in_out, L"&#45;", L"-", true);
	Sys::TextAssistant::Replace(in_out, L"&#46;", L".", true);
	Sys::TextAssistant::Replace(in_out, L"&#47;", L"/", true);
}

wchar_t* Convert::ToHtml(wchar_t c)
{
	switch(c)
	{
	case (unsigned char)'"': return L"&quot;";
	case (unsigned char)'&': return L"&amp;";
	case (unsigned char)'<': return L"&lt;";
	case (unsigned char)'>': return L"&gt;";
	case (unsigned char)' ': return L"&nbsp;";
	case (unsigned char)'¡': return L"&iexcl;";
	case (unsigned char)'¢': return L"&cent;";
	case (unsigned char)'£': return L"&pound;";
	case (unsigned char)'¤': return L"&curren;";
	case (unsigned char)'¥': return L"&yen;";
	case (unsigned char)'¦': return L"&brvbar;";
	case (unsigned char)'§': return L"&sect;";
	case (unsigned char)'¨': return L"&uml;";
	case (unsigned char)'©': return L"&copy;";
	case (unsigned char)'ª': return L"&ordf;";
	case (unsigned char)'«': return L"&laquo;";
	case (unsigned char)'¬': return L"&no;";
	//case (unsigned char)'­': return L"&shy;";
	case (unsigned char)'®': return L"&reg;";
	//case (unsigned char)'¯': return L"&macr;";
	//case (unsigned char)'°': return L"&deg;";
	//case (unsigned char)'±': return L"&plusmn;";
	//case (unsigned char)'²': return L"&sup2;";
	//case (unsigned char)'³': return L"&sup3;";
	//case (unsigned char)'´': return L"&acute;";
	//case (unsigned char)'µ': return L"&micro;";
	//case (unsigned char)'¶': return L"&para;";
	//case (unsigned char)'·': return L"&middot;";
	//case (unsigned char)'¸': return L"&cedil;";
	//case (unsigned char)'¹': return L"&sup1;";
	//case (unsigned char)'º': return L"&ordm;";
	//case (unsigned char)'»': return L"&raquo;";
	//case (unsigned char)'¼': return L"&frac14;";
	//case (unsigned char)'½': return L"&frac12;";
	//case (unsigned char)'¾': return L"&frac34;";
	case (unsigned char)'¿': return L"&iquest;";
	case (unsigned char)'À': return L"&Agrave;";
	case (unsigned char)'Á': return L"&Aacute;";
	case (unsigned char)'Â': return L"&Acirc;";
	case (unsigned char)'Ã': return L"&Atilde;";
	case (unsigned char)'Ä': return L"&Auml;";
	case (unsigned char)'Å': return L"&Aring;";
	case (unsigned char)'Æ': return L"&AElig;";
	case (unsigned char)'Ç': return L"&Ccedil;";
	case (unsigned char)'È': return L"&Egrave;";
	case (unsigned char)'É': return L"&Eacute;";
	case (unsigned char)'Ê': return L"&Ecirc;";
	case (unsigned char)'Ë': return L"&Euml;";
	case (unsigned char)'Ì': return L"&Igrave;";
	case (unsigned char)'Í': return L"&Iacute;";
	case (unsigned char)'Î': return L"&Icirc;";
	case (unsigned char)'Ï': return L"&Iuml;";
	case (unsigned char)'Ð': return L"&ETH;";
	case (unsigned char)'Ñ': return L"&Ntilde;";
	case (unsigned char)'Ò': return L"&Ograve;";
	case (unsigned char)'Ó': return L"&Oacute;";
	case (unsigned char)'Ô': return L"&Ocirc;";
	case (unsigned char)'Õ': return L"&Otilde;";
	case (unsigned char)'Ö': return L"&Ouml;";
	case (unsigned char)'×': return L"&times;";
	case (unsigned char)'Ø': return L"&Oslash;";
	case (unsigned char)'Ù': return L"&Ugrave;";
	case (unsigned char)'Ú': return L"&Uacute;";
	case (unsigned char)'Û': return L"&Ucirc;";
	case (unsigned char)'Ü': return L"&Uuml;";
	case (unsigned char)'Ý': return L"&Yacute;";
	case (unsigned char)'Þ': return L"&THORN;";
	case (unsigned char)'ß': return L"&szlig;";
	case (unsigned char)'à': return L"&agrave;";
	case (unsigned char)'á': return L"&aacut;e";
	case (unsigned char)'â': return L"&acirc;";
	case (unsigned char)'ã': return L"&atilde;";
	case (unsigned char)'ä': return L"&auml;";
	case (unsigned char)'å': return L"&aring;";
	case (unsigned char)'æ': return L"&aelig;";
	case (unsigned char)'ç': return L"&ccedil;";
	case (unsigned char)'è': return L"&egrave;";
	case (unsigned char)'é': return L"&eacute;";
	case (unsigned char)'ê': return L"&ecirc;";
	case (unsigned char)'ë': return L"&euml;";
	case (unsigned char)'ì': return L"&igrave;";
	case (unsigned char)'í': return L"&iacute;";
	case (unsigned char)'î': return L"&icirc;";
	case (unsigned char)'ï': return L"&iuml;";
	case (unsigned char)'ð': return L"&eth;";
	case (unsigned char)'ñ': return L"&ntilde;";
	case (unsigned char)'ò': return L"&ograve;";
	case (unsigned char)'ó': return L"&oacute;";
	case (unsigned char)'ô': return L"&ocirc;";
	case (unsigned char)'õ': return L"&otilde;";
	case (unsigned char)'ö': return L"&ouml;";
	case (unsigned char)'÷': return L"&divide;";
	case (unsigned char)'ø': return L"&oslash;";
	case (unsigned char)'ù': return L"&ugrave;";
	case (unsigned char)'ú': return L"&uacute;";
	case (unsigned char)'û': return L"&ucirc;";
	case (unsigned char)'ü': return L"&uuml;";
	case (unsigned char)'ý': return L"&yacute;";
	case (unsigned char)'þ': return L"&thorn;";
	case (unsigned char)'ÿ'	: return L"&yuml;";
	}
	return NULL;
}

void Convert::ToHtml(const wchar_t * input, wstring& output)
{
	wchar_t * html;
	const int len = (int)wcslen(input);
	output.reserve(len);

	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		html = Sys::Convert::ToHtml(*p);
		if (html == NULL)
		{
			output += *p;
		}
		else
		{
			output += html;
		}
	}
}

wchar_t* Convert::ToXml(wchar_t c)
{
	switch(c)
	{
	case (unsigned char)'&': return L"&amp;";
	case (unsigned char)'<': return L"&lt;";
	case (unsigned char)'>': return L"&gt;";
	case (unsigned char)'%': return L"&#37;";
	case (unsigned char)'\'': return L"&apos;";
	case (unsigned char)'\"': return L"&quot;";
	}
	return NULL;
}

void Convert::FromXml(wstring& in_out)
{
	Sys::TextAssistant::Replace(in_out, L"&#37;", L"%", false);
	Sys::TextAssistant::Replace(in_out, L"&gt;", L">", false);
	Sys::TextAssistant::Replace(in_out, L"&lt;", L"<", false);
	Sys::TextAssistant::Replace(in_out, L"&apos;", L"\'", false);
	Sys::TextAssistant::Replace(in_out, L"&quot;", L"\"", false);
	Sys::TextAssistant::Replace(in_out, L"&amp;", L"&", false);
}

void Convert::ToXml(const wchar_t * input, wstring& output)
{
	wchar_t * xmlTmp;
	const int len = (int)wcslen(input);
	output.clear();
	output.reserve(len);

	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		xmlTmp = Sys::Convert::ToXml(*p);
		if (xmlTmp == NULL)
		{
			output += *p;
		}
		else
		{
			output += xmlTmp;
		}
	}
}

void Convert::ToXml(const wstring& input, wstring& output)
{
	wchar_t * xmlTmp;
	const int len = (int)input.length();
	output.clear();
	output.reserve(len);
	wchar_t p;

	for(int i = 0; i<len; i++)
	{
		p = input[i];
		xmlTmp = Sys::Convert::ToXml(p);
		if (xmlTmp == NULL)
		{
			output += p;
		}
		else
		{
			output += xmlTmp;
		}
	}
}

int Convert::HexToInteger(wchar_t input)
{
	switch(tolower(input))
	{
	case '0': return 0;
	case '1': return 1;
	case '2': return 2;
	case '3': return 3;
	case '4': return 4;
	case '5': return 5;
	case '6': return 6;
	case '7': return 7;
	case '8': return 8;
	case '9': return 9;
	case 'a': return 10;
	case 'b': return 11;
	case 'c': return 12;
	case 'd': return 13;
	case 'e': return 14;
	case 'f': return 15;
	}
	return 0;
}

bool Convert::HexRequiresCoding(char input)
{
	if ('a' <= input && input <= 'z') return false;
	if ('A' <= input && input <='Z') return false;
	if ('0' <= input && input <='9') return false;
	//if (input == '.') return false;
	//if (input == '-') return false;
	//if (input == '~') return false;
	//if (input == '_') return false;
	return true;
}

bool Convert::HexRequiresCoding(wchar_t input)
{
	if ('a' <= input && input <= 'z') return false;
	if ('A' <= input && input <='Z') return false;
	if ('0' <= input && input <='9') return false;
	//if (input == '.') return false;
	//if (input == '-') return false;
	//if (input == '~') return false;
	//if (input == '_') return false;
	return true;
}

int Convert::HexComputeLength(const char* input)
{
	int len = 0;
	for(char* p = (char*)input; *p != '\0'; p++)
	{
		//___________________________________ space uses one character, but requires coding
		if (*p == ' ')
		{
			len++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			len += 3;
		}
		else
		{
			len++;
		}
	}
	return len;
}

int Convert::HexComputeLength(const wchar_t* input)
{
	int len = 0;
	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		//___________________________________ space uses one character, but requires coding
		if (*p == ' ')
		{
			len++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			len += 3;
		}
		else
		{
			len++;
		}
	}
	return len;
}

// Converts a string to its equivalent hexadecimal
bool Convert::WstringToHex(const wchar_t* input, wstring& output)
{
	const wchar_t * hex =L"0123456789ABCDEF";
	//__________________________________ Compute Length
	const int len = Sys::Convert::HexComputeLength(input);
	if (len == 0)
	{
		output.clear();
		return true;
	}
	//_________________________________ Memory Allocation
	try
	{
		output.resize(len);
	}
	catch(const std::bad_alloc&)
	{
		output.clear();
		return false;
	}
	int i = 0;
	//__________________________________ Convert
	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		//______________________________________ Check for spaces
		if (*p == ' ')
		{
			output[i] = '+';
			i++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			output[i] = '%';
			i++;
			output[i] = hex[*p/16];	
			i++;
			output[i] = hex[*p%16];
			i++;
		}
		else
		{
			output[i] = *p;
			i++;
			continue;
		}
	}
	return true;
}

// Converts a UTF8 string to its equivalent hexadecimal
bool Convert::UTF8ToHex(const char* input, string& output)
{
	const char * hex ="0123456789ABCDEF";
	//__________________________________ Compute Length
	const int len = Sys::Convert::HexComputeLength(input);
	if (len == 0)
	{
		output.clear();
		return true;
	}
	//_________________________________ Memory Allocation
	try
	{
		output.resize(len);
	}
	catch(const std::bad_alloc&)
	{
		output.clear();
		return false;
	}
	int i = 0;
	//__________________________________ Convert
	for(char* p = (char*)input; *p != '\0'; p++)
	{
		//______________________________________ Check for spaces
		if (*p == ' ')
		{
			output[i] = '+';
			i++;
			continue;
		}
		if (Sys::Convert::HexRequiresCoding(*p) == true)
		{
			output[i] = '%';
			i++;
			output[i] = hex[*p/16];	
			i++;
			output[i] = hex[*p%16];
			i++;
		}
		else
		{
			output[i] = *p;
			i++;
			continue;
		}
	}
	return true;
}

bool Convert::HexToUTF8(const char* input, string& output)
{
	output.clear();
	const int len = (int)strlen(input);
	if (len == 0) return true;
	output.reserve(len);
	int decimalValue;
	bool decode1 = false;
	bool decode2 = false;
	for(char* p = (char*)input; *p != '\0'; p++)
	{
		if (decode1 == false && decode2 == false)
		{
			if (*p == '%')
			{
				decode1 = true;
				decode2 = false;
				continue;
			}
			else if (*p == '+')
			{
				output += ' ';
			}
			else
			{
				output += (*p);
			}		
		}
		else if (decode1 == true && decode2 == false)//________ We process first letter after %
		{
			if ('0' <= *p  && *p <= '9')
			{
				decimalValue = (*p - '0') * 16;
			}
			else if ('A' <= *p && *p<='F') // Upper Case
			{
				decimalValue = (( *p - 'A') + 10) * 16;
			}
			else if ('a' <= *p && *p<='f') // Lower Case
			{
				decimalValue = ((*p - 'a') + 10) * 16;
			}
			decode1 = true;
			decode2 = true;
		}
		else if (decode1 == true && decode2 == true)//_________We process second letter after %
		{
			if ('0' <= *p  && *p <= '9')
			{
				decimalValue += (*p-'0');
			}
			else if ('A' <= *p && *p <= 'F') // Upper Case
			{
				decimalValue += (( *p - 'A') + 10);
			}
			else if ('a' <= *p && *p <= 'f') // Lower Case
			{
				decimalValue += (( *p - 'a') + 10);
			}
			output += ((char)(decimalValue));
			decode1 = false;
			decode2 = false;
		}
	}
	return true;
}

bool Convert::HexToUTF8(const wchar_t* input, string& output)
{
	output.clear();
	const int len = (int)wcslen(input);
	if (len == 0) return true;
	output.reserve(len);
	int decimalValue;
	bool decode1 = false;
	bool decode2 = false;
	for(wchar_t* p = (wchar_t*)input; *p != '\0'; p++)
	{
		if (decode1 == false && decode2 == false)
		{
			if (*p == '%')
			{
				decode1 = true;
				decode2 = false;
				continue;
			}
			else if (*p == '+')
			{
				output += ' ';
			}
			else
			{
				output += (char)(*p);
			}		
		}
		else if (decode1 == true && decode2 == false)//________ We process first letter after %
		{
			if ('0' <= *p  && *p <= '9')
			{
				decimalValue = (*p - '0') * 16;
			}
			else if ('A' <= *p && *p<='F') // Upper Case
			{
				decimalValue = (( *p - 'A') + 10) * 16;
			}
			else if ('a' <= *p && *p<='f') // Lower Case
			{
				decimalValue = ((*p - 'a') + 10) * 16;
			}
			decode1 = true;
			decode2 = true;
		}
		else if (decode1 == true && decode2 == true)//_________We process second letter after %
		{
			if ('0' <= *p  && *p <= '9')
			{
				decimalValue += (*p-'0');
			}
			else if ('A' <= *p && *p <= 'F') // Upper Case
			{
				decimalValue += (( *p - 'A') + 10);
			}
			else if ('a' <= *p && *p <= 'f') // Lower Case
			{
				decimalValue += (( *p - 'a') + 10);
			}
			output += ((char)decimalValue);
			decode1 = false;
			decode2 = false;
		}
	}
	return true;
}

double Convert::MseToGrade(const double mse) //Mean squared error to Grade [0 to 100]
{
	double value = 20.0*fabs(log10(fabs(sqrt(mse))));
	if (value<0.0) value = 0.0;
	if (value>100.0) value = 100.0;
	return value;
}

COLORREF Convert::TextToColorRef(const wchar_t* text)
{
	if (text == NULL) return RGB (0, 0, 0);
	const int len = (int)wcslen(text);
	if (len<5) return RGB (0, 0, 0);
	int red = 0, green = 0, blue = 0;
	//______________________________________________________________________________________Case 1: #FFACO5
	const wchar_t* pound = wcschr(text, '#');
	if (pound != NULL)
	{
		if ((int)wcslen(pound) < 7) return RGB (0, 0, 0);
		red = 16*Sys::Convert::HexToInteger(pound[1])+Sys::Convert::HexToInteger(pound[2]);
		green = 16*Sys::Convert::HexToInteger(pound[3])+Sys::Convert::HexToInteger(pound[4]);
		blue = 16*Sys::Convert::HexToInteger(pound[5])+Sys::Convert::HexToInteger(pound[6]);
		return RGB(red, green, blue);
	}
	//______________________________________________________________________________________ Case 2: 255, 654, 4554
	int next = 0;
	int i, j;
	wchar_t tmp[16];
	while ( (text[next]<'0' || text[next]>'9') && next<len) next++; // Keep going until find first digit
	//________________________________ red
	for(i = 0, j=next; i<16 && j<len; i++, j++)
	{
		tmp[i] = text[j];
		if (tmp[i]<'0' || tmp[i]>'9') // break when not finding a digit
		{
			tmp[i] = '\0';
			tmp[15] = '\0';
			red = _wtoi(tmp);
			next = j;
			break;
		}
	}
	while ( (text[next]<'0' || text[next]>'9') && next<len) next++; // Keep going until find first digit
	//________________________________ green
	for(i = 0, j=next; i<16 && j<len; i++, j++)
	{
		tmp[i] = text[j];
		if (tmp[i]<'0' || tmp[i]>'9') // break when not finding a digit
		{
			tmp[i] = '\0';
			tmp[15] = '\0';
			green = _wtoi(tmp);
			next = j;
			break;
		}
	}
	while ( (text[next]<'0' || text[next]>'9') && next<len) next++; // Keep going until find first digit
	//________________________________ blue
	for(i = 0, j=next; i<16 && j<len; i++, j++)
	{
		tmp[i] = text[j];
		if (j==len-1)
		{
			if ( (i+1)<16)
			{
				tmp[i+1] = '\0';
				tmp[15] = '\0';
				blue = _wtoi(tmp);
				break;
			}
		}
		if (tmp[i]<'0' || tmp[i]>'9')
		{
			tmp[i] = '\0';
			tmp[15] = '\0';
			blue = _wtoi(tmp);
			break;
		}
	}
	return RGB(red, green, blue);
}

COLORREF Convert::HSLColorToRgb(const Sys::HSLColor& hslColor)
{
	//_____________________________________ Without Color
	if (hslColor.saturation == 0.0)
	{
		const unsigned char value = (unsigned char)(hslColor.luminance*255);
		return RGB(value, value, value);
	}
	//_____________________________________ With Color
	const double b = (hslColor.luminance <= 0.5) ? hslColor.luminance+hslColor.luminance*hslColor.saturation : hslColor.luminance+hslColor.saturation-hslColor.luminance*hslColor.saturation;
	const double a = 2*hslColor.luminance - b;
	return RGB(Sys::Convert::Mag(a, b, hslColor.hue+120.0), Sys::Convert::Mag(a, b, hslColor.hue), Sys::Convert::Mag(a, b, hslColor.hue-120.0));
}

unsigned char Convert::Mag(double a, double b, double hue)
{
	//______________________________ Hue [0  360]
	if (hue > 360.0)
		hue -= 360.0;
	else if (hue < 0)
		hue += 360.0;
	//______________________________
	if (hue < 60.0)
	{
		a = a + (b-a)*hue/60.0;
	}
	else if (hue < 180.0)
	{
		a = b;
	}
	else if (hue < 240.0)
	{
		a = a + (b - a)*(240.0-hue)/60.0;
	}
	return (unsigned char)(a*255.0+0.5);
}

void Convert::RgbToHSLColor(const COLORREF input, Sys::HSLColor& output)
{
	enum color { RED, GREEN, BLUE };
	const unsigned char red = GetRValue(input);
	const unsigned char green = GetGValue(input);
	const unsigned char blue = GetBValue(input);
	//__________________________________ Red
	double minimum = green;
	double maximum = red;
	color bigger = RED;
	//__________________________________ Green
	if (red < green)
	{ 
		minimum = red;
		maximum = green;
		bigger = GREEN;
	}
	//__________________________________ Blue
	if (blue < minimum)
	{
		minimum = blue;
	}
	else if (maximum < blue)
	{
		maximum = blue;
		bigger = BLUE;
	}
	//___________________________________
	if (minimum == maximum)
	{
		output.hue = 0.0;
		output.saturation = 0.0;
		output.luminance = minimum/255.0;
	}
	else
	{
		const double sum = minimum + maximum;
		const double diff = maximum - minimum;
		output.luminance = sum/510.0;
		output.saturation = (output.luminance <= 0.5) ? diff/sum : diff/(510.0 - sum);
		//_________________________ HUE
		if (bigger == RED)
		{
			output.hue = 360 + ((green - blue)*60.0/diff);
		}
		else if (bigger == GREEN)
		{
			output.hue = 120 + ((blue - red)*60.0/diff);
		}
		else // BLUE
		{
			output.hue = 240 + ((red - green)*60.0/diff);
		}
		if (output.hue > 360.0) output.hue = output.hue - 360.0;
	}
}

COLORREF Convert::IntToColorRef(int value, bool isStandardFormat)
{
	if (value < 0) //_____________________________________ Negative -> Blue
	{
		if (isStandardFormat == true) return RGB(0, 0, 255);
		return RGBX(0, 0, 255);
	}
	else if (value < 256) //_______________________________ [0    255] -> [Blue    Cyan]
	{
		if (isStandardFormat == true) return RGB(0, value, 255);
		return RGBX(0, value, 255);
	}
	else if (value < 512) //_______________________________ [256    511] -> [Cyan    Green]
	{
		if (isStandardFormat == true) return RGB(0, 255, 511-value);
		return RGBX(0, 255, 511-value);
	}
	else if (value < 768) //_______________________________ [512    767] -> [Green    Yellow]
	{
		if (isStandardFormat == true) return RGB(value-512, 255, 0);
		return RGBX(value-512, 255, 0);
	}
	else if (value < 1024) //_______________________________ [768    1023] -> [Yellow    Red]
	{
		if (isStandardFormat == true) return RGB(255, 1023-value, 0);
		return RGBX(255, 1023-value, 0);
	}
	else if (value < 1280) //_______________________________ [1024    1279] -> [Red    Purple]
	{
		if (isStandardFormat == true) return RGB(255, 0, value-1024);
		return RGBX(255, 0, value-1024);
	}
	else if (value < 1536) //_______________________________ [1280    1535] -> [Purple   Black]
	{
		DWORD tmp = 1535-value;
		if (isStandardFormat == true) return RGB(tmp, 0, tmp);
		return RGBX(tmp, 0, tmp);
	}
	//_____________________________________________ [1536   infinity] -> Black
	return RGB(0, 0, 0);
}

COLORREF Convert::DoubleToColorRef(double value, bool isStandardFormat)
{
	return Sys::Convert::IntToColorRef((int)(1535*value+0.5), isStandardFormat);
}

COLORREF Convert::DoubleToColorRef(double value, bool isStandardFormat, int numColors)
{
	if (value < 0.0) value = 0.0;
	if (value > 1.0) value = 1.0; 
	if (numColors == 2) return Sys::Convert::IntToColorRef((int)(255*value+0.5), isStandardFormat);
	if (numColors == 3) return Sys::Convert::IntToColorRef((int)(511*value+0.5), isStandardFormat);
	if (numColors == 4) return Sys::Convert::IntToColorRef((int)(767*value+0.5), isStandardFormat);
	if (numColors == 5) return Sys::Convert::IntToColorRef((int)(1023*value+0.5), isStandardFormat);
	if (numColors == 6) return Sys::Convert::IntToColorRef((int)(1279*value+0.5), isStandardFormat);
	return Sys::Convert::IntToColorRef((int)(1535*value+0.5), isStandardFormat);

	//numColors--;
	////_________________________________________________________ Compute actual number of colors
	//int _numColors = numColors%10;
	//if (_numColors < 1) _numColors = 1;
	//if (_numColors > 7) _numColors = 7;
	////
	//if (value < 0.0) value = 0.0;
	//if (value > 1.0) value = 1.0; 

	//DWORD red, green, blue;
	//double up;
	//double down;

	//const double delta = 1.0/abs(_numColors);

	//if (numColors < 10) // Blue  > Cyan > Green > Yellow > Red > Purple > Black > Blue
	//{
	//	if (value <= delta)  // Blue to Cyan
	//	{
	//		up = value;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = (int)(up*255.0/delta);
	//		blue = 255;
	//	}
	//	else if (value <= 2.0*delta) // Cyan to Green
	//	{
	//		up = value - delta;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = 255;
	//		blue = (int)(down*255.0/delta);
	//	}
	//	else if (value <= 3.0*delta) //Green to Yellow
	//	{
	//		up = value - 2.0*delta;
	//		down = delta-up;
	//		//
	//		red = (int)(up*255.0/delta);
	//		green = 255;
	//		blue = 0;
	//	}
	//	else if (value <= 4.0*delta) // Yellow to Red
	//	{
	//		up = value - 3.0*delta;
	//		down = delta-up;
	//		//
	//		red = 255;
	//		green = (int)(down*255.0/delta);
	//		blue = 0;
	//	}
	//	else if (value <= 5.0*delta) // Red to Purple
	//	{
	//		up = value - 4.0*delta;
	//		down = delta-up;
	//		//
	//		red = 255;
	//		green = 0;
	//		blue = (int)(up*255.0/delta);
	//	}
	//	else if (value <= 6.0*delta)  // Purple to Black
	//	{
	//		up = value - 5.0*delta;
	//		down = delta-up;
	//		//
	//		red = (int)(down*255.0/delta);
	//		green = 0;
	//		blue = (int)(down*255.0/delta);
	//	}
	//	else // Black to Blue
	//	{
	//		up = value - 6.0*delta;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = 0;
	//		blue = (int)(up*255.0/delta);	
	//	}
	//}
	//else if (numColors < 20) // Black > Blue > Cyan > Green > Yellow > Red > Purple > Black
	//{
	//	
	//	if (value <= delta) // Black to Blue
	//	{
	//		up = value;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = 0;
	//		blue = (int)(up*255.0/delta);
	//	}
	//	else if (value <= 2.0*delta) // Blue to Cyan
	//	{
	//		up = value - delta;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = (int)(up*255.0/delta);
	//		blue = 255;
	//	}
	//	else if (value <= 3.0*delta) // Cyan to Green
	//	{
	//		up = value - 2.0*delta;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = 255;
	//		blue = (int)(down*255.0/delta);
	//	}
	//	else if (value <= 4.0*delta) //Green to Yellow
	//	{
	//		up = value - 3.0*delta;
	//		down = delta-up;
	//		//
	//		red = (int)(up*255.0/delta);
	//		green = 255;
	//		blue = 0;
	//	}
	//	else if (value <= 5.0*delta) // Yellow to Red
	//	{
	//		up = value - 4.0*delta;
	//		down = delta-up;
	//		//
	//		red = 255;
	//		green = (int)(down*255.0/delta);
	//		blue = 0;
	//	}
	//	else if (value <= 6.0*delta) // Red to Purple
	//	{
	//		up = value - 5.0*delta;
	//		down = delta-up;
	//		//
	//		red = 255;
	//		green = 0;
	//		blue = (int)(up*255.0/delta);
	//	}
	//	else // Purple to Black
	//	{
	//		up = value - 6.0*delta;
	//		down = delta-up;
	//		//
	//		red = (int)(down*255.0/delta);
	//		green = 0;
	//		blue = (int)(down*255.0/delta);
	//	}

	//}
	//else // Gray  > Blue > Cyan > Green > Yellow > Red > Purple > Gray 
	//{
	//	
	//	if (value <= delta) // Gray to Blue
	//	{
	//		up = value;
	//		down = delta-up;
	//		//
	//		red = (int)(128-up*127.0/delta);
	//		green = (int)(128-up*127.0/delta);
	//		blue = (int)(128+up*127.0/delta);
	//	}
	//	else if (value <= 2.0*delta) // Blue to Cyan
	//	{
	//		up = value - delta;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = (int)(up*255.0/delta);
	//		blue = 255;
	//	}
	//	else if (value <= 3.0*delta) // Cyan to Green
	//	{
	//		up = value - 2.0*delta;
	//		down = delta-up;
	//		//
	//		red = 0;
	//		green = 255;
	//		blue = (int)(down*255.0/delta);
	//	}
	//	else if (value <= 4.0*delta) //Green to Yellow
	//	{
	//		up = value - 3.0*delta;
	//		down = delta-up;
	//		//
	//		red = (int)(up*255.0/delta);
	//		green = 255;
	//		blue = 0;
	//	}
	//	else if (value <= 5.0*delta) // Yellow to Red
	//	{
	//		up = value - 4.0*delta;
	//		down = delta-up;
	//		//
	//		red = 255;
	//		green = (int)(down*255.0/delta);
	//		blue = 0;
	//	}
	//	else if (value <= 6.0*delta) // Red to Purple
	//	{
	//		up = value - 5.0*delta;
	//		down = delta-up;
	//		//
	//		red = 255;
	//		green = 0;
	//		blue = (int)(up*255.0/delta);
	//	}
	//	else // Purple to Gray
	//	{
	//		up = value - 6.0*delta;
	//		down = delta-up;
	//		//
	//		red = (int)(128 + down*127.0/delta);
	//		green = (int)(up*128.0/delta);
	//		blue = (int)(128 + down*127.0/delta);
	//	}
	//}

	//if (isStandardFormat == true) return RGB(red, green, blue);
	//return RGB(blue, green, red);
}

COLORREF Convert::TextToColorRef(const wstring& text)
{
	return Sys::Convert::TextToColorRef(text.c_str());
}

void Convert::CharInfoToColorText(const list<Sys::CharInfo>& input, list<Sys::ColorText>& output)
{
	list<Sys::CharInfo>::const_iterator p;
	const list<Sys::CharInfo>::const_iterator pend = input.end();
	Sys::ColorText ct;
	ct.color = RGB(0, 0, 0);

	for(p = input.begin(); p != pend; p++)
	{
		if (p->color == ct.color)
		{
			ct.text += p->character;
		}
		else
		{
			if (ct.text.empty() == false) output.push_back(ct);
			ct.text = p->character;
			ct.color = p->color;
		}
	}
	if (ct.text.empty() == false) output.push_back(ct);
}

COLORREF Convert::OleColorToColorRef(const OLE_COLOR input)
{
	const long red = input & 0x000000FF;
	const long green = (input & 0x0000FF00)>>8;
	const long blue = (input & 0x00FF0000)>>16;
	return RGB(red, green, blue);
}

OLE_COLOR Convert::ColorRefToOleColor(const COLORREF input)
{
	return (OLE_COLOR)input;
}

bool Convert::HiMetricToPixel(const SIZEL& inputHiMetric, SIZEL& resultPix)
{
	HDC hdc = ::GetDC(NULL);
	if (hdc==NULL) return false;
	const int nPixelsPerInchX = ::GetDeviceCaps(hdc, LOGPIXELSX);// Pixels per logical inch along width
	const int nPixelsPerInchY = ::GetDeviceCaps(hdc, LOGPIXELSY);// Pixels per logical inch along height
	::ReleaseDC(NULL, hdc);

	//#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), 2540)
	//lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);
	//lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);
	resultPix.cx = MulDiv(nPixelsPerInchX, inputHiMetric.cx, 2540);
	resultPix.cy = MulDiv(nPixelsPerInchY, inputHiMetric.cy, 2540);
	return true;
}

bool Convert::PixelToHiMetric(const SIZEL& inputPix, SIZEL& resultHiMetric)
{
	HDC hdc = ::GetDC(NULL);
	if (hdc==NULL) return false;
	const int nPixelsPerInchX = ::GetDeviceCaps(hdc, LOGPIXELSX);// Pixels per logical inch along width
	const int nPixelsPerInchY = ::GetDeviceCaps(hdc, LOGPIXELSY);// Pixels per logical inch along height
	::ReleaseDC(NULL, hdc);

	//#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(2540, (x), (ppli))
	//MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
	//MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
	resultHiMetric.cx = MulDiv(2540, inputPix.cx, nPixelsPerInchX);  
	resultHiMetric.cy = MulDiv(2540, inputPix.cy, nPixelsPerInchY); 
	return true;
}

int Convert::DlgUnitToPixelX(int dialogUnits)
{
	return (int)( (dialogUnits*LOWORD(::GetDialogBaseUnits())) /4.0+0.5);
}

int Convert::PixelToDlgUnitX(int pixels)
{
	return (int)(4.0*pixels/LOWORD(::GetDialogBaseUnits())+0.5);
}

int Convert::DlgUnitToPixelY(int dialogUnits)
{
	return (int)( (dialogUnits*HIWORD(::GetDialogBaseUnits())) /8.0+0.5);
}

int Convert::PixelToDlgUnitY(int pixels)
{
	return (int)(8.0*pixels/HIWORD(::GetDialogBaseUnits())+0.5);
}

int Convert::FontPointToLogicUnits(HDC hdc, double fontPoints)
{
	const double cyDpi = (double)::GetDeviceCaps(hdc, LOGPIXELSY);
	return (int)(cyDpi*fontPoints/72.0+0.5); 	// 1 inch = 72 points
}

int Convert::FontPointToLogicUnits(double fontPoints)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	const int logicUnits = Sys::Convert::FontPointToLogicUnits(hdc, fontPoints);
	if (hdc) ::DeleteDC(hdc);
	return logicUnits;
}

double Convert::LogicUnitsToFontPoint(int logicUnits)
{
	HDC hdc = ::CreateIC(L"DISPLAY", NULL, NULL, NULL);
	const double fontPoints = Sys::Convert::LogicUnitsToFontPoint(hdc, logicUnits);
	if (hdc) ::DeleteDC(hdc);
	return fontPoints;
}

double Convert::LogicUnitsToFontPoint(HDC hdc, int logicUnits)
{
	const double cyDpi = (double)::GetDeviceCaps(hdc, LOGPIXELSY);
	return (logicUnits*72.0/cyDpi);	// 1 inch = 72 points
}

int Convert::ToInt(const wchar_t* input)
{
	if (input==NULL) return 0;
	// We allow just numbers and -
	int j=0;
	wchar_t cValue[32];
	const int length = (int)MINIMUM(32, wcslen(input));
	for(int i=0; i<length; i++)
	{
		if (input[i]=='\0' || input[i]=='.') break;
		if (input[i]<'0' && input[i] != '-') continue;
		if (input[i]>'9' && input[i] != 0x2212) continue;
		cValue[j]=input[i];
		if (cValue[j]==0x2212) cValue[j] = '-';
		j++;
	}
	cValue[j]='\0';
	if (cValue[0]=='\0') return 0;
	return _wtoi(cValue);
}

int Convert::ToInt(const char* input)
{
	if (input==NULL) return 0;
	// We allow just numbers and -
	int j=0;
	char cValue[32];
	const int length = (int)MINIMUM(32, strlen(input));
	for (int i=0; i<length; i++)
	{
		if (input[i]=='\0' || input[i]=='.') break;
		if (input[i]<'0' && input[i] != '-') continue;
		if (input[i]>'9' && input[i] != 0x2212) continue;
		cValue[j]=input[i];
		if (cValue[j]==0x2212) cValue[j] = '-';
		j++;
	}
	cValue[j]='\0';
	if (cValue[0]=='\0') return 0;
	return atoi(cValue);
}

int Convert::ToInt(const wstring& input)
{
	return Sys::Convert::ToInt(input.c_str());
}

int Convert::ToInt(const string& input)
{
	return Sys::Convert::ToInt(input.c_str());
}

double Convert::ToDouble(const wchar_t* input)
{
	if (input==NULL) return 0.0;
	wchar_t cValue[32];
	const int length = (int)MINIMUM(32, wcslen(input));
	int i, j=0;
	for(i=0; i<length; i++)
	{
		cValue[j]=input[i];
		if (input[i]=='\0') break;
		if ('0'<=input[i] && input[i]<='9') ++j;
		if (input[i]=='-') ++j;
		if (input[i]==0x2212) ++j;
		if (input[i]=='+') ++j;
		if (input[i]=='e') ++j;
		if (input[i]=='E') ++j;
		if (input[i]=='.') ++j;
	}
	cValue[j]='\0';
	if (cValue[0]=='\0') return 0.0;
	for(i=0; i<j; i++)
	{
		if (cValue[i]==0x2212) cValue[i]='-';
	}
	return _wtof(cValue);
}

double Convert::ToDouble(const char* input)
{
	if (input==NULL) return 0.0;
	char cValue[32];
	const int length = (int)MINIMUM(32, strlen(input));
	int i, j=0;
	for (i=0; i<length; i++)
	{
		cValue[j]=input[i];
		if (input[i]=='\0') break;
		if ('0'<=input[i] && input[i]<='9') ++j;
		if (input[i]=='-') ++j;
		if (input[i]==0x2212) ++j;
		if (input[i]=='+') ++j;
		if (input[i]=='e') ++j;
		if (input[i]=='E') ++j;
		if (input[i]=='.') ++j;
	}
	cValue[j]='\0';
	if (cValue[0]=='\0') return 0.0;
	for (i=0; i<j; i++)
	{
		if (cValue[i]==0x2212) cValue[i]='-';
	}
	return atof(cValue);
}

double Convert::ToDouble(const wstring& input)
{
	return Sys::Convert::ToDouble(input.c_str());
}

double Convert::ToDouble(const string& input)
{
	return Sys::Convert::ToDouble(input.c_str());
}

bool Convert::ToBool(const wchar_t* input)
{
	if (input ==NULL) return false;
	if (wcslen(input) == 0) return false;
	if (input[0]=='1') return true;
	if (input[0]=='0') return false;
	if (lstrcmp(input, L"true")==0) return true;
	if (lstrcmp(input, L"TRUE")==0) return true;
	if (lstrcmp(input, L"on")==0) return true;
	if (lstrcmp(input, L"ON")==0) return true;
	if (lstrcmp(input, L"false")==0) return false;
	if (lstrcmp(input, L"FALSE")==0) return false;
	if (lstrcmp(input, L"off")==0) return false;
	if (lstrcmp(input, L"OFF")==0) return false;
	return false;
}

bool Convert::ToBool(const wstring& input)
{
	return ToBool(input.c_str());
}

// input; 5, 5.5, -8.2, +5.5, 1.2e10, +2.2e+20, -5.6e-10
// Set position to zero on the first call to this function
double Convert::ExtractDouble(int& position, const wchar_t* input, int input_length)
{
	wchar_t letter;
	wchar_t tmp[32];
	int k = 0;
	//__________________________________________________Find first of [0123456789.+-]
	for( ; position < input_length; position++)
	{
		letter = input[position];
		if ('0' <= letter && letter <='9') break;
		if (letter == '.' || letter == '-' || letter == 0x2212 || letter == '+') break;
	}
	//_________________________________________________ One digit numbers
	if (position == input_length-1) 
	{
		if ('0' <= letter && letter <='9')
		{
			tmp[0] = letter;
			tmp[1] = '\0';
			return _wtof(tmp);
		}
		return 0.0;
	}
	//__________________________________________________[+-]
	if (input[position] == '+')
	{
		tmp[k++] ='+';
		position++; // Move after the sign
	}
	else if (input[position] == '-' || input[position] == 0x2212)
	{
		tmp[k++] ='-';
		position++; // Move after the sign
	}
	//___________________________________________ [0123456789]
	for(; position < input_length && k < 32; position++)
	{
		letter = input[position];
		tmp[k++] = letter;
		if ('0' <= letter && letter <='9') continue;
		break;
	}

	//____________________________________________  Dot 
	if (input[position]=='.')
	{
		position++; // Go after the '.'
		if (position > input_length-1) // Are we done?
		{
			if (k <= 0) return 0.0; // Nothing found
			tmp[k] = '\0';
			return _wtof(tmp);
		}
		//___________________________________________ [0123456789]
		for(; position < input_length && k < 32; position++)
		{
			letter = input[position];
			tmp[k++] = letter;
			if ('0' <= letter && letter <='9') continue;
			break;
		}
	}
	//____________________________________________ [eE]
	letter = input[position];
	if (letter=='e' || letter=='E')
	{
		position++; // Go after the 'e' or 'E'
		//__________________________________________________[+-]
		if (input[position] == '+')
		{
			tmp[k++] = '+';
			position++; // Move after the sign
		}
		else if (input[position] == '-' || input[position] == 0x2212)
		{
			tmp[k++] = '-';
			position++; // Move after the sign
		}
		if (position >= input_length-1) // Are we done?
		{
			if (k <= 0) return 0.0; // Nothing found
			tmp[k] = '\0';
			return _wtof(tmp);
		}
		//___________________________________________ [0123456789]
		for(; position < input_length && k < 32; position++)
		{
			letter = input[position];
			tmp[k++] = letter;
			if ('0' <= letter && letter <='9') continue;
			break;
		}
	}
	if (position == input_length)
	{
	}
	else
	{
		k--;
	}
	if (k <= 0) return 0.0; // Nothing found
	tmp[k] = '\0';
	return _wtof(tmp);
}

// input; 5, 5.5, -8.2, +5.5, 1.2e10, +2.2e+20, -5.6e-10
// Set position to zero on the first call to this function
double Convert::ExtractDouble(int& position, const char* input, int input_length)
{
	char letter;
	char tmp[32];
	int k = 0;
	//__________________________________________________Find first of [0123456789.+-]
	for( ; position < input_length; position++)
	{
		letter = input[position];
		if ('0' <= letter && letter <='9') break;
		if (letter=='.' || letter=='-' || letter=='+') break;
	}
	//_________________________________________________ One digit numbers
	if (position == input_length-1) 
	{
		if ('0' <= letter && letter <='9')
		{
			tmp[0] = letter;
			tmp[1] = '\0';
			return atof(tmp);
		}
		return 0.0;
	}
	//__________________________________________________[+-]
	if (input[position] == '+')
	{
		tmp[k++] ='+';
		position++; // Move after the sign
	}
	else if (input[position] == '-')
	{
		tmp[k++] ='-';
		position++; // Move after the sign
	}
	//___________________________________________ [0123456789]
	for(; position < input_length && k < 32; position++)
	{
		letter = input[position];
		tmp[k++] = letter;
		if ('0' <= letter && letter <='9') continue;
		break;
	}

	//____________________________________________  Dot 
	if (input[position]=='.')
	{
		position++; // Go after the '.'
		if (position > input_length-1) // Are we done?
		{
			if (k <= 0) return 0.0; // Nothing found
			tmp[k] = '\0';
			return atof(tmp);
		}
		//___________________________________________ [0123456789]
		for(; position < input_length && k < 32; position++)
		{
			letter = input[position];
			tmp[k++] = letter;
			if ('0' <= letter && letter <='9') continue;
			break;
		}
	}
	//____________________________________________ [eE]
	letter = input[position];
	if (letter=='e' || letter=='E')
	{
		position++; // Go after the 'e' or 'E'
		//__________________________________________________[+-]
		if (input[position] == '+')
		{
			tmp[k++] = '+';
			position++; // Move after the sign
		}
		else if (input[position] == '-')
		{
			tmp[k++] = '-';
			position++; // Move after the sign
		}
		if (position >= input_length-1) // Are we done?
		{
			if (k <= 0) return 0.0; // Nothing found
			tmp[k] = '\0';
			return atof(tmp);
		}
		//___________________________________________ [0123456789]
		for(; position < input_length && k < 32; position++)
		{
			letter = input[position];
			tmp[k++] = letter;
			if ('0' <= letter && letter <='9') continue;
			break;
		}
	}
	if (position == input_length)
	{
	}
	else
	{
		k--;
	}
	if (k <= 0) return 0.0; // Nothing found
	tmp[k] = '\0';
	return atof(tmp);
}

complex<double> Convert::ExtractComplex(int& position, const wchar_t* input, int input_length)
{
	complex<double> result(0.0, 0.0);
	const int len = (int)wcslen(input);
	if (len<=0) return result;
	double value = ExtractDouble(position, input, len);
	if (position==len-1) // Are we done?
	{
		if (input[position] == 'i' || input[position] == 'j'  || input[position] == 'I'  || input[position] == 'J')
		{
			result._Val[_IM] =  value;
		}
		else
		{
			result._Val[_RE] =  value;
		}
		return result;
	}
	//_____________________________________________ Is it the imaginary part?
	wchar_t letter;
	if (position < len-1)
	{
		letter = input[position];
		if (letter == 'i' ||  letter == 'I' || letter == 'j' || letter == 'J')
		{
			result._Val[_IM] =  value;
			return result;
		}
	}
	//_____________________________________________ The value found was the real part
	result._Val[_RE] =  value;
	if (input[position] == ',' || input[position] == ';' || input[position] == ' ' || input[position] == '\t') return result;// This is it
	//___________________________________ Try to extract another double
	result._Val[_IM] = ExtractDouble(position, input, len);
	return result;
}

complex<double> Convert::ExtractComplex(int& position, const char* input, int input_length)
{
	complex<double> result(0.0, 0.0);
	const int len = (int)strlen(input);
	if (len<=0) return result;
	double value = ExtractDouble(position, input, len);
	if (position==len-1) // Are we done?
	{
		if (input[position] == 'i' || input[position] == 'j'  || input[position] == 'I'  || input[position] == 'J')
		{
			result._Val[_IM] =  value;
		}
		else
		{
			result._Val[_RE] =  value;
		}
		return result;
	}
	//_____________________________________________ Is it the imaginary part?
	wchar_t letter;
	if (position < len-1)
	{
		letter = input[position];
		if (letter == 'i' ||  letter == 'I' || letter == 'j' || letter == 'J')
		{
			result._Val[_IM] =  value;
			return result;
		}
	}
	//_____________________________________________ The value found was the real part
	result._Val[_RE] =  value;
	if (input[position] == ',' || input[position] == ';' || input[position] == ' ' || input[position] == '\t') return result;// This is it
	//___________________________________ Try to extract another double
	result._Val[_IM] = ExtractDouble(position, input, len);
	return result;
}

complex<double> Convert::ToComplex(const wchar_t* input)
{
	int position = 0;
	return ExtractComplex(position, input, (int)wcslen(input));
}

complex<double> Convert::ToComplex(const wstring& input)
{
	return ToComplex(input.c_str());
}

complex<double> Convert::ToComplex(const char* input)
{
	int position = 0;
	return ExtractComplex(position, input, (int)strlen(input));
}

complex<double> Convert::ToComplex(const string& input)
{
	return ToComplex(input.c_str());
}

bool Convert::ToMatrix(const valarray<double>& input, MATRIX& output)
{
	const int rows = (int)input.size();
	try
	{
		output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			output[i].resize(1);
			output[i][0] = input[i];
		}
	}
	catch(std::bad_alloc&)
	{
		return false;
	}
	return true;
}

bool Convert::ToMatrix(const valarray<complex<double> >& input, MATRIXC& output)
{
	const int rows = (int)input.size();
	try
	{
		output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			output[i].resize(1);
			output[i][0] = input[i];
		}
	}
	catch(std::bad_alloc&)
	{
		return false;
	}
	return true;
}

bool Convert::ToMatrix(const wchar_t* input, MATRIX& output)
{
	if (input==NULL)
	{
		output.clear();
		return true;
	}
	const int len = (int)wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return true;
	}
	vector<wstring> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = (int)lista.size();
	if (rows==0)
	{
		output.clear();
		return true;
	}
	try
	{
		output.resize(rows);
	}
	catch(std::bad_alloc&)
	{
		return false;
	}

	int cols = 0;
	for(int i=0; i<rows; i++)
	{
		if (ToVector(lista[i], output[i]) == false) return false;
		if (i == 0) //___________________ Save the number of columns in the first row
		{
			cols = (int)output[i].size();
		}
		else //________________________ Enforce the same number of columns in the other rows
		{
			if (cols != output[i].size())
			{
				valarray<double> tmp = output[i];
				output[i].resize(cols);
				const int new_size = MINIMUM(cols, (int)tmp.size());
				for(int k = 0; k < new_size; k++) output[i][k] = tmp[k];
			}
		}
	}
	return true;
}

bool Convert::ToMatrix(const wstring& input, MATRIX& output)
{
	return ToMatrix(input.c_str(), output);
}

bool Convert::ToMatrix(const char* input, MATRIX& output)
{
	if (input==NULL)
	{
		output.clear();
		return true;
	}
	const int len = (int)strlen(input);
	if (len <= 0)
	{
		output.clear();
		return true;
	}
	vector<string> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = (int)lista.size();
	if (rows==0)
	{
		output.clear();
		return true;
	}
	try
	{
		output.resize(rows);
		int cols = 0;
		for(int i=0; i<rows; i++)
		{
			if (ToVector(lista[i], output[i]) == false) return false;
			if (i == 0) //___________________ Save the number of columns in the first row
			{
				cols = (int)output[i].size();
			}
			else //________________________ Enforce the same number of columns in the other rows
			{
				if (cols != output[i].size())
				{
					valarray<double> tmp = output[i];
					output[i].resize(cols);
					const int new_size = MINIMUM(cols, (int)tmp.size());
					for(int k = 0; k < new_size; k++) output[i][k] = tmp[k];
				}
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Convert::ToMatrix(const string& input, MATRIX& output)
{
	return ToMatrix(input.c_str(), output);
}

bool Convert::ToMatrix(const wchar_t* input, MATRIXC& output)
{
	if (input==NULL)
	{
		output.clear();
		return true;
	}
	const int len = (int)wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return true;
	}
	vector<wstring> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = (int)lista.size();
	if (rows==0)
	{
		output.clear();
		return true;
	}
	try
	{
		output.resize(rows);
		int cols = 0;
		for(int i=0; i<rows; i++)
		{
			if (ToVector(lista[i], output[i]) == false) return false;
			if (i == 0) //___________________ Save the number of columns in the first row
			{
				cols = (int)output[i].size();
			}
			else //________________________ Enforce the same number of columns in the other rows
			{
				if (cols != output[i].size())
				{
					valarray<complex<double> > tmp = output[i];
					output[i].resize(cols);
					const int new_size = MINIMUM(cols, (int)tmp.size());
					for(int k = 0; k < new_size; k++) output[i][k] = tmp[k];
				}
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Convert::ToMatrix(const wstring& input, MATRIXC& output)
{
	return ToMatrix(input.c_str(), output);
}

bool Convert::ToMatrix(const char* input, MATRIXC& output)
{
	if (input==NULL)
	{
		output.clear();
		return true;
	}
	const int len = (int)strlen(input);
	if (len <= 0)
	{
		output.clear();
		return true;
	}
	vector<string> lista;
	Sys::Convert::ToVectorOfStrings(input, lista);
	const int rows = (int)lista.size();
	if (rows==0)
	{
		output.clear();
		return true;
	}
	try
	{
		output.resize(rows);
		int cols = 0;
		for(int i=0; i<rows; i++)
		{
			if (ToVector(lista[i], output[i]) == false) return false;
			if (i == 0) //___________________ Save the number of columns in the first row
			{
				cols = (int)output[i].size();
			}
			else //________________________ Enforce the same number of columns in the other rows
			{
				if (cols != output[i].size())
				{
					valarray<complex<double> > tmp = output[i];
					output[i].resize(cols);
					const int new_size = MINIMUM(cols, (int)tmp.size());
					for(int k = 0; k < new_size; k++) output[i][k] = tmp[k];
				}
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Convert::ToMatrix(const string& input, MATRIXC& output)
{
	return ToMatrix(input.c_str(), output);
}

wchar_t* Convert::ToVector(const MATRIX& input, int col_index, valarray<double>& output)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	if (col_index<0) return L"The column index must be bigger than or equal to zero";
	if (col_index>=cols) return L"The column index is bigger than or equal to the number of columns in the matrix";
	try
	{
		output.resize(rows);
	}
	catch(std::bad_alloc& )
	{
		return L"No enough memory";
	}
	for(int i = 0; i<rows; i++)
	{
		output[i] = input[i][col_index];
	}
	return NULL;
}

wchar_t* Convert::ToVector(const MATRIXC& input, int col_index, valarray<complex<double> >& output)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	if (col_index<0) return L"The column index must be bigger than or equal to zero";
	if (col_index>=cols) return L"The column index is bigger than or equal to the number of columns in the matrix";
	try
	{
		output.resize(rows);
	}
	catch(std::bad_alloc& )
	{
		return L"No enough memory";
	}
	for(int i = 0; i<rows; i++)
	{
		output[i] = input[i][col_index];
	}
	return NULL;
}

//__________________________________________________________________ valarray
bool Convert::ToVector(const wchar_t* input, valarray<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return true;
	}
	const int len = (int)wcslen(input);
	if (len <= 0)
	{
		output.resize(0);
		return true;
	}
	int position = 0;
	int cols = 0;
	//_________________ Try to get the number of cols
	do
	{
		ExtractDouble(position, input, len);
		cols++;
	}
	while(position < len-1);
	try
	{
		output.resize(cols);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	//__________________ Get the elements
	position = 0;
	for(int i = 0; i < cols; i++)
	{
		output[i] = ExtractDouble(position, input, len);
	}
	return true;

	////_________________ Try to get the number of cols
	//int cols = 1;
	//int i;
	//for(i=0; i<len; i++)
	//{
	//	if (input[i] == ',') cols++;
	//}

	//output.resize(cols);
	//int k = 0;
	//int col_count = 0;
	//wchar_t tmp[32];
	//wchar_t letter;
	//for(i=0; i<len; i++)
	//{
	//	letter = input[i];
	//	if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
	//	{
	//		if (letter==',' || k>=31 || i==len-1)
	//		{
	//			if (i==len-1) 
	//			{
	//				tmp[k++] = letter;
	//			}
	//			tmp[k] = '\0';
	//			output[col_count] =  _wtof(tmp);
	//			col_count++;
	//			k = 0;
	//			continue;
	//		}
	//		else
	//		{
	//			tmp[k++] = letter;
	//		}
	//	}
	//}
	//return output;
}

bool Convert::ToVector(const wstring& input, valarray<double>& output)
{
	return ToVector(input.c_str(), output);
}

bool Convert::ToVector(const char* input, valarray<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return true;
	}
	const int len = (int)strlen(input);
	if (len <= 0)
	{
		output.resize(0);
		return true;
	}
	int position = 0;
	int cols = 0;
	//_________________ Try to get the number of cols
	do
	{
		ExtractDouble(position, input, len);
		cols++;
	}
	while(position < len-1);
	try
	{
		output.resize(cols);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	//__________________ Get the elements
	position = 0;
	for(int i = 0; i < cols; i++)
	{
		output[i] = ExtractDouble(position, input, len);
	}
	return true;
	//if (input==NULL)
	//{
	//	output.resize(0);
	//	return output;
	//}
	//const int len = strlen(input);
	//if (len <= 0)
	//{
	//	output.resize(0);
	//	return output;
	//}

	////_________________ Try to get the number of cols
	//int cols = 1;
	//int i;
	//for(i=0; i<len; i++)
	//{
	//	if (input[i] == ',') cols++;
	//}

	//output.resize(cols);
	//int k = 0;
	//int col_count = 0;
	//char tmp[32];
	//char letter;
	//for(i=0; i<len; i++)
	//{
	//	letter = input[i];
	//	if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
	//	{
	//		if (letter==',' || k>=31 || i==len-1)
	//		{
	//			if (i==len-1) 
	//			{
	//				tmp[k++] = letter;
	//			}
	//			tmp[k] = '\0';
	//			output[col_count] =  atof(tmp);
	//			col_count++;
	//			k = 0;
	//			continue;
	//		}
	//		else
	//		{
	//			tmp[k++] = letter;
	//		}
	//	}
	//}
	//return output;
}

bool Convert::ToVector(const string& input, valarray<double>& output)
{
	return ToVector(input.c_str(), output);
}

//_____________________________________________________________________ Vector
bool Convert::ToVector(const wchar_t* input, vector<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return true;
	}
	const int len = (int)wcslen(input);
	if (len <= 0)
	{
		output.resize(0);
		return true;
	}
	int position = 0;
	int cols = 0;
	//_________________ Try to get the number of cols
	do
	{
		ExtractDouble(position, input, len);
		cols++;
	}
	while(position < len-1);
	try
	{
		output.resize(cols);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	//__________________ Get the elements
	position = 0;
	for(int i = 0; i < cols; i++)
	{
		output[i] = ExtractDouble(position, input, len);
	}
	return true;
	//if (input==NULL)
	//{
	//	output.resize(0);
	//	return output;
	//}
	//const int len = wcslen(input);
	//if (len <= 0)
	//{
	//	output.resize(0);
	//	return output;
	//}

	////_________________ Try to get the number of cols
	//int cols = 1;
	//int i;
	//for(i=0; i<len; i++)
	//{
	//	if (input[i] == ',') cols++;
	//}

	//output.resize(cols);
	//int k = 0;
	//int col_count = 0;
	//wchar_t tmp[32];
	//wchar_t letter;
	//for(i=0; i<len; i++)
	//{
	//	letter = input[i];
	//	if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
	//	{
	//		if (letter==',' || k>=31 || i==len-1)
	//		{
	//			if (i==len-1) 
	//			{
	//				tmp[k++] = letter;
	//			}
	//			tmp[k] = '\0';
	//			output[col_count] =  _wtof(tmp);
	//			col_count++;
	//			k = 0;
	//			continue;
	//		}
	//		else
	//		{
	//			tmp[k++] = letter;
	//		}
	//	}
	//}
	//return output;
}

bool Convert::ToVector(const wstring& input, vector<double>& output)
{
	return ToVector(input.c_str(), output);
}

bool Convert::ToVector(const char* input, vector<double>& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return true;
	}
	const int len = (int)strlen(input);
	if (len <= 0)
	{
		output.resize(0);
		return true;
	}
	int position = 0;
	int cols = 0;
	//_________________ Try to get the number of cols
	do
	{
		ExtractDouble(position, input, len);
		cols++;
	}
	while(position < len-1);
	try
	{
		output.resize(cols);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	//__________________ Get the elements
	position = 0;
	for(int i = 0; i < cols; i++)
	{
		output[i] = ExtractDouble(position, input, len);
	}
	return true;
	//if (input==NULL)
	//{
	//	output.resize(0);
	//	return output;
	//}
	//const int len = strlen(input);
	//if (len <= 0)
	//{
	//	output.resize(0);
	//	return output;
	//}

	////_________________ Try to get the number of cols
	//int cols = 1;
	//int i;
	//for(i=0; i<len; i++)
	//{
	//	if (input[i] == ',') cols++;
	//}

	//output.resize(cols);
	//int k = 0;
	//int col_count = 0;
	//char tmp[32];
	//char letter;
	//for(i=0; i<len; i++)
	//{
	//	letter = input[i];
	//	if ((letter>='0' && letter<='9') || letter=='E' || letter=='e' || letter==',' || letter=='-' || letter=='+' || letter=='.')
	//	{
	//		if (letter==',' || k>=31 || i==len-1)
	//		{
	//			if (i==len-1) 
	//			{
	//				tmp[k++] = letter;
	//			}
	//			tmp[k] = '\0';
	//			output[col_count] =  atof(tmp);
	//			col_count++;
	//			k = 0;
	//			continue;
	//		}
	//		else
	//		{
	//			tmp[k++] = letter;
	//		}
	//	}
	//}
	//return output;
}

bool Convert::ToVector(const string& input, vector<double>& output)
{
	return ToVector(input.c_str(), output);
}

//________________________________________________________________________ valarray<complex<double> >
bool Convert::ToVector(const wchar_t* input, valarray<complex<double> >& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return true;
	}
	const int len = (int)wcslen(input);
	if (len <= 0)
	{
		output.resize(0);
		return true;
	}
	int position = 0;
	int cols = 0;
	//_________________ Try to get the number of cols
	do
	{
		ExtractComplex(position, input, len);
		cols++;
	}
	while(position < len-1);
	try
	{
		output.resize(cols);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	//__________________ Get the elements
	position = 0;
	for(int i = 0; i < cols; i++)
	{
		output[i] = ExtractComplex(position, input, len);
	}
	return true;
}

bool Convert::ToVector(const wstring& input, valarray<complex<double> >& output)
{
	return ToVector(input.c_str(), output);
}

bool Convert::ToVector(const char* input, valarray<complex<double> >& output)
{
	if (input==NULL)
	{
		output.resize(0);
		return true;
	}
	const int len = (int)strlen(input);
	if (len <= 0)
	{
		output.resize(0);
		return true;
	}
	int position = 0;
	int cols = 0;
	//_________________ Try to get the number of cols
	do
	{
		ExtractComplex(position, input, len);
		cols++;
	}
	while(position < len-1);
	try
	{
		output.resize(cols);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	//__________________ Get the elements
	position = 0;
	for(int i = 0; i < cols; i++)
	{
		output[i] = ExtractComplex(position, input, len);
	}
	return true;
}

bool Convert::ToVector(const string& input, valarray<complex<double> >& output)
{
	return ToVector(input.c_str(), output);
}

Sys::Time Convert::VariantToTime(const _variant_t& input)
{
	Sys::Time st;
	if (input.vt == VT_DATE)
	{
		VariantTimeToSystemTime(input.date, &st);
	}
	else if (input.vt == (VT_DATE | VT_BYREF))
	{
		VariantTimeToSystemTime(*input.pdate, &st);
	}
	return st;
}

_variant_t Convert::TimeToVariant(const Sys::Time& input)
{
	_variant_t result;
	if (SystemTimeToVariantTime(&(SYSTEMTIME)input, &result.dblVal) == TRUE)
	{
		result.vt = VT_DATE;
	}
	else
	{
		result.Clear();
	}
	return result;
}

Sys::Time& Convert::ToTime(const wchar_t* input, Sys::Time& output)
{
	output.wHour = 0;
	output.wMilliseconds = 0;
	output.wDay = 0;
	output.wDayOfWeek = 0;
	output.wMinute = 0;
	output.wMonth = 0;
	output.wSecond = 0;
	output.wYear = 0;
	if (input==NULL) return output;
	const int len = (int)wcslen(input);
	if (len<=0) return output;
	int i = 0;
	//________________________ separate the tokens
	vector<wstring> elements;
	vector<bool> elements_used;
	wstring element;
	bool used = false;
	for(i=0; i<len; i++)
	{
		if (isalnum(input[i]))
		{
			element+=input[i];
		}
		else
		{
			elements.push_back(element);
			elements_used.push_back(used);
			element.clear();
		}
	}
	elements.push_back(element);
	elements_used.push_back(used);
	element.clear();

	//_______________________ find the month
	const int count = (int)elements.size();
	int tmp;
	for(i=0; i<count; i++)
	{
		tmp = ToMonth(elements[i]);
		if (tmp!=-1)
		{
			elements_used[i] = true;
			output.wMonth = tmp;
			break;
		}
	}

	//_______________________ find the year
	for(i=0; i<count; i++)
	{
		if (elements_used[i] == true) continue;
		tmp = ToYear(elements[i]);
		if (tmp!=-1)
		{
			elements_used[i] = true;
			output.wYear = tmp;
			break;
		}
	}

	//_______________________ find the day
	for(i=0; i<count; i++)
	{
		if (elements_used[i] == true) continue;
		tmp = ToMonthDay(elements[i]);
		if (tmp!=-1)
		{
			elements_used[i] = true;
			output.wDay = tmp;
			break;
		}
	}
	return output;
}


Sys::Time& Convert::ToTime(const wstring& input, Sys::Time& output)
{
	return ToTime(input.c_str(), output);
}

void Convert::SqlTimeToSysTime(const Sys::SqlTime& input, Sys::Time& output)
{
	output.wYear = input.year;
	output.wMonth = input.month;
	output.wDayOfWeek = 0;
	output.wDay = input.day;
	output.wHour = input.hour;
	output.wMinute = input.minute;
	output.wSecond = input.second;
	output.wMilliseconds = input.milliseconds;
	//__________________________________________ Try to fill wDayOfWeek
	FILETIME ft; 
	::SystemTimeToFileTime( &output, &ft ); 
	::FileTimeToSystemTime( &ft, &output); 
}

void Convert::SysTimeToSqlTime(const Sys::Time& input, Sys::SqlTime& output)
{
	output.year = input.wYear;
	output.month = input.wMonth;
	output.day = input.wDay;
	output.hour = input.wHour;
	output.minute = input.wMinute;
	output.second = input.wSecond;
	output.milliseconds = input.wMilliseconds;
}

//Get the file times using the Windows API call GetFileTime() instead of using the 
//C library stat(), and convert the FILETIME to time_t by subtracting the origin 
//(Jan 1 1600) and dividing by 10,000,000 to convert 100-nanosecond units to 
//seconds.
void Convert::time_tToFiletime(time_t input, FILETIME& filetime)
{
	//struct tm timeInfo;
	//localtime_s(&timeInfo, &input);
	//if (timeInfo.tm_isdst > 0) // Daylight Savings Time is in effect
	//{
	//	input += 3600; // Increase One Hour
	//}
	//else if (timeInfo.tm_isdst == 0) // Daylight Savings Time is not in effect
	//{
	//	//input += 1200; // Increase One Hour
	//}
	//else
	//{
	//	input += 1800; // Increase One Hour
	//}

    LONGLONG tmp = Int32x32To64(input, 10000000) + 116444736000000000;
    filetime.dwLowDateTime = (DWORD)tmp;
    filetime.dwHighDateTime = tmp >>32;
}

// returns -1 if error
int Convert::ToYear(wstring& text)
{
	if (text.length() != 4) return -1;
	for(int i=0; i<4; i++)
	{
		if (text[i]<'0') return -1;
		if (text[i]>'9') return -1;
	}
	int tmp = _tstoi(text.c_str());
	if (tmp<1000) return -1;
	if (tmp>4000) return -1;
	return tmp;
}

// returns -1 if error
int Convert::ToMonth(wstring& text)
{
	const int len = (int)text.length();
	if (len<=1) return -1;

	wstring tmp;
	int i;
	tmp.resize(len);
	for(i=0; i<len; i++)
	{
		tmp[i] = toupper(text[i]);
	}
	size_t found;

  found=tmp.find(L"ENE");
  if (found!=string::npos) return 1;
  //
  found=tmp.find(L"JAN");
  if (found!=string::npos) return 1;
  //
  found=tmp.find(L"FEB");
  if (found!=string::npos) return 2;
  //
  found=tmp.find(L"MAR");
  if (found!=string::npos) return 3;
  //
  found=tmp.find(L"ABR");
  if (found!=string::npos) return 4;
  //
  found=tmp.find(L"APR");
  if (found!=string::npos) return 4;
  //
  found=tmp.find(L"MAY");
  if (found!=string::npos) return 5;
  //
  found=tmp.find(L"JUN");
  if (found!=string::npos) return 6;
  //
  found=tmp.find(L"JUL");
  if (found!=string::npos) return 7;
  //
  found=tmp.find(L"AGO");
  if (found!=string::npos) return 8;
  //
  found=tmp.find(L"AUG");
  if (found!=string::npos) return 8;
  //
  found=tmp.find(L"SEP");
  if (found!=string::npos) return 9;
  //
  found=tmp.find(L"OCT");
  if (found!=string::npos) return 10;
  //
  found=tmp.find(L"NOV");
  if (found!=string::npos) return 11;
  //
  found=tmp.find(L"DIC");
  if (found!=string::npos) return 12;
  //
  found=tmp.find(L"DEC");
  if (found!=string::npos) return 12;

  return -1;

}

int Convert::ToMonthDay(wstring& text)
{
	const int len = (int)text.length();
	if (len<=0) return -1;
	if (len>2) return -1;
	for(int i=0; i<len; i++)
	{
		if (text[i]<'0') return -1;
		if (text[i]>'9') return -1;
	}
	int tmp = _tstoi(text.c_str());
	if (tmp<0) return -1;
	if (tmp>31) return -1;
	return tmp;
}

#ifdef WIN_SOCKETS_SUPPORT
Sys::Time& Convert::InternetTimeToSystemTime(unsigned int inputInternetTime, Sys::Time& output)
{
	inputInternetTime = ntohl(inputInternetTime); //swapt bytes
	FILETIME fileTime;
	LARGE_INTEGER li;
	SYSTEMTIME sysTime;
	//___________________________Transform for seconds since Jan. 1 1900 to SYSTEMTIME
	sysTime.wYear = 1900;
	sysTime.wMonth  = 1;
	sysTime.wDay = 1;
	sysTime.wHour  = 0;
	sysTime.wMinute  = 0;
	sysTime.wSecond = 0;
	sysTime.wMilliseconds = 0;

	SystemTimeToFileTime (&sysTime, &fileTime);
	li = * (LARGE_INTEGER *) &fileTime;
	li.QuadPart += (LONGLONG) 10000000 * inputInternetTime; 
	fileTime = * (FILETIME *) &li;
	FileTimeToSystemTime (&fileTime, &sysTime);
	SystemTimeToTzSpecificLocalTime(NULL, &sysTime, &sysTime);  // Adjust time zone
	return output;
}
#endif

//_________________________ ToString
wstring Convert::ToString(int input)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%d", input);
	//Sys::Convert::ToString(input, text, 32);
	return text;
}

wstring Convert::ToString(unsigned int input)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%d", input);
	//Sys::Convert::ToString(input, text, 32);
	return text;
}

wstring Convert::ToString(__int64 input)
{
	wchar_t text[64];
	_snwprintf_s(text, 64, _TRUNCATE, L"%I64i", input);
	return text;
}

const wchar_t* Convert::ToString(bool input)
{
	if (input == true) return L"true";
	return L"false";
}

void Convert::ToString(int input, wchar_t* output, int output_size)
{
	//if (input>=0)
		_snwprintf_s(output, output_size, _TRUNCATE, L"%d", input);
	//else
	//	_snwprintf_s(output, output_size, _TRUNCATE, L"%c%d", 0x2212, abs(input));
}

wstring Convert::ToString(double input)
{
	return Convert::ToString(input, L"%g");
}

wstring Convert::ToString(double input, const wchar_t* format)
{
	wchar_t text[32];
	Sys::Convert::ToString(input, format, text, 32);
	return text;
}

int Convert::ToString(double input, wchar_t* out_buffer, int out_buffer_size, bool compactFormat, bool replaceWithMinusSign)
{
	//__________________________________________ Is integer?
	if (input == (int)input)
	{
		if (replaceWithMinusSign && input < 0)
		{
			return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%c%d", 0x2212, (int)fabs(input));
		}
		return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d", (int)input);
	}
	if (compactFormat == false)
	{
		const int len = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%g", input);
		if (replaceWithMinusSign)
		{
			for(register wchar_t* p = out_buffer; *p != '\0'; p++) if (*p == '-') *p = 0x2212;
		}
		return len;
	}
	//________________________________________________________ Compact Format
	const double absinput = fabs(input);
	if (absinput == 0.0)
	{
		return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"0");
	}
	else if (absinput < 0.1)
	{
		const int len = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%.1e", input);
		if (replaceWithMinusSign)
		{
			for (register wchar_t* p = out_buffer; *p != '\0'; p++) if (*p == '-') *p = 0x2212;
		}
		return len;
	}
	else if (absinput < 1.0)
	{
		const int len = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%.4f", input);
		if (replaceWithMinusSign)
		{
			for (register wchar_t* p = out_buffer; *p != '\0'; p++) if (*p == '-') *p = 0x2212;
		}
		if (out_buffer[len-1] != '0') return len;
		out_buffer[len-1] = '\0';
		if (out_buffer[len-2] != '0') return len-1;
		out_buffer[len-2] = '\0';
		if (out_buffer[len-3] != '0') return len-2;
		out_buffer[len-3] = '\0';
		return len-3;
	}
	else if (absinput < 10.0)
	{
		const int len = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%.3f", input);
		if (replaceWithMinusSign)
		{
			for (register wchar_t* p = out_buffer; *p != '\0'; p++) if (*p == '-') *p = 0x2212;
		}
		if (out_buffer[len-1] != '0') return len;
		out_buffer[len-1] = '\0';
		if (out_buffer[len-2] != '0') return len-1;
		out_buffer[len-2] = '\0';
		return len-2;
	}
	else if (absinput < 100.0)
	{
		const int len = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%.2f", input);
		if (replaceWithMinusSign)
		{
			for (register wchar_t* p = out_buffer; *p != '\0'; p++) if (*p == '-') *p = 0x2212;
		}
		if (out_buffer[len-1] != '0') return len;
		out_buffer[len-1] = '\0';
		return len-1;
	}
	else if (absinput < 1000.0)
	{
		if (replaceWithMinusSign && input < 0.0)
		{
			return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%c%.1f", 0x2212, fabs(input));
		}
		return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%.1f", input);
	}
	const int len = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%.1e", input);
	if (replaceWithMinusSign)
	{
		for (register wchar_t* p = out_buffer; *p != '\0'; p++) if (*p == '-') *p = 0x2212;
	}
	return len;

	//double integer_part = 0.0;
	//double fraction_part = modf(input, &integer_part);
	//if (fraction_part == 0.0 && absinput < 10000)
	//{
	//	return _snwprintf_s(output, output_size, _TRUNCATE, L"%.0f", integer_part);
	//}
	//else if (input == 0.0)
	//{
	//	return _snwprintf_s(output, output_size, _TRUNCATE, L"0");
	//}
	//else if (absinput < 0.1)
	//{
	//	const int exponent = (int)(fabs(log10(absinput))+0.999999999999999999);
	//	const double based = pow(10.0, -exponent);
	//	const double mantissa = input/based;
	//	double integer_mantissa= 0.0;
	//	double fraction_mantissa = modf(mantissa, &integer_mantissa);
	//	if (integer_mantissa == 0.0)
	//	{
	//		return _snwprintf_s(output, output_size, _TRUNCATE, L"%.0f-e%d", mantissa, exponent);
	//	}
	//	else
	//	{
	//		const int decimal = (int)(fraction_mantissa*10);
	//		if (10*decimal == 0)
	//		{
	//			return _snwprintf_s(output, output_size, _TRUNCATE, L"%.0f-e%d", mantissa, exponent);
	//		}
	//		else
	//		{
	//			return _snwprintf_s(output, output_size, _TRUNCATE, L"%.1f-e%d", mantissa, exponent);
	//		}
	//	}
	//}
	//else if (absinput < 1.0)
	//{
	//	const int len = _snwprintf_s(output, output_size, _TRUNCATE, L"%.4f", input);
	//	if (output[len-1] != '0') return len;
	//	output[len-1] = '\0';
	//	if (output[len-2] != '0') return len-1;
	//	output[len-2] = '\0';
	//	if (output[len-3] != '0') return len-2;
	//	output[len-3] = '\0';
	//	return len-3;
	//}
	//else if (absinput < 10.0)
	//{
	//	const int len = _snwprintf_s(output, output_size, _TRUNCATE, L"%.3f", input);
	//	if (output[len-1] != '0') return len;
	//	output[len-1] = '\0';
	//	if (output[len-2] != '0') return len-1;
	//	output[len-2] = '\0';
	//	return len-2;
	//}
	//else if (absinput < 100.0)
	//{
	//	const int len = _snwprintf_s(output, output_size, _TRUNCATE, L"%.2f", input);
	//	if (output[len-1] != '0') return len;
	//	output[len-1] = '\0';
	//	return len-1;
	//}
	//else if (absinput < 1000.0)
	//{
	//	return _snwprintf_s(output, output_size, _TRUNCATE, L"%.1f", input);
	//}
	//else
	//{
	//	const int exponent = (int)(log10(absinput));
	//	const double based = pow(10.0, exponent);
	//	const double mantissa = input/based;
	//	double integer_mantissa= 0.0;
	//	double fraction_mantissa = modf(mantissa, &integer_mantissa);

	//	if (integer_mantissa == 0.0)
	//	{
	//		return _snwprintf_s(output, output_size, _TRUNCATE, L"%.0fe%d", mantissa, exponent);
	//	}
	//	else
	//	{
	//		const int decimal = (int)(fraction_mantissa*10);
	//		if (10*decimal == 0)
	//		{
	//			return _snwprintf_s(output, output_size, _TRUNCATE, L"%.0fe%d", mantissa, exponent);
	//		}
	//		else
	//		{
	//			return _snwprintf_s(output, output_size, _TRUNCATE, L"%.1fe%d", mantissa, exponent);
	//		}
	//		//_snwprintf_s(output, output_size, _TRUNCATE, L"%.1fe%d", mantissa, exponent);
	//	}
	//}
	//return 0; // Never get here
}

int Convert::ToString(double input, char* out_buffer, int out_buffer_size, bool compactFormat)
{
	if (compactFormat == false)
	{
		return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%g", input);
	}
	//_______________________________ Compact Format
	const double absinput = fabs(input);

	
	double integer_part = 0.0;
	double fraction_part = modf(input, &integer_part);
	if (fraction_part == 0.0)
	{
		return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.0f", integer_part);
	}
	else if (input == 0.0)
	{
		return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "0");
	}
	else if (absinput < 0.1)
	{
		const int exponent = (int)(fabs(log10(absinput))+0.99999999999);
		const double based = pow(10.0, -exponent);
		const double mantissa = input/based;
		double integer_mantissa= 0.0;
		double fraction_mantissa = modf(mantissa, &integer_mantissa);
		if (integer_mantissa == 0.0)
		{
			return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.0f-e%d", mantissa, exponent);
		}
		else
		{
			const int decimal = (int)(fraction_mantissa*10);
			if (10*decimal == 0)
			{
				return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.0f-e%d", mantissa, exponent);
			}
			else
			{
				return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.1f-e%d", mantissa, exponent);
			}
		}
	}
	else if (absinput < 1.0)
	{
		const int len = _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.4f", input);
		if (out_buffer[len-1] != '0') return len;
		out_buffer[len-1] = '\0';
		if (out_buffer[len-2] != '0') return len-1;
		out_buffer[len-2] = '\0';
		if (out_buffer[len-3] != '0') return len-2;
		out_buffer[len-3] = '\0';
		return len-3;
	}
	else if (absinput < 10.0)
	{
		const int len = _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.3f", input);
		if (out_buffer[len-1] != '0') return len;
		out_buffer[len-1] = '\0';
		if (out_buffer[len-2] != '0') return len-1;
		out_buffer[len-2] = '\0';
		return len-2;
	}
	else if (absinput < 100.0)
	{
		const int len = _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.2f", input);
		if (out_buffer[len-1] != '0') return len;
		out_buffer[len-1] = '\0';
		return len-1;
	}
	else if (absinput < 1000.0)
	{
		return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.1f", input);
	}
	else
	{
		const int exponent = (int)(log10(absinput));
		const double based = pow(10.0, exponent);
		const double mantissa = input/based;
		double integer_mantissa= 0.0;
		double fraction_mantissa = modf(mantissa, &integer_mantissa);

		if (integer_mantissa == 0.0)
		{
			return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.0fe%d", mantissa, exponent);
		}
		else
		{
			const int decimal = (int)(fraction_mantissa*10);
			if (10*decimal == 0)
			{
				return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.0fe%d", mantissa, exponent);
			}
			else
			{
				return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%.1fe%d", mantissa, exponent);
			}
			//_snwprintf_s(output, output_size, _TRUNCATE, L"%.1fe%d", mantissa, exponent);
		}
	}
	return 0; // Never get here
}

int Convert::ToString(const complex<double>& input, wchar_t* out_buffer, int out_buffer_size, bool compactFormat, bool replaceWithMinusSign)
{
	const double re = input.real();
	const double im = input.imag();
	wchar_t text[32];
	wchar_t text2[32];
	if (re == 0.0 && im == 0.0)
	{
		return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"0");
	}
	else if (re == 0.0)
	{
		Sys::Convert::ToString(im, text, 32, compactFormat, replaceWithMinusSign);
		return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%si", text);
	}
	else if (im == 0.0)
	{
		return Sys::Convert::ToString(re, out_buffer, out_buffer_size, compactFormat, replaceWithMinusSign);
	}
	else
	{
		Sys::Convert::ToString(re, text, 32, compactFormat, replaceWithMinusSign);
		Sys::Convert::ToString(fabs(im), text2, 32, compactFormat, replaceWithMinusSign);
		if (im > 0.0)
		{
			return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%s+%si", text, text2);
		}
		else
		{
			if (replaceWithMinusSign)
			{
				return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%s%c%si", text, 0x2212, text2);
			}
			else
			{
				return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%s-%si", text, text2);
			}
		}
	}
	return 0; // Never get here
}

int Convert::ToString(const complex<double>& input, char* out_buffer, int out_buffer_size, bool compactFormat)
{
	const double re = input.real();
	const double im = input.imag();
	char text[32];
	char text2[32];
	if (re == 0.0 && im == 0.0)
	{
		return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "0");
	}
	else if (re == 0.0)
	{
		Sys::Convert::ToString(im, text, 32, compactFormat);
		return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%si", text);
	}
	else if (im == 0.0)
	{
		return Sys::Convert::ToString(re, out_buffer, out_buffer_size, compactFormat);
	}
	else
	{
		Sys::Convert::ToString(re, text, 32, compactFormat);
		Sys::Convert::ToString(fabs(im), text2, 32, compactFormat);
		if (im > 0.0)
		{
			return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%s+%si", text, text2);
		}
		else
		{
			return _snprintf_s(out_buffer, out_buffer_size, _TRUNCATE, "%s-%si", text, text2);
		}
	}
	return 0; // Never get here
}

int Convert::ToString(double input, const wchar_t* format, wchar_t* out_buffer, int out_buffer_size)
{
	return _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, format, input);
	//for(int i=0; i<length; i++) 
	//{
	//	if (output[i]=='-') output[i]=0x2212;
	//}
}

wstring& Convert::ToString(const _variant_t& input, wstring& output)
{
	switch (input.vt)
	{
	case VT_EMPTY: output.clear(); return output;
	case VT_NULL: output.clear(); return output;
	case VT_I2: return Sys::Format(output, L"%d", input.iVal);
	case VT_I4: return Sys::Format(output, L"%d", input.lVal);
	case VT_R4: return Sys::Format(output, L"%g", input.fltVal);
	case VT_R8: return Sys::Format(output, L"%g", input.dblVal);
	case VT_CY: return Sys::Format(output, L"%d", input.cyVal);
	case VT_DATE:
	{
			Sys::Time tmp = Sys::Convert::VariantToTime(input);
			return Sys::Convert::DateToString(tmp, L"ddd',' MMM dd yyyy", output);
	}
	case VT_BSTR: return Sys::Format(output, L"%s", input.bstrVal);
	case VT_DISPATCH: output.clear(); return output; //pdispVal);
	case VT_ERROR: output.clear(); return output; //scode);
	case VT_BOOL: output = (input.boolVal == 1) ? true : false;  return output;
	case VT_VARIANT: output.clear(); return output;
	case VT_UNKNOWN: return Sys::Format(output, L"%d", input.punkVal);
	case VT_DECIMAL: return Sys::Format(output, L"%d", input.decVal);
	case VT_I1: return Sys::Format(output, L"%d", input.bVal);
	case VT_UI1: return Sys::Format(output, L"%d", input.bVal);
	case VT_UI2: return Sys::Format(output, L"%d", input.uiVal);
	case VT_UI4: return Sys::Format(output, L"%d", input.ulVal);
	case VT_I8: return Sys::Format(output, L"%d", input.llVal);
	case VT_UI8: return Sys::Format(output, L"%d", input.ullVal);
	case VT_INT: return Sys::Format(output, L"%d", input.intVal);
	case VT_UINT: return Sys::Format(output, L"%d", input.uintVal);
	case VT_VOID: return Sys::Format(output, L"%d", input.byref);
	case VT_HRESULT: return Sys::Format(output, L"%d", input.lVal);
	case VT_PTR: return Sys::Format(output, L"%d", input.byref);
	case VT_SAFEARRAY: return Sys::Format(output, L"%d", input.parray);
	case VT_CARRAY: return Sys::Format(output, L"%d", input.byref);
	case VT_USERDEFINED: return Sys::Format(output, L"%d", input.byref);
	case VT_LPSTR: return Sys::Format(output, L"%d", input.pcVal);
	case VT_LPWSTR: return Sys::Format(output, L"%d", input.pbstrVal);
	case VT_RECORD: output.clear(); return output;
#ifndef __vsshell_h__
	case VT_INT_PTR: return Sys::Format(output, L"%d", *input.pintVal);
	case VT_UINT_PTR: return Sys::Format(output, L"%d", *input.puintVal);
#endif
	case VT_ARRAY: output.clear(); return output;
		//________________________________________________________________ BYREF
	case VT_I2 | VT_BYREF: return Sys::Format(output, L"%d", *input.piVal);
	case VT_I4 | VT_BYREF: return Sys::Format(output, L"%d", *input.plVal);
	case VT_R4 | VT_BYREF: return Sys::Format(output, L"%g", *input.pfltVal);
	case VT_R8 | VT_BYREF: return Sys::Format(output, L"%g", *input.pdblVal);
	case VT_CY | VT_BYREF: return Sys::Format(output, L"%d", *input.pcyVal);
	case VT_DATE | VT_BYREF:
	{
			Sys::Time tmp = Sys::Convert::VariantToTime(input);
			return Sys::Convert::DateToString(tmp, L"ddd',' MMM dd yyyy", output);
	}
	case VT_BSTR | VT_BYREF: return Sys::Format(output, L"%d", *input.pbstrVal);
	case VT_DISPATCH | VT_BYREF: return Sys::Format(output, L"%d", *input.ppdispVal);
	case VT_ERROR | VT_BYREF: return Sys::Format(output, L"%d", *input.pscode);
	case VT_BOOL | VT_BYREF: return Sys::Format(output, L"%d", *input.pboolVal);
	case VT_VARIANT | VT_BYREF: output.clear(); return output;  //L"pvarVal);
	case VT_UNKNOWN | VT_BYREF:  output.clear(); return output;  //ppunkVal);
	case VT_DECIMAL | VT_BYREF: return Sys::Format(output, L"%g", *input.pdecVal);
	case VT_I1 | VT_BYREF: return Sys::Format(output, L"%d", *input.pbVal);
	case VT_UI1 | VT_BYREF: return Sys::Format(output, L"%d", *input.pbVal);
	case VT_UI2 | VT_BYREF: return Sys::Format(output, L"%d", *input.puiVal);
	case VT_UI4 | VT_BYREF: return Sys::Format(output, L"%d", *input.pulVal);
	case VT_I8 | VT_BYREF: return Sys::Format(output, L"%d", *input.pllVal);
	case VT_UI8 | VT_BYREF: return Sys::Format(output, L"%d", *input.pullVal);
	case VT_INT | VT_BYREF: return Sys::Format(output, L"%d", *input.pintVal);
	case VT_UINT | VT_BYREF: return Sys::Format(output, L"%d", *input.puintVal);
	case VT_VOID | VT_BYREF: output.clear(); return output;  //byref
	case VT_HRESULT | VT_BYREF: return Sys::Format(output, L"%d", *input.plVal);
	case VT_PTR | VT_BYREF: return Sys::Format(output, L"%d", input.byref);
	case VT_SAFEARRAY | VT_BYREF: return Sys::Format(output, L"%d", input.pparray);
	case VT_CARRAY | VT_BYREF: output.clear(); return output;  //.byref
	case VT_USERDEFINED | VT_BYREF: output.clear(); return output;  //byref
	case VT_LPSTR | VT_BYREF: output.clear(); return output;  //ppcVal
	case VT_LPWSTR | VT_BYREF: output.clear(); return output;  //ppbstrVal
	case VT_RECORD | VT_BYREF: output.clear(); return output;
#ifndef __vsshell_h__
	case VT_INT_PTR | VT_BYREF: output.clear(); return output;  //return Sys::Format(output, L"%d", **input.ppintVal);
	case VT_UINT_PTR | VT_BYREF: output.clear(); return output;  //return Sys::Format(output, L"%d", **input.ppuintVal);
#endif
	case VT_ARRAY | VT_BYREF: output.clear(); return output;
		//________________________________________________________________ SPECIAL
	case VT_RESERVED: output.clear(); return output;
	case VT_ILLEGAL: output.clear(); return output;
	case VT_TYPEMASK: output.clear(); return output;
	}
	return output;
}

wstring Convert::ToStringCommaSeparated(int input)
{
	wchar_t out[64];
	Sys::Convert::ToStringCommaSeparated(input, out, 64);
	return out;
}

void Convert::ToStringCommaSeparated(int input, wchar_t* out_buffer, int out_buffer_size)
{
	const int fvalue = abs(input);
	int low;
	int hi;
	int length = 0;
	if (fvalue<1000)
	{
		length = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d", input);
	}
	else if (fvalue<1000000)
	{
		hi = input/1000;
		low = fvalue%1000;
		if (low<10) length = _snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,00%d", hi, low);
		else if (low<100) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,0%d", hi, low);
		else if (low<1000) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,%d", hi, low);
	}
	else if (fvalue<1000000000)
	{
		int lowA = input/1000000;
		hi = (fvalue%1000000)/1000;
		low = (fvalue%1000000)%1000;
		if (low<10)
		{
			if (hi<10) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,00%d,00%d", lowA, hi, low);
			else if (hi<100) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,0%d,00%d", lowA, hi, low);
			else if (hi<1000) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,%d,00%d", lowA, hi, low);
		}
		else if (low<100) 
		{
			if (hi<10) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,00%d,0%d", lowA, hi, low);
			else if (hi<100) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,0%d,0%d", lowA, hi, low);
			else if (hi<1000) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,%d,0%d", lowA, hi, low);
		}
		else if (low<1000)
		{
			if (hi<10) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,00%d,%d", lowA, hi, low);
			else if (hi<100) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,0%d,%d", lowA, hi, low);
			else if (hi<1000) length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d,%d,%d", lowA, hi, low);
		}
	}
	else
	{
		length =_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%d", input);
	}
	//for(int i=0; i<length; i++) 
	//{
	//	if (output[i]=='-') out[i]=0x2212;
	//}
}

wstring Convert::ToStringUsingCurrencyFormat(double input)
{
	wchar_t text[32];
	Sys::Convert::ToStringUsingCurrencyFormat(input, text, 32);
	return text;
}

void Convert::ToStringUsingCurrencyFormat(double input, wchar_t* out_buffer, int out_buffer_size)
{
	const int fvalue = abs((int)input);
	const double diff = (fabs(input)-fvalue)+0.00000001;
	const int fracc= (int)(100.0*diff);

	wchar_t tmp[32];
	Sys::Convert::ToStringCommaSeparated((int)input, tmp, 32);
	_snwprintf_s(out_buffer, out_buffer_size, _TRUNCATE, L"%s.%02d", tmp, fracc);
}


//_____________________________________________________________ MATRIX
wstring& Convert::ToString(const MATRIX& input, wstring& output)
{
	const int rows = (int)input.size();
	if (rows<=0)
	{
		output.clear();
		return output;
	}
	const int cols = (int)input[0].size();
	int i, j;
	wchar_t text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (i == rows-1)
				{
					_snwprintf_s(text, 64, _TRUNCATE, L"%g", input[i][j]);
				}
				else
				{
					_snwprintf_s(text, 64, _TRUNCATE, L"%g\r\n", input[i][j]);
				}
			}
			else
			{
				_snwprintf_s(text, 64, _TRUNCATE, L"%g, ", input[i][j]);
			}
			output += text;
		}
	}
	return output;
}

string& Convert::ToString(const MATRIX& input, string& output)
{
	const int rows = (int)input.size();
	if (rows<=0)
	{
		output.clear();
		return output;
	}
	const int cols = (int)input[0].size();
	int i, j;
	char text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (i == rows-1)
				{
					_snprintf_s(text, 64, _TRUNCATE, "%g", input[i][j]);
				}
				else
				{
					_snprintf_s(text, 64, _TRUNCATE, "%g\r\n", input[i][j]);
				}
			}
			else
			{
				_snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i][j]);
			}
			output += text;
		}
	}
	return output;
}

wstring& Convert::ToString(const MATRIXC& input, wstring& output)
{
	const int rows = (int)input.size();
	if (rows<=0) 
	{
		output.clear();
		return output;
	}
	const int cols = (int)input[0].size();
	int i, j;
	wchar_t text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			Sys::Convert::ToString(input[i][j], text, 64, false, false);
			output+= text;
			if (j < cols-1) output+=L", ";
		}
		if (i < rows-1) output+=L"\r\n";
	}
	return output;
}

string& Convert::ToString(const MATRIXC& input, string& output)
{
	const int rows = (int)input.size();
	if (rows<=0) 
	{
		output.clear();
		return output;
	}
	const int cols = (int)input[0].size();
	int i, j;
	char text[64];
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			Sys::Convert::ToString(input[i][j], text, 64, false);
			output+= text;
			if (j < cols-1) output+=", ";
		}
		if (i < rows-1) output+="\r\n";
	}
	return output;
}

//_____________________________________________________________ valarray
wstring& Convert::ToString(const valarray<double>& input, wstring& output)
{
	const int size = (int)input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g", input[i]);
		}
		else
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

string& Convert::ToString(const valarray<double>& input, string& output)
{
	const int size = (int)input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
		}
		else
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

wstring& Convert::ToString(const valarray<complex<double> >& input, wstring& output)
{
	const int size = (int)input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		Sys::Convert::ToString(input[i], text, 64, false, false);
		output+=text;
		if (i < size-1) output+=L", ";  
	}
	return output;
}

string& Convert::ToString(const valarray<complex<double> >& input, string& output)
{
	const int size = (int)input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		Sys::Convert::ToString(input[i], text, 64, false);
		output+=text;
		if (i < size-1) output+=", ";  
	}
	return output;
}

//_____________________________________________________________ vector
wstring& Convert::ToString(const vector<double>& input, wstring& output)
{
	const int size = (int)input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g", input[i]);
		}
		else
		{
			_snwprintf_s(text, 64, _TRUNCATE, L"%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

string& Convert::ToString(const vector<double>& input, string& output)
{
	const int size = (int)input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		if (i == size-1)
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
		}
		else
		{
			_snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i]);
		}
		output += text;
	}
	return output;
}

wstring& Convert::ToString(const vector<complex<double> >& input, wstring& output)
{
	const int size = (int)input.size();
	output.clear();
	wchar_t text[64];
	for(int i= 0; i < size; i++)
	{
		Sys::Convert::ToString(input[i], text, 64, false, false);
		output+=text;
		if (i < size-1) output+=L", ";  
	}
	return output;
}

string& Convert::ToString(const vector<complex<double> >& input, string& output)
{
	const int size = (int)input.size();
	output.clear();
	char text[64];
	for(int i= 0; i < size; i++)
	{
		Sys::Convert::ToString(input[i], text, 64, false);
		output+=text;
		if (i < size-1) output+=", ";  
	}
	return output;
}

wstring& Convert::DateToString(const Sys::Time& input, const wchar_t* format, wstring& output)
{
	int length = ::GetDateFormat(NULL, NULL, &input, format, NULL, 0);
	output.resize(length);

	::GetDateFormat(NULL, NULL, &input, format, (LPWSTR)output.data(), length);
	output.resize(length-1);

	 //GetDateFormat (LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE | DATE_SHORTDATE,
  //                  &sysTime, NULL, szDate, sizeof (szDate)) ;
  //   
  //   GetTimeFormat (LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE | 
  //                       TIME_NOTIMEMARKER | TIME_FORCE24HOURFORMAT,
  //                  &sysTime, NULL, szTime, sizeof (szTime)) ;
	return output;
}

// format day: d, dd, ddd  or dddd
// format month: M, MM, MMM or MMMM
// format year: y, yy, yyy or yyyy
// format:  L"ddd',' MMM dd yyyy"
wstring Convert::ToString(const Sys::Time& input, const wchar_t* format)
{
	wstring output;
	int length = ::GetDateFormat(NULL, NULL, &input, format, NULL, 0);
	output.resize(length);

	::GetDateFormat(NULL, NULL, &input, format, (LPWSTR)output.data(), length);
	output.resize(length-1);
	return output;
}

// format: L"hh':'mm':'ss tt"
wstring& Convert::TimeToString(const Sys::Time& input, const wchar_t* format, wstring& output)
{
	int length = ::GetTimeFormat(NULL, NULL, &input, format, NULL, 0);
	output.resize(length);

	::GetTimeFormat(NULL, NULL, &input, format, (LPWSTR)output.data(), length);
	output.resize(length-1);
	return output;
}

void Convert::ClsidToString(REFCLSID clsid, wstring& output)
{
	Sys::Format(output, L"%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX", 
	  clsid.Data1, clsid.Data2, clsid.Data3, 
	  clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3],
	  clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7]);
}

void Convert::GuidToString(REFGUID guid, wstring& output)
{
	Sys::Format(output, L"%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX", 
	  guid.Data1, guid.Data2, guid.Data3, 
	  guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
	  guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
}


string& Convert::WstringToString(const wchar_t* input, string& output)
{
	if (input==NULL) 
	{
		output.clear();
		return output;
	}
	const int lenW = (int)wcslen(input);
	if (lenW<=0)
	{
		output.clear();
		return output;
	}
	
	const int lenA = ::WideCharToMultiByte(CP_ACP, 0, input, lenW, 0, 0, NULL, NULL);
	if (lenA<=0)
	{
		output.clear();
		return output;
	}
	output.resize(lenA+1);
	::WideCharToMultiByte(CP_ACP, 0, input, lenW, (LPSTR)output.data(), lenA, NULL, NULL);
	output.resize(lenA);
	return output;
}

void Convert::WstringToString(const wchar_t* input, Sys::Buffer& output)
{
	if (input==NULL) 
	{
		output.Delete();
		return;
	}
	const int lenW = (int)wcslen(input);
	if (lenW<=0)
	{
		output.Delete();
		return;
	}
	
	const int lenA = ::WideCharToMultiByte(CP_ACP, 0, input, lenW, 0, 0, NULL, NULL);
	if (lenA<=0)
	{
		output.Delete();
		return;
	}
	output.SetSize(lenA+1);
	::WideCharToMultiByte(CP_ACP, 0, input, lenW, (LPSTR)(char *)output, lenA, NULL, NULL);
	output.SetSize(lenA);
}

string& Convert::WstringToString(const wstring& input, string& output)
{
	return WstringToString(input.c_str(), output);
}

void Convert::WstringToString(const wstring& input, Sys::Buffer& output)
{
	WstringToString(input.c_str(), output);
}

wstring& Convert::StringToWstring(const char* input, wstring& output)
{
	if (input==NULL) 
	{
		output.clear();
		return output;
	}
	const int lenA = (int)strlen(input);
	if (lenA<=0)
	{
		output.clear();
		return output;
	}

	const int lenW = ::MultiByteToWideChar(CP_ACP, 0, input, lenA, 0, 0);
	if (lenW <= 0)
	{
		output.clear();
		return output;
	}
	output.resize(lenW+1);
	::MultiByteToWideChar(CP_ACP, 0, input, lenA, (LPWSTR)output.data(), lenW);
	output.resize(lenW);
	return output;
}

void Convert::StringToWstring(const Sys::Buffer& input, wstring& output)
{
	const size_t lenA = input.GetSize();
	if (lenA == 0) 
	{
		output.clear();
		return;
	}

	const int lenW = ::MultiByteToWideChar(CP_ACP, 0, input, (int)lenA, 0, 0);
	if (lenW <= 0)
	{
		output.clear();
		return;
	}
	output.resize(lenW+1);
	::MultiByteToWideChar(CP_ACP, 0, input, (int)lenA, (LPWSTR)output.data(), lenW);
	output.resize(lenW);
}

wstring& Convert::StringToWstring(const string& input, wstring& output)
{
	return StringToWstring(input.c_str(), output);
}

vector<wstring>& Convert::ToVectorOfStrings(const wchar_t* input, vector<wstring>& output)
{
	if (input == NULL)
	{
		output.clear();
		return output;
	}
	if (input[0] == '\0')
	{
		output.clear();
		return output;
	}
	//______________________________________________________________ Compute number of '\n' and number of '\r'
	int count_n = 1;  // '\n'
	int count_r = 1;   // '\r'
	register wchar_t* p;
	for(p = (wchar_t*)input; *p != '\0'; p++)
	{
		if (*p == '\n') count_n++;
		if (*p == '\r') count_r++;
	}
	//______________________________________________________________ one row
	if (count_n == 1 && count_r == 1)
	{
		output.push_back(input);
		return output;
	}
	//_______________________________________________________________ Prepare
	const bool lineBreakR = (count_n == 1 && count_r > 1);
	const int lineCount = (lineBreakR == true) ? count_r : count_n;
	const wchar_t sepMain = (lineBreakR == true) ? '\r' : '\n';
	const wchar_t sepOptional = (lineBreakR == true) ? '\n' : '\r';
	//
	int buffer_size = 16384;
	bool ok = true;
	register wchar_t *tmp = NULL;
	register int count = 0;
	output.reserve(lineCount);
	// Use an initial buffer size
	do
	{
		ok = true;
		if (tmp != NULL) delete [] tmp;
		tmp = new wchar_t[buffer_size];
		count = 0;
		for(p = (wchar_t*)input; *p != '\0'; p++)
		{
			if (*p == sepOptional) continue;
			if (*p == sepMain)
			{
				if (buffer_size <= count)
				{
					ok = false; // No enough memory
					break;
				}
				tmp[count] = '\0';
				output.push_back(tmp);
				count = 0;
			}
			else
			{
				tmp[count] = *p;
				count++;
				if (buffer_size <= count)
				{
					ok = false; // No enough memory
					break;
				}
			}
		}

		if (ok == true)
		{
			if (buffer_size <= count)
			{
				ok = false; // No enough memory
			}
			else if (*p == '\0' && 0 < count)
			{
				tmp[count] = '\0';
				output.push_back(tmp);
			}
		}
		if (ok == false)
		{
			buffer_size *= 2;
			output.clear();
			output.reserve(lineCount);
		}
	}
	while (ok == false);
	if (tmp != NULL) delete [] tmp;
	return output;

	//if (input==NULL)
	//{
	//	output.clear();
	//	return output;
	//}
	//const int len = wcslen(input);
	//if (len <= 0)
	//{
	//	output.clear();
	//	return output;
	//}
	//wstring tmp;
	//for(int i=0; i<len; i++)
	//{
	//	if (input[i]=='\r') continue;
	//	if (input[i]=='\n')
	//	{
	//		output.push_back(tmp);
	//		tmp.clear();
	//	}
	//	else
	//	{
	//		tmp+=input[i];
	//		if (i==len-1 && tmp.length()>0)
	//		{
	//			output.push_back(tmp);
	//		}
	//	}
	//}
	//return output;
}

vector<wstring>& Convert::ToVectorOfStrings(const wstring& input, vector<wstring>& output)
{
	return ToVectorOfStrings(input.c_str(), output);
}

vector<string>& Convert::ToVectorOfStrings(const char* input, vector<string>& output)
{
	if (input == NULL)
	{
		output.clear();
		return output;
	}
	if (input[0] == '\0')
	{
		output.clear();
		return output;
	}
	//______________________________________________________________ Compute number of '\n' and number of '\r'
	int count_n = 1;  // '\n'
	int count_r = 1;   // '\r'
	register char* p;
	for (p = (char*)input; *p != '\0'; p++)
	{
		if (*p == '\n') count_n++;
		if (*p == '\r') count_r++;
	}
	//______________________________________________________________ one row
	if (count_n == 1 && count_r == 1)
	{
		output.push_back(input);
		return output;
	}
	//_______________________________________________________________ Prepare
	const bool lineBreakR = (count_n == 1 && count_r > 1);
	const int lineCount = (lineBreakR == true) ? count_r : count_n;
	const wchar_t sepMain = (lineBreakR == true) ? '\r' : '\n';
	const wchar_t sepOptional = (lineBreakR == true) ? '\n' : '\r';
	//
	int buffer_size = 16384;
	bool ok = true;
	register char*tmp = NULL;
	register int count = 0;
	output.reserve(lineCount);
	// Use an initial buffer size
	do
	{
		ok = true;
		if (tmp != NULL) delete [] tmp;
		tmp = new char[buffer_size];
		count = 0;
		for(p = (char*)input; *p != '\0'; p++)
		{
			if (*p == '\r') continue;
			if (*p == '\n')
			{
				if (buffer_size <= count)
				{
					ok = false; // No enough memory
					break;
				}
				tmp[count] = '\0';
				output.push_back(tmp);
				count = 0;
			}
			else
			{
				tmp[count] = *p;
				count++;
				if (buffer_size <= count)
				{
					ok = false; // No enough memory
					break;
				}
			}
		}

		if (ok == true)
		{
			if (buffer_size <= count)
			{
				ok = false; // No enough memory
			}
			else if (*p == '\0' && 0 < count)
			{
				tmp[count] = '\0';
				output.push_back(tmp);
			}
		}
		if (ok == false)
		{
			buffer_size *= 2;
			output.clear();
			output.reserve(lineCount);
		}
	}
	while (ok == false);
	if (tmp != NULL) delete [] tmp;
	return output;
	//if (input==NULL)
	//{
	//	output.clear();
	//	return output;
	//}
	//const int len = strlen(input);
	//if (len <= 0)
	//{
	//	output.clear();
	//	return output;
	//}
	//string tmp;
	//for(int i=0; i<len; i++)
	//{
	//	if (input[i]=='\r') continue;
	//	if (input[i]=='\n')
	//	{
	//		output.push_back(tmp);
	//		tmp.clear();
	//	}
	//	else if (i==len-1 && tmp.length()>0)
	//	{
	//		tmp+=input[i];
	//		output.push_back(tmp);
	//		break;
	//	}
	//	else
	//	{
	//		tmp+=input[i];
	//		if (i==len-1 && tmp.length()>0)
	//		{
	//			output.push_back(tmp);
	//			break;
	//		}
	//	}
	//}
	//return output;
}

vector<string>& Convert::ToVectorOfStrings(const string& input, vector<string>& output)
{
	return ToVectorOfStrings(input.c_str(), output);
}

vector<wstring>& Convert::ToVectorOfStrings(const wchar_t* input, wchar_t separator, vector<wstring>& output)
{
	if (input==NULL)
	{
		output.clear();
		return output;
	}
	const int len = (int)wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return output;
	}
	wstring tmp;
	for(int i=0; i<len; i++)
	{
		if (input[i] == separator)
		{
			output.push_back(tmp);
			tmp.clear();
		}
		else if (i==len-1 && tmp.length()>0)
		{
			tmp+=input[i];
			output.push_back(tmp);
			tmp.clear();
		}
		else
		{
			tmp+=input[i];
		}
	}
	if (tmp.length() > 0) output.push_back(tmp);
	return output;
}

vector<wstring>& Convert::ToVectorOfStrings(const wstring& input, wchar_t separator, vector<wstring>& output)
{
	return ToVectorOfStrings(input.c_str(), separator, output);
}

void Convert::ToSet(const wchar_t* input, wchar_t separator, set<wstring>& output)
{
	if (input==NULL)
	{
		output.clear();
		return;
	}
	const int len = (int)wcslen(input);
	if (len <= 0)
	{
		output.clear();
		return;
	}
	wstring tmp;
	for(int i=0; i<len; i++)
	{
		if (input[i] == separator)
		{
			output.insert(tmp);
			tmp.clear();
		}
		else if (i==len-1 && tmp.length()>0)
		{
			tmp+=input[i];
			output.insert(tmp);
			tmp.clear();
		}
		else
		{
			tmp+=input[i];
		}
	}
	if (tmp.length() > 0) output.insert(tmp);
}

bool Convert::UTF8ToWstring(const string& input, wstring& output)
{
	const int lengthUTF8 = (int)input.length();
    if (lengthUTF8<=0)
    {
        output.clear();
		return true;
	}
	DWORD dwConversionFlags = 0;
#ifdef WC_ERR_INVALID_CHARS
		dwConversionFlags = WC_ERR_INVALID_CHARS;
#endif
	//__________________________________________ Compute output buffer size
    const int lengthUTF16 = ::MultiByteToWideChar(CP_UTF8, dwConversionFlags,  input.c_str(), lengthUTF8, NULL, 0);
    if ( lengthUTF16 == 0 )
	{
        output.clear();
		return false;
	}
	output.resize(lengthUTF16);
	//_____________________________________________________ Perform conversion
    return (::MultiByteToWideChar(CP_UTF8, dwConversionFlags, input.c_str(), lengthUTF8, (wchar_t*)output.c_str(), lengthUTF16) != 0);
}

bool Convert::UTF8ToWstring(const Sys::Buffer& input, wstring& output)
{
	const int lengthUTF8 = (int)input.GetSize();
    if (lengthUTF8<=0)
    {
        output.clear();
		return true;
	}
	DWORD dwConversionFlags = 0;
#ifdef WC_ERR_INVALID_CHARS
		dwConversionFlags = WC_ERR_INVALID_CHARS;
#endif
	//__________________________________________ Computer output buffer size
	const int cchUTF16 = ::MultiByteToWideChar(CP_UTF8, dwConversionFlags, (const char*)input, lengthUTF8, NULL, 0);
	output.resize(cchUTF16);
	//___________________________________________ Convert
	return (::MultiByteToWideChar(CP_UTF8, dwConversionFlags, (const char*)input,  lengthUTF8, (wchar_t*)output.c_str(), cchUTF16) != 0);
}

bool Convert::WstringToUTF8(const wstring& input, string& output)
{
	const int lengthUTF16 = (int)input.length();
	if (lengthUTF16 <= 0) 
	{
		output.clear();
		return true;
	}

	DWORD dwConversionFlags = 0;
#ifdef WC_ERR_INVALID_CHARS
	dwConversionFlags = WC_ERR_INVALID_CHARS;
#endif
	//_____________________________________________________ Compute buffer length
    const int lengthUTF8 = ::WideCharToMultiByte(CP_UTF8,  dwConversionFlags, input.c_str(),  lengthUTF16, NULL,  0, NULL, NULL);
	if (lengthUTF8 == 0)
	{
		output.clear();
		return false;
	}
	output.resize(lengthUTF8);
	//_____________________________________________________ Perform conversion
    return (::WideCharToMultiByte(CP_UTF8, dwConversionFlags, input.c_str(), lengthUTF16, (char*)output.c_str(), lengthUTF8, NULL, NULL) != 0);
}

bool Convert::WstringToUTF8(const wstring& input, Sys::Buffer& output)
{
	const int lengthUTF16 = (int)input.size();
	if (lengthUTF16 <= 0) 
	{
		output.Delete();
		return true;
	}
	DWORD dwConversionFlags = 0;
#ifdef WC_ERR_INVALID_CHARS
	dwConversionFlags = WC_ERR_INVALID_CHARS;
#endif
    //_____________________________________________________ Compute buffer length
	const int lengthUTF8 = ::WideCharToMultiByte(CP_UTF8,  dwConversionFlags, input.c_str(), lengthUTF16, NULL,  0, NULL, NULL);
	if (lengthUTF8 == 0)
	{
		output.Delete();
		return false;
	}
	if (output.SetSize(lengthUTF8) == false) return false;
	//_____________________________________________________ Perform conversion
	return (::WideCharToMultiByte(CP_UTF8, dwConversionFlags, input.c_str(), static_cast<int>( lengthUTF16 ), (char*)output, lengthUTF8, NULL, NULL) != 0);
}

void Convert::CppToHtml(const wchar_t* input_cppLine, wstring& output_html, bool indent, bool includeNeuralLabVariables)
{
	// It converts one line of code written in cpp to html
	if (input_cppLine==NULL)
	{
		output_html.clear();
		return;
	}
	const int length = (int)wcslen(input_cppLine);
	if (length<=0)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}
	int i;
	//____________________________ Check for empty code line
	bool IsEmpty = true;
	for(i = 0; i < length; i++)
	{
		if (input_cppLine[i] != ' ' && input_cppLine[i] != '\t' && input_cppLine[i] != '\r' && input_cppLine[i] != '\n')
		{
			IsEmpty = false;
			break;
		}
	}
	if (IsEmpty == true)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}

	//_______________________________ Normal code line
	wstring cppCode;

	const wchar_t* pComment = wcsstr(input_cppLine, L"//");
	bool isCommentOnly = false;

	if (pComment != NULL)
	{
		// Be sure // does not occur inside quotes
		int numQuotes = 0;
		for(i=0; i<length-1; i++)
		{
			if (i != 0)
			{
				if (input_cppLine[i] == '\"')
				{
					if (input_cppLine[i-1] != '\\')  // Be sure quotes are not \"
					{
						numQuotes++;
						continue;
					}
				}
			}
			if (input_cppLine[i] == '/' && input_cppLine[i+1] == '/')
			{
				if (numQuotes%2 == 0)
				{
					break;
				}
				else
				{
					pComment = NULL; //  "something//else", thus it is not a comment
					break;
				}
			}
		}
		//____________________________ Comment of Code + Comment
		if (pComment != NULL)
		{
			for(i=0; i<length; i++)
			{
				if (input_cppLine[i] == ' ' || input_cppLine[i]=='\t') continue;
				if (input_cppLine[i] != '/')
				{
					isCommentOnly = false;
					break;
				}
				if (input_cppLine[i] == '/')
				{
					isCommentOnly = true;
					break;
				}
			}
		}
	}
	if (pComment==NULL) //______________________________________________ only code
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_cppLine, cppCode);
		if (indent) Sys::TextAssistant::Replace(cppCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		CppToHtml(cppCode, indent, includeNeuralLabVariables);
		output_html = cppCode;
	}
	else if (isCommentOnly) //________________________________________ only comment
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_cppLine, cppCode);
		if (indent) Sys::TextAssistant::Replace(cppCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		output_html = L"<span style=\"color:#009000\">";
		output_html += cppCode;
		output_html += L"</span>";
	}
	else //________________________________________ comment and code
	{
		wstring comment;
		const int commentLength = (int)wcslen(pComment);
		comment.assign(pComment, commentLength);
		//_______________________  code
		wstring tmp;
		tmp.assign(input_cppLine, length-commentLength);
		if (indent) Sys::TextAssistant::Replace(tmp, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		Sys::TextAssistant::ReplaceBiggerLessThan(tmp.c_str(), cppCode);
		CppToHtml(cppCode, indent, includeNeuralLabVariables);
		output_html = cppCode;
		//_______________________ comment
		output_html += L"<span style=\"color:#009000\">";
		output_html += comment;
		output_html += L"</span>";	
	}
}

void Convert::CppToHtml(wstring& in_out, bool indent, bool includeNeuralLabVariables)
{
	//_________________________________________________ Strings
	wstring input(in_out);
	wstring output;
	Sys::Convert::QuotedCppToHtml(input.c_str(), L"color:#CF0000", output);
	in_out = output;
	//
	Sys::TextAssistant::Replace(in_out, L"class", L"<span style=\"color:#0000ff\">class</span>", true);
	Sys::TextAssistant::Replace(in_out, L"unsigned", L"<span style=\"color:#0000ff\">unsigned</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#include", L"<span style=\"color:#0000ff\">#include</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#define", L"<span style=\"color:#0000ff\">#define</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#pragma once", L"<span style=\"color:#0000ff\">#pragma once</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#pragma code_page", L"<span style=\"color:#0000ff\">#pragma code_page</span>", true);
	Sys::TextAssistant::Replace(in_out, L"int", L"<span style=\"color:#0000ff\">int</span>", true);
	Sys::TextAssistant::Replace(in_out, L"long", L"<span style=\"color:#0000ff\">long</span>", true);
	Sys::TextAssistant::Replace(in_out, L"short", L"<span style=\"color:#0000ff\">short</span>", true);
	Sys::TextAssistant::Replace(in_out, L"double", L"<span style=\"color:#0000ff\">double</span>", true);
	Sys::TextAssistant::Replace(in_out, L"public", L"<span style=\"color:#0000ff\">public</span>", true);
	Sys::TextAssistant::Replace(in_out, L"protected", L"<span style=\"color:#0000ff\">protected</span>", true);
	Sys::TextAssistant::Replace(in_out, L"private", L"<span style=\"color:#0000ff\">private</span>", true);
	Sys::TextAssistant::Replace(in_out, L"return", L"<span style=\"color:#0000ff\">return</span>", true);
	Sys::TextAssistant::Replace(in_out, L"const", L"<span style=\"color:#0000ff\">const</span>", true);
	Sys::TextAssistant::Replace(in_out, L"for", L"<span style=\"color:#0000ff\">for</span>", true);
	Sys::TextAssistant::Replace(in_out, L"while", L"<span style=\"color:#0000ff\">while</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#ifdef", L"<span style=\"color:#0000ff\">#ifdef</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#ifndef", L"<span style=\"color:#0000ff\">#ifndef</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#undef", L"<span style=\"color:#0000ff\">#undef</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#if", L"<span style=\"color:#0000ff\">#if</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#endif", L"<span style=\"color:#0000ff\">#endif</span>", true);
	Sys::TextAssistant::Replace(in_out, L"#else", L"<span style=\"color:#0000ff\">#else</span>", true);
	Sys::TextAssistant::Replace(in_out, L"switch", L"<span style=\"color:#0000ff\">switch</span>", true);
	Sys::TextAssistant::Replace(in_out, L"if", L"<span style=\"color:#0000ff\">if</span>", true);
	Sys::TextAssistant::Replace(in_out, L"case ", L"<span style=\"color:#0000ff\">case</span>", true);
	Sys::TextAssistant::Replace(in_out, L"default", L"<span style=\"color:#0000ff\">default</span>", true);
	Sys::TextAssistant::Replace(in_out, L"break", L"<span style=\"color:#0000ff\">break</span>", true);
	Sys::TextAssistant::Replace(in_out, L"continue", L"<span style=\"color:#0000ff\">continue</span>", true);
	Sys::TextAssistant::Replace(in_out, L"false", L"<span style=\"color:#0000ff\">false</span>", true);
	Sys::TextAssistant::Replace(in_out, L"true", L"<span style=\"color:#0000ff\">true</span>", true);
	Sys::TextAssistant::Replace(in_out, L"else", L"<span style=\"color:#0000ff\">else</span>", true);
	Sys::TextAssistant::Replace(in_out, L"else if", L"<span style=\"color:#0000ff\">else if</span>", true);
	Sys::TextAssistant::Replace(in_out, L"this", L"<span style=\"color:#0000ff\">this</span>", true);
	Sys::TextAssistant::Replace(in_out, L"new", L"<span style=\"color:#0000ff\">new</span>", true);
	Sys::TextAssistant::Replace(in_out, L"void", L"<span style=\"color:#0000ff\">void</span>", true);
	Sys::TextAssistant::Replace(in_out, L"inline", L"<span style=\"color:#0000ff\">inline </span>", true);
	Sys::TextAssistant::Replace(in_out, L"bool", L"<span style=\"color:#0000ff\">bool </span>", true);
	Sys::TextAssistant::Replace(in_out, L"virtual", L"<span style=\"color:#0000ff\">virtual</span>", true);
	Sys::TextAssistant::Replace(in_out, L"static", L"<span style=\"color:#0000ff\">static</span>", true);
	Sys::TextAssistant::Replace(in_out, L"struct", L"<span style=\"color:#0000ff\">struct</span>", true);
	Sys::TextAssistant::Replace(in_out, L"operator", L"<span style=\"color:#0000ff\">operator</span>", true);
	Sys::TextAssistant::Replace(in_out, L"namespace", L"<span style=\"color:#0000ff\">namespace</span>", true);
	Sys::TextAssistant::Replace(in_out, L"using", L"<span style=\"color:#0000ff\">using</span>", true);
	Sys::TextAssistant::Replace(in_out, L"wchar_t", L"<span style=\"color:#0000ff\">wchar_t</span>", true);
	Sys::TextAssistant::Replace(in_out, L"wstring", L"<span style=\"color:#0000ff\">wstring</span>", true);
	Sys::TextAssistant::Replace(in_out, L"case", L"<span style=\"color:#0000ff\">case</span>", true);
	Sys::TextAssistant::Replace(in_out, L"try", L"<span style=\"color:#0000ff\">try</span>", true);
	Sys::TextAssistant::Replace(in_out, L"catch", L"<span style=\"color:#0000ff\">catch</span>", true);
	Sys::TextAssistant::Replace(in_out, L"do", L"<span style=\"color:#0000ff\">do</span>", true);
	Sys::TextAssistant::Replace(in_out, L"finally", L"<span style=\"color:#0000ff\">finally</span>", true);
	Sys::TextAssistant::Replace(in_out, L"__asm", L"<span style=\"color:#0000ff\">__asm</span>", true);
	Sys::TextAssistant::Replace(in_out, L"_variant_t", L"<span style=\"color:#0000ff\">_variant_t</span>", true);
	Sys::TextAssistant::Replace(in_out, L"interface", L"<span style=\"color:#0000ff\">interface</span>", true);
	Sys::TextAssistant::Replace(in_out, L"importlib", L"<span style=\"color:#0000ff\">importlib</span>", true);
	Sys::TextAssistant::Replace(in_out, L"helpstring", L"<span style=\"color:#c000ff\">helpstring</span>", true);
	Sys::TextAssistant::Replace(in_out, L"coclass", L"<span style=\"color:#c000ff\">coclass</span>", true);
	Sys::TextAssistant::Replace(in_out, L"uuid", L"<span style=\"color:#c000ff\">uuid</span>", true);
	Sys::TextAssistant::Replace(in_out, L"__uuidof", L"<span style=\"color:#c00000\">__uuidof</span>", true);
	Sys::TextAssistant::Replace(in_out, L"HRESULT", L"<span style=\"color:#c000ff\">HRESULT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"IUnknown", L"<span style=\"color:#c000ff\">IUnknown</span>", true);
	Sys::TextAssistant::Replace(in_out, L"IDispatch", L"<span style=\"color:#c000ff\">IDispatch</span>", true);
	Sys::TextAssistant::Replace(in_out, L"STDMETHODIMP", L"<span style=\"color:#c000ff\">STDMETHODIMP</span>", true);
	Sys::TextAssistant::Replace(in_out, L"STDMETHOD", L"<span style=\"color:#c000ff\">STDMETHOD</span>", true);
	Sys::TextAssistant::Replace(in_out, L"IClassFactory", L"<span style=\"color:#c000ff\">IClassFactory</span>", true);
	Sys::TextAssistant::Replace(in_out, L"BEGIN_COM_MAP", L"<span style=\"color:#a000a0\">BEGIN_COM_MAP</span>", true);
	Sys::TextAssistant::Replace(in_out, L"COM_INTERFACE_ENTRY", L"<span style=\"color:#a000a0\">COM_INTERFACE_ENTRY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"COM_INTERFACE_ENTRY2", L"<span style=\"color:#a000a0\">COM_INTERFACE_ENTRY2</span>", true);
	Sys::TextAssistant::Replace(in_out, L"END_COM_MAP", L"<span style=\"color:#a000a0\">END_COM_MAP</span>", true);
	Sys::TextAssistant::Replace(in_out, L"Com::Object", L"<span style=\"color:#c000ff\">Com::Object</span>", true);
	Sys::TextAssistant::Replace(in_out, L"LONG", L"<span style=\"color:#c000ff\">LONG</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DWORD", L"<span style=\"color:#c000ff\">DWORD</span>", true);
	//Sys::TextAssistant::Replace(in_out, L"MATRIX", L"<span style=\"color:#c000ff\">MATRIX</span>", true);
	//Sys::TextAssistant::Replace(in_out, L"MATRIXC", L"<span style=\"color:#c000ff\">MATRIXC</span>", true);
	Sys::TextAssistant::Replace(in_out, L"COLORREF", L"<span style=\"color:#c000ff\">COLORREF</span>", true);
	Sys::TextAssistant::Replace(in_out, L"vector", L"<span style=\"color:#c000ff\">vector</span>", true);
	Sys::TextAssistant::Replace(in_out, L"valarray", L"<span style=\"color:#c000ff\">valarray</span>", true);
	Sys::TextAssistant::Replace(in_out, L"complex", L"<span style=\"color:#c000ff\">complex</span>", true);
	Sys::TextAssistant::Replace(in_out, L"map", L"<span style=\"color:#c000ff\">map</span>", true);
	Sys::TextAssistant::Replace(in_out, L"REFIID", L"<span style=\"color:#c000ff\">REFIID</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CLSID", L"<span style=\"color:#c000ff\">CLSID</span>", true);
	Sys::TextAssistant::Replace(in_out, L"HWND", L"<span style=\"color:#c000ff\">HWND</span>", true);
	Sys::TextAssistant::Replace(in_out, L"LRESULT", L"<span style=\"color:#c000ff\">LRESULT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"BOOL", L"<span style=\"color:#c000ff\">BOOL</span>", true);
	Sys::TextAssistant::Replace(in_out, L"LOGFONT", L"<span style=\"color:#c000ff\">LOGFONT</span>", true);
	//Sys::TextAssistant::Replace(in_out, L"import", L"<span style=\"color:#0000ff\">import</span>", true);
	if (includeNeuralLabVariables == true)
	{
		Sys::TextAssistant::Replace(in_out, L"Matrix", L"<span style=\"color:#0000ff\">Matrix</span>", true);
		Sys::TextAssistant::Replace(in_out, L"Vector", L"<span style=\"color:#0000ff\">Vector</span>", true);
		Sys::TextAssistant::Replace(in_out, L"Complex", L"<span style=\"color:#0000ff\">Complex</span>", true);
		Sys::TextAssistant::Replace(in_out, L"ComplexVector", L"<span style=\"color:#0000ff\">ComplexVector</span>", true);
		Sys::TextAssistant::Replace(in_out, L"ComplexMatrix", L"<span style=\"color:#0000ff\">ComplexMatrix</span>", true);
		Sys::TextAssistant::Replace(in_out, L"LayerNet", L"<span style=\"color:#0000ff\">LayerNet</span>", true);
		Sys::TextAssistant::Replace(in_out, L"KohoNet", L"<span style=\"color:#0000ff\">KohoNet</span>", true);
		Sys::TextAssistant::Replace(in_out, L"ProbNet", L"<span style=\"color:#0000ff\">ProbNet</span>", true);
		Sys::TextAssistant::Replace(in_out, L"sin", L"<span style=\"color:#ff00ff\">sin</span>", true);
		Sys::TextAssistant::Replace(in_out, L"cos", L"<span style=\"color:#ff00ff\">cos</span>", true);
		Sys::TextAssistant::Replace(in_out, L"tan", L"<span style=\"color:#ff00ff\">tan</span>", true);
		Sys::TextAssistant::Replace(in_out, L"asin", L"<span style=\"color:#ff00ff\">asin</span>", true);
		Sys::TextAssistant::Replace(in_out, L"acos", L"<span style=\"color:#ff00ff\">acos</span>", true);
		Sys::TextAssistant::Replace(in_out, L"atan", L"<span style=\"color:#ff00ff\">atan</span>", true);
		Sys::TextAssistant::Replace(in_out, L"sinh", L"<span style=\"color:#ff00ff\">sinh</span>", true);
		Sys::TextAssistant::Replace(in_out, L"cosh", L"<span style=\"color:#ff00ff\">cosh</span>", true);
		Sys::TextAssistant::Replace(in_out, L"tanh", L"<span style=\"color:#ff00ff\">tanh</span>", true);
		Sys::TextAssistant::Replace(in_out, L"sqrt", L"<span style=\"color:#ff00ff\">sqrt</span>", true);
		Sys::TextAssistant::Replace(in_out, L"log10", L"<span style=\"color:#ff00ff\">log10</span>", true);
		Sys::TextAssistant::Replace(in_out, L"log", L"<span style=\"color:#ff00ff\">log</span>", true);
		Sys::TextAssistant::Replace(in_out, L"exp", L"<span style=\"color:#ff00ff\">exp</span>", true);
		Sys::TextAssistant::Replace(in_out, L"abs", L"<span style=\"color:#ff00ff\">abs</span>", true);
		Sys::TextAssistant::Replace(in_out, L"sinc", L"<span style=\"color:#ff00ff\">sinc</span>", true);
		Sys::TextAssistant::Replace(in_out, L"triang", L"<span style=\"color:#ff00ff\">triang</span>", true);
		Sys::TextAssistant::Replace(in_out, L"saw", L"<span style=\"color:#ff00ff\">saw</span>", true);
		Sys::TextAssistant::Replace(in_out, L"rect", L"<span style=\"color:#ff00ff\">rect</span>", true);
		Sys::TextAssistant::Replace(in_out, L"ceil", L"<span style=\"color:#ff00ff\">ceil</span>", true);
		Sys::TextAssistant::Replace(in_out, L"floor", L"<span style=\"color:#ff00ff\">floor</span>", true);
		Sys::TextAssistant::Replace(in_out, L"toint", L"<span style=\"color:#ff00ff\">toint</span>", true);
		Sys::TextAssistant::Replace(in_out, L"rand", L"<span style=\"color:#ff00ff\">rand</span>", true);
		Sys::TextAssistant::Replace(in_out, L"randi", L"<span style=\"color:#ff00ff\">randi</span>", true);
		Sys::TextAssistant::Replace(in_out, L"isprime", L"<span style=\"color:#ff00ff\">isprime</span>", true);
		Sys::TextAssistant::Replace(in_out, L"fft", L"<span style=\"color:#ff00ff\">fft</span>", true);
		Sys::TextAssistant::Replace(in_out, L"ifft", L"<span style=\"color:#ff00ff\">ifft</span>", true);
		Sys::TextAssistant::Replace(in_out, L"realfft", L"<span style=\"color:#ff00ff\">realfft</span>", true);
		Sys::TextAssistant::Replace(in_out, L"irealfft", L"<span style=\"color:#ff00ff\">irealfft</span>", true);
		Sys::TextAssistant::Replace(in_out, L"spectrum", L"<span style=\"color:#ff00ff\">spectrum</span>", true);
		Sys::TextAssistant::Replace(in_out, L"FirFilter", L"<span style=\"color:#ff00ff\">FirFilter</span>", true);
		Sys::TextAssistant::Replace(in_out, L"ComputeMse", L"<span style=\"color:#ff00ff\">ComputeMse</span>", true);
		Sys::TextAssistant::Replace(in_out, L"ConfusionMatrix", L"<span style=\"color:#ff00ff\">ConfusionMatrix</span>", true);
	}

	if (indent) Sys::TextAssistant::Replace(in_out, L"\t", L"&nbsp;&nbsp;&nbsp;", false);
}

void Convert::SqlToHtml(const wchar_t* input_sqlLine, wstring& output_html, bool indent)
{
	// It converts one line of code written in sql to html
	if (input_sqlLine==NULL)
	{
		output_html.clear();
		return;
	}
	const int length = (int)wcslen(input_sqlLine);
	if (length<=0)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}

	//____________________________ Check for empty code line
	bool IsEmpty = true;
	for(int i = 0; i < length; i++)
	{
		if (input_sqlLine[i] != ' ' && input_sqlLine[i] != '\t' && input_sqlLine[i] != '\r' && input_sqlLine[i] != '\n')
		{
			IsEmpty = false;
			break;
		}
	}
	if (IsEmpty == true)
	{
		//output_html = L"<br />";
		output_html.clear();
		return;
	}

	//_______________________________ Normal code line

	wstring sqlCode;

	const wchar_t* pComment = wcsstr(input_sqlLine, L"--");
	bool isCommentOnly = false;
	for(int i=0; i<length-1; i++)
	{
		if (input_sqlLine[i]==' ' || input_sqlLine[i]=='\t') continue;
		if (input_sqlLine[i]!=' ' && input_sqlLine[i]!='\t')
		{
			if (input_sqlLine[i]!='-') break;
		}
		if (input_sqlLine[i]=='-' && input_sqlLine[i]=='-') 
		{
			isCommentOnly =true;
			break;
		}
	}

	if (pComment==NULL) //______________________________________________ only code
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_sqlLine, sqlCode);
		SqlToHtml(sqlCode, indent);
		output_html = sqlCode;
	}
	else if (isCommentOnly) //________________________________________ only comment
	{
		Sys::TextAssistant::ReplaceBiggerLessThan(input_sqlLine, sqlCode);
		if (indent) Sys::TextAssistant::Replace(sqlCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		output_html = L"<span style=\"color:#009000\">";
		output_html += sqlCode;
		output_html += L"</span>";
	}
	else //________________________________________ comment and code
	{
		wstring comment;
		const int commentLength = (int)wcslen(pComment);
		comment.assign(pComment, commentLength);
		//_______________________  code
		wstring tmp;
		tmp.assign(input_sqlLine, length-commentLength);
		Sys::TextAssistant::ReplaceBiggerLessThan(tmp.c_str(), sqlCode);
		if (indent) Sys::TextAssistant::Replace(sqlCode, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
		SqlToHtml(sqlCode, indent);
		output_html = sqlCode;
		//_______________________ comment
		output_html += L"<span style=\"color:#009000\">";
		output_html += comment;
		output_html += L"</span>";	
	}
}

void Convert::SqlToHtml(wstring& in_out, bool indent)
{
	//_________________________________________________ Strings
	wstring input(in_out);
	wstring output;
	Sys::Convert::QuotedSqlToHtml(input.c_str(), L"color:#FF0000", output);
	in_out = output;
	//
	Sys::TextAssistant::Replace(in_out, L"SELECT", L"<span style=\"color:#0000ff\">SELECT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"FROM", L"<span style=\"color:#0000ff\">FROM</span>", true);
	Sys::TextAssistant::Replace(in_out, L"WHERE", L"<span style=\"color:#0000ff\">WHERE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"HAVING", L"<span style=\"color:#0000ff\">HAVING</span>", true);
	Sys::TextAssistant::Replace(in_out, L"AND", L"<span style=\"color:#0000ff\">AND</span>", true);
	Sys::TextAssistant::Replace(in_out, L"OR", L"<span style=\"color:#0000ff\">OR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CREATE", L"<span style=\"color:#0000ff\">CREATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DELETE", L"<span style=\"color:#0000ff\">DELETE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"VIEW", L"<span style=\"color:#0000ff\">VIEW</span>", true);
	Sys::TextAssistant::Replace(in_out, L"INSERT", L"<span style=\"color:#0000ff\">INSERT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ALTER", L"<span style=\"color:#0000ff\">ALTER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"UPDATE", L"<span style=\"color:#0000ff\">UPDATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"PROCEDURE", L"<span style=\"color:#0000ff\">PROCEDURE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DROP", L"<span style=\"color:#0000ff\">DROP</span>", true);
	Sys::TextAssistant::Replace(in_out, L"INT", L"<span style=\"color:#0000ff\">INT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"INTEGER", L"<span style=\"color:#0000ff\">INTEGER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DECIMAL", L"<span style=\"color:#0000ff\">DECIMAL</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NUMBER", L"<span style=\"color:#0000ff\">NUMBER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NUMERIC", L"<span style=\"color:#0000ff\">NUMERIC</span>", true);
	Sys::TextAssistant::Replace(in_out, L"UNION", L"<span style=\"color:#0000ff\">UNION</span>", true);
	Sys::TextAssistant::Replace(in_out, L"VARCHAR", L"<span style=\"color:#0000ff\">VARCHAR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NVARCHAR", L"<span style=\"color:#0000ff\">NVARCHAR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"VARCHAR2", L"<span style=\"color:#0000ff\">VARCHAR2</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DATE", L"<span style=\"color:#0000ff\">DATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DATETIME", L"<span style=\"color:#0000ff\">DATETIME</span>", true);
	Sys::TextAssistant::Replace(in_out, L"SMALLDATETIME", L"<span style=\"color:#0000ff\">SMALLDATETIME</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CHAR", L"<span style=\"color:#0000ff\">CHAR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NCHAR", L"<span style=\"color:#0000ff\">NCHAR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"REPLACE", L"<span style=\"color:#0000ff\">REPLACE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"TRIGGER", L"<span style=\"color:#0000ff\">TRIGGER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"TABLE", L"<span style=\"color:#0000ff\">TABLE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"INTO", L"<span style=\"color:#0000ff\">INTO</span>", true);
	Sys::TextAssistant::Replace(in_out, L"VALUES", L"<span style=\"color:#0000ff\">VALUES</span>", true);
	Sys::TextAssistant::Replace(in_out, L"PRIMARY KEY", L"<span style=\"color:#0000ff\">PRIMARY KEY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"REFERENCES", L"<span style=\"color:#0000ff\">REFERENCES</span>", true);
	Sys::TextAssistant::Replace(in_out, L"USE", L"<span style=\"color:#0000ff\">USE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"EXECUTE", L"<span style=\"color:#0000ff\">EXECUTE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"BEGIN", L"<span style=\"color:#0000ff\">BEGIN</span>", true);
	Sys::TextAssistant::Replace(in_out, L"END", L"<span style=\"color:#0000ff\">END</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DISTINCT", L"<span style=\"color:#0000ff\">DISTINCT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"LIKE", L"<span style=\"color:#0000ff\">LIKE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CHECK", L"<span style=\"color:#0000ff\">CHECK</span>", true);
	Sys::TextAssistant::Replace(in_out, L"READ ONLY", L"<span style=\"color:#0000ff\">READ ONLY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"OPTION", L"<span style=\"color:#0000ff\">OPTION</span>", true);
	Sys::TextAssistant::Replace(in_out, L"GRANT", L"<span style=\"color:#0000ff\">GRANT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"REVOKE", L"<span style=\"color:#0000ff\">REVOKE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ROLLBACK", L"<span style=\"color:#0000ff\">ROLLBACK</span>", true);
	Sys::TextAssistant::Replace(in_out, L"SAVEPOINT", L"<span style=\"color:#0000ff\">SAVEPOINT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"TRANSACTION", L"<span style=\"color:#0000ff\">TRANSACTION</span>", true);
	Sys::TextAssistant::Replace(in_out, L"COMMIT", L"<span style=\"color:#0000ff\">COMMIT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"SET", L"<span style=\"color:#0000ff\">SET</span>", true);
	Sys::TextAssistant::Replace(in_out, L"GROUP BY", L"<span style=\"color:#0000ff\">GROUP BY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"AS", L"<span style=\"color:#0000ff\">AS</span>", true);
	Sys::TextAssistant::Replace(in_out, L"IF", L"<span style=\"color:#0000ff\">IF</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DATABASE", L"<span style=\"color:#0000ff\">DATABASE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"WITH", L"<span style=\"color:#0000ff\">WITH</span>", true);
	Sys::TextAssistant::Replace(in_out, L"RAISERROR", L"<span style=\"color:#0000ff\">RAISERROR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"GO", L"<span style=\"color:#0000ff\">GO</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DECLARE", L"<span style=\"color:#0000ff\">DECLARE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CURSOR", L"<span style=\"color:#0000ff\">CURSOR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"READ_ONLY", L"<span style=\"color:#0000ff\">READ_ONLY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"FOR", L"<span style=\"color:#0000ff\">FOR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"OPEN", L"<span style=\"color:#0000ff\">OPEN</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CLOSE", L"<span style=\"color:#0000ff\">CLOSE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"WHILE", L"<span style=\"color:#0000ff\">WHILE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NEXT", L"<span style=\"color:#0000ff\">NEXT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"FETCH", L"<span style=\"color:#0000ff\">FETCH</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DEALLOCATE", L"<span style=\"color:#0000ff\">DEALLOCATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"RETURN", L"<span style=\"color:#0000ff\">RETURN</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ORDER", L"<span style=\"color:#0000ff\">ORDER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CONSTRAINT", L"<span style=\"color:#0000ff\">CONSTRAINT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"IDENTITY", L"<span style=\"color:#0000ff\">IDENTITY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"AUTO_INCREMENT", L"<span style=\"color:#0000ff\">AUTO_INCREMENT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"INNER", L"<span style=\"color:#0000ff\">INNER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"JOIN", L"<span style=\"color:#0000ff\">JOIN</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ON", L"<span style=\"color:#0000ff\">ON</span>", true);
	Sys::TextAssistant::Replace(in_out, L"UNIQUE", L"<span style=\"color:#0000ff\">UNIQUE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"FOREIGN", L"<span style=\"color:#0000ff\">FOREIGN</span>", true);
	Sys::TextAssistant::Replace(in_out, L"INTERSECT", L"<span style=\"color:#0000ff\">INTERSECT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ALTER", L"<span style=\"color:#0000ff\">ALTER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ADD", L"<span style=\"color:#0000ff\">ADD</span>", true);
	Sys::TextAssistant::Replace(in_out, L"MODIFY", L"<span style=\"color:#0000ff\">MODIFY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DEFAULT", L"<span style=\"color:#0000ff\">DEFAULT</span>", true);
	//
	Sys::TextAssistant::Replace(in_out, L"@@IDENTITY", L"<span style=\"color:#C000C0\">@@IDENTITY</span>", true);
	Sys::TextAssistant::Replace(in_out, L"@@FETCH_STATUS", L"<span style=\"color:#C000C0\">@@FETCH_STATUS</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ABS", L"<span style=\"color:#C000C0\">ABS</span>", true);
	Sys::TextAssistant::Replace(in_out, L"MOD", L"<span style=\"color:#C000C0\">MOD</span>", true);
	Sys::TextAssistant::Replace(in_out, L"TRUNCATE", L"<span style=\"color:#C000C0\">TRUNCATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"POWER", L"<span style=\"color:#C000C0\">POWER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ROUND", L"<span style=\"color:#C000C0\">ROUND</span>", true);
	Sys::TextAssistant::Replace(in_out, L"AVG", L"<span style=\"color:#C000C0\">AVG</span>", true);
	Sys::TextAssistant::Replace(in_out, L"MIN", L"<span style=\"color:#C000C0\">MIN</span>", true);
	Sys::TextAssistant::Replace(in_out, L"MAX", L"<span style=\"color:#C000C0\">MAX</span>", true);
	Sys::TextAssistant::Replace(in_out, L"AVG", L"<span style=\"color:#C000C0\">AVG</span>", true);
	Sys::TextAssistant::Replace(in_out, L"SUM", L"<span style=\"color:#C000C0\">SUM</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NVL", L"<span style=\"color:#C000C0\">NVL</span>", true);
	Sys::TextAssistant::Replace(in_out, L"TO_NUMBER", L"<span style=\"color:#C000C0\">TO_NUMBER</span>", true);
	Sys::TextAssistant::Replace(in_out, L"TO_CHAR", L"<span style=\"color:#C000C0\">TO_CHAR</span>", true);
	Sys::TextAssistant::Replace(in_out, L"TO_DATE", L"<span style=\"color:#C000C0\">TO_DATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DATEFORMAT", L"<span style=\"color:#C000C0\">DATEFORMAT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DATEPART", L"<span style=\"color:#C000C0\">DATEPART</span>", true);
	Sys::TextAssistant::Replace(in_out, L"DATEDIFF", L"<span style=\"color:#C000C0\">DATEPART</span>", true);
	Sys::TextAssistant::Replace(in_out, L"ISDATE", L"<span style=\"color:#C000C0\">ISDATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"GETDATE", L"<span style=\"color:#C000C0\">GETDATE</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CONVERT", L"<span style=\"color:#C000C0\">CONVERT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"CAST", L"<span style=\"color:#C000C0\">CAST</span>", true);
	Sys::TextAssistant::Replace(in_out, L"db_name", L"<span style=\"color:#C000C0\">db_name</span>", true);
	//
	Sys::TextAssistant::Replace(in_out, L"EXISTS", L"<span style=\"color:#707070\">EXISTS</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NOT", L"<span style=\"color:#707070\">NOT</span>", true);
	Sys::TextAssistant::Replace(in_out, L"NULL", L"<span style=\"color:#707070\">NULL</span>", true);
	Sys::TextAssistant::Replace(in_out, L"(", L"<span style=\"color:#707070\">(</span>", false);
	Sys::TextAssistant::Replace(in_out, L")", L"<span style=\"color:#707070\">)</span>", false);
	//Sys::TextAssistant::Replace(in_out, L"*", L"<span style=\"color:#707070\">*</span>", false);
	//
	if (indent) Sys::TextAssistant::Replace(in_out, L"\t", L"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", false);
}

void Convert::QuotedSqlToHtml(const wchar_t* input, const wchar_t* cssStyle, wstring& output_html)
{
	const int len = (int)wcslen(input);
	if (len == 0)
	{
		output_html.clear();
		return;
	}
	try
	{
		output_html.reserve(len);
	}
	catch(const std::bad_alloc& )
	{
		return;
	}
	bool isInsideQuotes = false;
	for(int i = 0; i<len; i++)
	{
		if (isInsideQuotes == true)//_______________ Quoted text
		{
			if (input[i] == '\'')
			{
				if (i > 0) 
				{
					if (input[i-1] == '\\')
					{
						output_html += input[i]; // scape sequence
						continue;
					}
				}
				output_html += L"'</span>";
				isInsideQuotes = false;
			}
			else
			{
				output_html += input[i]; 
			}
		}
		else//_______________________________ Regular code
		{
			if (input[i] == '\'')
			{
				output_html += L"<span style=\"";
				output_html += cssStyle;
				output_html += L"\">'";
				isInsideQuotes = true;
			}
			else
			{
				output_html += input[i]; 
			}
		}
	}
}

void Convert::QuotedCppToHtml(const wchar_t* input, const wchar_t* cssStyle, wstring& output_html)
{
	const int len = (int)wcslen(input);
	if (len == 0)
	{
		output_html.clear();
		return;
	}
	try
	{
		output_html.reserve(len);
	}
	catch(const std::bad_alloc& )
	{
		return;
	}
	bool isInsideQuotes = false;
	for(int i = 0; i<len; i++)
	{
		if (isInsideQuotes == true)//_______________ Quoted text
		{
			if (input[i] == '\"')
			{
				if (i > 0) 
				{
					if (input[i-1] == '\\')
					{
						if (input [i -2 ] != '\\')
						{
							output_html += input[i]; // scape sequence
							continue;
						}
					}
				}
				output_html += L"\"</span>";
				isInsideQuotes = false;
			}
			else
			{
				output_html += input[i]; 
			}
		}
		else//_______________________________ Regular code
		{
			if (input[i] == '\"')
			{
				output_html += L"<span style=\"";
				output_html += cssStyle;
				output_html += L"\">\"";
				isInsideQuotes = true;
			}
			else
			{
				output_html += input[i]; 
			}
		}
	}
}

bool Convert::ValarrayToVectorInt(const valarray<double>& input, valarray<int>& output)
{
	const int len = (int)input.size();
	if (len == 0)
	{
		output.resize(0);
		return true;
	}
	try
	{
		output.resize(len);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	for(int i = 0; i<len; i++)
	{
		output[i] = (int)input[i];
	}
	return true;
}

bool Convert::RelativePathToAbsolutePath(const wchar_t* in_basePath, const wchar_t* in_relativePath, wstring& out_absolutePath)
{
	out_absolutePath.clear();
	//___________________________________________________ Validate input parameters
	if (in_basePath == NULL) return false;
	if (in_relativePath == NULL)
	{
		out_absolutePath = in_basePath;
		return true;
	}
	const size_t len_basePath = wcslen(in_basePath);
	if (len_basePath == 0) return false;
	const size_t len_relativePath = wcslen(in_relativePath);
	if (len_relativePath == 0)
	{
		out_absolutePath = in_basePath;
		return true;
	}
	//____________________________________________________________________________ relative begins with \ base + relative
	if (in_relativePath[0] == '\\')
	{
		out_absolutePath = in_basePath;
		out_absolutePath += in_relativePath;
		return true;
	}
	//____________________________________________________________________________ relative begins with ..
	//___________________________________________________ Base Path Tokens
	vector<wstring> baseToken;
	const int base_count = Sys::TextAssistant::GetTokens(in_basePath, '\\', baseToken);
	if (base_count == 0) return false;
	//___________________________________________________ Relative Path Tokens
	vector<wstring> relativeToken;
	const int relative_count = Sys::TextAssistant::GetTokens(in_relativePath, '\\', relativeToken);
	if (relative_count == 0) return false;
	if (relativeToken[0] != L"..") return false;
	//___________________________________________________ Count levels down
	int i = 0, j = 0;
	int levelDown_count = 0;
	for (i = 0; i < relative_count; i++)
	{
		if (relativeToken[i] == L"..") levelDown_count++;
	}
	//_________________________________________________ Compute Output
	const int output_count = base_count - levelDown_count;
	if (output_count <= 0) return false;
	for (i = 0; i < output_count; i++)
	{
		out_absolutePath += baseToken[i];
		out_absolutePath += L"\\";
	}
	//const int keep_count = relative_count - levelDown_count;
	for (j = levelDown_count; j < relative_count; i++, j++)
	{
		out_absolutePath += relativeToken[j];
		if (j < (relative_count -1)) out_absolutePath += L"\\";
	}
	return true;
}
 
bool Convert::AbsolutePathToRelativePath(const wchar_t* in_basePath, const wchar_t* in_absolutePath, wstring& out_relativePath)
{
	out_relativePath.clear();
	//___________________________________________________ Validate input parameters
	if (in_basePath == NULL) return false;
	if (in_absolutePath == NULL) return false;
	const size_t len_basePath = wcslen(in_basePath);
	if (len_basePath == 0) return false;
	const size_t len_absolutePath = wcslen(in_absolutePath);
	if (len_absolutePath == 0) return false;
	//___________________________________________________ Base Path Tokens
	vector<wstring> baseToken;
	const int base_count = Sys::TextAssistant::GetTokens(in_basePath, '\\', baseToken);
	if (base_count == 0) return false;
	//___________________________________________________ Absolute Path Tokens
	vector<wstring> absoluteToken;
	const int absolute_count = Sys::TextAssistant::GetTokens(in_absolutePath, '\\', absoluteToken);
	if (absolute_count == 0) return false;
	//___________________________________________________ Compare paths
	wstring base_lower;
	wstring absolute_lower;
	int equal_count;
	for (equal_count = 0; equal_count < base_count && equal_count < absolute_count; equal_count++)
	{
		base_lower = baseToken[equal_count];
		Sys::TextAssistant::ToLower(base_lower);
		//
		absolute_lower = absoluteToken[equal_count];
		Sys::TextAssistant::ToLower(absolute_lower);
		//
		if (base_lower != absolute_lower) break;
	}
	if (equal_count == 0) return false;
	if (equal_count == base_count && equal_count == absolute_count) // Nothing to do
	{
		out_relativePath.clear();
		return true;
	}
	//_________________________________________________ Compute Output
	int i;
	if (equal_count == base_count)
	{
		out_relativePath += L"\\";
		for(i = equal_count; i < absolute_count; i++)
		{
			out_relativePath += absoluteToken[i];
			if (i < (absolute_count-1)) out_relativePath += L"\\";
		}
	}
	else if (equal_count < base_count)
	{
		const int extra = base_count - equal_count;
		for (i = 0; i < extra; i++)
		{
			out_relativePath += L"..\\";
		}
		for (i = equal_count; i < absolute_count; i++)
		{
			out_relativePath += absoluteToken[i];
			if (i < (absolute_count-1)) out_relativePath += L"\\";
		}
	}
	else // base_count < equal_count)
	{
		// Impossible to get here
		return false;
	}
	return true;
}

//bool Convert::Base64BitEncrypt(const wchar_t* input, wstring& output)
//{
//	const int len = wcslen(input);
//	if (len == 0)
//	{
//		output.clear();
//		return false;
//	}
//	const int bitsLen = len*8;
//	const int residue = bitsLen%6;
//	const int out_len = (residue == 0) ? bitsLen/6 : bitsLen/6+1;
//	//_____________________________________________ Memory allocation
//	try
//	{
//		output.resize(out_len);
//	}
//	catch(const std::bad_alloc )
//	{
//		return false;
//	}
//	unsigned char * data = new unsigned char[len]; 
//	if (data == NULL) return false;
//	//____________________________________________ Convert to 8 bits
//	int i;
//	for(i = 0; i<len; i++)
//	{
//		data[i] = (unsigned char)input[i];
//	}
//
//	//____________________________________________ Read in groups of 6 bits
//	char value = 0;
//	int index;
//	//int borrar;
//
//	for(i = 0; i<out_len; i++)
//	{
//		index = i*6/8;
//		switch(i%4)
//		{
//		case 0:   // First six bits from current
//			value = (data[index] & 0xFC)>>2;
//			output[i] = (wchar_t)value;
//			break;
//		case 1:  // 2 bits from current, 4 bits from next
//			if (i == out_len-1)
//			{
//				value = (data[index] & 0x03);
//			}
//			else
//			{
//				value = ((data[index] & 0x03)>>4) | ((data[index+1] & 0xF0)>>4);
//			}
//			output[i] = (wchar_t)value;
//			break;
//		case 2: //4 bits from current, 2 bits from next
//			if (i == out_len-1)
//			{
//				value = (data[index] & 0x0F);
//			}
//			else
//			{
//				value = ((data[index] & 0x0F)<<2) | ((data[index+1] & 0xC0)>>6);
//			}
//			output[i] = (wchar_t)value;
//			break;
//		case 3: //last six bits from current
//			value = (data[index] & 0x3F);
//			output[i] = (wchar_t)value;
//			break;
//		}
//		//borrar = (int)value;
//	}
//	if (data) delete [] data;
//	return true;
//}

bool Convert::IsBase64(unsigned char input) 
{
	if (isalnum(input)) return true;
	if (input == '+') return true;
	if (input == '/') return true;
	return false;
}

bool Convert::Base64BitEncode(const char* input, const int inputLen, string& output)
{
	output.clear();
	if (inputLen == 0)
	{
		output.clear();
		return true;
	}

	output.reserve((int)(4*ceil(inputLen/3.0)));
	const char * table  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	unsigned char in[3], out[4];
	int i = 0;
	for(int k = 0; k<inputLen; k++)
	{
		in[i] = input[k];
		i++;
		if (i == 3) 
		{
			out[0] = (in[0] & 0xFC) >> 2;
			out[1] = ((in[0] & 0x03) << 4) | ((in[1] & 0xF0) >> 4);
			out[2] = ((in[1] & 0x0F) << 2) | ((in[2] & 0xC0) >> 6);
			out[3] = in[2] & 0x3F;

			for(i = 0; (i <4) ; i++)
			{
				output += table[out[i]];
			}
			i = 0;
		}
	}

	if (i != 0)
	{
		int j = 0;
		for(j = i; j < 3; j++)
		{
			in[j] = '\0';
		}
		//____________________________________
		out[0] = (in[0] & 0xFC) >> 2;
		out[1] = ((in[0] & 0x03) << 4) | ((in[1] & 0xF0) >> 4);
		out[2] = ((in[1] & 0x0F) << 2) | ((in[2] & 0xC0) >> 6);
		out[3] = in[2] & 0x3F;
		//_____________________________________
		for (j = 0; j < i + 1; j++)
		{
			output += table[out[j]];
		}

		while(i < 3)
		{
			output += '=';
			i++;
		}
	}
	return true;
	//const int len = strlen(input);
	//if (len == 0)
	//{
	//	output.clear();
	//	return true;
	//}
	//const int bitsLen = len*8;
	//const int residue = bitsLen%6;
	//const int out_len = (residue == 0) ? bitsLen/6 : bitsLen/6+1;
	////_____________________________________________ Memory allocation
	//try
	//{
	//	output.resize(out_len);
	//}
	//catch(const std::bad_alloc )
	//{
	//	return false;
	//}

	////____________________________________________ Read in groups of 6 bits
	//int value = 0;
	//int index;

	//for(int i = 0; i<out_len; i++)
	//{
	//	index = i*6/8;
	//	switch(i%4)
	//	{
	//	case 0:   // First six bits from current
	//		value = (input[index] & 0xFC)>>2;
	//		break;
	//	case 1:  // 2 bits from current, 4 bits from next
	//		if (i == out_len-1)
	//		{
	//			value = (input[index] & 0x03);
	//		}
	//		else
	//		{
	//			value = ((input[index] & 0x03)>>4) | ((input[index+1] & 0xF0)>>4);
	//		}
	//		break;
	//	case 2: //4 bits from current, 2 bits from next
	//		if (i == out_len-1)
	//		{
	//			value = (input[index] & 0x0F);
	//		}
	//		else
	//		{
	//			value = ((input[index] & 0x0F)<<2) | ((input[index+1] & 0xC0)>>6);
	//		}
	//		break;
	//	case 3: //last six bits from current
	//		value = (input[index] & 0x3F);
	//		break;
	//	}
	//	output[i] = key[value];
	//}
	//return true;
}

bool Convert::Base64BitDecode(const char* input, const int inputLen, string& output)
{
	const char * table  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	//const int len = strlen(input);
	if (inputLen == 0)
	{
		output.clear();
		return true;
	}
	output.reserve((int)(3.0*ceil(inputLen/4.0)));
	int i = 0, s = 0;
	const int keylen = (int)strlen(table);
	unsigned char a[3], b[4];
	for(int k = 0; k < inputLen; k++)
	{
		if (input[k] == '=') break;
		if (Sys::Convert::IsBase64((unsigned char)input[k]) == false) break;
		b[i] = input[k];
		i++;
		if (i ==4) 
		{
			for(i = 0; i <4; i++)
			{
				for(s = 0; s<keylen; s++)
				{
					if (b[i] == table[s])
					{
						b[i] = s;
						break;
					}
				}
			}

			a[0] = (b[0] << 2) + ((b[1] & 0x30) >> 4);
			a[1] = ((b[1] & 0x0F) << 4) + ((b[2] & 0x3C) >> 2);
			a[2] = ((b[2] & 0x3) << 6) + b[3];

			for(i = 0; i < 3; i++)
			{
				output += a[i];
			}
			i = 0;
		}
	}

	if (i != 0) 
	{
		int j = 0;
		for (j = i; j <4; j++)
		{
			b[j] = 0;
		}

		for (j = 0; j <4; j++)
		{
			for(s = 0; s<keylen; s++)
			{
				if (b[j] == table[s])
				{
					b[j] = s;
					break;
				}
			}
		}

		a[0] = (b[0] << 2) + ((b[1] & 0x30) >> 4);
		a[1] = ((b[1] & 0x0F) << 4) + ((b[2] & 0x3C) >> 2);
		a[2] = ((b[2] & 0x3) << 6) + b[3];

		for (j = 0; (j < i - 1); j++)
		{
			output += a[j];
		}
	}
	return true;
}

//_____________________________________________________________________ Sys::Information
int Information::getSystemWindowsDirectory(wstring& result)
{
	int size = ::GetSystemWindowsDirectory(NULL, 0);
	result.resize(size);
	::GetSystemWindowsDirectory((wchar_t*)result.data(), size);
	result.resize(size-1);
	return size;
}

int Information::getSystemDirectory(wstring& result)
{
	int size = ::GetSystemDirectory(NULL, 0);
	result.resize(size);
	::GetSystemDirectory((wchar_t*)result.data(), size);
	result.resize(size-1);
	return size;
}

int Information::getCurrentDirectory(wstring& result)
{
	int size = ::GetCurrentDirectory(0, NULL);
	result.resize(size);
	::GetCurrentDirectory(size, (wchar_t*)result.data());
	result.resize(size-1);
	return size;
}

int Information::getWindowsDirectory(wstring& result)
{
	int size = ::GetWindowsDirectory(NULL, 0);
	result.resize(size);
	::GetWindowsDirectory((wchar_t*)result.data(), size);
	result.resize(size-1);
	return size;
}

int Information::getProgramFileName(HMODULE hInstance, wstring& output)
{
	const DWORD initial_size = 512;
	DWORD size= initial_size;
	DWORD result = 0;
	do
	{
		size *= 2;
		output.resize(size);
		//result = ::GetModuleFileNameEx(hInstance, NULL, (wchar_t*)output.data(), size);
		result = ::GetModuleFileName(hInstance, (wchar_t*)output.data(), size);
		if (result == 0) return 0; // Error
	}
	while (result == size);
	output.resize(result);
	return result;
}

int Information::getCurrentProgramFileName(wstring& output)
{
	output.clear();
	HMODULE hModule = NULL;
	if (::GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, NULL, &hModule) == 0) return 0;
	const DWORD initial_size = 512;
	DWORD size= initial_size;
	DWORD result = 0;
	do
	{
		size *= 2;
		output.resize(size);
		result = ::GetModuleFileName(hModule, (wchar_t*)output.data(), size);
		if (result == 0) return 0; // Error
	}
	while (result == size);
	output.resize(result);
	return result;
}

WORD Information::getCacheLineSize()
{
	WORD cacheLineSize = 0;
	typedef BOOL (WINAPI *LPFN_GLPI)(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, PDWORD);
	HMODULE module = ::GetModuleHandle(L"kernel32");
	if (module==NULL) return -1;
	LPFN_GLPI Glpi = (LPFN_GLPI)::GetProcAddress(module, "GetLogicalProcessorInformation");
	if (Glpi == NULL) return -1;

	BOOL done = FALSE;
	BOOL rc;
	DWORD returnLength = 0;
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;

	while (!done)
	{
		rc = Glpi(buffer, &returnLength);

		if (FALSE == rc)
		{
			if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
			{
				if (buffer) ::free(buffer);
				buffer=(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(returnLength);
				if (NULL == buffer) return -2;
			}
			else
			{
				return -3;  // Call ::GetLastError() to get detailed information
			}
		}
		else
		{
			done = TRUE;
		}
	}

	DWORD procCoreCount = 0;
	DWORD byteOffset = 0;
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION	ptr=buffer;

	while (byteOffset < returnLength)
	{
		switch (ptr->Relationship)
		{
		case RelationProcessorCore:
			procCoreCount++;
			break;
		case RelationNumaNode:
			break;
		case RelationProcessorPackage:
			break;
		case RelationCache:
			cacheLineSize = ptr->Cache.LineSize;
			if (buffer) ::free(buffer);
			return cacheLineSize;
		default:
			break;
		}
		byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
		ptr++;
	}

	if (buffer) ::free(buffer);
	return 0;
}

//_____________________________________________________________________ Sys::Region
Region::Region()
{
	hrgn = NULL;
}

Region::~Region()
{
	Delete();
}

bool Region::CreatePolygon(LPPOINT lpPoints, int count, int mode)
{
	Delete();
	hrgn = ::CreatePolygonRgn(lpPoints, count, mode);
	return (hrgn != 0);
}

bool Region::CreatePolyPolygon(const POINT *lppt, const int *polyCounts, int count, int polyFillMode)
{
	Delete();
	hrgn = ::CreatePolyPolygonRgn(lppt, polyCounts, count, polyFillMode);
	return (hrgn != 0);
}

bool Region::CreateElliptic(int x1, int y1, int x2, int y2)
{
	Delete();
	hrgn = ::CreateEllipticRgn(x1, y1, x2, y2);
	return (hrgn != 0);
}

bool Region::CreateRect(int x1, int y1, int x2, int y2)
{
	Delete();
	hrgn = ::CreateRectRgn(x1, y1, x2, y2);
	return (hrgn != 0);
}

bool Region::CreateRoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
{
	Delete();
	hrgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
	return (hrgn != 0);
}

// ::BeginPath() > Gdi painting functions > EndPath() > CreateFromPath > 
bool Region::CreateFromPath(HDC hdc)
{
	Delete();
	hrgn = ::PathToRegion(hdc);
	return (hrgn != 0);
}

void Region::Delete()
{
	if (hrgn)
	{
		::DeleteObject(hrgn);
		hrgn = NULL;
	}
}

//_____________________________________________________________________ TextBufferA
TextBufferA::TextBufferA()
{
}

TextBufferA::~TextBufferA()
{
}

bool TextBufferA::WriteText(const string& source)
{
	buffer+=source;
	return true;
}

//_____________________________________________________________________ TextBufferW
TextBufferW::TextBufferW()
{
}

TextBufferW::~TextBufferW()
{
}

bool TextBufferW::WriteText(const wstring& source)
{
	buffer+=source;
	return true;
}

//_____________________________________________________________________ Gzip
Gzip::Gzip()
{
}

Gzip::~Gzip()
{
}

/* Compress from file source to file dest until EOF on source.
   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
   allocated for processing, Z_STREAM_ERROR if an invalid compression
   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
   version of the library linked do not match, or Z_ERRNO if there is
   an error reading or writing the files. */
int Gzip::def(FILE *source, FILE *dest, int level)
{
#ifdef ZLIB_H
    int ret, flush;
    unsigned have;
    z_stream strm;
    char in[DATA_GZIP_CHUNK];
    char out[DATA_GZIP_CHUNK];

    /* allocate deflate state */
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    //ret = deflateInit(&strm, level);
	ret = deflateInit2(&strm, level, Z_DEFLATED, 16+15,  8, Z_DEFAULT_STRATEGY);
    if (ret != Z_OK)
        return ret;

    /* compress until end of file */
    do {
        strm.avail_in = (uInt)fread(in, 1, DATA_GZIP_CHUNK, source);
        if (ferror(source)) {
            (void)deflateEnd(&strm);
            return Z_ERRNO;
        }
        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
        strm.next_in = (Bytef*)in;

        /* run deflate() on input until output buffer not full, finish
           compression if all of source has been read in */
        do {
            strm.avail_out = DATA_GZIP_CHUNK;
            strm.next_out = (Bytef*)out;
            ret = deflate(&strm, flush);    /* no bad return value */
            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
            have = DATA_GZIP_CHUNK - strm.avail_out;
            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
                (void)deflateEnd(&strm);
                return Z_ERRNO;
            }
        } while (strm.avail_out == 0);
        assert(strm.avail_in == 0);     /* all input will be used */

        /* done when last data in file processed */
    } while (flush != Z_FINISH);
    assert(ret == Z_STREAM_END);        /* stream will be complete */

    /* clean up and return */
    (void)deflateEnd(&strm);
    return Z_OK;
#else
	return 0;
#endif
}

/* Decompress from file source to file dest until stream ends or EOF.
   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be
   allocated for processing, Z_DATA_ERROR if the deflate data is
   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and
   the version of the library linked do not match, or Z_ERRNO if there
   is an error reading or writing the files. */
int Gzip::inf(FILE *source, FILE *dest)
{
#ifdef ZLIB_H
    int ret;
    unsigned have;
    z_stream strm;
    char in[DATA_GZIP_CHUNK];
    char out[DATA_GZIP_CHUNK];

    /* allocate inflate state */
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = 0;
    strm.next_in = Z_NULL;
    //ret = inflateInit2(&strm);
	ret = inflateInit2(&strm, 15);
    if (ret != Z_OK)
        return ret;

    /* decompress until deflate stream ends or end of file */
    do {
        strm.avail_in = (uInt)fread(in, 1, DATA_GZIP_CHUNK, source);
        if (ferror(source)) {
            (void)inflateEnd(&strm);
            return Z_ERRNO;
        }
        if (strm.avail_in == 0)
            break;
        strm.next_in = (Bytef*)in;

        /* run inflate() on input until output buffer not full */
        do {
            strm.avail_out = DATA_GZIP_CHUNK;
            strm.next_out = (Bytef*)out;
            ret = inflate(&strm, Z_NO_FLUSH);
            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
            switch (ret) {
            case Z_NEED_DICT:
                ret = Z_DATA_ERROR;     /* and fall through */
            case Z_DATA_ERROR:
            case Z_MEM_ERROR:
                (void)inflateEnd(&strm);
                return ret;
            }
            have = DATA_GZIP_CHUNK - strm.avail_out;
            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
                (void)inflateEnd(&strm);
                return Z_ERRNO;
            }
        } while (strm.avail_out == 0);
        assert(strm.avail_in == 0);     /* all input will be used */

        /* done when inflate() says it's done */
    } while (ret != Z_STREAM_END);

    /* clean up and return */
    (void)inflateEnd(&strm);
    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
#else
	return 0;
#endif
}

int Gzip::def(Sys::Buffer& source, Sys::Buffer& destination)
{
#ifdef ZLIB_H
	int level = Z_DEFAULT_COMPRESSION;
	int ret, flush;
	unsigned have;
	z_stream strm;
	char in[DATA_GZIP_CHUNK];
	char out[DATA_GZIP_CHUNK];

	/* allocate deflate state */
	strm.zalloc = Z_NULL;
	strm.zfree = Z_NULL;
	strm.opaque = Z_NULL;
	//ret = deflateInit(&strm, level);
	ret = deflateInit2(&strm, level, Z_DEFLATED, 16+15,  8, Z_DEFAULT_STRATEGY);
	if (ret != Z_OK)
		return ret;

	/* compress until end of file */
	do 
	{
		strm.avail_in = (uInt)source.Read(in, DATA_GZIP_CHUNK);
		if (source.Ferror()== true) 
		{
			(void)deflateEnd(&strm);
			return Z_ERRNO;
		}
		flush = (source.Feof() == true) ? Z_FINISH : Z_NO_FLUSH;
		strm.next_in = (Bytef*)in;

		/* run deflate() on input until output buffer not full, finish
			compression if all of source has been read in */
		do 
		{
			strm.avail_out = DATA_GZIP_CHUNK;
			strm.next_out = (Bytef*)out;
			ret = deflate(&strm, flush);    /* no bad return value */
			assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
			have = DATA_GZIP_CHUNK - strm.avail_out;
			if (destination.Write(out, have) != have || destination.Feof() == true) {
				(void)deflateEnd(&strm);
				return Z_ERRNO;
			}
		} while (strm.avail_out == 0);
		assert(strm.avail_in == 0);     /* all input will be used */

		/* done when last data in file processed */
	} while (flush != Z_FINISH);
	assert(ret == Z_STREAM_END);        /* stream will be complete */

	/* clean up and return */
	(void)deflateEnd(&strm);
	return Z_OK;
#else
	return 0;
#endif
}

/* report a zlib or i/o error */
void Gzip::zerr(int ret)
{
#ifdef ZLIB_H
    fputs("zpipe: ", stderr);
    switch (ret) {
    case Z_ERRNO:
        if (ferror(stdin))
            fputs("error reading stdin\n", stderr);
        if (ferror(stdout))
            fputs("error writing stdout\n", stderr);
        break;
    case Z_STREAM_ERROR:
        fputs("invalid compression level\n", stderr);
        break;
    case Z_DATA_ERROR:
        fputs("invalid or incomplete deflate data\n", stderr);
        break;
    case Z_MEM_ERROR:
        fputs("out of memory\n", stderr);
        break;
    case Z_VERSION_ERROR:
        fputs("zlib version mismatch!\n", stderr);
    }
#endif
}

//_____________________________________________________________________ Sys::FileReader
FileReader::FileReader(void)
{
	hFile = INVALID_HANDLE_VALUE;
	position = 0;
	dwRead = 0;
}

FileReader::~FileReader(void)
{
	this->Close();
}

size_t FileReader::GetSizeInBytes()
{
	LARGE_INTEGER value;
	if (GetFileSizeEx(hFile, &value) != 0)
	{
		return value.LowPart;
	}
	return 0;
}

bool FileReader::PrivateOpen(const wchar_t* filename)
{
	this->Close();
	hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ,
		NULL, OPEN_EXISTING, 0, NULL);
	position = 0;
	dwRead = 0;
	numBytes = 0;
	if (hFile == INVALID_HANDLE_VALUE) return false;
	DWORD highSize;
	numBytes = ::GetFileSize(hFile, &highSize);
	return true;
}

void FileReader::Close()
{
	if (hFile != INVALID_HANDLE_VALUE)
	{
		::CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	}
	position = 0;
	dwRead = 0;
	numBytes = 0;
}

bool FileReader::IsOpen()
{	
	return (hFile != INVALID_HANDLE_VALUE);
}

//_____________________________________________________________________ Sys::FileReaderAscii
FileReaderAscii::FileReaderAscii(void)
{
	buffer = new unsigned char[WIN_FILEREADER_SIZE];
	isNextValid = false;
}

FileReaderAscii::~FileReaderAscii(void)
{
	if (buffer != NULL) delete [] buffer;
}

bool FileReaderAscii::Open(const wchar_t* filename)
{
	isNextValid = false;
	if (PrivateOpen(filename) == false) return false;
	//___________________________________________ Have ready the next character to be read
	if (position == dwRead && FillBuffer() == false) return false;
	next = buffer[position++];
	isNextValid = true;
	return true;
}

bool FileReaderAscii::Open(const wstring& filename)
{
	return Open(filename.c_str());
}

bool FileReaderAscii::FillBuffer()
{
	if (hFile == INVALID_HANDLE_VALUE) return false;
	DWORD bytesToRead = WIN_FILEREADER_SIZE;
	if (::ReadFile(hFile, buffer, bytesToRead, &dwRead, NULL) == 0)
	{
		Close();
		return false;
	}
	position = 0;
	if (dwRead == 0)
	{
		Close();
		return false;
	}
	return true;
}

bool FileReaderAscii::Read(char& character)
{
	if (hFile == INVALID_HANDLE_VALUE) return false;
	if (position == dwRead && FillBuffer() == false)
	{
		if (isNextValid)
		{
			character = next;
			isNextValid = false;
			return true;
		}
	}
	character = next;
	next = buffer[position++];
	return true;
}

bool FileReaderAscii::Read(unsigned char& character)
{
	if (hFile == INVALID_HANDLE_VALUE) return false;
	if (position == dwRead && FillBuffer() == false)
	{
		if (isNextValid)
		{
			character = (unsigned char)next;
			isNextValid = false;
			return true;
		}
	}
	character = (unsigned char)next;
	next = buffer[position++];
	return true;
}

bool FileReaderAscii::Advance()
{
	char c;
	return Read(c);
}

bool FileReaderAscii::Peek(char& character)
{
	if (isNextValid == false) return false;
	character = next;
	return true;
}

bool FileReaderAscii::Peek(unsigned char& character)
{
	if (isNextValid == false) return false;
	character = (unsigned char)next;
	return true;
}

int FileReaderAscii::ReadNumber(int& out_status)
{
	char text[32];
	int i = 0;
	char c;
	out_status = -1; // End of file
	//______________________________________ skip spaces, tabs or line returns
	while (true)
	{
		if (Read(c) == false) return -1000000; // End of file
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n') continue;
		break;
	}
	//_______________________________________ Is a negative number?
	const bool isNegative = (c == '-');
	const bool isDigit = ('0' <= c && c <= '9');
	if (isDigit == false && isNegative == false)
	{
		out_status = 1; // Error
		return -2000000;
	}
	//_______________________________________ We reach this point when c is a digit or c is a negative sign
	if (isDigit)
	{
		text[i] = c;
		i++;
	}
	while (i < 32)
	{
		if (Peek(c) == false)
		{
			text[i] = '\0';
			out_status = 0;
			return isNegative ? -1*atoi(text) : atoi(text);
		}
		if ('0' <= c && c <= '9')
		{
			text[i] = c;
			i++;
			if (Advance() == false)
			{
				text[i] = '\0';
				out_status = 0;
				return isNegative ? -1*atoi(text) : atoi(text);
			}
		}
		else
		{
			text[i] = '\0';
			out_status = 0;
			return isNegative ? -1*atoi(text) : atoi(text);
		}
	}
	out_status = 1; // Error
	return -2000000;
}

bool FileReaderAscii::MoveAfter(const char thisCharacter)
{
	char c;
	while (true)
	{
		if (Read(c) == false) return false;
		if (c == thisCharacter) return true;
	}
	return false;
}

bool FileReaderAscii::MoveAfter(const char* thisWord)
{
	const char * p = thisWord;
	char c;
	while(true)
	{
		if (Read(c) == false) return false;
		while (*p == c)
		{
			if (Peek(c) == false) return false;
			p++;
			if (*p == '\0') return true;
			if (Read(c) == false) return false;
		}
		p = thisWord;
	}
	return false;
}

size_t FileReaderAscii::GetCharCount()
{
	return numBytes/sizeof(char);
}

int FileReaderAscii::GetLine(string& output)
{
	output.clear();
	int count = 0;
	int i = 0;
	char c;
	while(Read(c))
	{
		if (c == '\r') continue;
		if (c == '\n') return i; // Normal end
		output += c;
	}
	return -1;
}

int FileReaderAscii::GetLine(unsigned char* out_buffer, int bufferLength)
{
	int count = 0;
	int i = 0;
	unsigned char c;
	bufferLength--;
	for (i = 0; i < bufferLength; )
	{
		if (Read(c) == false)
		{
			out_buffer[i] = '\0';
			if (i == 0) return -1;
		}
		if (c == '\r') continue;
		if (c == '\n')
		{
			out_buffer[i] = '\0';
			return i; // Normal end
		}
		out_buffer[i++] = c;
	}
	return -2;  // Buffer is not large enough
}

//_____________________________________________________________________ Sys::FileReaderW
FileReaderW::FileReaderW(void)
{
	buffer = new wchar_t[WIN_FILEREADER_SIZE];
	isNextValid = false;
}

FileReaderW::~FileReaderW(void)
{
	if (buffer != NULL) delete [] buffer;
}

bool FileReaderW::Open(const wchar_t* filename)
{
	isNextValid = false;
	if (PrivateOpen(filename) == false) return false;
	//___________________________________________ Have ready the next character to be read
	if (position == dwRead && FillBuffer() == false)
	{
		isNextValid = false;
		return false;
	}
	next = buffer[position++];
	isNextValid = true;
	return true;
}

bool FileReaderW::Open(const wstring& filename)
{
	return Open(filename.c_str());
}

bool FileReaderW::FillBuffer()
{
	if (hFile == INVALID_HANDLE_VALUE) return false;
	DWORD bytesToRead = WIN_FILEREADER_SIZE*sizeof(wchar_t);
	if (::ReadFile(hFile, buffer, bytesToRead, &dwRead, NULL) == 0)
	{
		Close();
		return false;
	}
	dwRead /= (DWORD)sizeof(wchar_t);
	position = 0;
	if (dwRead == 0)
	{
		Close();
		return false;
	}
	return true;
}

bool FileReaderW::Read(wchar_t& character)
{
	if (hFile == INVALID_HANDLE_VALUE) return false;
	if (position == dwRead && FillBuffer() == false)
	{
		if (isNextValid)
		{
			character = (unsigned char)next;
			isNextValid = false;
			return true;
		}
	}
	character = (unsigned char)next;
	next = buffer[position++];
	return true;
}

bool FileReaderW::Advance()
{
	wchar_t c;
	return Read(c);
}

bool FileReaderW::Peek(wchar_t& character)
{
	if (isNextValid == false) return false;
	character = next;
	return true;
}

int FileReaderW::ReadNumber(int&out_status)
{
	wchar_t text[32];
	int i = 0;
	wchar_t c;
	out_status = -1; // End of file
	//______________________________________ skip spaces, tabs or line returns
	while (true)
	{
		if (Read(c) == false) return -1000000; // End of file
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n') continue;
		break;
	}
	//_______________________________________ Is a negative number?
	const bool isNegative = (c == '-');
	const bool isDigit = ('0' <= c && c <= '9');
	if (isDigit == false && isNegative == false)
	{
		out_status = 1; // Error
		return -2000000;
	}
	//_______________________________________ We reach this point when c is a digit or c is a negative sign
	if (isDigit)
	{
		text[i] = c;
		i++;
	}
	while (i < 32)
	{
		if (Peek(c) == false)
		{
			text[i] = '\0';
			out_status = 0;
			return isNegative ? -1*_wtoi(text) : _wtoi(text);
		}
		if ('0' <= c && c <= '9')
		{
			text[i] = c;
			i++;
			if (Advance() == false)
			{
				text[i] = '\0';
				out_status = 0;
				return isNegative ? -1*_wtoi(text) : _wtoi(text);
			}
		}
		else
		{
			text[i] = '\0';
			out_status = 0;
			return isNegative ? -1*_wtoi(text) : _wtoi(text);
		}
	}
	out_status = 1; // Error
	return -2000000;
}

bool FileReaderW::MoveAfter(const wchar_t thisCharacter)
{
	wchar_t c;
	while (true)
	{
		if (Read(c) == false) return false;
		if (c == thisCharacter) return true;
	}
	return false;
}

bool FileReaderW::MoveAfter(const wchar_t* thisWord)
{
	const wchar_t * p = thisWord;
	wchar_t c;
	while(true)
	{
		if (Read(c) == false) return false;
		while (*p == c)
		{
			if (Peek(c) == false) return false;
			p++;
			if (*p == '\0') return true;
			if (Read(c) == false) return false;
		}
		p = thisWord;
	}
	return false;
}

size_t FileReaderW::GetCharCount()
{
	return numBytes/sizeof(wchar_t);
}

int FileReaderW::GetLine(wstring& output)
{
	output.clear();
	int count = 0;
	int i = 0;
	wchar_t c;
	while (Read(c))
	{
		if (c == '\r') continue;
		if (c == '\n') return i; // Normal end
		output += c;
	}
	return -1;
}

int FileReaderW::GetLine(wchar_t* out_buffer, int bufferLength)
{
	int count = 0;
	int i = 0;
	wchar_t c;
	bufferLength--;
	for (i = 0; i < bufferLength; )
	{
		if (Read(c) == false)
		{
			out_buffer[i] = '\0';
			if (i == 0) return -1;
		}
		if (c == '\r') continue;
		if (c == '\n')
		{
			out_buffer[i] = '\0';
			return i; // Normal end
		}
		out_buffer[i++] = c;
	}
	return -2;  // Buffer is not large enough
}
	
//_____________________________________________________________________ File
File::File(void)
{
	hFile = INVALID_HANDLE_VALUE;
}

File::~File(void)
{
	this->Close();
}

HANDLE File::Create(const wchar_t* fileName, DWORD desiredAccess, DWORD shareMode, LPSECURITY_ATTRIBUTES securityAttributes, 
		DWORD creationDisposition, DWORD flagsAndAttributes, HANDLE templateFile)
{
	this->Close();
	hFile = ::CreateFile(fileName, desiredAccess, shareMode, securityAttributes, creationDisposition, flagsAndAttributes, templateFile);
	return hFile;
}

//Moves the file pointer of the specified file
// moveMethod: FILE_BEGIN, FILE_CURRENT, FILE_END
bool File::SetPointer(LARGE_INTEGER distanceToMove, PLARGE_INTEGER newFilePointer, DWORD moveMethod)
{
	return (::SetFilePointerEx(hFile, distanceToMove, newFilePointer, moveMethod) != 0);
}

bool File::SetEnd()
{
	return (::SetEndOfFile(hFile) != 0);
}

HANDLE File::GetHandle()
{
	return hFile;
}

//The NTFS file system stores time values in UTC format, so they are not affected by changes in time zone or daylight saving time. 
//The FAT file system stores time values based on the local time of the computer.
bool File::SetFileTime(const wchar_t* filename, FILETIME& creation, FILETIME& access, FILETIME& write)
{
	// FILE_FLAG_BACKUP_SEMANTICS
	HANDLE h = ::CreateFile(filename, FILE_WRITE_ATTRIBUTES, 
                                   FILE_SHARE_READ|FILE_SHARE_WRITE, 
                                   NULL, 
                                   OPEN_EXISTING, 
                                   FILE_ATTRIBUTE_NORMAL, NULL);
	if (h == INVALID_HANDLE_VALUE) return false;
	::SetFileTime(h, &creation, &access, &write);
	::CloseHandle(h);
	return true;
}

//The NTFS file system stores time values in UTC format, so they are not affected by changes in time zone or daylight saving time. 
//The FAT file system stores time values based on the local time of the computer.
void File::GetTime(FILETIME& creation, FILETIME& access, FILETIME& write)
{
	::GetFileTime( hFile, &creation, &access, &write);
}

// HANDLE filename = CreateFile("c:\\filenamehere.txt", FILE_WRITE_ATTRIBUTES, 
//                                   FILE_SHARE_READ|FILE_SHARE_WRITE, 
//                                   NULL, 
//                                   OPEN_EXISTING, 
//                                   FILE_ATTRIBUTE_NORMAL, NULL);
//The NTFS file system stores time values in UTC format, so they are not affected by changes in time zone or daylight saving time. 
//The FAT file system stores time values based on the local time of the computer.
void File::SetTime(FILETIME& creation, FILETIME& access, FILETIME& write)
{
	::SetFileTime(hFile, &creation, &access, &write);
}

//______________________________________________________________ Sys::IStorer
int File::Write(const void* in_buffer, int bufferSizeInBytes)
{
	DWORD written;
	if (::WriteFile(hFile, in_buffer, bufferSizeInBytes, &written, NULL) == FALSE) return -1; 
	return (int)written;
}

int File::Read(void *out_buffer, int bufferSizeInBytes)
{
	DWORD dwRead;
	if (::ReadFile(hFile, out_buffer, bufferSizeInBytes, &dwRead, NULL) == false) return -1;
	return (int)dwRead;
}

//______________________________________________________________ Sys::IChannel
int File::Receive(char *out_buffer, int bufferSizeInBytes)
{
	DWORD dwRead;
	if (::ReadFile(hFile, out_buffer, bufferSizeInBytes, &dwRead, NULL) == false) return -1;
	return (int)dwRead;
}

int File::Send(const char* in_buffer, int bufferSizeInBytes)
{
	DWORD written;
	if (::WriteFile(hFile, in_buffer, bufferSizeInBytes, &written, NULL) == FALSE) return -1; 
	return (int)written;
}

//______________________________________________________________ int
//bool File::Write(int data)
//{
//	DWORD written;
//	DWORD bytesToWrite = sizeof(int);
//	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
//	return (written == bytesToWrite);
//}
//
//bool File::Read(int& data)
//{
//	DWORD dwRead;
//	DWORD bytesToRead = sizeof(int);
//	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
//	return (dwRead == bytesToRead);
//}

//______________________________________________________________ char
bool File::Write(char data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(char);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(char& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(char);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________ unsigned char
bool File::Write(unsigned char data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(unsigned char);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(unsigned char& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(unsigned char);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________ __int16
bool File::Write(__int16 data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(__int16);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(__int16& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(__int16);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________ unsigned __int16
bool File::Write(unsigned __int16 data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(unsigned __int16);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(unsigned __int16& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(unsigned __int16);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________ __int32
bool File::Write(__int32 data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(__int32);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(__int32& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(__int32);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________ unsigned __int32
bool File::Write(unsigned __int32 data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(unsigned __int32);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(unsigned __int32& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(unsigned __int32);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________ double
bool File::Write(double data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(double);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(double& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(double);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________ wstring
bool File::Write(const wstring& data)
{
	return Sys::SerialAssistant::Save(*this, data);
}

bool File::Read(wstring& data)
{
	return Sys::SerialAssistant::Load(*this, data);
}

//______________________________________________________________ bool
bool File::Write(bool data)
{
	DWORD written;
	DWORD bytesToWrite = 1;//sizeof(bool);
	__int8 _data = data ? 0x01 : 0x00;
	::WriteFile(hFile, &_data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(bool& data)
{
	DWORD dwRead;
	DWORD bytesToRead = 1;//sizeof(bool);
	__int8 _data = false;
	::ReadFile(hFile, &_data, bytesToRead, &dwRead, NULL);
	if (dwRead == bytesToRead)
	{
		data = (_data == 0x00) ? false : true;
		return true;
	}
	return false;
}

//______________________________________________________________ Sys::Time
bool File::Write(const Sys::Time& data)
{
	DWORD written;
	DWORD bytesToWrite = sizeof(Sys::Time);
	::WriteFile(hFile, &data, bytesToWrite, &written, NULL);
	return (written == bytesToWrite);
}

bool File::Read(Sys::Time& data)
{
	DWORD dwRead;
	DWORD bytesToRead = sizeof(Sys::Time);
	::ReadFile(hFile, &data, bytesToRead, &dwRead, NULL);
	return (dwRead == bytesToRead);
}

//______________________________________________________________
bool File::CreateForWritting(const wstring& filename)
{
	return this->CreateForWritting(filename.c_str());
}

bool File::CreateForWritting(const wchar_t* filename)
{
	this->Close();
	hFile = ::CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	return (hFile!=INVALID_HANDLE_VALUE);
}

bool File::CreateForReading(const wstring& filename)
{
	return this->CreateForReading(filename.c_str());
}

bool File::CreateForReading(const wchar_t* filename)
{
	this->Close();
	hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, 
		NULL, OPEN_EXISTING, 0, NULL);
	return (hFile!=INVALID_HANDLE_VALUE);
}

void File::Close()
{
	if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;
}

bool File::Flush()
{
	return (::FlushFileBuffers(hFile) != 0);
}

bool File::IsOpen()
{
	return (hFile!=INVALID_HANDLE_VALUE);
}

// Returns the size in bytes of the file
bool File::GetSize(LARGE_INTEGER& size)
{
	return (::GetFileSizeEx(hFile, &size) != 0);
}

size_t File::GetSizeInBytes()
{
	LARGE_INTEGER value;
	if (GetFileSizeEx(hFile, &value) != 0)
	{
		return value.LowPart;
	}
	return 0;
}

bool File::WriteText(const wchar_t* source)
{
	if (source==NULL) return true;
	const int bytes = (int)(sizeof(wchar_t)*wcslen(source));
	if (bytes == 0) return true;
	if (Write(source, bytes)!=bytes) return false;
	return true;
}

bool File::WriteText(const char* source)
{
	if (source==NULL) return true;
	const int bytes = (int)(sizeof(char)*strlen(source));
	if (bytes == 0) return true;
	if (Write(source, bytes)!=bytes) return false;
	return true;
}

//___________________ITextWriterA
bool File::WriteText(const string& source)
{
	const int bytes = (int)source.length();
	if (bytes == 0) return true;
	if (Write(source.data(), bytes)!=bytes) return false;
	return true;
}

//___________________ITextWriterW
bool File::WriteText(const wstring& source)
{
	const int bytes = (int)(source.length()*sizeof(wchar_t));
	if (bytes == 0) return true;
	if (Write(source.data(), bytes)!=bytes) return false;
	return true;
}

//____________________________________________________________ CG::GammaCorrection
GammaCorrection::GammaCorrection()
{
	_gamma = 0.0; // Force To initialize Gamma
	SetGamma(0.7);
}

GammaCorrection::~GammaCorrection()
{
}

void GammaCorrection::SetGamma(double gamma)
{
	if (gamma < 0.0) gamma = 0.0;
	if (gamma > 10.0) gamma = 10.0;
	if (_gamma == gamma) return; // Nothing to do
	_gamma = gamma;
	for (int i = 0; i < 256; i++)
	{
		Transform[i] = MINIMUM(255, (unsigned char)(255.0*pow((i/255.0), 1.0/_gamma)+0.5));
	}
}

double GammaCorrection::GetGamma()
{
	return _gamma;
}

//____________________________________________________________ Sys::PortablePixMap
PortablePixMap::PortablePixMap()
{
	Clear();
	brightness = 1.0;
}

PortablePixMap::~PortablePixMap()
{
}

void PortablePixMap::SetGamma(double gamma)
{
	gc.SetGamma(gamma);
}

double PortablePixMap::GetGamma()
{
	return gc.GetGamma();
}

const wchar_t* PortablePixMap::Save(const wchar_t* filename, const Sys::Graphics& input_graphics)
{
	Clear();
	_width = input_graphics.GetWidth();
	_height = input_graphics.GetHeight();
	_isBinary = true;
	_maxColor = 255;
	Sys::File file;
	if (file.CreateForWritting(filename) == false) return L"Sys::PortablePixMap::Save unable to write file";
	//________________________________________________________________________ Magic Number
	if (file.WriteText("P6\n") == false) return L"Sys::PortablePixMap::Save unable to write Magic Number";
	//________________________________________________________________________ width, height and maxColor
	char text[32];
	_snprintf_s(text, 32, _TRUNCATE, "%d %d\n%d\n", _width, _height, _maxColor);
	if (file.WriteText(text) == false) return L"Sys::PortablePixMap::Save unable to write: width, height and max color value";
	//________________________________________________________________________ pixels
	int x;
	int y;
	COLORREF color;
	for (y = 0; y < _height; y++)
	{
		for (x = 0; x < _width; x++)
		{
			color = input_graphics.GetPixel(x, y);
			text[0] = GetRValueX(color);
			text[1] = GetGValueX(color);
			text[2] = GetBValueX(color);
			file.Write((const void*)text, 3);
		}
	}
	return NULL;
}

const wchar_t* PortablePixMap::Save(const wstring& filename, const Sys::Graphics& input_graphics)
{
	return Save(filename.c_str(), input_graphics);
}

const wchar_t* PortablePixMap::Load(const wchar_t* filename, Sys::Graphics& out_graphics)
{
	Clear();
	if (this->Open(filename) == false)
	{
		Close();
		return L"CG::PortablePixMap::Load the file could not be open";
	}
	char c;
	//________________________________________________________________________ P
	if (Read(c) == false)
	{
		Close(); 
		return L"CG::PortablePixMap::Load the file is damaged";
	}
	if (c != 'P' && c != 'p')
	{
		Close(); 
		return L"CG::PortablePixMap::Load the file is damaged";
	}
	//________________________________________________________________________ Magic Number
	if (Read(c) == false)
	{
		Close(); 
		return L"CG::PortablePixMap::Load the file is damaged";
	}
	if (c != '6') 
	{
		Close(); 
		return L"CG::PortablePixMap::Load this class only opens P6 (PPM binary) files";
	}
	this->_isBinary = true;
	//________________________________________________________________________ Width, Height, MaxColors
	if (ReadInteger(_width) == false)
	{
		Close(); 
		return L"CG::PortablePixMap::Load unable to read image width";
	}
	if (ReadInteger(_height) == false)
	{
		Close(); 
		return L"CG::PortablePixMap::Load unable to read image height";
	}
	if (ReadInteger(_maxColor) == false) 
	{
		Close(); 
		return L"CG::PortablePixMap::Load unable to read maximum color value";
	}
	if (_maxColor != 255)
	{
		Close(); 
		return L"CG::PortablePixMap::Load the maximum color value must be 255";
	}
	if (Read(c) == false)
	{
		Close(); 
		return L"CG::PortablePixMap::Load unable to read pixel begining"; // Move one byte ahead
	}
	//________________________________________________________________________
	if (out_graphics.Create(_width, _height) == false) return L"CG::PortablePixMap::Load not enough memory to create Sys::Graphics object";
	//________________________________________________________________________  Read Pixels
	unsigned __int8 red;
	unsigned __int8 green;
	unsigned __int8 blue;
	const int totalPixel = _width*_height;
	int count = 0;
	int x = 0;
	int y = 0;
	int delta1;
	int delta2;
	double minus_brightness = 1.0 - brightness;
	
	for (count = 0; count < totalPixel; count++)
	{
		if (Read(red) == false)
		{
			out_graphics.CreateBitmap();
			this->Close();
			return L"CG::PortablePixMap::Load unable to read red";
		}
		if (Read(green) == false)
		{
			out_graphics.CreateBitmap();
			this->Close();
			return L"CG::PortablePixMap::Load unable to read green";
		}
		if (Read(blue) == false)
		{
			out_graphics.CreateBitmap();
			this->Close();
			return L"CG::PortablePixMap::Load unable to read green";
		}
		if (brightness != 1.0)
		{
			delta1 = MINIMUM(red, green);
			delta2 = MINIMUM(delta1, blue);
			delta2 = (int)(minus_brightness*delta2+0.5);
			//if (delta2 > 20) delta2 = 20;
			red = red - delta2;
			green = green - delta2;
			blue = blue - delta2;
		}
		if (gc.GetGamma() != 1.0)
		{
			red = gc.Transform[red];
			green = gc.Transform[green];
			blue = gc.Transform[blue];
		}
		GRAPHICS_SETPIXEL(out_graphics, x, y, RGBX(red, green, blue)); //out_graphics.SetPixel(x, y, red, green, blue);
		x++;
		if (x == _width)
		{
			x = 0;
			y++;
		}
	}
	out_graphics.CreateBitmap();
	this->Close();
	return NULL;
}

bool PortablePixMap::ReadInteger(int& result)
{
	char c;
	int status = -1;
	while (Peek(c))
	{
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
		{
			Read(c);
			continue;
		}
		if (c == '#')
		{
			Read(c);
			MoveAfter('\n');
		}
		else
		{
			result = ReadNumber(status);
			if (status != 0) return false;
			return true;
		}
	}
	return false;
}

const wchar_t* PortablePixMap::Load(const wstring& filename, Sys::Graphics& out_graphics)
{
	return Load(filename.c_str(), out_graphics);
}

int PortablePixMap::GetWidth()
{
	return _width;
}

int PortablePixMap::GetHeight()
{
	return _height;
}

bool PortablePixMap::IsBinary()
{
	return _isBinary;
}

int PortablePixMap::GetMaxColor()
{
	return _maxColor;
}

void PortablePixMap::Clear()
{
	_width = 0;
	_height = 0;
	_maxColor = 0;
	_isBinary = true;
}

//_____________________________________________________________________ TextAssistant
TextAssistant::TextAssistant(void)
{
}

TextAssistant::~TextAssistant(void)
{
}

bool TextAssistant::IsSeparator(const wstring& input, int index)
{
	const size_t len = input.length();
	if (index<0) return true;
	if (index >= (int)len) return true;
	return Sys::TextAssistant::IsSeparator(input[index]);
}

bool TextAssistant::IsSeparator(const string& input, int index)
{
	const size_t len = input.length();
	if (index<0) return true;
	if (index >= (int)len) return true;
	return Sys::TextAssistant::IsSeparator((unsigned char)input[index]);
}

bool TextAssistant::IsSeparator(wchar_t input)
{
	if (input == (unsigned char)'\t') return true;
	if (input == (unsigned char)' ') return true;
	if (input == (unsigned char)'\r') return true;
	if (input == (unsigned char)'\n') return true;
	if (input == (unsigned char)'(') return true;
	if (input == (unsigned char)')') return true;
	if (input == (unsigned char)'[') return true;
	if (input == (unsigned char)']') return true;
	if (input == (unsigned char)'{') return true;
	if (input == (unsigned char)'}') return true;
	if (input == (unsigned char)'+') return true;
	if (input == (unsigned char)'-') return true;
	if (input == (unsigned char)'*') return true;
	if (input == (unsigned char)'/') return true;
	if (input == (unsigned char)'\\') return true;
	if (input == (unsigned char)'>') return true;
	if (input == (unsigned char)'<') return true;
	if (input == (unsigned char)'=') return true;
	if (input == (unsigned char)'%') return true;
	if (input == (unsigned char)':') return true;
	if (input == (unsigned char)';') return true;
	if (input == (unsigned char)'.') return true;
	if (input == (unsigned char)',') return true;
	if (input == (unsigned char)'¡') return true;
	if (input == (unsigned char)'!') return true;
	if (input == (unsigned char)'?') return true;
	if (input == (unsigned char)'¿') return true;
	if (input == (unsigned char)'|') return true;
	if (input == (unsigned char)'&') return true;
	if (input == (unsigned char)'\"') return true;
	if (input == (unsigned char)'\v') return true;
	if (input == 0xA0) return true;
	if (input == (unsigned char)'\0') return true;
	//if (input < '0') return true;
	//if ('9' < input && input <= '?') return true;
	//if ('Z' < input && input < 'a') return true;
	//if ('z' < input && input <= '¿') return true;
	return false;
}

bool TextAssistant::IsSeparator(unsigned char input)
{
	if (input == (unsigned char)'\t') return true;
	if (input == (unsigned char)' ') return true;
	if (input == (unsigned char)'\r') return true;
	if (input == (unsigned char)'\n') return true;
	if (input == (unsigned char)'(') return true;
	if (input == (unsigned char)')') return true;
	if (input == (unsigned char)'[') return true;
	if (input == (unsigned char)']') return true;
	if (input == (unsigned char)'{') return true;
	if (input == (unsigned char)'}') return true;
	if (input == (unsigned char)'+') return true;
	if (input == (unsigned char)'-') return true;
	if (input == (unsigned char)'*') return true;
	if (input == (unsigned char)'/') return true;
	if (input == (unsigned char)'\\') return true;
	if (input == (unsigned char)'>') return true;
	if (input == (unsigned char)'<') return true;
	if (input == (unsigned char)'=') return true;
	if (input == (unsigned char)'%') return true;
	if (input == (unsigned char)':') return true;
	if (input == (unsigned char)';') return true;
	if (input == (unsigned char)'.') return true;
	if (input == (unsigned char)',') return true;
	if (input == (unsigned char)'¡') return true;
	if (input == (unsigned char)'!') return true;
	if (input == (unsigned char)'?') return true;
	if (input == (unsigned char)'¿') return true;
	if (input == (unsigned char)'|') return true;
	if (input == (unsigned char)'&') return true;
	if (input == (unsigned char)'\"') return true;
	if (input == (unsigned char)'\v') return true;
	if (input == 0xA0) return true;
	if (input == '\0') return true;
	//if (input < '0') return true;
	//if ('9' < input && input <= '?') return true;
	//if ('Z' < input && input < 'a') return true;
	//if ('z' < input && input <= '¿') return true;
	return false;
}

//bool TextAssistant::MatchWholeWord(const wchar_t* input, size_t input_len, size_t positionBegin, size_t positionEnd)
//{
//	if (positionBegin == positionEnd)
//	{
//		return (Sys::TextAssistant::IsSeparator(input[positionBegin]) == false);
//	}
//	//______________________________________________________________ Begin
//	bool okBegin = false;
//	if (positionBegin == 0)
//	{
//		okBegin = true;
//	}
//	else if (Sys::TextAssistant::IsSeparator(input[positionBegin]) == true)
//	{
//		okBegin = true;
//	}
//	//______________________________________________________________ End
//	bool okEnd = false;
//	if (positionEnd == (input_len-1))
//	{
//		okEnd = true;
//	}
//	else if (Sys::TextAssistant::IsSeparator(input[positionEnd]) == true)
//	{
//		okEnd = true;
//	}
//	return (okBegin && okEnd);
//}

int TextAssistant::FindWholeWord(const wchar_t* input, size_t positionStart, const wchar_t* findThisWord)
{
	//_____________________________________________ Check input
	if (input == NULL) return -1;
	const size_t len = wcslen(input)+1;
	if (len == 1) return -1;
	//_____________________________________________ Check findThisWord
	if (findThisWord == NULL) return -1;
	const size_t lenWord = wcslen(findThisWord);
	if (lenWord == 0) return -1;
	//
	size_t i = 0, j = 0;
	size_t position = 0;
	bool isPreviousCharSeparator = (positionStart == 0) ? true : Sys::TextAssistant::IsSeparator(input[positionStart]);
	for (i = positionStart; i < len; i++)
	{
		if (Sys::TextAssistant::IsSeparator(input[i]) == true || i == len -1)
		{
			//_________________________ do we reach the end of the word?
			if (j == lenWord)
			{
				if (isPreviousCharSeparator == true) return (int)position;
			}
			j = 0;
			position = i+1;
			isPreviousCharSeparator = true;
		}
		else
		{
			//________________________ keep comparing word
			if (j < lenWord)
			{
				if (findThisWord[j] == input[i])
				{
					j++;
				}
				else
				{
					isPreviousCharSeparator = false;
					j = 0;
					position = i + 1;
				}
			}
			else
			{
				isPreviousCharSeparator = false;
				j = 0;
				position = i+1;
			}
		}
	}
	return -1;
}

int TextAssistant::Find(const wchar_t* input, size_t positionStart, const wchar_t* findThis)
{
	if (input == NULL) return -1;
	if (findThis == NULL) return -1;
	if (findThis[0] == '\0') return -1;
	const wchar_t *q = wcsstr(input+positionStart, findThis);
	if (q == NULL) return -1;
	return (int)(q - input);
}

//int TextAssistant::FindWord(const wchar_t* input, size_t positionStart, const wchar_t* findThisWord, bool matchWholeWord)
//{
//	if (matchWholeWord) return Sys::TextAssistant::FindWholeWord(input, positionStart, findThisWord);
//	return Sys::TextAssistant::FindWord(input, positionStart, findThisWord);
//	////____________________________________________________________________________ Match Whole Word
//	//if (input == NULL) return -1;
//	//if (findThisWord == NULL) return -1;
//	//const size_t len_input = wcslen(input);
//	//const size_t len_findThisWord = wcslen(findThisWord);
//	//int p1 = 0;
//	//while(true)
//	//{
//	//	p1 = Sys::TextAssistant::FindWord(input, positionStart, findWhat);
//	//	if (p1 == -1) break;
//	//	if (Sys::TextAssistant::MatchWholeWord(input, len_input, p1, p1+len_findWhat) == true) return p1;
//	//	positionStart = p1 + len_findWhat;
//	//}
//	//return -1;
//}

int TextAssistant::Find(const wchar_t* input, size_t positionStart, const wchar_t* findThis, bool matchWholeWord, bool matchCase)
{
	int result = -1;
	if (input == NULL) return -1;
	if (input[0] == '\0') return -1;
	if (matchCase)
	{
		if (matchWholeWord)
		{
			result = Sys::TextAssistant::FindWholeWord(input, positionStart, findThis);
		}
		else
		{
			result = Sys::TextAssistant::Find(input, positionStart, findThis);
		}
	}
	else
	{
		//___________________________________________________________    lowerInput is the lowercase version of input
		if (input == NULL) return -1;
		const size_t len_input = wcslen(input)+1;
		if (len_input == 1) return -1;
		wchar_t * lowerInput = new wchar_t[len_input];
		size_t i;
		for (i = 0; i < len_input; i++) lowerInput[i] = tolower(input[i]);
		//___________________________________________________________   lowerFindThis is the lowercase version of findThis
		if (findThis == NULL) return -1;
		const size_t len_findThis = wcslen(findThis)+1;
		if (len_findThis == 1) return -1;
		wchar_t * lowerFindThis = new wchar_t[len_findThis];
		for (i = 0; i < len_findThis; i++) lowerFindThis[i] = tolower(findThis[i]);
		//___________________________________________________________ FindWord
		if (matchWholeWord)
		{
			result = Sys::TextAssistant::FindWholeWord(lowerInput, positionStart, lowerFindThis);
		}
		else
		{
			result = Sys::TextAssistant::Find(lowerInput, positionStart, lowerFindThis);
		}
		//___________________________________________________________ Clean up
		if (lowerInput) delete [] lowerInput;
		if (lowerFindThis) delete[] lowerFindThis;
	}
	return result;
}

bool TextAssistant::IsDigit(const wchar_t input)
{
	if (input < (unsigned char)'0') return false;
	if (input > (unsigned char)'9') return false;
	return true;
}

bool TextAssistant::IsDigit(const unsigned char input)
{
	if (input < (unsigned char)'0') return false;
	if (input > (unsigned char)'9') return false;
	return true;
}

bool TextAssistant::IsIntegerNumber(const wchar_t* input)
{
	const wchar_t* p;
	for (p = input; *p != '\0'; p++)
	{
		if (*p < (unsigned char)'0') return false;
		if (*p > (unsigned char)'9') return false;
	}
	return true;
}

bool TextAssistant::IsIntegerNumber(const unsigned char* input)
{
	const unsigned char* p;
	for (p = input; *p != '\0'; p++)
	{
		if (*p < (unsigned char)'0') return false;
		if (*p > (unsigned char)'9') return false;
	}
	return true;
}

bool TextAssistant::IsChar(wchar_t input)
{
	if (input < (unsigned char)'A') return false;
	if ((unsigned char)'Z' < input && input < (unsigned char)'a') return false;
	if ((unsigned char)'z' < input) return false;
	return true;
}

bool TextAssistant::IsChar(unsigned char input)
{
	if (input < (unsigned char)'A') return false;
	if ((unsigned char)'Z' < input && input < (unsigned char)'a') return false;
	if ((unsigned char)'z' < input) return false;
	return true;
}

bool TextAssistant::IsCharAccent(wchar_t input)
{
	if ((unsigned char)'A' <= (unsigned char)input && (unsigned char)input <= (unsigned char)'Z') return true;
	if ((unsigned char)'a' <= (unsigned char)input && (unsigned char)input <= (unsigned char)'z') return true;
	if ((unsigned char)'À' <= (unsigned char)input && (unsigned char)input <= (unsigned char)'Ö') return true;
	if ((unsigned char)'Ø' <= (unsigned char)input && (unsigned char)input <= (unsigned char)'ö') return true;
	if ((unsigned char)'ø' <= (unsigned char)input && (unsigned char)input <= (unsigned char)'ÿ') return true;
	return false;
}

bool TextAssistant::IsCharAccent(unsigned char input)
{
	if ((unsigned char)'A' <= input && input <= (unsigned char)'Z') return true;
	if ((unsigned char)'a' <= input && input <= (unsigned char)'z') return true;
	if ((unsigned char)'À' <= input && input <= (unsigned char)'Ö') return true;
	if ((unsigned char)'Ø' <= input && input <= (unsigned char)'ö') return true;
	if ((unsigned char)'ø' <= input && input <= (unsigned char)'ÿ') return true;
	return false;
}

bool TextAssistant::IsValidIdChar(wchar_t letter)
{
	if (letter == (unsigned char)'_') return true;
	if ((unsigned char)'a' <= letter && letter <= (unsigned char)'z') return true;
	if ((unsigned char)'A' <= letter && letter <= (unsigned char)'Z') return true;
	if ((unsigned char)'0' <= letter && letter <= (unsigned char)'9') return true;
	return false;
}

bool TextAssistant::IsValidIdChar(unsigned char letter)
{
	if (letter == (unsigned char)'_') return true;
	if ((unsigned char)'a' <= letter && letter <= (unsigned char)'z') return true;
	if ((unsigned char)'A' <= letter && letter <= (unsigned char)'Z') return true;
	if ((unsigned char)'0' <= letter && letter <= (unsigned char)'9') return true;
	return false;
}

bool TextAssistant::GetDouble(const wchar_t* input, double& output)
{
	const wchar_t* p = input;
	wchar_t text[32];
	int i = 0;
	//_________________________________________________ + or -
	if (*p == (unsigned char)'+' || *p == (unsigned char)'-')
	{
		text[i] = *p;
		p++;
		i++;
	}
	//________________________________________________ digits
	while ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
	{
		text[i] = *p;
		p++;
		i++;
		if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
	}
	//_______________________________________________ .
	if (*p == '.')
	{
		text[i] = *p;
		p++;
		i++;
		if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
	}
	//________________________________________________ digits
	while ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
	{
		text[i] = *p;
		p++;
		i++;
		if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
	}
	//_______________________________________________ e or E
	if (*p == (unsigned char)'e' || *p == (unsigned char)'E')
	{
		text[i] = *p;
		p++;
		i++;
		if (*p == (unsigned char)'+' || *p == (unsigned char)'-')
		{
			text[i] = *p;
			p++;
			i++;
			if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
		}
		while ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
		{
			text[i] = *p;
			p++;
			i++;
			if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
		}
	}
FIN:
	text[i] = '\0';
	output = _wtof(text);
	return (*p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n');
}

bool TextAssistant::GetDouble(const unsigned char* input, double& output)
{
	const unsigned char* p = input;
	char text[32];
	int i = 0;
	//_________________________________________________ + or -
	if (*p == (unsigned char)'+' || *p == (unsigned char)'-')
	{
		text[i] = *p;
		p++;
		i++;
	}
	//________________________________________________ digits
	while ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
	{
		text[i] = *p;
		p++;
		i++;
		if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
	}
	//_______________________________________________ .
	if (*p == '.')
	{
		text[i] = *p;
		p++;
		i++;
		if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
	}
	//________________________________________________ digits
	while ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
	{
		text[i] = *p;
		p++;
		i++;
		if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
	}
	//_______________________________________________ e or E
	if (*p == (unsigned char)'e' || *p == (unsigned char)'E')
	{
		text[i] = *p;
		p++;
		i++;
		if (*p == (unsigned char)'+' || *p == (unsigned char)'-')
		{
			text[i] = *p;
			p++;
			i++;
			if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
		}
		while ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
		{
			text[i] = *p;
			p++;
			i++;
			if (i == 31 || *p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n') goto FIN;
		}
	}
	FIN:
	text[i] = '\0';
	output = atof(text);
	return (*p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n');
}

bool TextAssistant::GetMantissa(const unsigned char* input, int& output)
{
	output = 0;
	const unsigned char* p = input;
	if (*p != (unsigned char)'e' && *p != (unsigned char)'E') return false;
	p++;
	return Sys::TextAssistant::GetInteger(p, output);
}

bool TextAssistant::GetMantissa(const wchar_t* input, int& output)
{
	output = 0;
	const wchar_t* p = input;
	if (*p != (unsigned char)'e' && *p != (unsigned char)'E') return false;
	p++;
	return Sys::TextAssistant::GetInteger(p, output);
}

bool TextAssistant::GetInteger(const unsigned char* input, int& output)
{
	output = 0;
	const unsigned char* p = input;
	bool isPositive = true;
	if (*p == (unsigned char)'+')
	{
		isPositive = true;
		p++;
	}
	if (*p == (unsigned char)'-')
	{
		isPositive = false;
		p++;
	}
	if (*p < (unsigned char)'0' || (unsigned char)'9' < *p) return false;
	char text[16];
	int i = 0;
	while (i < 15)
	{
		if ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
		{
			text[i] = *p;
			i++;
			p++;
		}
		else
		{
			text[i] = '\0';
			output = atoi(text);
			if (isPositive == false) output = -1*output;
			return (*p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n');
		}
	}
	return false;
}

bool TextAssistant::GetInteger(const wchar_t* input, int& output)
{
	output = 0;
	const wchar_t* p = input;
	bool isPositive = true;
	if (*p == '+')
	{
		isPositive = true;
		p++;
	}
	if (*p == '-')
	{
		isPositive = false;
		p++;
	}
	if (*p < (unsigned char)'0' || (unsigned char)'9' < *p) return false;
	wchar_t text[16];
	int i = 0;
	while (i < 15)
	{
		if ((unsigned char)'0' <= *p && *p <= (unsigned char)'9')
		{
			text[i] = *p;
			i++;
			p++;
		}
		else
		{
			text[i] = '\0';
			output = _wtoi(text);
			if (isPositive == false) output = -1*output;
			return (*p == '\0' || *p == (unsigned char)' ' || *p == (unsigned char)'\t' || *p == (unsigned char)'\r' || *p == (unsigned char)'\n');
		}
	}
	return false;
}

bool TextAssistant::IsEmailAddress(const wchar_t* text)
{
	tr1::wregex reg(L"[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[a-zA-Z]{2}|com|org|net|edu|gov|mil|biz|info|mobi|name|aero|asia|jobs|museum)\\b");
	return tr1::regex_match(text, reg);
}

bool TextAssistant::IsEmailAddressChar(wchar_t c)
{
	if ((unsigned char)'A' <= c && c <= (unsigned char)'Z') return true;
	if ((unsigned char)'a' <= c && c <= (unsigned char)'z') return true;
	if ((unsigned char)'0' <= c && c <= (unsigned char)'9') return true;
	if (c == (unsigned char)'.') return true;
	if (c == (unsigned char)'_') return true;
	if (c == (unsigned char)'-') return true;
	if (c == (unsigned char)'+') return true;
	if (c == (unsigned char)'@') return true;
	return false;
}

// Deletes all ocurrecences of the the string that begins with start and ends with end
int TextAssistant::SmartDelete(wstring& in_out, const wstring& start, const wstring& end)
{
	const int lenStart = (int)start.length();
	if (lenStart<=0) return 0;
	const int lenEnd = (int)end.length();
	if (lenEnd<=0) return 0;
	int len = (int)in_out.length();
	if (len<=0) return 0;
	int count=0;
	int q = 0;
	int pStart = 0;
	int pEnd = 0;
	while(true)
	{
		pStart = (int)in_out.find(start, pStart);
		if (pStart == std::wstring::npos) break;
		//
		pEnd = (int)in_out.find(end, pStart);
		if (pEnd == std::wstring::npos) break;
		//
		q = 0;
		while(pEnd+lenEnd+q <= len)
		{
			in_out[pStart+q] = in_out[pEnd+lenEnd+q];
			q++;
		}
		len = len- (pEnd+lenEnd-pStart);
		in_out.resize(len);
		count++;
	}
	return count;
}

// Deletes all ocurrecences of the the string that begins with start and ends with end
int TextAssistant::SmartDelete(string& in_out, const string& start, const string& end)
{
	const int lenStart = (int)start.length();
	if (lenStart<=0) return 0;
	const int lenEnd = (int)end.length();
	if (lenEnd<=0) return 0;
	int len = (int)in_out.length();
	if (len<=0) return 0;
	int count=0;
	int q = 0;
	int pStart = 0;
	int pEnd = 0;
	while(true)
	{
		pStart = (int)in_out.find(start, pStart);
		if (pStart == std::string::npos) break;
		//
		pEnd = (int)in_out.find(end, pStart);
		if (pEnd == std::string::npos) break;
		//
		q = 0;
		while(pEnd+lenEnd+q <= len)
		{
			in_out[pStart+q] = in_out[pEnd+lenEnd+q];
			q++;
		}
		len = len- (pEnd+lenEnd-pStart);
		in_out.resize(len);
		count++;
	}
	return count;
}

int TextAssistant::DeleteAfter(wstring& in_out, const wchar_t character)
{
	const int pos = (int)in_out.find(character);
	if (pos == std::wstring::npos) return 0;
	in_out.resize(pos);
	return pos;
}

int TextAssistant::DeleteAfter(string& in_out, const unsigned char character)
{
	int pos = (int)in_out.find(character);
	if (pos == std::string::npos) return 0;
	in_out.resize(pos);
	return pos;
}

wstring& TextAssistant::TruncateToFit(HDC hdc, const wstring& input, wstring& output, int width, bool appendEllipses)
{
	SIZE size;
	TEXTMETRIC tm;
	::GetTextMetrics(hdc, &tm);
	const int i = width/tm.tmAveCharWidth;
	int j = 2;
	const int len = (int)input.length();

	output = input;
	::GetTextExtentPoint32W(hdc, output.c_str(), len, &size);
	if (width>size.cx) return output;

	do
	{
		output.assign(input, 0, i-j);
		if (appendEllipses) output += L"...";
		::GetTextExtentPoint32W(hdc, output.c_str(), (int)output.length(), &size);
		j++;
	}
	while (width<size.cx);
	return output;
}

string& TextAssistant::TruncateToFit(HDC hdc, const string& input, string& output, int width, bool appendEllipses)
{
	SIZE size;
	TEXTMETRIC tm;
	::GetTextMetrics(hdc, &tm);
	const int i = width/tm.tmAveCharWidth;
	int j = 2;
	const int len = (int)input.length();

	output = input;
	::GetTextExtentPoint32A(hdc, output.c_str(), len, &size);
	if (width>size.cx) return output;

	do
	{
		output.assign(input, 0, i-j);
		if (appendEllipses) output += "...";
		::GetTextExtentPoint32A(hdc, output.c_str(), (int)output.length(), &size);
		j++;
	}
	while (width<size.cx);
	return output;
}

bool TextAssistant::LoadFromResource(HINSTANCE hInst, int resource_id, wstring& output)
{
	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resource_id), L"BIN");
	if (hrsrc==NULL) return false;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return false;
	DWORD dwSize = SizeofResource(hInst, hrsrc); 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	output.resize(dwSize/sizeof(wchar_t));
	::CopyMemory((void*)output.data(), dataResource, dwSize);
	::FreeResource(hResource);
	return true;
}

bool TextAssistant::LoadFromResource(HINSTANCE hInst, int resource_id, string& output)
{
	HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(resource_id), L"BIN");
	if (hrsrc==NULL) return false;

	HGLOBAL hResource = ::LoadResource(hInst, hrsrc);
	if (hResource==NULL) return false;
	DWORD dwSize = SizeofResource(hInst, hrsrc); 
	BYTE * dataResource = (BYTE*) ::LockResource(hResource);
	output.resize(dwSize/sizeof(char));
	::CopyMemory((void*)output.data(), dataResource, dwSize);
	::FreeResource(hResource);
	return true;
}

wstring& TextAssistant::RemoveTrailingSpaces(wstring& in_out)
{
	int len = (int)in_out.length();
	if (len<=0) return in_out;
	int n = 0;
	int i = 0;
	//___________ delete spaces, tabs, line returns or line carriage at the beginning
	while ( (in_out[i]==' ' || in_out[i]=='\t' || in_out[i]=='\r' || in_out[i]=='\n' || in_out[i]==0xA0) && i<len) 
	{
		n++;
		i++;
	}
	if (n > 0) in_out.erase(0, n);
	//___________ delete spaces, tabs, line returns or line carriage at the end
	len = (int)in_out.length();
	if (len == 0) return in_out;
	n = 0;
	i = len -1;
	while ( (in_out[i]==' ' || in_out[i]=='\t' || in_out[i]=='\r' || in_out[i]=='\n' || in_out[i]==0xA0) && i>=0) 
	{
		n++;
		i--;
	}
	if (n > 0) in_out.erase(i+1, n);
	return in_out;
}

void TextAssistant::ToUpper(wchar_t* in_out)
{
	const unsigned char ax = (unsigned char)'à';
	const unsigned char yx = (unsigned char)'ý';
	const wchar_t offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char a = (unsigned char)'a';
	const unsigned char z= (unsigned char)'z';
	const wchar_t offset = (unsigned char)'a' - (unsigned char)'A';
	//
	for(register wchar_t* p = in_out; *p != '\0'; p++)
	{
		if (ax <= (*p) && (*p) <= yx)
		{
			(*p) -= offsetx;
		}
		else if (a <= (*p) && (*p) <= z)
		{
			(*p) -= offset;
		}
	}
}

void TextAssistant::ToUpper(unsigned char* in_out)
{
	const unsigned char ax = 'à';
	const unsigned char yx = 'ý';
	const unsigned char offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char a = 'a';
	const unsigned char z= 'z';
	const unsigned char offset = (unsigned char)'a' - (unsigned char)'A';
	//
	for (register unsigned char* p = (unsigned char*)in_out; *p != '\0'; p++)
	{
		if (ax <= (*p) && (*p) <= yx)
		{
			(*p) -= offsetx;
		}
		else if (a <= (*p) && (*p) <= z)
		{
			(*p) -= offset;
		}
	}
}

void TextAssistant::ToUpper(const wchar_t* in, wchar_t* out)
{
	const unsigned char ax = (unsigned char)'à';
	const unsigned char yx = (unsigned char)'ý';
	const wchar_t offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char a = (unsigned char)'a';
	const unsigned char z= (unsigned char)'z';
	const wchar_t offset = (unsigned char)'a' - (unsigned char)'A';
	//
	register const wchar_t* pin = in;
	register wchar_t* pout = out;
	for(; *pin != '\0'; pin++, pout++)
	{
		if (ax <= (*pin) && (*pin) <= yx)
		{
			(*pout) -= offsetx;
		}
		else if (a <= (*pin) && (*pin) <= z)
		{
			(*pout) -= offset;
		}
	}
	*pout = '\0';
}

void TextAssistant::ToUpper(const unsigned char* in, unsigned char* out)
{
	const unsigned char ax = 'à';
	const unsigned char yx = 'ý';
	const unsigned char offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char a = 'a';
	const unsigned char z= 'z';
	const unsigned char offset = (unsigned char)'a' - (unsigned char)'A';
	//
	register const unsigned char* pin = in;
	register unsigned char* pout = out;
	for (; *pin != '\0'; pin++, pout++)
	{
		if (ax <= (*pin) && (*pin) <= yx)
		{
			(*pout) -= offsetx;
		}
		else if (a <= (*pin) && (*pin) <= z)
		{
			(*pout) -= offset;
		}
	}
	*pout = '\0';
}

wstring& TextAssistant::ToUpper(wstring& in_out)
{
	const unsigned char ax = (unsigned char)'à';
	const unsigned char yx = (unsigned char)'ý';
	const wchar_t offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char a = (unsigned char)'a';
	const unsigned char z= (unsigned char)'z';
	const wchar_t offset = (unsigned char)'a' - (unsigned char)'A';
	//
	const size_t len = in_out.size();
	register size_t i;
	for(i = 0; i < len; i++)
	{
		if (ax <= in_out[i] && in_out[i] <= yx)
		{
			in_out[i] -= offsetx;
		}
		else if (a <= in_out[i] && in_out[i] <= z)
		{
			in_out[i] -= offset;
		}
	}
	return in_out;
}

string& TextAssistant::ToUpper(string& in_out)
{
	const unsigned char ax = 'à';
	const unsigned char yx = 'ý';
	const unsigned char offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char a = 'a';
	const unsigned char z= 'z';
	const unsigned char offset = (unsigned char)'a' - (unsigned char)'A';
	//
	const size_t len = in_out.size();
	register size_t i;
	for (i = 0; i < len; i++)
	{
		if (ax <= (unsigned char)in_out[i] && (unsigned char)in_out[i] <= yx)
		{
			in_out[i] -= offsetx;
		}
		else if (a <= (unsigned char)in_out[i] && (unsigned char)in_out[i] <= z)
		{
			in_out[i] -= offset;
		}
	}
	return in_out;
}

wchar_t TextAssistant::ToUpper(wchar_t c)
{
	if ((unsigned char)'à' <= c && c <= (unsigned char)'ý') return c - (wchar_t)('à'- 'À');
	if ((unsigned char)'a' <= c && c <= (unsigned char)'z') return c - (wchar_t)('a' - 'A');
	return c;
}

unsigned char TextAssistant::ToUpper(unsigned char c)
{
	if ((unsigned char)'à' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'ý') return (unsigned char)c - (unsigned char)('à' - 'À');
	if ((unsigned char)'a' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'z') return (unsigned char)c - (unsigned char)('a' - 'A');
	return c;
}

unsigned char TextAssistant::ToLower(unsigned char c)
{
	if ((unsigned char)'À' <= c && c <= (unsigned char)'Ý') return c + (wchar_t)('à' - 'À');
	if ((unsigned char)'A' <= c && c <= (unsigned char)'Z') return c + (wchar_t)('a' - 'A');
	return c;
}

wchar_t TextAssistant::ToLower(wchar_t c)
{
	if ((unsigned char)'À' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'Ý') return c + (wchar_t)('à' - 'À');
	if ((unsigned char)'A' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'Z') return c + (wchar_t)('a' - 'A');
	return c;
}

void TextAssistant::ToLower(wchar_t* in_out)
{
	const unsigned char AX = (unsigned char)'À';
	const unsigned char YX = (unsigned char)'Ý';
	const wchar_t offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char A = (unsigned char)'A';
	const unsigned char Z= (unsigned char)'Z';
	const wchar_t offset = (unsigned char)'a' - (unsigned char)'A';
	//
	for (register wchar_t* p = in_out; *p != '\0'; p++)
	{
		if (AX<= (*p) && (*p) <= YX)
		{
			(*p) += offsetx;
		}
		else if (A <= (*p) && (*p) <= Z)
		{
			(*p) += offset;
		}
	}
}

void TextAssistant::ToLower(unsigned char* in_out)
{
	const unsigned char AX = 'À';
	const unsigned char YX = 'Ý';
	const unsigned char offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char A = 'A';
	const unsigned char Z= 'Z';
	const unsigned char offset = (unsigned char)'a' - (unsigned char)'A';
	//
	for (register unsigned char* p = in_out; *p != '\0'; p++)
	{
		if (AX<= (*p) && (*p) <= YX)
		{
			(*p) += offsetx;
		}
		else if (A <= (*p) && (*p) <= Z)
		{
			(*p) += offset;
		}
	}
}

void TextAssistant::ToLower(const wchar_t* in, wchar_t* out)
{
	const unsigned char AX = (unsigned char)'À';
	const unsigned char YX = (unsigned char)'Ý';
	const wchar_t offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char A = (unsigned char)'A';
	const unsigned char Z= (unsigned char)'Z';
	const wchar_t offset = (unsigned char)'a' - (unsigned char)'A';
	//
	register const wchar_t* pin = in;
	register wchar_t* pout = out;
	//
	for (; *pin != '\0'; pin++, pout++)
	{
		if (AX<= (*pin) && (*pin) <= YX)
		{
			(*pout) += offsetx;
		}
		else if (A <= (*pin) && (*pin) <= Z)
		{
			(*pout) += offset;
		}
	}
	*pout= '\0';
}

void TextAssistant::ToLower(const unsigned char* in, unsigned char* out)
{
	const unsigned char AX = 'À';
	const unsigned char YX = 'Ý';
	const unsigned char offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char A = 'A';
	const unsigned char Z= 'Z';
	const unsigned char offset = (unsigned char)'a' - (unsigned char)'A';
	//
	register const unsigned char* pin = in;
	register unsigned char* pout = out;
	//
	for (; *pin != '\0'; pin++, pout++)
	{
		if (AX<= (*pin) && (*pin) <= YX)
		{
			(*pout) += offsetx;
		}
		else if (A <= (*pin) && (*pin) <= Z)
		{
			(*pout) += offset;
		}
	}
	*pout= '\0';
}

wstring& TextAssistant::ToLower(wstring& in_out)
{
	const unsigned char AX = (unsigned char)'À';
	const unsigned char YX = (unsigned char)'Ý';
	const wchar_t offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char A = (unsigned char)'A';
	const unsigned char Z= (unsigned char)'Z';
	const wchar_t offset = (unsigned char)'a' - (unsigned char)'A';
	//
	const size_t len = in_out.size();
	register size_t i;
	for (i = 0; i < len; i++)
	{
		if (AX<= in_out[i] && in_out[i] <= YX)
		{
			in_out[i] += offsetx;
		}
		else if (A <= in_out[i] && in_out[i] <= Z)
		{
			in_out[i] += offset;
		}
	}
	return in_out;
}

string& TextAssistant::ToLower(string& in_out)
{
	const unsigned char AX = 'À';
	const unsigned char YX = 'Ý';
	const unsigned char offsetx = (unsigned char)'à' - (unsigned char)'À';
	//
	const unsigned char A = 'A';
	const unsigned char Z= 'Z';
	const unsigned char offset = (unsigned char)'a' - (unsigned char)'A';
	//
	const size_t len = in_out.size();
	register size_t i;
	for (i = 0; i < len; i++)
	{
		if (AX <= (unsigned char)in_out[i] && (unsigned char)in_out[i] <= YX)
		{
			in_out[i] += offsetx;
		}
		else if (A <= (unsigned char)in_out[i] && (unsigned char)in_out[i] <= Z)
		{
			in_out[i] += offset;
		}
	}
	return in_out;
}

bool TextAssistant::IsLowerCase(wchar_t c)
{
	if ((unsigned char)'a' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'z') return true;
	if ((unsigned char)'ß' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'þ') return true;
	return false;
}

bool TextAssistant::IsLowerCase(unsigned char c)
{
	if ((unsigned char)'a' <= c && c <= (unsigned char)'z') return true;
	if ((unsigned char)'ß' <= c && c <= (unsigned char)'þ') return true;
	return false;
}

bool TextAssistant::IsUpperCase(wchar_t c)
{
	if ((unsigned char)'A' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'Z') return true;
	if ((unsigned char)'À' <= (unsigned char)c && (unsigned char)c <= (unsigned char)'Þ') return true;
	return false;
}

bool TextAssistant::IsUpperCase(unsigned char c)
{
	if ((unsigned char)'A' <= c && c <= (unsigned char)'Z') return true;
	if ((unsigned char)'À' <= c && c <= (unsigned char)'Þ') return true;
	return false;
}

void TextAssistant::ReplaceAccents(wchar_t* in_out)
{
	for (register wchar_t* p = in_out; *p != '\0'; p++)
	{
		*p = Sys::TextAssistant::ReplaceAccents(*p);
	}
}

void TextAssistant::ReplaceAccents(unsigned char* in_out)
{
	for (register unsigned char* p = in_out; *p != '\0'; p++)
	{
		*p = Sys::TextAssistant::ReplaceAccents(*p);
	}
}

void TextAssistant::ReplaceAccents(const wchar_t* in, wchar_t* out)
{
	register const wchar_t* pin;
	register wchar_t* pout;
	for (pin = in, pout = out; *pin != '\0'; pin++, pout++)
	{
		*pout = Sys::TextAssistant::ReplaceAccents(*pin);
	}
}

void  TextAssistant::ReplaceAccents(const unsigned char* in, unsigned char* out)
{
	register const unsigned char* pin;
	register unsigned char* pout;
	for (pin = in, pout = out; *pin != '\0'; pin++, pout++)
	{
		*pout = Sys::TextAssistant::ReplaceAccents(*pin);
	}
}

wstring& TextAssistant::ReplaceAccents(wstring& in_out)
{
	const size_t len = (int)in_out.size();
	register size_t i;
	for (i = 0; i < len; i++)
	{
		in_out[i] = Sys::TextAssistant::ReplaceAccents(in_out[i]);
	}
	return in_out;
}

string& TextAssistant::ReplaceAccents(string& in_out)
{
	const size_t len = in_out.size();
	register size_t i;
	for (i = 0; i < len; i++)
	{
		in_out[i] = Sys::TextAssistant::ReplaceAccents((unsigned char)in_out[i]);
	}
	return in_out;
}

wchar_t TextAssistant::ReplaceAccents(wchar_t c)
{
	if ((unsigned char)'Á' <= c && c <= (unsigned char)'Å') return (unsigned char)'A';
	if ((unsigned char)'È' <= c && c <= (unsigned char)'Ë') return (unsigned char)'E';
	if ((unsigned char)'Ì' <= c && c <= (unsigned char)'Ï') return (unsigned char)'I';
	if ((unsigned char)'Ò' <= c && c <= (unsigned char)'Ö') return (unsigned char)'O';
	if ((unsigned char)'Ù' <= c && c <= (unsigned char)'Ü') return (unsigned char)'U';
	if ((unsigned char)'Ý' == c) return (unsigned char)'Y';
	if ((unsigned char)'Ñ' == c) return (unsigned char)'N';
	//
	if ((unsigned char)'à' <= c && c <= (unsigned char)'å') return (unsigned char)'a';
	if ((unsigned char)'è' <= c && c <= (unsigned char)'ë') return (unsigned char)'e';
	if ((unsigned char)'ì' <= c && c <= (unsigned char)'ï') return (unsigned char)'i';
	if ((unsigned char)'ò' <= c && c <= (unsigned char)'ö') return (unsigned char)'o';
	if ((unsigned char)'ù' <= c && c <= (unsigned char)'ü') return (unsigned char)'u';
	if ((unsigned char)'ý' == c) return (unsigned char)'y';
	if ((unsigned char)'ñ' == c) return (unsigned char)'n';
	return c;
}

unsigned char TextAssistant::ReplaceAccents(unsigned char c)
{
	if ((unsigned char)'Á' <= c && c <= (unsigned char)'Å') return 'A';
	if ((unsigned char)'È' <= c && c <= (unsigned char)'Ë') return 'E';
	if ((unsigned char)'Ì' <= c && c <= (unsigned char)'Ï') return 'I';
	if ((unsigned char)'Ò' <= c && c <= (unsigned char)'Ö') return 'O';
	if ((unsigned char)'Ù' <= c && c <= (unsigned char)'Ü') return 'U';
	if ((unsigned char)'Ý' == c) return (unsigned char)'Y';
	if ((unsigned char)'Ñ' == c) return (unsigned char)'N';
	//
	if ((unsigned char)'à' <= c && c <= (unsigned char)'å') return 'a';
	if ((unsigned char)'è' <= c && c <= (unsigned char)'ë') return 'e';
	if ((unsigned char)'ì' <= c && c <= (unsigned char)'ï') return 'i';
	if ((unsigned char)'ò' <= c && c <= (unsigned char)'ö') return 'o';
	if ((unsigned char)'ù' <= c && c <= (unsigned char)'ü') return 'u';
	if ((unsigned char)'ý' == c) return (unsigned char)'y';
	if ((unsigned char)'ñ' == c) return (unsigned char)'n';
	return c;
}

unsigned int TextAssistant::StringCompareWithAccents(unsigned char c)
{
	static unsigned char data[] = {110, 255, 255, 255, 255, 255, 255, 255, 255, 111, 113, 255, 255, 112, 255, 255, 255, 255, 255, 255, 255, 
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 
		129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 56, 64, 65, 66, 68, 73, 74, 75, 76, 81, 
		82, 83, 84, 85, 87, 94, 95, 96, 97, 98, 99, 104, 105, 106, 107, 109, 147, 148, 149, 150, 151, 255, 0, 8, 10, 11, 13, 18, 19, 20, 21, 
		26, 27, 28, 29, 30, 32, 39, 40, 41, 42, 43, 44, 49, 50, 51, 52, 55, 152, 153, 154, 155, 255, 255, 255, 255, 255, 255, 255, 255, 255, 
		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 156, 
		157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 255, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 
		182, 183, 184, 185, 57, 58, 59, 60, 61, 62, 63, 255, 69, 70, 71, 72, 77, 78, 79, 80, 67, 86, 88, 89, 90, 91, 92, 186, 93, 100, 101, 102, 
		103, 108, 188, 9, 1, 2, 3, 4, 5, 6, 7, 255, 14, 15, 16, 17, 22, 23, 24, 25, 12, 31, 33, 34, 35, 36, 37, 187, 38, 45, 46, 47, 48, 53, 255};
	return data[c];

	//unsigned char cdata[] = "aàáâãäåæbßcdðeèéêëfghiìíîïjklmnñoòóôõöøpqrstuùúûüvwxyýÿzAÀÁÂÃÄÅÆBCDÐEÈÉÊËFGHIÌÍÎÏJKLMNÑOÒÓÔÕÖØPQRSTUÙÚÛÜVWXYÝZ\0\t\r\n !\"#$%&\'()*+,-./0123456789:;<=>?@[\\]^_{|}~¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿×÷Þ";
	//wchar_t text[32];
	//unsigned char c, result;
	//bool found = false;
	//for (c = 0; c < 255; c++)
	//{
	//	found = false;
	//	for (result = 0; result < 255; result++)
	//	{
	//		if (c == cdata[result])
	//		{
	//			_snwprintf_s(text, 32, _TRUNCATE, L"%d, ", Sys::TextAssistant::StringCompareWithAccents(c));
	//			tbxOutput.Text += text;
	//			found = true;
	//			break;
	//		}
	//	}
	//	if (found == false) tbxOutput.Text += L"255, ";
	//}
}

int TextAssistant::StringCompareWithAccents(const wchar_t* string1, const wchar_t * string2)
{
	const wchar_t* s1;
	const wchar_t* s2;
	int d1, d2;
	for (s1 = string1, s2 = string2; *s1 != '\0' && *s2 != '\0'; s1++, s2++)
	{
		d1 = Sys::TextAssistant::StringCompareWithAccents((unsigned char)*s1);
		d2 = Sys::TextAssistant::StringCompareWithAccents((unsigned char)*s2);
		if (d1 < d2) return -1;
		if (d1 > d2) return 1;
	}
	if (*s1 == '\0' && *s2 == '\0') return 0;
	if (*s1 == '\0' && *s2 != '\0') return -1;
	return 1;
}

int TextAssistant::StringCompareWithAccents(const unsigned char* string1, const unsigned char* string2)
{
	const unsigned char* s1;
	const unsigned char* s2;
	int d1, d2;
	for (s1 = string1, s2 = string2; *s1 != '\0' && *s2 != '\0'; s1++, s2++)
	{
		d1 = Sys::TextAssistant::StringCompareWithAccents(*s1);
		d2 = Sys::TextAssistant::StringCompareWithAccents(*s2);
		if (d1 < d2) return -1;
		if (d1 > d2) return 1;
	}
	if (*s1 == '\0' && *s2 == '\0') return 0;
	if (*s1 == '\0' && *s2 != '\0') return -1;
	return 1;
}

int TextAssistant::DeleteChar(wstring& in_out, wchar_t remove)
{
	const int len = (int)in_out.length();
	if (len<=0) return 0;
	int count = 0;
	int i, j;

	for(i=0; i<len; i++)
	{
		if (in_out[i] == remove) count++;
	}

	wstring tmp(in_out);
	in_out.resize(len-count);

	for(i=0, j= 0; i<len; i++)
	{
		if (tmp[i] == remove) continue;
		in_out[j++] = tmp[i];
	}
	return count;
}

int TextAssistant::ReplaceChar(wstring& in_out, wchar_t oldChar, wchar_t newChar)
{
	const int len = (int)in_out.length();
	if (len<=0) return 0;
	int count = 0;
	for(int i=0; i<len; i++)
	{
		if (in_out[i] == oldChar)
		{
			in_out[i] = newChar;
			count++;
		}
	}
	return count;
}

int TextAssistant::Delete(wstring& in_out, const wchar_t* deleteThisText, bool matchWholeWord)
{
	const size_t len = in_out.length();
	if (len<=0) return 0;
	const size_t lenWord = wcslen(deleteThisText);
	if (lenWord<=0) return 0;

	const int count = Sys::TextAssistant::GetFindCount(in_out, deleteThisText, matchWholeWord);
	if (count<=0) return 0;

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(deleteThisText, pos)) != std::string::npos)
		{ 
			if (Sys::TextAssistant::IsSeparator((const wstring&)in_out, (int)pos - 1) && Sys::TextAssistant::IsSeparator((const wstring&)in_out, (int)(pos + lenWord)))
			{
				in_out.erase(pos, lenWord); 
			}
		} 
	}
	else
	{
		while((pos = in_out.find(deleteThisText, pos)) != std::wstring::npos)
		{ 
			in_out.erase(pos, lenWord); 
		} 
	}
	return count;
}

int TextAssistant::Replace(wstring& in_out, const wchar_t* findThis, const wchar_t* replaceWithThis, bool matchWholeWord, bool matchCase)
{
	int count = 0;
	int pos = 0;
	const size_t len_findThis = wcslen(findThis);
	if (len_findThis <= 0) return 0;
	const size_t len_replaceWithThis = wcslen(replaceWithThis);

	while ((pos = Sys::TextAssistant::Find(in_out.c_str(), pos, findThis, matchWholeWord, matchCase)) != -1)
	{
		in_out.replace(pos, len_findThis, replaceWithThis);
		pos += (int)len_replaceWithThis;
		count++;
	}
	return count;
}

int TextAssistant::Replace(const wchar_t* input, wstring& output, const wchar_t* findThis, const wchar_t* replaceWithThis, bool matchWholeWord, bool matchCase)
{
	if (input == NULL) return 0;
	if (findThis == NULL) return 0;
	if (replaceWithThis == NULL) return 0;
	//____________________________________________________________________________
	const size_t len_input = wcslen(input);
	if (len_input == 0) return 0;
	//____________________________________________________________________________
	const int count = Sys::TextAssistant::GetFindCount(input, findThis, matchWholeWord, matchCase);
	if (count == 0) return 0;
	//____________________________________________________________________________
	size_t len_findThis = wcslen(findThis);
	if (len_findThis == 0) return 0;
	//____________________________________________________________________________
	size_t len_replaceWithThis = wcslen(replaceWithThis);
	if (len_replaceWithThis == 0) return 0;
	//____________________________________________________________________________
	size_t new_len = len_input + count*(len_replaceWithThis-len_findThis);// + 1;
	output.resize(new_len);
	int pa = 0;
	int positionStart = 0;
	int n = 0;
	int output_index = 0;
	int i;
	int remaining = 0;
	
	while (true)
	{
		pa = positionStart;
		positionStart = Sys::TextAssistant::Find(input, (size_t)positionStart, findThis, matchWholeWord, matchCase);
		if (positionStart == -1)
		{
			remaining = (int)len_input - pa;
			if (remaining > 0)
			{
				for (i = 0; i < remaining; i++)
				{
					output[output_index] = input[pa+i];
					output_index++;
				}
			}
			break;
		}
		else
		{
			n = (int)(positionStart - pa);
			//_______________________________ lstrcpyn(qa, pa, n);
			for(i = 0; i < n; i++)
			{
				output[output_index] = input[pa+i];
				output_index++;
			}
			//_______________________________ lstrcat(qa, replaceWithThis);
			for (i = 0; i < (int)len_replaceWithThis; i++)
			{
				output[output_index] = replaceWithThis[i];
				output_index++;
			}
			positionStart += (int)len_findThis;
		}
	}
	return count;
}

int TextAssistant::Replace(wstring& in_out, const wchar_t* findThis, const wchar_t* replaceWithThis, bool matchWholeWord)
{
	const int len = (int)in_out.length();
	if (len<=0) return 0;
	const size_t len_findThis = wcslen(findThis);
	if (len_findThis<=0) return 0;
	const size_t len_replaceWithThis = wcslen(replaceWithThis);

	const int count = Sys::TextAssistant::GetFindCount(in_out, findThis, matchWholeWord);
	if (count<=0) return 0;
	const int newLen = len + count * (int)(len_replaceWithThis - len_findThis);
	in_out.reserve(newLen);

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(findThis, pos)) != std::string::npos)
		{ 
			if (Sys::TextAssistant::IsSeparator((const wstring&)in_out, (int)pos - 1) && Sys::TextAssistant::IsSeparator((const wstring&)in_out, (int)(pos + len_findThis)))
			{
				in_out.replace(pos, len_findThis, replaceWithThis);
				pos += len_replaceWithThis;
			}
			else
			{
				pos += len_findThis;
			}
		} 
	}
	else
	{
		while((pos = in_out.find(findThis, pos)) != std::wstring::npos)
		{ 
			in_out.replace(pos, len_findThis, replaceWithThis);
			pos += len_replaceWithThis;
		} 
	}
	return count;
}

int TextAssistant::ReplaceBiggerLessThan(const wchar_t* input, wstring& output)
{
	const int len = (int)wcslen(input);
	if (len<=0)
	{
		output.clear();
		return 0;
	}
	int i;
	int count = 0;
	for(i = 0; i < len; i++)
	{
		if (input[i] == '<' || input[i] == '>') count++;
	}
	if (count<=0)
	{
		output = input;
		return 0;
	}
	const int newLen = len + count * (3);
	output.reserve(newLen);
	for(i = 0; i<len; i++)
	{
		if (input[i] == '<')
		{
			output += L"&lt;";
		}
		else if (input[i] == '>')
		{
			output += L"&gt;";
		}
		else
		{
			output += input[i];
		}
	}
	
	return count;
}

void TextAssistant::FirstUppercase(wchar_t* in_out)
{
	const size_t len = wcslen(in_out);
	if (len <= 0) return;
	in_out[0] = toupper(in_out[0]);
	if (len == 1) return;
	for (size_t i = 1; i<len; i++)
	{
		if (in_out[i - 1] == ' ')
		{
			in_out[i] = toupper(in_out[i]);
		}
		else
		{
			in_out[i] = tolower(in_out[i]);
		}
	}
}

void TextAssistant::FirstUppercase(unsigned char* in_out)
{
	const size_t len = strlen((char*)in_out);
	if (len <= 0) return;
	in_out[0] = toupper(in_out[0]);
	if (len == 1) return;
	for (size_t i = 1; i<len; i++)
	{
		if (in_out[i - 1] == (unsigned char)' ')
		{
			in_out[i] = toupper(in_out[i]);
		}
		else
		{
			in_out[i] = tolower(in_out[i]);
		}
	}
}

wstring& TextAssistant::FirstUppercase(wstring& in_out)
{
	const int len = (int)in_out.length();
	if (len<=0) return in_out;
	in_out[0] = toupper(in_out[0]);
	if (len==1) return in_out;
	for(int i=1; i<len; i++)
	{
		if ( in_out[i-1]==' ')
		{
			in_out[i] = toupper(in_out[i]);
		}
		else
		{
			in_out[i] = tolower(in_out[i]);
		}
	}
	return in_out;
}

int TextAssistant::GetFindCount(const wstring& input, const wstring& findThis, bool matchWholeWord)
{
	if (input.length()<=0) return 0;
	int count = 0;
	int pos = 0;
	const int len = (int)findThis.length();

	while(true)
	{
		pos = (int)input.find(findThis, pos);
		if (pos == std::wstring::npos) 
		{
			break;
		}
		else
		{
			if (matchWholeWord == true)
			{
				if (Sys::TextAssistant::IsSeparator(input, pos-1)==true && Sys::TextAssistant::IsSeparator(input, pos+len)==true) count++;
			}
			else
			{
				count++;
			}
		}
		pos+=len;
	}
	return count;
}

int TextAssistant::GetFindCount(const string& input, const string& findThis, bool matchWholeWord)
{
	if (input.length()<=0) return 0;
	int count = 0;
	int pos = 0;
	const int len = (int)findThis.length();

	while(true)
	{
		pos = (int)input.find(findThis, pos);
		if (pos == std::string::npos) 
		{
			break;
		}
		else
		{
			if (matchWholeWord == true)
			{
				if (Sys::TextAssistant::IsSeparator(input, pos-1)==true && Sys::TextAssistant::IsSeparator(input, pos+len)==true) count++;
			}
			else
			{
				count++;
			}
		}
		pos+=len;
	}
	return count;
}

int TextAssistant::GetFindCount(const wchar_t* input, const wchar_t* findThis, bool matchWholeWord, bool matchCase)
{
	if (input == NULL) return 0;
	if (findThis == NULL) return 0;
	int count = 0;
	size_t positionStart = 0;
	const size_t len_findThis = wcslen(findThis);
	int result = 0;
	while (true)
	{
		result = Sys::TextAssistant::Find(input, positionStart, findThis, matchWholeWord, matchCase);
		if (result < 0)
		{
			break;
		}
		else
		{
			count++;
			positionStart = (size_t)result + len_findThis;
		}
	}
	return count;
}

string& TextAssistant::RemoveTrailingSpaces(string& in_out)
{
	int len = (int)in_out.length();
	if (len<=0) return in_out;
	int n = 0;
	int i = 0;
	//___________ delete spaces at the beginning
	while (in_out[i]==' ' && i<len) 
	{
		n++;
		i++;
	}
	in_out.erase(0, n);
	//___________ delete spaces at the end
	len = (int)in_out.length();
	n = 0;
	i = len -1;
	while (in_out[i]==' ' && i>=0) 
	{
		n++;
		i--;
	}
	in_out.erase(i+1, n);
	return in_out;
}

wstring& TextAssistant::RemoveExtraSpaces(wstring& in_out)
{
	wstring tmp(in_out);
	const size_t len = tmp.length();
	size_t i;
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == '\r' || tmp[i] == '\n' || tmp[i] == '\t')
		{
			tmp[i] = ' ';
		}
	}
	size_t spaceCount = 0;
	in_out.clear();
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == ' ')
		{
			if (spaceCount == 0)
			{
				in_out += ' ';
			}
			spaceCount++;
		}
		else
		{
			in_out += tmp[i];
			spaceCount = 0;
		}
	}
	return in_out;
}

// Removes carriage returns, tabs and extra spaces
string& TextAssistant::RemoveExtraSpaces(string& in_out)
{
	string tmp(in_out);
	const size_t len = tmp.length();
	size_t i;
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == '\r' || tmp[i] == '\n' || tmp[i] == '\t')
		{
			tmp[i] = ' ';
		}
	}
	size_t spaceCount = 0;
	in_out.clear();
	for(i = 0; i < len; i++)
	{
		if (tmp[i] == ' ')
		{
			if (spaceCount == 0)
			{
				in_out += ' ';
			}
			spaceCount++;
		}
		else
		{
			in_out += tmp[i];
			spaceCount = 0;
		}
	}
	return in_out;
}

int TextAssistant::DeleteChar(wchar_t* in_out, wchar_t remove)
{
	const int len = (int)wcslen(in_out);
	if (len<=0) return 0;
	int count = 0;
	int i, j;

	for(i=0, j= 0; i<len; i++)
	{
		if (in_out[i] == remove) continue;
		in_out[j++] = in_out[i];
	}
	in_out[j] = '\0';
	return count;
}

int TextAssistant::DeleteChar(string& in_out, char remove)
{
	const int len = (int)in_out.length();
	if (len<=0) return 0;
	int count = 0;
	int i, j;

	for(i=0; i<len; i++)
	{
		if (in_out[i] == remove) count++;
	}

	string tmp(in_out);
	in_out.resize(len-count);

	for(i=0, j= 0; i<len; i++)
	{
		if (tmp[i] == remove) continue;
		in_out[j++] = tmp[i];
	}
	return count;
}

int TextAssistant::ReplaceChar(unsigned char* in_out, unsigned char oldChar, unsigned char newChar)
{
	const size_t len = strlen((char*)in_out);
	if (len == 0) return 0;
	int count = 0;
	for (size_t i=0; i<len; i++)
	{
		if (in_out[i] == oldChar)
		{
			in_out[i] = newChar;
			count++;
		}
	}
	return count;
}

int TextAssistant::ReplaceChar(wchar_t* in_out, wchar_t oldChar, wchar_t newChar)
{
	const size_t len = wcslen(in_out);
	if (len == 0) return 0;
	int count = 0;
	for(size_t i=0; i<len; i++)
	{
		if (in_out[i] == oldChar) 
		{
			in_out[i] = newChar;
			count++;
		}
	}
	return count;
}

int TextAssistant::ReplaceChar(string& in_out, char oldChar, char newChar)
{
	const int len = (int)in_out.length();
	int count = 0;
	if (len<=0) return 0;
	for(int i=0; i<len; i++)
	{
		if (in_out[i] == oldChar) 
		{
			in_out[i] = newChar;
			count++;
		}
	}
	return count;
}

int TextAssistant::Delete(string& in_out, const char* deleteThisText, bool matchWholeWord)
{
	const size_t len = in_out.length();
	if (len<=0) return 0;
	const size_t lenWord = strlen(deleteThisText);
	if (lenWord<=0) return 0;

	const int count = GetFindCount(in_out, deleteThisText, matchWholeWord);
	if (count<=0) return 0;

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(deleteThisText, pos)) != std::string::npos)
		{ 
			if (Sys::TextAssistant::IsSeparator((const string&)in_out, (int)pos - 1) && Sys::TextAssistant::IsSeparator((const string&)in_out, (int)(pos + lenWord)))
			{
				in_out.erase(pos, lenWord); 
			}
		} 
	}
	else
	{
		while((pos = in_out.find(deleteThisText, pos)) != std::string::npos)
		{ 
			in_out.erase(pos, lenWord); 
		} 
	}
	return count;
}

int TextAssistant::Replace(string& in_out, const char* findThis, const char* replaceWithThis, bool matchWholeWord)
{
	const int len = (int)in_out.length();
	if (len<=0) return 0;
	const size_t len_findThis = strlen(findThis);
	if (len_findThis<=0) return 0;
	const size_t len_replaceWithThis= strlen(replaceWithThis);

	const int count = Sys::TextAssistant::GetFindCount(in_out, findThis, matchWholeWord);
	if (count<=0) return 0;
	const int newLen = (int)(len + count * (len_replaceWithThis - len_findThis));
	in_out.reserve(newLen);

	size_t pos = 0; 
	if (matchWholeWord == true)
	{
		while((pos = in_out.find(findThis, pos)) != std::string::npos)
		{ 
			if (Sys::TextAssistant::IsSeparator((const string&)in_out, (int)pos - 1) && Sys::TextAssistant::IsSeparator((const string&)in_out, (int)(pos + len_findThis)))
			{
				in_out.replace(pos, len_findThis, replaceWithThis);
				pos += len_replaceWithThis;
			}
			else
			{
				pos += len_findThis;
			}
		} 
	}
	else
	{
		while((pos = in_out.find(findThis, pos)) != std::string::npos)
		{ 
			in_out.replace(pos, len_findThis, replaceWithThis);
			pos += len_replaceWithThis;
		} 
	}
	return count;
}

int TextAssistant::ExpandEscapeSequences(const wstring& input, wstring& output)
{
	output.clear();
	int count = 0;
	const int len = (int)input.length();
	for(int i = 0; i<len; i++)
	{
		if (input[i] == '"')
		{
			output += L"\\\"";
			count++;
		}
		else if (input[i] == '\\')
		{
			output += L"\\\\";
			count++;
		}
		else
		{
			output += input[i];
		}
	}
	return count;
}

string& TextAssistant::FirstUppercase(string& in_out)
{
	const int len = (int)in_out.length();
	if (len<=0) return in_out;
	in_out[0] = toupper(in_out[0]);
	if (len==1) return in_out;
	for(int i=1; i<len; i++)
	{
		if ( in_out[i-1]==' ')
		{
			in_out[i] = toupper(in_out[i]);
		}
		else
		{
			in_out[i] = tolower(in_out[i]);
		}
	}
	return in_out;
}

bool TextAssistant::IsUnicode(const void* input, int inputSize)
{
	int nUnicodeTest = IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_REVERSE_SIGNATURE;
	if (IsTextUnicode (input, inputSize, &nUnicodeTest) == TRUE) return true;
		
	//BYTE bySwap;
	//if (nUnicodeTest & IS_TEXT_UNICODE_REVERSE_SIGNATURE)
	//{
	//	for (i = 0 ; i < n / 2 ; i++)
	//	{
	//		bySwap = ((BYTE *) pText) [2 * i] ;
	//		((BYTE *) pText) [2 * i] = ((BYTE *) pText) [2 * i + 1] ;
	//		((BYTE *) pText) [2 * i + 1] = bySwap ;
	//	}
	//}
	return false;
}

bool TextAssistant::ExtractFileExt(const wchar_t* input, wchar_t * buffer, int bufferSize)
{
	if (input == NULL) return false;
	buffer[0] = '\0';
	register wchar_t *dotPosition = NULL;
	register wchar_t *p;
	//_________________________________________ Find the position of last dot
	for(p = (wchar_t*)input; *p != '\0'; p++)//, len++)
	{
		if (*p == '.') dotPosition = p;
	}
	if (dotPosition == NULL) return false;
	dotPosition++;
	if (*dotPosition == '\0') return false; // We reach the end
	//____________________________________________ Copy Result
	p  = buffer;
	bufferSize--;
	register int i;
	for(i = 0; i < bufferSize && *dotPosition != '\0' ; i++, dotPosition++, p++)
	{
		*p = towlower(*dotPosition);
	}
	*p = '\0';
	if (*dotPosition == '\0') return true; // We reach the end, we are OK
	return false;
}

bool TextAssistant::CopyTruncate(const wchar_t* source, wchar_t* destination, int destination_len)
{
	//_________________________________________ Handle empty source separately
	if (source[0] == '\0')
	{
		if (destination_len >= 1)
		{
			destination[0] = '\0';
			return true;
		}
		return false;
	}
	//__________________________________________ General case
	register wchar_t * p = (wchar_t *)source;
	register int n = 0;
	for( ; *p != '\0' && n < destination_len-1; p++, n++, destination++)
	{
		*destination = *p;
	}
	if (n == destination_len-1 && *p != '\0')
	{
		*destination = '\0';
		return false;
	}
	if (*p == '\0') *destination = '\0';
	return true;
}

bool TextAssistant::AreSimilar(const wchar_t* text1, const wchar_t* text2)
{
	const int len1 = (int)wcslen(text1);
	const int len2 = (int)wcslen(text2);
	//_________________________________________ Easy cases
	if (len1 == 0) return false;
	if (len2 == 0) return false;
	//
	register wchar_t *p = (wchar_t*)text1;
	register wchar_t *q = (wchar_t*)text2;
	register int count = 0;
	const double len = MINIMUM(len1, len2);
	//________________________________________ Similarity at the beginning
	for( ; *p != '\0' && *q != '\0'; p++, q++)
	{
		if (*p == *q)
		{
			count++;
			continue;
		}
		break;
	}
	double similarity = count/len;
	if (similarity > 0.5) return true;
	//________________________________________ Similarity at the end
	count = 0;
	p = (wchar_t*)(text1+len1);
	q = (wchar_t*)(text2+len2);
	for( ; p != text1 && q != text2; p--, q--)
	{
		if (*p == *q)
		{
			count++;
			continue;
		}
		break;
	}
	similarity = count/len;
	if (similarity > 0.5) return true;
	return false;
}

bool TextAssistant::AreSimilar(const wstring& text1, const wstring& text2)
{
	const int len1 = (int)text1.length();
	const int len2 = (int)text2.length();
	//_________________________________________ Easy cases
	if (len1 == 0) return false;
	if (len2 == 0) return false;
	//
	register int i1;
	register int i2;
	register int count = 0;
	const double len = MINIMUM(len1, len2);
	//________________________________________ Similarity at the beginning
	for(i1= 0, i2 = 0; i1 < len1 && i2 < len2; i1++, i2++)
	{
		if (text1[i1] == text2[i2])
		{
			count++;
			continue;
		}
		break;
	}
	double similarity = count/len;
	if (similarity > 0.5) return true;
	//________________________________________ Similarity at the end
	count = 0;
	for(i1 = len1-1, i2 = len2-1; i1 >= 0 && i2 >= 0; i1--, i2--)
	{
		if (text1[i1] == text2[i2])
		{
			count++;
			continue;
		}
		break;
	}
	similarity = count/len;
	if (similarity > 0.5) return true;
	return false;
}

bool TextAssistant::ExtractFileName(const wchar_t* input, bool keepFileExt, wchar_t * buffer, int bufferSize)
{
	buffer[0] = '\0';
	const int len = (int)wcslen(input);
	if (len < 4 ) return false;
	int i, j;
	int position = -1;

	//_____________________________ Find last back slash
	for(i = len-1; i>=0; i--)
	{
		if (input[i] == '\\')
		{
			position = i;
			break;
		}
	}
	//if (position <= 0)
	//{
	//	// Therea are not any back slashes
	//	position = -1;
	//}
	//_____________________________ Copy Result
	for(i = position+1, j = 0; i<len && j<bufferSize; i++, j++)
	{
		buffer[j] = input[i];
		if (keepFileExt ==false)
		{
			if (buffer[j] == '.')
			{
				buffer[j] = '\0';
				return true;
			}
		}
	}
	if (i == len && j < bufferSize-1)
	{
		buffer[j] = '\0';
		return true;
	}
	buffer[bufferSize-1] = '\0';
	return false;
}

bool TextAssistant::SeparateFilePathAndFilename(const wchar_t* input, wstring& out_path, wstring& out_filename)
{
	out_path.clear();
	out_filename.clear();
	//
	const int len = (int)wcslen(input);
	if (len < 4) return false;
	int i;
	int position = -1;

	//_____________________________ Find last back slash
	for (i = len-1; i >= 0; i--)
	{
		if (input[i] == '\\')
		{
			position = i;
			break;
		}
	}
	//_____________________________ file without a path
	if (position <= 0)
	{
		out_filename = input;
		return true;
	}
	//_____________________________ path
	out_path.reserve(position-1);
	for(i = 0; i < position; i++)
	{
		out_path.push_back(input[i]);
	}
	//_____________________________ Copy Result
	out_filename.reserve(len - position);
	for (i = position+1; i < len; i++)
	{
		out_filename.push_back(input[i]);
	}
	return true;
}

bool TextAssistant::ExtractFileName(const wchar_t* input, bool keepFileExt, wstring& output)
{
	output.clear();
	const int len = (int)wcslen(input);
	if (len < 4 ) return false;
	int i;
	int position = -1;

	//_____________________________ Find last back slash
	for(i = len-1;  i>= 0; i--)
	{
		if (input[i] == '\\')
		{
			position = i;
			break;
		}
	}
	//_____________________________ Copy Result
	for(i = position+1; i  < len; i++)
	{
		if (keepFileExt == true)
		{
			output.push_back(input[i]);
		}
		else
		{
			if (input[i] == '.')
			{
				return true;
			}
			else
			{
				output.push_back(input[i]);
			}
		}
	}
	return true;
}

bool TextAssistant::ExtractFilePath(const wchar_t* input, wstring& output)
{
	output.clear();
	const int len = (int)wcslen(input);
	if (len < 5) return false;
	int i;
	int position = -1;
	//_____________________________ Find last back slash
	for (i = 0; i<len; i++)
	{
		if (input[i] == '\\') position = i;
	}
	if (position <= 0) return false;
	//_____________________________ Copy Result
	for (i = 0; i<len; i++)
	{
		output+= input[i];
		if (i == position-1) return true;
	}
	return true;
}

bool TextAssistant::ExtractFilePath(const wchar_t* input, wchar_t * buffer, int bufferSize)
{
	const int len = (int)wcslen(input);
	buffer[0] = '\0';
	if (len < 5 ) return false;
	int i;
	int position = -1;
	//_____________________________ Find last back slash
	for(i = 0; i<len; i++)
	{
		if (input[i] == '\\') position = i;
	}
	if (position <= 0) return false;
	//_____________________________ Copy Result
	for(i = 0; i<len && i<bufferSize; i++)
	{
		buffer[i] = input[i];
		if (i == position)
		{
			buffer[i] = '\0';
			return true;
		}
	}
	buffer[bufferSize-1] = '\0';
	return false;
}

int TextAssistant::GetTokens(const wchar_t* input, wchar_t separator, vector<wstring>& out_tokens)
{
	const wchar_t* p;
	wstring token;
	for (p = input; *p != '\0'; p++)
	{
		if (*p == separator)
		{
			out_tokens.push_back(token);
			token.clear();
		}
		else
		{
			token += *p;
		}
	}
	if (token.empty() == false) out_tokens.push_back(token);
	return (int)out_tokens.size();
}

void TextAssistant::GetStopWordsInEnglish(set<wstring>& output)
{
	const wchar_t* data[] = { L"a", L"about", L"above", L"across", L"after", L"afterwards", L"again", L"against", L"all", L"almost", L"alone", L"along",
		L"already", L"also", L"although", L"always", L"am", L"among", L"amongst", L"amoungst", L"amount", L"an", L"and",
		L"another", L"any", L"anyhow", L"anyone", L"anything", L"anyway", L"anywhere", L"are", L"around", L"as", L"at",
		L"back", L"be", L"became", L"because", L"become", L"becomes", L"becoming", L"been", L"before", L"beforehand", L"behind",
		L"being", L"below", L"beside", L"besides", L"between", L"beyond", L"bill", L"both", L"bottom", L"but", L"by",
		L"call", L"can", L"cannot", L"cant", L"co", L"computer", L"con", L"could", L"couldnt", L"cry", L"de",
		L"describe", L"detail", L"do", L"done", L"down", L"due", L"during", L"each", L"eg", L"eight", L"either",
		L"eleven", L"else", L"elsewhere", L"empty", L"enough", L"etc", L"even", L"ever", L"every", L"everyone", L"everything",
		L"everywhere", L"except", L"few", L"fifteen", L"fify", L"fill", L"find", L"fire", L"first", L"five", L"for",
		L"former", L"formerly", L"forty", L"found", L"four", L"from", L"front", L"full", L"further", L"get", L"give",
		L"go", L"had", L"has", L"hasnt", L"have", L"he", L"hence", L"her", L"here", L"hereafter", L"hereby",
		L"herein", L"hereupon", L"hers", L"herse", L"him", L"himse", L"his", L"how", L"however", L"hundred", L"i",
		L"ie", L"if", L"in", L"inc", L"indeed", L"interest", L"into", L"is", L"it", L"its", L"itse",
		L"keep", L"last", L"latter", L"latterly", L"least", L"less", L"ltd", L"made", L"many", L"may", L"me",
		L"meanwhile", L"might", L"mill", L"mine", L"more", L"moreover", L"most", L"mostly", L"move", L"much", L"must",
		L"my", L"myse", L"name", L"namely", L"neither", L"never", L"nevertheless", L"next", L"nine", L"no", L"nobody",
		L"none", L"noone", L"nor", L"not", L"nothing", L"now", L"nowhere", L"of", L"off", L"often", L"on",
		L"once", L"one", L"only", L"onto", L"or", L"other", L"others", L"otherwise", L"our", L"ours", L"ourselves",
		L"out", L"over", L"own", L"part", L"per", L"perhaps", L"please", L"put", L"rather", L"re", L"same",
		L"see", L"seem", L"seemed", L"seeming", L"seems", L"serious", L"several", L"she", L"should", L"show", L"side",
		L"since", L"sincere", L"six", L"sixty", L"so", L"some", L"somehow", L"someone", L"something", L"sometime", L"sometimes",
		L"somewhere", L"still", L"such", L"system", L"take", L"ten", L"than", L"that", L"the", L"their", L"them",
		L"themselves", L"then", L"thence", L"there", L"thereafter", L"thereby", L"therefore", L"therein", L"thereupon", L"these", L"they",
		L"thick", L"thin", L"third", L"this", L"those", L"though", L"three", L"through", L"throughout", L"thru", L"thus",
		L"to", L"together", L"too", L"top", L"toward", L"towards", L"twelve", L"twenty", L"two", L"un", L"under",
		L"until", L"up", L"upon", L"us", L"very", L"via", L"was", L"we", L"well", L"were", L"what",
		L"whatever", L"when", L"whence", L"whenever", L"where", L"whereafter", L"whereas", L"whereby", L"wherein", L"whereupon", L"wherever",
		L"whether", L"which", L"while", L"whither", L"who", L"whoever", L"whole", L"whom", L"whose", L"why", L"will",
		L"with", L"within", L"without", L"would", L"yet", L"you", L"your", L"yours", L"yourself", L"yourselves" };
	set<wstring>::iterator p = output.begin();
	for (int i = 0; i < 319; i++)
	{
		if (i == 0)
		{
			output.insert(data[i]);
		}
		else
		{
			p = output.insert(p, data[i]);
		}
	}
}

void TextAssistant::GetStopWordsInSpanish(set<wstring>& output)
{
	const wchar_t* data[] = { L"algún", L"alguna", L"algunas", L"alguno", L"algunos", L"ambos", L"ampleamos", L"ante", L"antes", L"aquel", L"aquellas", L"aquellos",
		L"aqui", L"arriba", L"atras", L"bajo", L"bastante", L"bien", L"cada", L"cierta", L"ciertas", L"cierto", L"ciertos",
		L"como", L"con", L"conseguimos", L"conseguir", L"consigo", L"consigue", L"consiguen", L"consigues", L"cual", L"cuando", L"dentro",
		L"desde", L"donde", L"dos", L"el", L"ellas", L"ellos", L"empleais", L"emplean", L"emplear", L"empleas", L"empleo",
		L"en", L"encima", L"entonces", L"entre", L"era", L"eramos", L"eran", L"eras", L"eres", L"es", L"esta",
		L"estaba", L"estado", L"estais", L"estamos", L"estan", L"estoy", L"fin", L"fue", L"fueron", L"fui", L"fuimos",
		L"gueno", L"ha", L"hace", L"haceis", L"hacemos", L"hacen", L"hacer", L"haces", L"hago", L"incluso", L"intenta",
		L"intentais", L"intentamos", L"intentan", L"intentar", L"intentas", L"intento", L"ir", L"la", L"largo", L"las", L"lo",
		L"los", L"mientras", L"mio", L"modo", L"muchos", L"muy", L"nos", L"nosotros", L"otro", L"para", L"pero",
		L"podeis", L"podemos", L"poder", L"podria", L"podriais", L"podriamos", L"podrian", L"podrias", L"por", L"por qué", L"porque",
		L"primero", L"puede", L"pueden", L"puedo", L"quien", L"sabe", L"sabeis", L"sabemos", L"saben", L"saber", L"sabes",
		L"ser", L"si", L"siendo", L"sin", L"sobre", L"sois", L"solamente", L"solo", L"somos", L"soy", L"su",
		L"sus", L"también", L"teneis", L"tenemos", L"tener", L"tengo", L"tiempo", L"tiene", L"tienen", L"todo", L"trabaja",
		L"trabajais", L"trabajamos", L"trabajan", L"trabajar", L"trabajas", L"trabajo", L"tras", L"tuyo", L"ultimo", L"un", L"una",
		L"unas", L"uno", L"unos", L"usa", L"usais", L"usamos", L"usan", L"usar", L"usas", L"uso", L"va",
		L"vais", L"valor", L"vamos", L"van", L"vaya", L"verdad", L"verdadera", L"verdadero", L"vosotras", L"vosotros", L"voy",
		L"yo " };
	set<wstring>::iterator p = output.begin();
	for (int i = 0; i < 178; i++)
	{
		if (i == 0)
		{
			output.insert(data[i]);
		}
		else
		{
			p = output.insert(p, data[i]);
		}
	}
}

void TextAssistant::GetWordList(const wchar_t* folder, const wchar_t* filter, int textEncoding, set<wstring>& output)
{
	vector<Sys::FileInfo> fileList;
	const int count = Sys::FileDirectory::GetFileListRecursive(folder, filter, fileList);
	if (count == 0) return;
	vector<Sys::FileInfo>::iterator p = fileList.begin();
	vector<Sys::FileInfo>::const_iterator listEnd = fileList.end();
	string content;
	wstring wcontent;
	wstring filename;
	for (; p != listEnd; p++)
	{
		filename = p->path;
		filename += L"\\";
		filename += p->findData.name;
		//
		if (textEncoding == SYS_GETWORDLIST_ASCII)
		{
			Sys::FileAssistant::TextLoad(filename, content);
			Sys::Convert::StringToWstring(content, wcontent);
		}
		else if (textEncoding == SYS_GETWORDLIST_UNICODE)
		{
			Sys::FileAssistant::TextLoad(filename, wcontent);
		}
		else if (textEncoding == SYS_GETWORDLIST_UTF8)
		{
			Sys::FileAssistant::TextLoad(filename, content);
			Sys::Convert::UTF8ToWstring(content, wcontent);
		}
		Sys::TextAssistant::ToLower(wcontent);
		Sys::TextAssistant::GetWordList(wcontent.c_str(), output);
	}
}

void TextAssistant::GetWordList(const wchar_t* input, set<wstring>& output)
{
	const size_t len = wcslen(input);
	wchar_t buffer[64];
	size_t i = 0, j = 0;
	for (i = 0; i < len; i++)
	{
		if (j == 0 && Sys::TextAssistant::IsSeparator(input[i]) == true) continue;
		if (Sys::TextAssistant::IsSeparator(input[i]) == true || j == 63)
		{
			//_________________________ insert word
			buffer[j] = '\0';
			if (wcslen(buffer) != 0) output.insert(buffer);
			j = 0;
		}
		else
		{
			//________________________ keep copying word
			buffer[j++] = input[i];
		}
	}
}

void TextAssistant::GetWordList(const wchar_t* input, vector<wstring>& output)
{
	const size_t len = wcslen(input);
	wchar_t buffer[64];
	size_t i = 0, j = 0;
	for (i = 0; i < len; i++)
	{
		if (Sys::TextAssistant::IsSeparator(input[i]) == true || j == 63)
		{
			//_________________________ insert word
			buffer[j] = '\0';
			if (wcslen(buffer) != 0) output.push_back(buffer);
			j = 0;
		}
		else
		{
			//________________________ keep copying word
			buffer[j++] = input[i];
		}
	}
}

//_____________________________________________________________________ Sys::String
//_____________________________________________________________________ Sys::Wstring

////_____________________________________________________________________ Sys::StringCompare
//StringCompare::StringCompare()
//{
//	int result;
//	for (unsigned char i = 0; i < 256; i++)
//	{
//		data[i] = Sys::TextAssistant::StringCompareWithAccents(i);
//	}
//}
//
//StringCompare::~StringCompare()
//{
//}
//
//int StringCompare::Compare(const unsigned char* string1, const unsigned char* string2)
//{
//	const unsigned char* s1;
//	const unsigned char* s2;
//	unsigned int d1, d2;
//	for(s1 = string1, s2 = string2; *s1 != '\0' && *s2 != '\0'; s1++, s2++)
//	{
//		d1 = data[*s1];
//		d2 = data[*s2];
//		if (d1 < d2) return 1;
//		if (d1 > d2) return -1;
//	}
//	if (*s1 == '\0' && *s2 == '\0') return 0;
//	if (*s1 == '\0' && *s2 != '\0') return 1;
//	return -1;
//}
//
//int StringCompare::Compare(const wchar_t* string1, const wchar_t * string2)
//{
//	const wchar_t* s1;
//	const wchar_t* s2;
//	unsigned char d1, d2;
//	for (s1 = string1, s2 = string2; *s1 != '\0' && *s2 != '\0'; s1++, s2++)
//	{
//		d1 = data[*s1];
//		d2 = data[*s2];
//		if (d1 < d2) return 1;
//		if (d1 > d2) return -1;
//	}
//	if (*s1 == '\0' && *s2 == '\0') return 0;
//	if (*s1 == '\0' && *s2 != '\0') return 1;
//	return -1;
//}

//_____________________________________________________________________ Sys::PrintLine

//_____________________________________________________________________ SerialAssistant
SerialAssistant::SerialAssistant(void)
{
}

SerialAssistant::~SerialAssistant(void)
{
}

bool SerialAssistant::Save(Sys::IStorer& destination, double source)
{
	int bytes = sizeof(double);
	if (destination.Write(&source, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, double& destination)
{
	int bytes = sizeof(double);
	if (source.Read(&destination, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, int source)
{
	int bytes = sizeof(int);
	if (destination.Write(&source, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, int& destination)
{
	int bytes = sizeof(int);
	if (source.Read(&destination, bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const wstring& source)
{
	const __int32 length = (__int32)source.length();
	int bytes = sizeof(__int32);
	if (destination.Write(&length, bytes)!=bytes) return false;
	//
	bytes = length*sizeof(wchar_t);
	if (destination.Write(source.data(), bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const string& source)
{
	const __int32 length = (__int32)source.length();
	int bytes = sizeof(__int32);
	if (destination.Write(&length, bytes)!=bytes) return false;
	//
	bytes = length;
	if (destination.Write(source.data(), bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, wstring& destination)
{
	__int32 bytes = sizeof(__int32);
	__int32 length = 0;
	if (source.Read(&length, bytes) != bytes) return false;
	//
	destination.resize(length);
	bytes = length*sizeof(wchar_t);
	if (source.Read((void*)destination.data(), bytes)!=bytes) return false;
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, string& destination)
{
	__int32 bytes = sizeof(__int32);
	__int32 length = 0;
	if (source.Read(&length, bytes) != bytes) return false;
	//
	destination.resize(length);
	bytes = length;
	if (source.Read((void*)destination.data(), bytes) != bytes) return false;
	return true;
}

__int32 SerialAssistant::GetByteCount(const wstring& text)
{
	__int32 byteCount = (__int32)sizeof(__int32);
	byteCount += (__int32)(text.length()*sizeof(wchar_t));
	return byteCount;
}

__int32 SerialAssistant::GetByteCount(const string& text)
{
	__int32 byteCount = (__int32)sizeof(__int32);
	byteCount += (__int32)(text.length()*sizeof(char));
	return byteCount;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const MATRIX& source)
{
	const __int32 size = (__int32)source.size();
	__int32 bytes = sizeof(__int32);
	if (destination.Write(&size, bytes)!=bytes) return false;
	for(__int32 i=0; i<size; i++)
	{
		if (Save(destination, source[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const valarray<double>& source)
{
	const __int32 size = (__int32)source.size();
	__int32 bytes = sizeof(__int32);
	if (destination.Write(&size, bytes)!=bytes) return false;
	bytes = sizeof(double);
	double tmp = 0.0;
	for(__int32 i=0; i<size; i++)
	{
		tmp = source[i];
		if (destination.Write(&tmp, bytes)!=bytes) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, MATRIX& destination)
{
	__int32 size = 0;
	__int32 bytes = sizeof(__int32);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);

	for(__int32 i=0; i<size; i++)
	{
		if (Load(source, destination[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, valarray<double>& destination)
{
	__int32 size = 0;
	__int32 bytes = sizeof(__int32);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);
	double tmp = 0.0;
	bytes = sizeof(double);
	for(__int32 i=0; i<size; i++)
	{
		if (source.Read(&tmp, bytes)!=bytes) return false;
		destination[i] = tmp;
	}
	return true;
}

//______________________________complex
bool SerialAssistant::Save(Sys::IStorer& destination, const MATRIXC& source)
{
	const __int32 size = (__int32)source.size();
	__int32 bytes = sizeof(__int32);
	if (destination.Write(&size, bytes)!=bytes) return false;
	for(__int32 i=0; i<size; i++)
	{
		if (Save(destination, source[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Save(Sys::IStorer& destination, const valarray<complex<double> >& source)
{
	const __int32 size = (__int32)source.size();
	__int32 bytes = sizeof(__int32);
	if (destination.Write(&size, bytes)!=bytes) return false;
	bytes = sizeof(complex<double>);
	complex<double> tmp = 0.0;
	for(__int32 i=0; i<size; i++)
	{
		tmp = source[i];
		if (destination.Write(&tmp, bytes)!=bytes) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, MATRIXC& destination)
{
	__int32 size = 0;
	__int32 bytes = sizeof(__int32);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);

	for(__int32 i=0; i<size; i++)
	{
		if (Load(source, destination[i])==false) return false;
	}
	return true;
}

bool SerialAssistant::Load(Sys::IStorer& source, valarray<complex<double> >& destination)
{
	__int32 size = 0;
	__int32 bytes = sizeof(__int32);
	if (source.Read(&size, bytes)!=bytes) return false;
	destination.resize(size);
	complex<double> tmp = 0.0;
	bytes = sizeof(complex<double>);
	for(__int32 i=0; i<size; i++)
	{
		if (source.Read(&tmp, bytes)!=bytes) return false;
		destination[i] = tmp;
	}
	return true;
}

//_____________________________________________________________________ FileAssistant
FileAssistant::FileAssistant(void)
{
}

FileAssistant::~FileAssistant(void)
{
}

bool FileAssistant::DoesFileExist(const wchar_t* filename)
{
	HANDLE hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	const bool exists = (hFile != INVALID_HANDLE_VALUE);
	if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	return exists;
}

bool FileAssistant::DoesFileExist(const wstring& filename)
{
	return Sys::FileAssistant::DoesFileExist(filename.c_str());
}

bool FileAssistant::CreateFileFromResource(HINSTANCE hInstance, int resource_id, const wchar_t* destinationFileName)
{
	HRSRC hRsrc = ::FindResource(hInstance, MAKEINTRESOURCE(resource_id), L"BIN");
	if (hRsrc == NULL) return false;
	HGLOBAL hResource = ::LoadResource(hInstance, hRsrc);
	if (hResource == NULL) return false;
	DWORD dwSize = ::SizeofResource(hInstance, hRsrc);
	unsigned char * dataResource = (unsigned char*)::LockResource(hResource);
	HANDLE hFile = ::CreateFile(destinationFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		::FreeResource(hResource);
		return false;
	}
	DWORD written = 0;
	::WriteFile(hFile, dataResource, dwSize, &written, NULL);
	const bool ok = (written == dwSize);
	if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	::FreeResource(hResource);
	return ok;
}

bool FileAssistant::CreateFileFromResource(HINSTANCE hInstance, int resource_id, const wstring& destinationFileName)
{
	return FileAssistant::CreateFileFromResource(hInstance, resource_id, destinationFileName.c_str());
}

// It returns 1 if the file is UNICODE. It returns 0 if the file is not UNICODE.  It returns -1 if error.
int FileAssistant::IsTextFileUnicode(const wchar_t* filename)
{
	HANDLE hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return -1;
	//
	DWORD highSize;
	DWORD numBytes = ::GetFileSize(hFile, &highSize);
	char* data = new char[numBytes];
	if (data == NULL)
	{
		::CloseHandle(hFile);
		return -1;
	}
	DWORD read;
	if (::ReadFile(hFile, data, numBytes, &read, NULL) == FALSE)
	{
		::CloseHandle(hFile);
		if (data != NULL) delete [] data;
		return -1;
	}
	//_________________________________________________________ Is UNICODE?
	int unicodeTest = IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_REVERSE_SIGNATURE;
	if (IsTextUnicode(data, numBytes, &unicodeTest) == TRUE)
	{
		::CloseHandle(hFile);
		if (data != NULL) delete[] data;
		return 1;
	}
	::CloseHandle(hFile);
	if (data != NULL) delete[] data;
	return 0;
}

int FileAssistant::IsTextFileUnicode(const wstring& filename)
{
	return Sys::FileAssistant::IsTextFileUnicode(filename.c_str());
}

bool FileAssistant::CreateEmptyZipFile(const wchar_t* filename)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	//______________________________ Write Header
	BYTE zipHeader[] = {80, 75, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	return (file.Write(zipHeader, sizeof(zipHeader)) != 0);
}

bool FileAssistant::CreateEmptyZipFile(const wstring& filename)
{
	return CreateEmptyZipFile(filename.c_str());
}

bool FileAssistant::ZipFile(const wchar_t* inputFileName, const wchar_t* outputFileName)
{
	Com::Boot boot; // CoInitialize and CoUninitalize
	//___________________________________________________________ Convert to _variant_t
	_variant_t var_sourceFile(inputFileName);
	_variant_t var_zipFile(outputFileName);
	//___________________________________________________________ We create an empty zip file
	if (Sys::FileAssistant::CreateEmptyZipFile(outputFileName) == false) return false;

	IShellDispatchPtr shell;
	FolderPtr destinationFile = NULL;
	_variant_t copyOptions = FOF_NO_UI;// Do not display User Interface(VT_I4, FOF_NO_UI);
	HRESULT hr;

	try
	{
		//___________________________________________________________ Get Shell
		hr = CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER, IID_IShellDispatch, (void **)&shell);
		if (FAILED(hr)) return false;
		//___________________________________________________________ Set destination file
		hr = shell->NameSpace(var_zipFile, &destinationFile);
		if (FAILED(hr)) return false;
		//___________________________________________________________ We add the file to the zip file
		hr = destinationFile->CopyHere(var_sourceFile, copyOptions);
		if (FAILED(hr)) return false;
		if (hr == S_FALSE) return false;
		//___________________________________________________________ Wait for the copy thread to complete
		Sleep(1000);
	}
	catch(_com_error error)
	{
		return false;
	}	
	return true;
}

bool FileAssistant::ZipFile(const wstring& inputFileName, const wstring& outputFileName)
{
	return ZipFile(inputFileName.c_str(), outputFileName.c_str());
}

bool FileAssistant::ZipFolder(const wchar_t* inputFolderName, const wchar_t* outputFileName)
{
	Com::Boot boot; // CoInitialize and CoUninitalize
	//___________________________________________________________ Convert to _variant_t
	_variant_t var_sourceFolder(inputFolderName);
	_variant_t var_zipFile(outputFileName);
	//___________________________________________________________ We create an empty zip file
	if (Sys::FileAssistant::CreateEmptyZipFile(outputFileName) == false) return false;

	IShellDispatchPtr shell;
	FolderPtr folderSource = NULL;
	FolderPtr folderDestination = NULL;
	FolderItemsPtr folderItems = NULL;
	_variant_t copyOptions = FOF_NO_UI;// Do not display User Interface(VT_I4, FOF_NO_UI);
	HRESULT hr;

	try
	{
		//___________________________________________________________ Get Shell
		hr = CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER, IID_IShellDispatch, (void **)&shell);
		if (FAILED(hr)) return false;
		//___________________________________________________________ Set destination file
		hr = shell->NameSpace(var_zipFile, &folderDestination);
		if (FAILED(hr)) return false;
		//___________________________________________________________ Set source folder
		hr = shell->NameSpace(var_sourceFolder, &folderSource);
		if (FAILED(hr)) return false;
		//___________________________________________________________ Get the items in the folder
		folderSource->Items(&folderItems);
		//___________________________________________________________ We add the files to the zip file
		_variant_t var_folderItems((IDispatch*)folderItems, true);
		hr = folderDestination->CopyHere(var_folderItems, copyOptions);
		if (FAILED(hr)) return false;
		//___________________________________________________________ Wait for the copy thread to complete
		Sleep(1000);
	}
	catch(_com_error error)
	{
		return false;
	}	
	return true;
}

bool FileAssistant::ZipFolder(const wstring& inputFolderName, const wstring& outputFileName)
{
	return ZipFolder(inputFolderName.c_str(), outputFileName.c_str());
}

bool FileAssistant::Save(const wchar_t* filename, const wstring& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const wstring& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Save(const wchar_t* filename, const string& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const string& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Load(const wchar_t* filename, wstring& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, wstring& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::Load(const wchar_t* filename, string& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, string& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::TextSave(const wchar_t* filename, const wstring& input, bool writeOrderByte)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int bytes = (int)(input.length()*sizeof(wchar_t));
	if (bytes<=0) return true;
	if (writeOrderByte)
	{
		WORD wByteOrderMark = 0xFEFF;
		if (file.Write(&wByteOrderMark, sizeof(WORD))!=sizeof(WORD)) return false;
	}
	if (file.Write((void*)input.data(), bytes) != bytes) return false;
	return true;
}

bool FileAssistant::TextSave(const wstring& filename, const wstring& input, bool writeOrderByte)
{
	return TextSave(filename.c_str(), input, writeOrderByte);
}

bool FileAssistant::TextSave(const wchar_t* filename, const string& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int bytes = (int)input.length()*sizeof(char);
	if (bytes<=0) return true;
	if (file.Write((void*)input.data(), bytes) != bytes) return false;
	return true;
}

bool FileAssistant::TextSave(const wstring& filename, const string& input)
{
	return TextSave(filename.c_str(), input);
}

bool FileAssistant::TextLoad(const wchar_t* filename, wstring& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false)
	{
		output.clear();
		return false;
	}
	const int bytes = (int)file.GetSizeInBytes();
	if (bytes <= 0)
	{
		output.clear();
		return true;
	}
	output.resize(bytes/sizeof(wchar_t));
	if (file.Read((void*)output.data(), bytes) != bytes) return false;
	return true;
}
bool FileAssistant::TextLoad(const wstring& filename, wstring& output)
{
	return TextLoad(filename.c_str(), output);
}

bool FileAssistant::TextLoad(const wchar_t* filename, string& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false)
	{
		output.clear();
		return false;
	}
	const int bytes = (int)file.GetSizeInBytes();
	if (bytes <= 0)
	{
		output.clear();
		return true;
	}
	output.resize(bytes/sizeof(char));
	if (file.Read((void*)output.data(), bytes) != bytes) return false;
	return true;
}

bool FileAssistant::TextLoad(const wstring& filename, string& output)
{
	return TextLoad(filename.c_str(), output);
}

bool FileAssistant::Save(const wchar_t* filename, const MATRIX& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const MATRIX& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Save(const wchar_t* filename, const valarray<double>& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const valarray<double>& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Load(const wchar_t* filename, MATRIX& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, MATRIX& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::Load(const wchar_t* filename, valarray<double>& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, valarray<double>& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::CsvSave(const wchar_t* filename, const MATRIX& input, const char* format)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int rows = (int)input.size();
	if (rows<=0) return true;
	const int cols = (int)input[0].size();
	int i, j;
	char text[64];
	int bytes = 0;
	for(i = 0; i<rows; i++)
	{
		if (format == NULL)
		{
			for(j= 0; j<cols; j++)
			{
				if (j==cols-1)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g", input[i][j]);
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i][j]);
				}
				if (file.Write(text, bytes)!=bytes) return false;
			}
		}
		else
		{
			for(j= 0; j<cols; j++)
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, format, input[i][j]);
				if (file.Write(text, bytes)!=bytes) return false;
				//
				if (j != cols-1) if (file.Write(L", ", bytes)!=bytes) return false; 
			}
		}
		if (i != rows-1)
		{
			const char* terminator = "\r\n";
			bytes = 2*sizeof(char);
			if (file.Write(terminator, bytes)!=bytes) return false;
		}
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, const MATRIX& input, const char* format)
{
	return Sys::FileAssistant::CsvSave(filename.c_str(), input, format);
}

bool FileAssistant::CsvSave(const wchar_t* filename, const MATRIX& input)
{
	return Sys::FileAssistant::CsvSave(filename, input, NULL);
}

bool FileAssistant::CsvSave(const wstring& filename, const MATRIX& input)
{
	return CsvSave(filename.c_str(), input);
}

bool FileAssistant::CsvSave(const wchar_t* filename, const valarray<double>& input, bool isRow)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int len = (int)input.size();
	if (len<=0) return true;
	char text[64];
	int bytes = 0;
	int i = 0;
	if (isRow == true)
	{
		for(i = 0; i<len; i++)
		{
			if (i==len-1)
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
			}
			else
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g, ", input[i]);
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
	}
	else
	{
		for(i = 0; i<len; i++)
		{
			if (i==len-1)
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g", input[i]);
			}
			else
			{
				bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g\r\n", input[i]);
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, const valarray<double>& input, bool isRow)
{
	return CsvSave(filename.c_str(), input, isRow);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, MATRIX& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = (int)file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToMatrix(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, MATRIX& output)
{
	return CsvLoad(filename.c_str(), output);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, valarray<double>& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = (int)file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToVector(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, valarray<double>& output)
{
	return CsvLoad(filename.c_str(), output);
}

bool FileAssistant::CsvIsComplex(const wchar_t* filename) // Returns true when the data in the CSV file is complex
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = (int)file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	//________________________________________ Does the file has: i, j, I, or J?
	size_t npos = data.find("i");
	if (npos != string::npos) return true;
	npos = data.find("j");
	if (npos != string::npos) return true;
	npos = data.find("I");
	if (npos != string::npos) return true;
	npos = data.find("J");
	if (npos != string::npos) return true;
	return false;
}

bool FileAssistant::CsvIsComplex(const wstring& filename) // Returns true when the data in the CSV file is complex
{
	return CsvIsComplex(filename.c_str());
}

//_________________________________________ complex
bool FileAssistant::Save(const wchar_t* filename, const MATRIXC& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, const MATRIXC& input)
{
	return Save(filename.c_str(), input);
}

bool FileAssistant::Save(const wchar_t* filename, const valarray<complex<double> >& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Save(const wstring& filename, valarray<complex<double> >& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename.c_str())==false) return false;
	return Sys::SerialAssistant::Save(file, input);
}

bool FileAssistant::Load(const wchar_t* filename, MATRIXC& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, MATRIXC& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::Load(const wchar_t* filename, valarray<complex<double> >& output)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Sys::SerialAssistant::Load(file, output);
}

bool FileAssistant::Load(const wstring& filename, valarray<complex<double> >& output)
{
	return Load(filename.c_str(), output);
}

bool FileAssistant::CsvSave(const wchar_t* filename, const MATRIXC& input)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int rows = (int)input.size();
	if (rows<=0) return true;
	const int cols = (int)input[0].size();
	int i, j;
	char text[64];
	int bytes = 0;
	for(i = 0; i<rows; i++)
	{
		for(j= 0; j<cols; j++)
		{
			if (j==cols-1)
			{
				if (input[i][j].imag()==0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g", input[i][j].real());
				}
				else if (input[i][j].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g+%gi", input[i][j].real(), input[i][j].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g-%gi", input[i][j].real(), -input[i][j].imag());
				}
			}
			else
			{
				if (input[i][j].imag()==0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g,", input[i][j].real());
				}
				else if (input[i][j].imag()>0)
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g+%gi, ", input[i][j].real(), input[i][j].imag());
				}
				else
				{
					bytes = sizeof(char) * _snprintf_s(text, 64, _TRUNCATE, "%g-%gi, ", input[i][j].real(), -input[i][j].imag());
				}
			}
			if (file.Write(text, bytes)!=bytes) return false;
		}
		if (i!=rows-1)
		{
			const char * terminator = "\r\n";
			bytes = 2*sizeof(char);
			if (file.Write(terminator, bytes)!=bytes) return false;
		}
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, const MATRIXC& input)
{
	return CsvSave(filename.c_str(), input);
}

bool FileAssistant::CsvSave(const wchar_t* filename, valarray<complex<double> >& input, bool isRow)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	const int len = (int)input.size();
	if (len<=0) return true;
	char text[64];
	char separator[3];
	int bytes = 0;
	int i = 0;

	if (isRow == true)
	{
		separator[0] = ',';
		separator[1] = ' ';
	}
	else
	{
		separator[0] = '\r';
		separator[1] = '\n';
	}
	separator[2] = '\0';
	for(int i = 0; i < len; i++)
	{
		bytes = Sys::Convert::ToString(input[i], text, 64, false);
		if (file.Write(text, bytes) != bytes) return false;
		if (i != len-1)
		{
			bytes = 2*sizeof(char);
			if (file.Write(separator, bytes) != bytes) return false;
		}	
	}
	return true;
}

bool FileAssistant::CsvSave(const wstring& filename, valarray<complex<double> >& input, bool isRow)
{
	return CsvSave(filename.c_str(), input, isRow);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, MATRIXC& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = (int)file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToMatrix(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, MATRIXC& output)
{
	return CsvLoad(filename.c_str(), output);
}

bool FileAssistant::CsvLoad(const wchar_t* filename, valarray<complex<double> >& output)
{
	string data;
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	const int bytes = (int)file.GetSizeInBytes();
	data.resize(bytes/sizeof(char));
	if (file.Read((void*)data.data(), bytes)!=bytes) return false;
	Sys::Convert::ToVector(data, output);
	return true;
}

bool FileAssistant::CsvLoad(const wstring& filename, valarray<complex<double> >& output)
{
	return CsvLoad(filename.c_str(), output);
}

bool FileAssistant::DeleteFile(const wchar_t* filename)
{
	wstring text;
	Sys::Format(text, L"\\\\?\\%s", filename);
	::SetFileAttributes(text.c_str(), FILE_ATTRIBUTE_NORMAL);
	return (::DeleteFile(text.c_str()) != 0);
}

bool FileAssistant::DeleteFile(const wstring& filename)
{
	return Sys::FileAssistant::DeleteFile(filename.c_str());
}

// It returns 1, if files are equal
// It returns 0, if files are different
// It returns -1, if error
int FileAssistant::CompareFiles(const wchar_t* filenameA, const wchar_t* filenameB)
{
	Sys::File a, b;
	//_____________________________________________________________________________________________ Open both files
	HANDLE ha = a.Create(filenameA, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	//HANDLE ha = a.Create(filenameA, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (ha == INVALID_HANDLE_VALUE) return -1;
	//
	HANDLE hb = b.Create(filenameB, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	//HANDLE hb = b.Create(filenameB, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hb == INVALID_HANDLE_VALUE) return -1;

	//_____________________________________________________________________________________________ Get the size of each file
	LARGE_INTEGER asize, bsize;
	if (a.GetSize(asize) == false) return -1;
	if (b.GetSize(bsize) == false) return -1;

	//______________________________________________________________________________________________ Are they the same size?
	if (asize.HighPart != bsize.HighPart || asize.LowPart != bsize.LowPart) return 0;
	//_______________________________________________________________________________________________ Buffer Allocation
	const int buffer_size = 64*1024;
	unsigned char * bufferA = new unsigned char[buffer_size];
	if (bufferA == NULL) return -1;
	unsigned char * bufferB = new unsigned char[buffer_size];
	if (bufferB == NULL)
	{
		if (bufferA != NULL) delete [] bufferA;
		return -1;
	}
	//____________________________________________________________________________________________ Read and Compare
	DWORD readA = 0;
	DWORD readB = 0;
	DWORD bytesToRead = sizeof(unsigned char)*buffer_size;
	register int i = 0;
	unsigned char * pa;
	unsigned char * pb;

	//____________________________
	int count;
	int remain;
	const int sizeint = (int)( log((double)sizeof(int)) / log(2.0) );
	register int *ia;
	register int *ib;
	int count4;
	int remain4;
	bool different;
	do
	{
		//________________________________ Read
		::ReadFile(ha, bufferA, bytesToRead, &readA, NULL);
		::ReadFile(hb, bufferB, bytesToRead, &readB, NULL);
		//________________________________ Compare
		if (readA != readB)
		{
			if (bufferA != NULL) delete [] bufferA;
			if (bufferB != NULL) delete [] bufferB;
			return -1;
		}
		//if (::memcmp(bufferA, bufferB, readA) != 0)
		//{
		//	if (bufferA != NULL) delete [] bufferA;
		//	if (bufferB != NULL) delete [] bufferB;
		//	return 0;
		//}

		count = readA >> sizeint; //readA / sizeint;
		remain = readA - (count << sizeint); //readA % sizeint;
		ia = (int*)bufferA;
		ib = (int*)bufferB;
		//___________________________________________
		count4 = count/4;
		remain4 = count%4;
		for(i = 0; i < count4; i++)
		{
			different = (*ia != *ib);
			ia++;
			ib++;
			//
			different |= (*ia != *ib);
			ia++;
			ib++;
			//
			different |= (*ia != *ib);
			ia++;
			ib++;
			//
			different |= (*ia != *ib);
			ia++;
			ib++;
			//
			if (different == true)
			{
				if (bufferA != NULL) delete [] bufferA;
				if (bufferB != NULL) delete [] bufferB;
				return 0;
			}
		}
		for(i = 0; i < remain4; i++, ia++, ib++)
		{
			if (*ia == *ib) continue;
			//__________________ Files are Different
			if (bufferA != NULL) delete [] bufferA;
			if (bufferB != NULL) delete [] bufferB;
			return 0;
		}
		//for(i = count; i != 0; i--, ia++, ib++)
		//{
		//	if (*ia == *ib) continue;
		//	//__________________ Files are Different
		//	if (bufferA != NULL) delete [] bufferA;
		//	if (bufferB != NULL) delete [] bufferB;
		//	return 0;
		//}
		//__________________________________________ remain
		pa = (unsigned char*)ia;
		pb = (unsigned char*)ib;
		for(i = remain; i != 0; i--, pa++, pb++)
		{
			if (*pa != *pb)
			{
				//__________________ Files are Different
				if (bufferA != NULL) delete [] bufferA;
				if (bufferB != NULL) delete [] bufferB;
				return 0;
			}
		}
	}
	while(readA > 0);
	//____________________________________________________________________________________________ Files are Equal
	if (bufferA != NULL) delete [] bufferA;
	if (bufferB != NULL) delete [] bufferB;
	return 1;
}

// It returns 1, if files are equal
// It returns 0, if files are different
// It returns -1, if error
// There is an error in this functions, in some cases it returns 1, when the files are different
int FileAssistant::CompareFilesIOCP(const wchar_t* filenameA, const wchar_t* filenameB)
{
	LARGE_INTEGER fileSizeA = {0};
	LARGE_INTEGER fileSizeB = {0};
	const int bufferSize = (64 * 1024);
	const ULONG_PTR CK_READA = 0;
	const ULONG_PTR CK_READB = 1;

	try 
	{
		{
			//_________________________________________________________________________________ A
			Sys::File fileA;
			HANDLE hFileA = fileA.Create(filenameA, GENERIC_READ, FILE_SHARE_READ, 
				NULL, OPEN_EXISTING,  FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, NULL);
			if (hFileA == INVALID_HANDLE_VALUE) return -1;
			if (fileA.GetSize(fileSizeA) == false) return -1;
			//
			// Rounds a value down to the nearest multiple of bufferSize
			//fileSizeDestination.QuadPart = ((fileSizeSource.QuadPart / bufferSize) * bufferSize) + (((fileSizeSource.QuadPart % bufferSize) > 0) ? bufferSize : 0);
			//
			//_________________________________________________________________________________ Destination
			Sys::File fileB;
			HANDLE hFileB = fileB.Create(filenameB, GENERIC_READ, FILE_SHARE_READ, 
				NULL, OPEN_EXISTING,  FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, NULL);
			if (hFileB == INVALID_HANDLE_VALUE) return -1;
			if (fileB.GetSize(fileSizeB) == false) return -1;
			//
			if (fileSizeA.HighPart != fileSizeB.HighPart) return 0;
			if (fileSizeA.LowPart != fileSizeB.LowPart) return 0;
			//fileDestination.SetPointer(fileSizeDestination, NULL, FILE_BEGIN);
			//fileDestination.SetEnd();

			//_______________________________ Associate the IOCP with the files
			Mt::IOCport iocp(0);
			iocp.AssociateDevice(hFileA, CK_READA); 
			iocp.AssociateDevice(hFileB, CK_READB);

			Mt::InputOutputRequestX ior[MAX_PENDING_IO_REQS];
			LARGE_INTEGER nextReadOffsetA = { 0 };
			LARGE_INTEGER nextReadOffsetB = { 0 };
			int readsInProgressA  = 0;
			int readsInProgressB = 0;
			//______________________________ Pretend that MAX_PENDING_IO_REQS readings from B have been completed
			for (int i = 0; i < MAX_PENDING_IO_REQS; i++) 
			{
				if (ior[i].AllocBuffer(bufferSize) == false) return -1;
				readsInProgressB++;
				iocp.PostStatus(CK_READB, 0, ior[i]);
			}

			while ((readsInProgressA > 0) || (readsInProgressB > 0)) 
			{
				ULONG_PTR compKey;
				DWORD numBytes;
				Mt::InputOutputRequestX * pior;
				iocp.GetStatus(compKey, numBytes, (OVERLAPPED**) &pior);

				switch (compKey) 
				{
				case CK_READA:  // Read A completed
					readsInProgressA--;
					if (nextReadOffsetB.QuadPart < fileSizeB.QuadPart) 
					{
						pior->bytesA = numBytes;
						pior->ReadB(hFileB, nextReadOffsetB);  // request Read from B (Continues without waiting to be completed)
						readsInProgressB++;
						nextReadOffsetB.QuadPart += bufferSize; // Advance source offset
					}
					break;
				case CK_READB: // Read B completed
					readsInProgressB--;
					if (nextReadOffsetA.QuadPart < fileSizeA.QuadPart) 
					{
						pior->bytesB = numBytes;
						if (pior->bytesA > 0 && pior ->bytesB > 0)
						{
							if (pior->CompareAandB() != 1) return 0;  // Compare buffer content
						}
						pior->ReadA(hFileA, nextReadOffsetA);  // request Read from A  (Continues without waiting to be completed)
						readsInProgressA++;
						nextReadOffsetA.QuadPart += bufferSize; // Advance source offset
					}
					break;
				}
			}
		}
	}
	catch (...) 
	{
	}

	//if (ok == true) 
	//{
	//	Sys::File destination;
	//	HANDLE h = destination.Create(destination_filename, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	//	if (h != INVALID_HANDLE_VALUE)
	//	{
	//		destination.SetPointer(fileSizeSource, NULL, FILE_BEGIN);
	//		destination.SetEnd();
	//	}
	//}
	return 1;
}

bool FileAssistant::CopyFileIOCP(const wchar_t* source_filename, const wchar_t* destination_filename)
{
   bool ok = false;
	LARGE_INTEGER fileSizeSource = {0};
	LARGE_INTEGER fileSizeDestination;
	const int bufferSize = (64 * 1024);
	const ULONG_PTR CK_READ = 0;
	const ULONG_PTR CK_WRITE = 1;

	try 
	{
		{
			//_________________________________________________________________________________ Source
			Sys::File fileSource;
			HANDLE hFileSource = fileSource.Create(source_filename, GENERIC_READ, FILE_SHARE_READ, 
				NULL, OPEN_EXISTING,  FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, NULL);
			if (hFileSource == INVALID_HANDLE_VALUE) return false;
			//
			if (fileSource.GetSize(fileSizeSource) == false) return false;
			//
			// Rounds a value down to the nearest multiple of bufferSize
			fileSizeDestination.QuadPart = ((fileSizeSource.QuadPart / bufferSize) * bufferSize) + (((fileSizeSource.QuadPart % bufferSize) > 0) ? bufferSize : 0);
			//
			//_________________________________________________________________________________ Destination
			Sys::File fileDestination;
			HANDLE hFileDestination = fileDestination.Create(destination_filename, GENERIC_WRITE | FILE_WRITE_ATTRIBUTES, 0, NULL, 
				CREATE_ALWAYS, FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, hFileSource);
			if (hFileDestination == INVALID_HANDLE_VALUE) return false; //goto leave;
			//
			fileDestination.SetPointer(fileSizeDestination, NULL, FILE_BEGIN);
			fileDestination.SetEnd();

			Mt::IOCport iocp(0);
			iocp.AssociateDevice(hFileSource, CK_READ); 
			iocp.AssociateDevice(hFileDestination, CK_WRITE);

			Mt::InputOutputRequest ior[MAX_PENDING_IO_REQS];
			LARGE_INTEGER nextReadOffset = { 0 };
			int readsInProgress  = 0;
			int writesInProgress = 0;

			for (int i = 0; i < MAX_PENDING_IO_REQS; i++) 
			{
				if (ior[i].AllocBuffer(bufferSize) == false) return false;
				writesInProgress++;
				iocp.PostStatus(CK_WRITE, 0, ior[i]);
			}

			while ((readsInProgress > 0) || (writesInProgress > 0)) 
			{
				ULONG_PTR compKey;
				DWORD numBytes;
				Mt::InputOutputRequest * pior;
				iocp.GetStatus(compKey, numBytes, (OVERLAPPED**) &pior);

				switch (compKey) 
				{
				case CK_READ:  // Read completed, write to destination
					readsInProgress--;
					pior->Write(hFileDestination);  // Write to same offset read from source
					writesInProgress++;
					break;

				case CK_WRITE: // Write completed, read from source
					writesInProgress--;
					if (nextReadOffset.QuadPart < fileSizeDestination.QuadPart) 
					{
						pior->Read(hFileSource, nextReadOffset);
						readsInProgress++;
						nextReadOffset.QuadPart += bufferSize; // Advance source offset
					}
					break;
				}
			}
			ok = true;
		}
	}
	catch (...) 
	{
	}

	if (ok == true) 
	{
		Sys::File destination;
		HANDLE h = destination.Create(destination_filename, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (h != INVALID_HANDLE_VALUE)
		{
			destination.SetPointer(fileSizeSource, NULL, FILE_BEGIN);
			destination.SetEnd();
		}
	}
	return ok;
}

bool FileAssistant::CopyFile(const wstring& source_filename, const wstring& destination_filename)
{
	return Sys::FileAssistant::CopyFile(source_filename.c_str(), destination_filename.c_str());
}

bool FileAssistant::CopyFile(const wchar_t* source_filename, const wchar_t* destination_filename)
{
	::SetFileAttributes(destination_filename, FILE_ATTRIBUTE_NORMAL); // If the destination file exists, be sure we can write it
	//wchar_t a[1024], b[1024];
	//_sntprintf_s(a, 1024, _TRUNCATE, L"\\\\?\\%s", source_filename);
	//_sntprintf_s(b, 1024, _TRUNCATE, L"\\\\?\\%s", destination_filename);
	//::CopyFile(a, b, FALSE);
	//return true;
	LARGE_INTEGER fileSizeSource;
	LARGE_INTEGER ini = {0};
	//_________________________________________________________________________________ Source
	Sys::File fileSource;
	HANDLE hFileSource = fileSource.Create(source_filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	//HANDLE hFileSource = fileSource.Create(source_filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFileSource == INVALID_HANDLE_VALUE) return false;
	//
	if (fileSource.GetSize(fileSizeSource) == false) return false;
	//
	//_________________________________________________________________________________ Destination
	Sys::File fileDestination;
	HANDLE hFileDestination = fileDestination.Create(destination_filename, GENERIC_WRITE | FILE_WRITE_ATTRIBUTES, 0, NULL, CREATE_ALWAYS, 0, NULL);//hFileSource);
	if (hFileDestination == INVALID_HANDLE_VALUE) return false;
	fileDestination.SetPointer(fileSizeSource, NULL, FILE_BEGIN);
	fileDestination.SetEnd(); // Set the end of file so that blocks are next to each other
	fileDestination.SetPointer(ini, NULL, FILE_BEGIN); // Restore the pointer to the begin
	//_________________________________________________________________________________ Create Buffer
	const DWORD bufferSize = (64 * 1024);
	unsigned char *buffer = new unsigned char[bufferSize];
	if (buffer == NULL) return false;
	DWORD bytesRead;
	DWORD bytesWritten;

	::ReadFile(hFileSource, buffer, bufferSize, &bytesRead, NULL);
	for( ; bytesRead > 0; ::ReadFile(hFileSource, buffer, bufferSize, &bytesRead, NULL))
	{
		::WriteFile(hFileDestination, buffer, bytesRead, &bytesWritten, NULL);
		if (bytesWritten != bytesRead)
		{
			if (buffer != NULL) delete [] buffer; 
			return false;
		}
	}
	
	//____________________________________________________________________________________________ Make the time_write equal
	FILETIME create;
	FILETIME access;
	FILETIME write;
	//
	fileSource.GetTime(create, access, write);
	fileSource.Close();
	//
	fileDestination.SetTime(create, access, write);
	fileDestination.Close();
	//
	if (buffer != NULL) delete [] buffer; 
	return true;

	//FileTimeToSystemTime
	//SystemTimeToTzSpecificLocalTime
	//SystemTimeToFileTime

	//	Return value Description 
//-1 First file time is earlier than second file time.
//0 First file time is equal to second file time.
//1 First file time is later than second file time.
// 
	//	CompareFileTime 

	// SetFileSize How to set a file size

	//if (::CompareFileTime(&create, &create2) != 0)
}

bool FileAssistant::FindFilePath(HINSTANCE hInstance, const wchar_t* foldername, const wchar_t* filename, const wchar_t* fixed_location, wstring& out_path)
{
	wstring wFilename;
	Sys::Information::getProgramFileName(hInstance, wFilename);
	//::MessageBox(NULL, wFilename.c_str(), L"1", MB_OK);
	Sys::TextAssistant::ExtractFilePath(wFilename.c_str(), out_path);
	//::MessageBox(NULL, out_path.c_str(), L"2", MB_OK);
	//___________________________________________________________________ Try at ExecutableFolder
	wFilename = out_path;
	wFilename += L"\\";
	wFilename += filename;
	//::MessageBox(NULL, wFilename.c_str(), L"3", MB_OK);
	if (Sys::FileAssistant::DoesFileExist(wFilename) == true) return true;
	//___________________________________________________________________ Try at ExecutableFolder\foldername
	if (foldername != NULL)
	{
		out_path += L"\\";
		out_path += foldername;
		wFilename = out_path;
		wFilename += L"\\";
		wFilename += filename;
		//::MessageBox(NULL, wFilename.c_str(), L"4", MB_OK);
		if (Sys::FileAssistant::DoesFileExist(wFilename) == true) return true;
	}
	//___________________________________________________________________ Try at Program Files\foldername
	if (foldername != NULL)
	{
		Sys::Information::getProgramFilesPath(out_path);
		out_path += L"\\";
		out_path += foldername;	
		wFilename = out_path;
		wFilename += L"\\";
		wFilename += filename;
		//::MessageBox(NULL, wFilename.c_str(), L"5", MB_OK);
		if (Sys::FileAssistant::DoesFileExist(wFilename) == true) return true;
	}
	//___________________________________________________________________ Try at Current Folder
	Sys::Information::getCurrentDirectory(out_path);
	wFilename =  out_path;
	wFilename += L"\\";
	wFilename += filename;
	//::MessageBox(NULL, wFilename.c_str(), L"6", MB_OK);
	if (Sys::FileAssistant::DoesFileExist(wFilename) == true) return true;
	//___________________________________________________________________ Try in a sub-folder after Current folder
	if (foldername != NULL)
	{
		out_path += L"\\";
		out_path += foldername;
		wFilename = out_path;
		wFilename += L"\\";
		wFilename += filename;
		//::MessageBox(NULL, wFilename.c_str(), L"7", MB_OK);
		if (Sys::FileAssistant::DoesFileExist(wFilename) == true) return true;
	}
	//___________________________________________________________________ Try a fixed location
	out_path = fixed_location;
	wFilename =  out_path;
	wFilename += L"\\";
	wFilename += filename;
	//::MessageBox(NULL, wFilename.c_str(), L"8", MB_OK);
	return Sys::FileAssistant::DoesFileExist(wFilename);
}

//_____________________________________________________________________ DLLibrary
DLLibrary::DLLibrary(void)
{
	hLibrary = NULL;
}

DLLibrary::~DLLibrary(void)
{
	if (hLibrary != NULL) ::FreeLibrary(hLibrary);
}

void DLLibrary::Free(void)
{
	if (hLibrary != NULL)
	{
		::FreeLibrary(hLibrary);
		hLibrary = NULL;
	}
}

HINSTANCE DLLibrary::GetHinstance()
{
	return hLibrary;
}

bool DLLibrary::Load(const wchar_t* dllName)
{
	this->Free();
	hLibrary = ::LoadLibrary(dllName);
	return (hLibrary!=NULL);
}

bool DLLibrary::Load(const wstring& dllName)
{
	this->Free();
	hLibrary = ::LoadLibrary(dllName.c_str());
	return (hLibrary!=NULL);
}

FARPROC DLLibrary::GetProcAddress(LPCSTR functionName)
{
	return ::GetProcAddress(hLibrary, functionName);
}

//_____________________________________________________________________EncryptedFile
EncryptedFile::EncryptedFile(void)
{
	Clear();
}

void EncryptedFile::Clear()
{
	m_bRestore = false;
	m_nKey = 0;
	m_nKeySize = 0;
	m_pszKey = NULL;
}

EncryptedFile::~EncryptedFile(void)
{
}

bool EncryptedFile::Encrypt(LPCTSTR lpOriginalFile, LPCTSTR lpDestinationFile, const char* pszKey)
{
	this->m_bRestore = false;
	return this->Encryption(lpOriginalFile, lpDestinationFile, pszKey);
}

bool EncryptedFile::DeEncrypt(LPCTSTR lpOriginalFile, LPCTSTR lpDestinationFile, const char* pszKey)
{
	this->m_bRestore = true;
	return this->Encryption(lpOriginalFile, lpDestinationFile, pszKey);
}

bool EncryptedFile::Encryption(LPCTSTR lpOriginalFile, LPCTSTR lpDestinationFile, const char* pszKey)
{
	DWORD i=0;
	//BYTE pByte[1];
	DWORD dwRead, dwWritten;
	DWORD dwToBeRead = 1;
	Sys::File fileOriginal;
	Sys::File fileDestination;
	BOOL bReadOk= false;
	BOOL bDone=false;
	BOOL bWrittenOk = false;
	int nCoded = 0;
	char buffer[256];

	m_nKey=0;
	if (pszKey==NULL) return false;
	m_pszKey = (char*)pszKey;
	m_nKeySize = (int)strlen(pszKey);

	if (fileOriginal.CreateForReading(lpOriginalFile))
	{
		if (fileDestination.CreateForWritting(lpDestinationFile))
		{
			for(;;)
			{
				dwToBeRead = 256;
				dwRead = fileOriginal.Read(buffer, dwToBeRead);
				if (dwRead == 0) break;
				for(i=0; i<dwRead; i++) buffer[i] = Code(buffer[i]);
				dwWritten = fileDestination.Write(buffer, dwRead);
				if (dwRead != dwWritten ==0) return false;
			}
		}
	}
	Clear();

	return true;
}

/* You must initialize m_nKey before using Code */
unsigned char EncryptedFile::Code(unsigned char nOneLetter)
{
	int nEncryptedData=nOneLetter;
	int nKey=0;
	int nOffset=DATA_LAST_CODE-DATA_FIRST_CODE+1;

	if ((DATA_FIRST_CODE<=nOneLetter) && (nOneLetter<=DATA_LAST_CODE))
	{
		nKey=m_pszKey[m_nKey];
		if (m_bRestore==false)
		{
			nEncryptedData+=nKey;
			while (nEncryptedData>DATA_LAST_CODE)
				nEncryptedData=nEncryptedData-nOffset;					
		}
		else
		{
			nEncryptedData-=nKey;
			while (nEncryptedData<DATA_FIRST_CODE)
				nEncryptedData=nEncryptedData+nOffset;	
		}
		m_nKey++;
		if (m_nKey>=m_nKeySize)
			m_nKey=0;
	}
	return (unsigned char)nEncryptedData;
}

//_____________________________________________________________________ NamedPipe
NamedPipe::NamedPipe(void)
{
	handle = INVALID_HANDLE_VALUE;
}

// lpName = L"\\\\.\\pipe\\TimeService");
// lpName = L"\\\\ServerName\\pipe\\TimeService");
// nTimeout = 1000 millisec
// nBufferSize = sizeof(struct to move through the pipe)
// You may implement a Server as a Service
bool NamedPipe::CreateServer(const wchar_t * lpName, DWORD nBufferSize, DWORD nTimeout)
{
	Close();
	handle = ::CreateNamedPipe(lpName, 
		PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE, 1, nBufferSize, nBufferSize, nTimeout, NULL);
	return (handle != INVALID_HANDLE_VALUE);
}

NamedPipe::~NamedPipe(void)
{
	Close();
}

bool NamedPipe::IsOpen()
{
	return (handle != INVALID_HANDLE_VALUE);
}

HANDLE NamedPipe::GetHandle()
{
	return handle;
}

bool NamedPipe::Connect()
{
	ZeroMemory(&m_o, sizeof(OVERLAPPED));
	return (::ConnectNamedPipe(handle, &m_o) != 0);
}

bool NamedPipe::Flush()
{
	return (::FlushFileBuffers(handle) != 0);
}

bool NamedPipe::Disconnect()
{
	return (::DisconnectNamedPipe(handle) != 0);
}

void NamedPipe::Close()
{
	if (handle != INVALID_HANDLE_VALUE)
	{
		::CloseHandle(handle);
		handle = INVALID_HANDLE_VALUE;
	}
}

// tienes que pasar un pointer DWORD a lpNumberofBytesWritten 
// nNumberOfBytesToWrite = sizeof(wchar_t)*lstrlen(sz);
bool NamedPipe::Write(LPCVOID lpBuffer, DWORD nNumbOfBytesToWrite, LPDWORD lpNumbOfBytesWritten)
{
	return (::WriteFile(handle, lpBuffer, nNumbOfBytesToWrite, lpNumbOfBytesWritten, NULL) != 0);
}

bool NamedPipe::Read(LPVOID lpBuffer, DWORD nNumbOfBytesToRead, LPDWORD lpNumbOfBytesRead)
{
	return (::ReadFile(handle, lpBuffer, nNumbOfBytesToRead, lpNumbOfBytesRead, NULL) != 0);
}

NamedPipe::operator HANDLE() 
{
	return handle;
}

//_____________________________________________________________________ SvgReader
SvgReader::SvgReader(void)
{
}

SvgReader::~SvgReader(void)
{
}

bool SvgReader::CreateFromFile(const wstring& filename)
{
	Sys::File file;
	string asciiText;
	if (Sys::FileAssistant::TextLoad(filename, asciiText) == false) return false;
	Sys::Convert::StringToWstring(asciiText, svgText);
	return true;
}

void SvgReader::CreateFromText(const wchar_t* svgText)
{
	this->svgText = svgText;
}

// the resource must be a UNICODE resource
bool SvgReader::CreateFromResource(HINSTANCE hInst, int resource_id)
{
	string asciiText;
	if (Sys::TextAssistant::LoadFromResource(hInst, resource_id, asciiText)== false) return false;
	Sys::Convert::StringToWstring(asciiText, svgText);
	return true;
}

bool SvgReader::GetBezierPoints(const wchar_t* svg_id, vector<Sys::Point2D>& out_points)
{
	out_points.clear();
	size_t p = FindSvgObject(L"<path ", L" d=\"", svg_id);
	if (p == 0) return false;
	return GetPoints(p, out_points);
}

bool SvgReader::GetPolylinePoints(const wchar_t* svg_id, vector<Sys::Point2D>& out_points)
{
	out_points.clear();
	size_t p = FindSvgObject(L"<polyline ", L" points=\"", svg_id);
	if (p == 0) return false;
	return GetPoints(p, out_points);
}

bool SvgReader::GetPolygonPoints(const wchar_t* svg_id, vector<Sys::Point2D>& out_points)
{
	out_points.clear();
	size_t p = FindSvgObject(L"<polygon ", L" points=\"", svg_id);
	if (p == 0) return false;
	return GetPoints(p, out_points);
}

size_t SvgReader::FindSvgObject(const wchar_t* type, const wchar_t* beginToken, const wchar_t* svg_id)
{
	size_t begin = 0;
	size_t end = 0;
	wstring token;
	bool found = false;

	do
	{
		begin = svgText.find(type, begin);
		if (begin != std::wstring::npos)
		{
			begin += wcslen(type);
			end = svgText.find(L"/>", begin);
			if (end != std::wstring::npos)// ___________________________ We found <type ...  />
			{
				token = L"id=\"";
				token += svg_id;
				token += L"\"";
				begin = svgText.find(token, begin);
				if (begin != std::wstring::npos)
				{
					if (begin < end) // We found <type id="..."  />
					{
						begin += token.length();
						found = true;
						break;
					}
					else
					{
						begin = end; /// This id belongs to next tag. Go to next tag
					}
				}
			}
			else
			{
				begin = end; // Go to next tag
			}
		}
	}
	while (begin != std::wstring::npos);

	//_______________________________________ Get to the beginToken
	if (beginToken == NULL)
	{
		if (found) return begin;
	}
	else
	{
		if (found)
		{
			begin = svgText.find(beginToken, begin);
			if (begin != std::wstring::npos)
			{
				if (begin < end)
				{
					begin += wcslen(beginToken);
					return begin;
				}
			}
		}
	}
	//_________________________ We get here during an error
	return 0;
}

bool SvgReader::GetPoints(size_t begin, vector<Sys::Point2D>& out_points)
{
	//______________________________________ Find end of Svg Object
	size_t end = svgText.find(L"/>", begin);
	if (end == std::wstring::npos) return false;

	//______________________________________ Get the points
	wchar_t text[32];
	bool isRelative = false;
	bool storePoint = false;
	int k = 0;
	wchar_t c;
	int count = 0;
	Sys::Point2D origin;
	Sys::Point2D point;
	double value;

	for(size_t i = begin; i <= end; i++)
	{
		//if (count == 44)
		//{
		//	int x = 10;
		//	x++;
		//}
		c = svgText[i];
		if (k == 32) k = 0;
		if (c == 'M')
		{
			isRelative = false;
		}
		else if (c == 'm')
		{
			storePoint = true;
			isRelative = true;
		}
		else if (c == 'C')
		{
			isRelative = false;
		}
		else if (c == 'c')
		{
			storePoint = true;
			isRelative = true;
			//
			text[k] = '\0';
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			count++;
		}
		else if (c == 'l')
		{
			storePoint = true;
			isRelative = true;
			//
			text[k] = '\0';
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			count++;
		}
		else if (c == 'z' || c == 'Z') // Close curve
		{
			// Process last point
			text[k] = '\0';
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			break;
		}
		else if (IsNumericValid(c))
		{
			text[k++] = c;
		}
		else
		{
			text[k] = '\0';
			if (k == 0) break;
			k = 0;
			value = _wtof(text);
			ProcessValue(isRelative, value, count, point, origin, storePoint, out_points);
			count++;
		}	
	}
	return (count>0);
}

void SvgReader::ProcessValue(bool isRelative, double value, int count, Sys::Point2D& point, Sys::Point2D& origin, bool& storePoint, vector<Sys::Point2D>& out_points)
{
	if (count%2 == 0)
	{
		point.x = (float)value;
	}
	else
	{
		point.y = (float)value;
		//____________________________________ First point is origin
		if (out_points.size() == 0 && storePoint)
		{
			origin = point;
			out_points.push_back(origin);
			return;
		}
		//____________________________________ Move origin
		if (out_points.size()%3 == 0 && storePoint)
		{
			origin.x += point.x;
			origin.y += point.y;
			out_points.push_back(origin);
			return;
		}
		//____________________________________ Add origin to the point
		if (isRelative && out_points.size()%3 != 0)
		{
			point.x += origin.x;
			point.y += origin.y;
		}
		out_points.push_back(point);
	}
}

bool SvgReader::GetRectangle(const wchar_t* svg_id, Sys::Point2D& out_position, Sys::Point2D& out_size)
{
	//_____________________________________ Clear return value
	out_position.x = 0;
	out_position.y = 0;
	out_size.x = 0;
	out_size.y = 0;
	//
	size_t begin = FindSvgObject(L"<rect ", NULL, svg_id);
	if (begin == 0) return false;

	//______________________________________ Find end of Svg Object
	size_t end = svgText.find(L"/>", begin);
	if (end == std::wstring::npos) return false;

	out_position.x = (float)GetDouble(begin, end, L"x=\"");
	out_position.y = (float)GetDouble(begin, end, L"y=\"");
	out_size.x = (float)GetDouble(begin, end, L"width=\"");
	out_size.y = (float)GetDouble(begin, end, L"height=\"");
	return true;
}

double SvgReader::GetDouble(size_t& begin, size_t end, const wchar_t* key)
{
	begin = svgText.find(key, begin);
	if (begin == std::wstring::npos) return 0.0;
	if (begin > end) return 0.0; // invalid object
	begin += wcslen(key);
	wchar_t text[32];
	wchar_t c;
	int k = 0;
	for(size_t i = begin; i<end; i++)
	{
		if (k >=32) k = 0;
		c = svgText[i];
		if (IsNumericValid(c))
		{
			text[k++] = c;
		}
		else
		{
			text[k] = '\0';
			begin = i;
			return _wtof(text);
		}
	}

	return 0.0;
}

bool SvgReader::IsNumericValid(wchar_t c)
{
	if (c == '.') return true;
	if (c == 'E') return true;
	if (c == 'e') return true;
	if (c == '-') return true;
	if ('0' <= c && c <= '9') return true;
	return false;
}

//_____________________________________________________________________Xml
Xml::Xml(void)
{
	utf_8 = true;
	node_id = 0;
}

Xml::~Xml(void)
{
}

int Xml::GetNode_ID() const
{
	return node_id;
}

void Xml::RefreshNodeIDs()
{
	int id = 0;
	PrivateRefreshNodeID(id);
}

void Xml::PrivateRefreshNodeID(int& id)
{
	//________________________________________ Set node_id
	node_id = id;
	id++;
	//________________________________________ Recursion
	list<Sys::Xml>::iterator p = child.begin();
	const list<Sys::Xml>::iterator pend = child.end();
	for(; p != pend; p++)
	{
		p->PrivateRefreshNodeID(id);
	}
}

bool Xml::GetChild(const wchar_t* child_name, list<Sys::Xml>::iterator& out_child)
{
	if (child.empty() == true) return false;
	out_child = child.begin();
	const list<Sys::Xml>::iterator cend = child.end();
	for(; out_child != cend; out_child++)
	{
		if (out_child->name == child_name) return true;
	}
	return false;
}

bool Xml::GetChild(const wstring& child_name, list<Sys::Xml>::iterator& out_child)
{
	return GetChild(child_name.c_str(), out_child);
}

bool Xml::GetChild(int child_index, list<Sys::Xml>::iterator& out_child)
{
	if (child.empty() == true) return false;
	out_child = child.begin();
	const list<Sys::Xml>::iterator cend = child.end();
	int i;
	for(i = 0; out_child != cend; out_child++, i++)
	{
		if (child_index == i) return true;
	}
	return false;
}

bool Xml::GetChildByNoPrefixName(const wchar_t* child_noPrefix_name, list<Sys::Xml>::iterator& out_child)
{
	if (child.empty() == true) return false;
	out_child = child.begin();
	wstring np;
	const list<Sys::Xml>::iterator cend = child.end();
	for(; out_child != cend; out_child++)
	{
		if (out_child->GetNameWithoutPrefix(np) == true)
		{
			if (np == child_noPrefix_name) return true;
		}
	}
	return false;
}

bool Xml::GetChildByNoPrefixName(const wstring& child_noPrefix_name, list<Sys::Xml>::iterator& out_child)
{
	return GetChildByNoPrefixName(child_noPrefix_name.c_str(), out_child);
}

bool Xml::SetChildValue(const wchar_t* child_name, const wchar_t* child_value)
{
	if (child.empty() == true) return false;
	list<Sys::Xml>::iterator p = child.begin();
	const list<Sys::Xml>::iterator cend = child.end();
	for(; p != cend; p++)
	{
		if (p->name == child_name)
		{
			p->value = child_value;
			return true;
		}
	}
	return false;
}

bool Xml::SetChildValue(const wstring& child_name, const wstring& child_value)
{
	return SetChildValue(child_name.c_str(), child_value.c_str());
}

bool Xml::SetChildValue(int child_index, const wchar_t* child_value)
{
	if (child.empty() == true) return false;
	list<Sys::Xml>::iterator p = child.begin();
	const list<Sys::Xml>::iterator cend = child.end();
	int i;
	for(i = 0; p != cend; p++, i++)
	{
		if (i == child_index)
		{
			p->value = child_value;
			return true;
		}
	}
	return false;
}

bool Xml::SetChildValue(int child_index, const wstring& child_value)
{
	return SetChildValue(child_index, child_value.c_str());
}

bool Xml::GetChildValue(const wchar_t* child_name, wstring& out_child_value) const
{
	out_child_value.clear();
	if (child.empty() == true) return false;
	list<Sys::Xml>::const_iterator p = child.begin();
	const list<Sys::Xml>::const_iterator cend = child.end();
	for(; p != cend; p++)
	{
		if (p->name == child_name)
		{
			out_child_value = p->value;
			return true;
		}
	}
	return false;
}

bool Xml::GetChildValue(const wstring& child_name, wstring& out_child_value) const
{
	return GetChildValue(child_name.c_str(), out_child_value);
}

bool Xml::GetChildValue(int child_index, wstring& out_child_value) const
{
	out_child_value.clear();
	if (child.empty() == true) return false;
	list<Sys::Xml>::const_iterator p = child.begin();
	const list<Sys::Xml>::const_iterator cend = child.end();
	int i;
	for(i = 0; p != cend; p++, i++)
	{
		if (i == child_index)
		{
			out_child_value = p->value;
			return true;
		}
	}
	return false;
}

bool Xml::GetNameWithoutPrefix(wstring& out_name) const
{
	out_name.clear();
	if (name.empty()== true) return false;
	const size_t pos = name.find(L":");
	if (pos == std::wstring::npos)
	{
		out_name = name;
	}
	else
	{
		out_name.assign(name.begin()+pos+1, name.end());
	}
	return true;
}

void Xml::SetAttribute(const wchar_t* attribute_name, const wchar_t* attribute_value)
{
	attribute[attribute_name] = attribute_value;
}

void Xml::SetAttribute(const wstring& attribute_name, const wstring& attribute_value)
{
	attribute[attribute_name] = attribute_value;
}

bool Xml::GetAttribute(const wchar_t* attribute_name, wstring& out_attribute_value) const
{
	out_attribute_value.clear();
	map<wstring, wstring>::const_iterator p = attribute.find(attribute_name);
	if (p == attribute.end()) return false;
	out_attribute_value = p->second;
	return true;
}

bool Xml::GetAttribute(const wstring& attribute_name, wstring& out_attribute_value) const
{
	return GetAttribute(attribute_name.c_str(), out_attribute_value);
}

bool Xml::GetPrefix(wstring& out_prefix) const
{
	out_prefix.clear();
	if (name.empty()== true) return false;
	const size_t pos = name.find(L":");
	if (pos == std::wstring::npos) return false;
	out_prefix.assign(name.begin(), name.begin()+pos);
	return true;
}

bool Xml::Get_xmlns(const Sys::Xml& childNode, wstring& out_xmlns) const
{
	out_xmlns.clear();
	map<wstring, wstring>::const_iterator p;
	//_________________________________________________ Try to find xmlns from attribute in child
	p = childNode.attribute.find(L"xmlns");
	if (p != childNode.attribute.end())
	{
		out_xmlns = p->second;
		return true;
	}
	//_________________________________________________ Try to find xmlns using xmlns:prefix from attribute in child
	wstring prefix;
	const int child_node_id = childNode.GetNode_ID();
	if (childNode.GetPrefix(prefix) == true)
	{
		wstring full_name(L"xmlns:");
		full_name += prefix;
		p = childNode.attribute.find(full_name);
		if (p != childNode.attribute.end())
		{
			out_xmlns = p->second;
			return true;
		}
		//_______________________________________________ Try to find xmlns using xmlns:prefix attribute with recursion
		PrivateRecursion_xmlns_prefix(child_node_id, full_name.c_str(), out_xmlns);
		if (out_xmlns.empty() == false) return true;
	}
	//_______________________________________________ Try to find xmlns using xmlns attribute with recursion
	PrivateRecursion_xmlns(child_node_id, out_xmlns);
	if (out_xmlns.empty() == false) return true;
	//
	return false;
}

// It returns false to stop recursion
bool Xml::PrivateRecursion_xmlns_prefix(const int child_node_id, const wchar_t* xmlns_tofind, wstring& out_xmlns) const
{
	if (node_id == child_node_id) return false; // End of recursion
	//______________________________________________________ Try to find in attributes
	map<wstring, wstring>::const_iterator p = attribute.find(xmlns_tofind);
	if (p != attribute.end())
	{
		out_xmlns = p->second;
		return false; // Found. End of recursion
	}
	//_____________________________________________________ Recursion
	list<Sys::Xml>::const_iterator q = child.begin();
	const list<Sys::Xml>::const_iterator qend = child.end();
	for (; q != qend; q++)
	{
		if (q->PrivateRecursion_xmlns_prefix(child_node_id, xmlns_tofind, out_xmlns) == false) return false;
	}
	return true;
}

void Xml::PrivateRecursion_xmlns(const int child_node_id, wstring& out_xmlns) const
{
	if (node_id == child_node_id) return; // End of recursion
	//______________________________________________________ Update out_xmlns using latest xmlns
	map<wstring, wstring>::const_iterator p = attribute.find(L"xmlns");
	if (p != attribute.end()) out_xmlns = p->second;
	//______________________________________________________ Update out_xmlns using latest xmlns:
	const map<wstring, wstring>::const_iterator pend = attribute.end();
	size_t pos;
	for (p = attribute.begin(); p != pend; p++)
	{
		pos = p->first.find(L"xmlns:");
		if (pos == std::wstring::npos) continue;
		if (pos == 0) out_xmlns = p->second;
	}
	//_____________________________________________________ Recursion
	list<Sys::Xml>::const_iterator q = child.begin();
	const list<Sys::Xml>::const_iterator qend = child.end();
	for (; q != qend; q++)
	{
		q->PrivateRecursion_xmlns(child_node_id, out_xmlns);
	}
}

int Xml::GetMaxValueLength() const
{
	if (child.empty() == true) return (int)value.length();
	//___________________________________
	int maxTextLength = 0;
	int length;
	list<Sys::Xml>::const_iterator p = child.begin();
	const list<Sys::Xml>::const_iterator pend = child.end();
	for(; p != pend; p++)
	{
		length = p->GetMaxValueLength();
		if (length > maxTextLength) maxTextLength = length;
	}
	return maxTextLength;
}

Sys::Xml& Xml::AddChild(const Sys::Xml& child)
{
	this->child.push_back(child);
	return this->child.back();
}

Sys::Xml& Xml::AddChild(const wchar_t* name)
{
	Sys::Xml node;
	child.push_back(node);
	child.back().name = name;
	return child.back();
}

Sys::Xml& Xml::AddChild(const wstring& name)
{
	return AddChild(name.c_str());
}

Sys::Xml& Xml::AddChild(const wchar_t* name, const wchar_t* value)
{
	Sys::Xml node;
	child.push_back(node);
	child.back().name = name;
	child.back().value = value;
	return child.back();
}

Sys::Xml& Xml::AddChild(const wstring& name, const wstring& value)
{
	return AddChild(name.c_str(), value.c_str());
}

Sys::Xml& Xml::AddChild(const wchar_t* name, const wchar_t* value, const map<wstring, wstring>& attribute)
{
	Sys::Xml node;
	child.push_back(node);
	child.back().name = name;
	child.back().value = value;
	child.back().attribute = attribute;
	return child.back();
}

Sys::Xml& Xml::AddChild(const wstring& name, const wstring& value, const map<wstring, wstring>& attribute)
{
	return AddChild(name.c_str(), value.c_str(), attribute);
}

bool Xml::CopyTo(Sys::IEnumerator& num) const
{
	const int maxTextLength = GetMaxValueLength()+1;
	const int childCount = (int)child.size();
	if (childCount == 0) return true; // Nothing to copy
	const int colCount = (int)child.front().child.size(); 
	int row, col;
	int actualColCount = 0;
	//__________________________________________ Memory allocation
	wchar_t** pData=new wchar_t* [colCount];
	for(col = 0; col<colCount; col++)
	{
		pData[col]=new wchar_t [maxTextLength];
		pData[col][0]='\0';
	}
	//__________________________________________ For each Child node
	list<Sys::Xml>::const_iterator p_row = child.begin();
	list<Sys::Xml>::const_iterator p_col;
	for (row = 0; row < childCount; row++, p_row++)
	{
		actualColCount = (int)p_row->child.size();
		//_________ Be sure all columns are empty
		for (col = 0; col < colCount; col++) pData[col][0]='\0'; 
		//_________ Copy Columns;
		p_col = p_row->child.begin();
		for (col = 0; col < colCount && col < actualColCount; col++, p_col++)
		{
			_snwprintf_s(pData[col], maxTextLength, _TRUNCATE, L"%s", p_col->value.c_str());
		}
		num.Enumerate(pData, actualColCount, row);
	}

	//__________________________________________ Clean up
	if (pData != NULL)
	{
		for (col = 0; col < colCount; col++)
		{
			if (pData[col] != NULL) delete [] pData[col];
		}
		delete [] pData;
	}
	return true;
}

//________________________________________________________________ Sys::IEnumerator
void Xml::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	int i;
	list<Sys::Xml>::iterator p;
	if (rowIndex == 0)
	{
		if (child.empty() == true) //_____________________________ Create first child
		{
			wchar_t text[32];
			if (name.empty() == true) name = L"list";
			child.resize(1);
			child.front().name = L"item";
			child.front().child.resize(colCount);
			p = child.front().child.begin();
			for(i = 0; i < colCount; i++, p++)
			{
				_snwprintf_s(text, 32, _TRUNCATE, L"property%d", i+1);
				p->name = text;
			}
		}
	}
	else //________________________________________________ Other rows
	{
		if (child.empty() == true) return; // Impossible
		child.push_back(child.front()); // Insert a new no equal to first one
	}
	//____________________________________________________ Copy Node
	const int paramCount = (int)(child.back().child.size());
	p = child.back().child.begin();
	for(i = 0; i < colCount && i <paramCount; i++, p++)
	{
		p->value = data[i];
	}
}

bool Xml::LoadHead(const wchar_t* data, size_t& position)
{
	if (data == NULL) return false;
	//____________________________________________ find <?
	const wchar_t * pos1 = wcsstr(data, L"<?");
	if (pos1 == NULL) return false;
	//____________________________________________ find ?>
	const wchar_t* pos2 = wcsstr(pos1, L"?>");
	if (pos2 == NULL) return false;
	//____________________________________________ Return position after Header
	position = (size_t)(pos2 + 2 - data);
	//____________________________________________ Check for: UTF-8 or UTF-16 in head
	wstring head;
	head.assign(pos1 + 2, pos2);

	if (utf_8 == true)
	{
		// Nothing to check as utf-8 is optional
	}
	else
	{
		if (head.find(L"\"utf-16\"") == std::string::npos) return false;
	}
	return true;
}

// Returns: XML_ERROR, XML_OPENING_TAG, XML_VALUE, XML_CLOSING_TAG, XML_COMMENT
int Xml::LookAhead(const wstring& data, size_t position)
{
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif

	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == ' ' || data[position] == '\t' || data[position] == '\r' || data[position] == '\n') continue;
		if (data[position] == '<')
		{
			if (position+1 < len)
			{
				if (data[position+1] == '/')
				{
					return WXML_CLOSING_TAG;
				}
				else if (data[position+1] == '!')
				{
					return WXML_COMMENT;
				}
				else
				{
					return WXML_OPENING_TAG;
				}
			}
			else
			{
				return WXML_ERROR;
			}
		}
		else
		{
			return WXML_VALUE;
		}
	}
	return WXML_ERROR;
}

bool Xml::LoadData(const wstring& data)
{
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	size_t position = 0;
	bool isMonoTag;

	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == ' ' || data[position] == '\t' || data[position] == '\r' || data[position] == '\n') continue;
		if (data[position] == '<')
		{
			switch (LookAhead(data, position))
			{
			case WXML_ERROR:
				name = L"ERROR Sys::Xml::LoadData syntax error";
				return false;
			case WXML_OPENING_TAG:
				if (OpeningTag(data, position, isMonoTag) == false) return false;
				if (isMonoTag == false)
				{
					if (TagBody(data, position) == false) return false;
					if (ClosingTag(data, position) == false) return false;
				}
				RefreshNodeIDs();
				return true;
			//case XML_VALUE:
			//	return L"Syntax error: expected <";
			//	break;
			case WXML_CLOSING_TAG:
				name = L"ERROR Sys::Xml::LoadData found greater than sign while expecting less than sign";
				return false;
			case WXML_COMMENT:
				if (Comment(data, position) == false) return false;
				break;
			}
			RefreshNodeIDs();
			return true;
		}
		else
		{
			name = L"ERROR Sys::Xml::LoadData expected less than sign";
			return false;
		}
	}
	RefreshNodeIDs();
	return true;
}

bool Xml::TagBody(const wstring& data, size_t& position)
{
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	size_t ini_position = position;
	bool isMonoTag;
	
	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == ' ' || data[position] == '\t' || data[position] == '\r' || data[position] == '\n') continue;
		//_______________________________________ LookAhead
		switch(LookAhead(data, position))
		{
		case WXML_ERROR:
			return false;
		case WXML_OPENING_TAG:
			{
				Sys::Xml newXml;
				child.push_back(newXml);
				Sys::Xml& p = child.back();
				if (p.OpeningTag(data, position, isMonoTag) == false) return false;
				if (isMonoTag == false)
				{
					p.TagBody(data, position);
					if (p.ClosingTag(data, position) == false) return false;
				}
			}
			break;
		case WXML_VALUE:
			position = ini_position; // Restore position to preserve spaces
			if (LoadValue(data, position) == false) return false;
			return true;
		case WXML_CLOSING_TAG:
			return true;
		case WXML_COMMENT:
			if (Comment(data, position) == false) return false;
			break;
		}
	}
	return true;
}

bool Xml::Comment(const wstring& data, size_t& position)
{
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif

	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == ' ' || data[position] == '\t' || data[position] == '\r' || data[position] == '\n') continue;
		if (data[position] == '<')
		{
			if (position+3 < len)
			{
				if (data[position+1] != '!') return false;
				if (data[position+2] != '-') return false;
				if (data[position+3] != '-') return false;
				for( ; position < len; position++)
				{
					if (data[position] == '>')
					{
						position++;
						return true;
					}
				}
				return false;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	return false;
}

bool Xml::LoadValue(const wstring& data, size_t& position)
{
	value.clear();
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == '<')
		{
			Sys::Convert::FromXml(value);
			return true;
		}
		value.push_back(data[position]);
	}
	return false;
}

bool Xml::CreateFromUtf8(const Sys::Buffer& input)
{
	return CreateFromUtf8String((const char*)input);
}

bool Xml::CreateFromUtf8String(const char* input_data)
{
	if (input_data == NULL)
	{
		Delete();
		return true;
	}
	wstring data;
	Sys::Convert::UTF8ToWstring(input_data, data);
	return CreateFromString(data.c_str());
}

bool Xml::CreateFromString(const wchar_t* input_data)
{
	Delete();
	//
	size_t position = 0;
	if (LoadHead(input_data, position) == false) return L"Sys::Xml::CreateFromString Unable to read XML version and encoding";
	//_____________________________________________________ Delete Head
	wstring winput(input_data+ position);
	return LoadData(winput);
}

bool Xml::CreateFromString(const wstring& input_data)
{
	return CreateFromString(input_data.c_str());
}

bool Xml::Load(const wchar_t* filename)
{
	Delete();
	const int unicodeTest = Sys::FileAssistant::IsTextFileUnicode(filename);
	if (unicodeTest == -1)
	{
		name = L"ERROR Sys::Xml::Load Unable to read file";
		return false;
	}
	wstring input;
	 //_____________________________________ UTF-16
	if (unicodeTest == 1)
	{
		utf_8 = false;
		if (Sys::FileAssistant::TextLoad(filename, input) == false)
		{
			name = L"ERROR Sys::Xml::Load Unable to read file";
			return false;
		}
	}
	else //_________________________________ UTF-8
	{
		utf_8 = true;
		string tmp;
		if (Sys::FileAssistant::TextLoad(filename, tmp) == false)
		{
			name = L"ERROR Sys::Xml::Load Unable to read file";
			return false;
		}
		Sys::Convert::UTF8ToWstring(tmp, input);
	}
	//_____________________________________________________ Load Head
	size_t position = 0;
	if (LoadHead(input.c_str(), position) == false)
	{
		name = L"ERROR Sys::Xml::Load Unable to read XML header (version and encoding)";
		return false;
	}
	//_____________________________________________________ Delete Head
	wstring winput;
	winput.assign(input.begin()+position, input.end());
	//_____________________________________________________ Load
	return LoadData(winput);
}

bool Xml::Load(const wstring& filename)
{
	return Load(filename.c_str());
}

bool Xml::OpeningTag(const wstring& data, size_t& position, bool& isMonoTag)
{
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	
	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == ' ' || data[position] == '\t' || data[position] == '\r' || data[position] == '\n') continue;
		if (data[position] == '<')
		{
			position++; // Move after <
			if (LoadName(data, position, isMonoTag) == false) return false;
			return true;
		}
	}
	return false;
}

bool Xml::LoadName(const wstring& data, size_t& position, bool& out_isMonoTag)
{
	out_isMonoTag = false;
	name.clear();
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	//____________________________________________ Name
	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == '>')
		{
			position++; // Mover after >
			return true;
		}
		if (data[position] == '/')
		{
			position++; // Mover after /
			if (position < len)
			{
				if (data[position] == '>')
				{
					//position++; // Mover after >
					out_isMonoTag = true;
					return true;
				}
			}
			return true;
		}
		if (data[position] == ' ' || data[position] == '\t' || data[position] == '\r' || data[position] == '\n')
		{
			if (IsMonoTag(data, position) == true)
			{
				continue;
			}
			else
			{
				return LoadAttribute(data, position);
			}
		}
		name.push_back(data[position]);
	}
	name = L"ERROR Sys::XML::LoadName unable to load name";
	return false;
}

bool Xml::IsMonoTag(const wstring& data, size_t& position)
{
	const size_t len = data.size();
	const size_t old_position = position;
	//____________________________________________ Move after separator
	for (; position < len; position++)
	{
		if (data[position] != ' ' && data[position] != '\t' && data[position] != '\r' && data[position] != '\n') break;
	}

	if (position < len)
	{
		if (data[position] == '/')
		{
			position--;
			return true;
		}
	}
	//___________________________________________ Restore original position
	position = old_position;
	return false;
}

bool Xml::LoadAttribute(const wstring& data, size_t& position)
{
	attribute.clear();
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	wstring attribute_name;
	wstring attribute_value;
	bool nameFound = false;
	bool valueFound = false;
	//____________________________________________ Move after separator
	for (; position < len; position++)
	{
		if (data[position] != ' ' && data[position] != '\t' && data[position] != '\r' && data[position] != '\n') break;
	}
	//____________________________________________ Get Attribute
	for (; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == '>')
		{
			position++; // Mover after >
			return true;
		}
		nameFound = false;
		valueFound = false;
		if (LoadAttributeName(data, position, nameFound, attribute_name) == false) return false;
		if (nameFound == true)
		{
			if (LoadAttributeValue(data, position, valueFound, attribute_value) == false) return false;
		}
		if (nameFound == true && valueFound == true)
		{
			attribute[attribute_name] = attribute_value;
			position--; // Move back
		}
	}
	attribute[L"ERROR"] = L"Sys::XML::LoadAttribute missing greater than sign";
	return false;
}

bool Xml::LoadAttributeName(const wstring& data, size_t& position, bool& found, wstring& out_name)
{
	out_name.clear();
	found = false;
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	//____________________________________________ Move after separator
	for (; position < len; position++)
	{
		if (data[position] != ' ' && data[position] != '\t' && data[position] != '\r' && data[position] != '\n') break;
	}
	//____________________________________________ Are we at the end?
	if (data[position] == '>')
	{
		position--;
		return true;
	}
	//____________________________________________ Get Attribute
	for (; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == '=')
		{
			Sys::TextAssistant::RemoveTrailingSpaces(out_name);
			position++; // Mover after =
			found = true;
			return true;
		}
		out_name.push_back(data[position]);
	}
	attribute[L"ERROR"] = L"Sys::XML::LoadAttributeName expected equal sign";
	return false;
}

bool Xml::LoadAttributeValue(const wstring& data, size_t& position, bool& found, wstring& out_value)
{
	out_value.clear();
	found = false;
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	//____________________________________________ Move after separator
	for (; position < len; position++)
	{
		if (data[position] != ' ' && data[position] != '\t' && data[position] != '\r' && data[position] != '\n') break;
	}
	//____________________________________________ Move after quotes
	if (data[position] == '\"')
	{
		position++;
	}
	else
	{
		attribute[L"ERROR"] =  L"ERROR Sys::Xml::LoadAttributeValue expected quotes sign";
		return false;
	}
	//____________________________________________ Get Attribute
	for (; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == '\"') // || data[position] == '\t' || data[position] == '\r' || data[position] == '\n' || data[position] == '>')
		{
			position++;
			found = true;
			//if (data[position] == '>') position--; //Move back
			return true;
		}
		out_value.push_back(data[position]);
	}
	attribute[L"ERROR"] =  L"ERROR Sys::Xml::LoadAttributeValue expected quotes sign";
	return false;
}


bool Xml::ClosingTag(const wstring& data, size_t& position)
{
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	int state = 0;
	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == ' ' || data[position] == '\t' || data[position] == '\r' || data[position] == '\n') continue;
		//____________________________________________ find </
		if (state == 0)
		{
			if (data[position] == '<') state = 1;
		}
		else
		{
			if (data[position] == '/')
			{
				position++; // Move after /
				if (CheckName(data, position) == true) return true;
				name = L"ERROR: Sys::Xml::ClosingTag closing tag name does not match";
				return false;
			}
			else
			{
				name = L"ERROR: Sys::Xml::ClosingTag expected /";
				return false;
			}
		}
	}
	name = L"ERROR: Sys::Xml::ClosingTag expected less than sign";
	return false;
}

bool Xml::CheckName(const wstring& data, size_t& position)
{
	wstring newName;
	const size_t len = data.size();
#ifdef _DEBUG
	wchar_t a;
#endif
	for( ; position < len; position++)
	{
#ifdef _DEBUG
		a = data[position];
#endif
		if (data[position] == '>')
		{
			if (CompareName(newName) == true)	
			{
				//position++; // Move after >
				return true;
			}
			return false;
		}
		newName.push_back(data[position]);
	}
	return false;
}

bool Xml::CompareName(const wstring& newName)
{
	const int lenName = (int)name.size();
	const int lenNewName = (int)newName.size();
	if (lenName == lenNewName)
	{
		return (name == newName);
	}
	const int minLen = MINIMUM(lenName, lenNewName);
	register int i = 0;
	for(i = 0; i < minLen; i++)
	{
		if (name[i] != newName[i]) return false;
	}
	if (i < lenName)
	{
		if (name[i] == ' ') return true;
	}
	else
	{
		return true;
	}
	return false;
}

void Xml::PrivateGetXmlText(wstring& data, int& indent) const
{
	wstring text;
	const int childCount = (int)child.size();
	int i;
	//______________________________________________________ Indent
	for(i = 0; i < indent; i++) data += '\t';
	//______________________________________________________ Opening Tag
	Sys::Format(text, L"<%s", name.c_str());
	data += text;

	if (attribute.empty() == false)
	{
		map<wstring, wstring>::const_iterator attr = attribute.begin();
		const map<wstring, wstring>::const_iterator aend = attribute.end();
		const int attribute_count = (int)attribute.size();
		for(; attr != aend; attr++)
		{
			data += L" ";
			data += attr->first;
			data += L"=\"";
			data += attr->second;
			data += L"\"";
		}
	}

	if (childCount == 0)
	{
		data += L">";
	}
	else
	{
		data += L">\r\n";
	}
	//______________________________________________________ Body or Value
	if (childCount == 0)
	{
		if (value.empty() == false)
		{
			Sys::Convert::ToXml(value, text);
			data += text;
		}
	}
	else
	{
		indent++;
		list<Sys::Xml>::const_iterator p = child.begin();
		const list<Sys::Xml>::const_iterator pend = child.end();
		for(; p != pend; p++)
		{
			p->PrivateGetXmlText(data, indent);
		}
		indent--;
	}

	//______________________________________________________ ClosingTag
	//______________________________________________________ Indent
	if ((childCount != 0))
	{
		if (value.empty() == true)
		{
			for(i = 0; i < indent; i++) data += '\t';
		}
	}
	Sys::Format(text, L"</%s>\r\n", name.c_str());
	data += text;
}

void Xml::PrivateGetXmlText(Sys::ITextWriterW& data, int& indent) const
{
	wstring text;
	const int childCount = (int)child.size();
	int i;
	//______________________________________________________ Indent
	for(i = 0; i < indent; i++) data.WriteText(L"\t");
	//______________________________________________________ Opening Tag
	Sys::Format(text, L"<%s", name.c_str());
	data.WriteText(text);

	if (attribute.empty() == false)
	{
		map<wstring, wstring>::const_iterator attr = attribute.begin();
		const map<wstring, wstring>::const_iterator aend = attribute.end();
		const int attribute_count = (int)attribute.size();
		for(; attr != aend; attr++)
		{
			data.WriteText(L" ");
			data.WriteText(attr->first);
			data.WriteText(L"=\"");
			data.WriteText(attr->second);
			data.WriteText(L"\"");
		}
	}

	if (childCount == 0)
	{
		data.WriteText(L">");
	}
	else
	{
		data.WriteText(L">\r\n");
	}
	//______________________________________________________ Body or Value
	if (childCount == 0)
	{
		if (value.empty() == false)
		{
			Sys::Convert::ToXml(value, text);
			data.WriteText(text);
		}
	}
	else
	{
		indent++;
		list<Sys::Xml>::const_iterator p = child.begin();
		const list<Sys::Xml>::const_iterator pend = child.end();
		for(; p != pend; p++)
		{
			p->PrivateGetXmlText(data, indent);
		}
		indent--;
	}

	//______________________________________________________ ClosingTag
	//______________________________________________________ Indent
	if ((childCount != 0))
	{
		if (value.empty() == true)
		{
			for(i = 0; i < indent; i++) data.WriteText(L"\t");
		}
	}
	Sys::Format(text, L"</%s>\r\n", name.c_str());
	data.WriteText(text);
}

void Xml::GetHtml(wstring& output_html)
{
	output_html.clear();
	//_______________________________________________ Content
	if (utf_8 == true)
	{
		output_html += L"<span style=\"color:#909090\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br />";
	}
	else
	{
		output_html += L"<span style=\"color:#909090\">&lt;?xml version=\"1.0\" encoding=\"utf-16\"?&gt;</span><br />";
	}
	int indent = 0;
	PrivateGetXmlTextAsHtml(output_html, indent);
	output_html += L"</br>";	
}

void Xml::PrivateGetXmlTextAsHtml(wstring& data, int& indent) const
{
	wstring text;
	const int childCount = (int)child.size();
	int i;
	//______________________________________________________ Indent
	for (i = 0; i < indent; i++) data += L"&nbsp;&nbsp;&nbsp;";
	//______________________________________________________ Opening Tag
	Sys::Format(text, L"<span style=\"color:#909090\">&lt;</span><span style=\"color:#5050FF\">%s</span>", name.c_str());
	data += text;

	if (attribute.empty() == false)
	{
		map<wstring, wstring>::const_iterator attr = attribute.begin();
		const map<wstring, wstring>::const_iterator aend = attribute.end();
		const int attribute_count = (int)attribute.size();
		for(; attr != aend; attr++)
		{
			data += L"&nbsp;<span style=\"color:#909090\">";
			data += attr->first;
			data += L"=\"";
			data += attr->second;
			data += L"\"</span>";
		}
	}

	if (childCount == 0)
	{
		data += L"<span style=\"color:#909090\">&gt;</span>";
	}
	else
	{
		data += L"<span style=\"color:#909090\">&gt;</span><br />";
	}
	//______________________________________________________ Body or Value
	if (childCount == 0)
	{
		if (value.empty() == false)
		{
			Sys::Convert::ToXml(value, text);
			data += L"<span style=\"color:#000000\">";
			data += text;
			data += L"</span>";
		}
	}
	else
	{
		indent++;
		list<Sys::Xml>::const_iterator p = child.begin();
		const list<Sys::Xml>::const_iterator pend = child.end();
		for(; p != pend; p++)
		{
			p->PrivateGetXmlTextAsHtml(data, indent);
		}
		indent--;
	}

	//______________________________________________________ ClosingTag
	//______________________________________________________ Indent
	if ((childCount != 0))
	{
		if (value.empty() == true)
		{
			for (i = 0; i < indent; i++) data += L"&nbsp;&nbsp;&nbsp;";
		}
	}
	Sys::Format(text, L"<span style=\"color:#909090\">&lt;/</span><span style=\"color:#5050FF\">%s</span><span style=\"color:#909090\">&gt;</span><br />", name.c_str());
	data += text;
}

void Xml::GetXmlText(Sys::ITextWriterW& output_data)
{
	if (utf_8 == true)
	{
		output_data.WriteText(L"<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n");
	}
	else
	{
		output_data.WriteText(L"<?xml version=\"1.0\" encoding=\"utf-16\"?>\r\n");
	}
	int indent = 0;
	PrivateGetXmlText(output_data, indent);
}

void Xml::GetXmlText(wstring& output_data)
{
	if (utf_8 == true)
	{
		output_data = L"<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n";
	}
	else
	{
		output_data = L"<?xml version=\"1.0\" encoding=\"utf-16\"?>\r\n";
	}
	int indent = 0;
	PrivateGetXmlText(output_data, indent);
}

void Xml::GetXmlText(string& output_data)
{
	wstring data;
	GetXmlText(data);
	if (utf_8 == true)
	{
		Sys::Convert::WstringToUTF8(data, output_data);
	}
	else
	{
		Sys::Convert::WstringToString(data, output_data);
	}
}

bool Xml::Save(const wchar_t* filename)
{
	//___________________________________________ Get Data
	wstring data;
	GetXmlText(data);
	//___________________________________________ UTF-8 Save
	if (utf_8 == true)
	{
		string input;
		Sys::Convert::WstringToUTF8(data, input);
		return Sys::FileAssistant::TextSave(filename, input);
	}
	//___________________________________________ UTF-16 Save
	return Sys::FileAssistant::TextSave(filename, data, true);
}

void Xml::Delete()
{
	name.clear();
	value.clear();
	attribute.clear();
	child.clear();
	utf_8 = true;
}

bool Xml::IsXml(const char* input)
{
	if (input == NULL) return false;
	const int len = (int)strlen(input);
	int n = 0;
	bool foundBeginning = false;
	//__________________________________ Move to beginning
	for (n = 0; n < len; n++)
	{
		if (input[n] == ' ') continue;
		if (input[n] == '\t') continue;
		if (input[n] == '\r') continue;
		if (input[n] == '\n') continue;
		foundBeginning = true;
		break;
	}
	if (foundBeginning == false) return true;
	//_______________
	if (n >= len) return false;
	if (input[n++] != '<') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != '?') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != 'x') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != 'm') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != 'l') return false;
	//_______________ Separator
	if (n >= len) return false;
	if (input[n] == ' ') return true;
	if (input[n] == '\t') return true;
	if (input[n] == '\r') return true;
	if (input[n] == '\n') return true;
	//_______________
	return false;
}

bool Xml::IsXml(const wchar_t* input)
{
	if (input == NULL) return false;
	const int len = (int)wcslen(input);
	int n = 0;
	bool foundBeginning = false;
	//__________________________________ Move to beginning
	for (n = 0; n < len; n++)
	{
		if (input[n] == ' ') continue;
		if (input[n] == '\t') continue;
		if (input[n] == '\r') continue;
		if (input[n] == '\n') continue;
		foundBeginning = true;
		break;
	}
	if (foundBeginning == false) return true;
	//_______________
	if (n >= len) return false;
	if (input[n++] != '<') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != '?') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != 'x') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != 'm') return false;
	//_______________
	if (n >= len) return false;
	if (input[n++] != 'l') return false;
	//_______________ Separator
	if (n >= len) return false;
	if (input[n] == ' ') return true;
	if (input[n] == '\t') return true;
	if (input[n] == '\r') return true;
	if (input[n] == '\n') return true;
	//_______________
	return false;
}

//_____________________________________________________________________ SoapEnvelope
SoapEnvelope::SoapEnvelope()
{
	Constructor();
}

void SoapEnvelope::Constructor()
{
	utf_8 = true;
	majorVersion = 1;
	minorVersion = 2;
	name = L"soap:Envelope";
	//___________________________________________ Envelope Attributes
	attribute.clear();
	attribute[L"xmlns:soap"] = L"http://www.w3.org/2001/12/soap-envelope";
	attribute[L"soap:encodingStyle"] = L"http://www.w3.org/2001/12/soap-encoding";
	//___________________________________________ Body
	child.resize(1);
	child.front().name = L"soap:Body";
	//___________________________________________ Action
	child.front().child.resize(1);
	child.front().child.front().name = L"MyAction";
	//___________________________________________ Action attributes
	child.front().child.front().attribute.clear();
	child.front().child.front().attribute[L"xmlns"] = L"http://www.ERROR.com";
}

SoapEnvelope::~SoapEnvelope()
{
}

//________________________________________________________________ Sys::IEnumerator
void SoapEnvelope::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return;
	body->child.begin()->Enumerate(data, colCount, rowIndex);
}

bool SoapEnvelope::GetResponse(list<Sys::Xml>::iterator& out_response)
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return false; // Action not found
	out_response = body->child.begin();
	return true;
}

bool SoapEnvelope::GetBody(list<Sys::Xml>::iterator& out_body)
{
	return GetChildByNoPrefixName(L"Body", out_body);
}

wstring SoapEnvelope::GetActionXmlns()
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return L"";
	if (body->child.empty() == true) return L""; // Action not found
	//_______________________________________________________
	wstring xmlns;
	if (Get_xmlns(body->child.front(), xmlns) == false) return L"";
	return xmlns;
}

bool SoapEnvelope::SetActionXmlns(const wstring name)
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return false; // Action not found
	body->child.front().attribute[L"xmlns"] = name;
	return true;
}

wstring SoapEnvelope::GetActionName()
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return L""; // Action not found
	//_____________________________________________ Remove Prefix
	const size_t pos = body->child.front().name.find(L":");
	if (pos == std::wstring::npos) return body->child.front().name;
	wstring tmp;
	tmp.assign(body->child.front().name.begin()+pos+1, body->child.front().name.end());
	return tmp;
}

bool SoapEnvelope::SetActionName(const wstring name)
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return false; // Action not found
	body->child.front().name = name;
	return true;
}

bool SoapEnvelope::AddParameter(const wchar_t* name, const wchar_t* value)
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return false; // Action not found
	//
	Sys::Xml xml;
	xml.name = name;
	xml.value = value;
	body->child.front().child.push_back(xml);
	return true;
}

bool SoapEnvelope::AddParameter(const wstring& name, const wstring& value)
{
	return AddParameter(name.c_str(), value.c_str());
}

bool SoapEnvelope::AddParameter(const wchar_t* name, const int value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return AddParameter(name, tmp.c_str());
}

bool SoapEnvelope::AddParameter(const wstring& name, const int value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return AddParameter(name.c_str(), tmp.c_str());
}

bool SoapEnvelope::AddParameter(const wchar_t* name, const double value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return AddParameter(name, tmp.c_str());
}

bool SoapEnvelope::AddParameter(const wstring& name, const double value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return AddParameter(name.c_str(), tmp.c_str());
}

bool SoapEnvelope::AddParameter(const wchar_t* name, const bool value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return AddParameter(name, tmp.c_str());
}

bool SoapEnvelope::AddParameter(const wstring& name, const bool value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return AddParameter(name.c_str(), tmp.c_str());
}

bool SoapEnvelope::DeleteAllParameters()
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return false;
	body->child.front().child.clear();
	return true;
}

bool SoapEnvelope::GetParameterIterator(const wchar_t* name, list<Sys::Xml>::iterator& out_parameter)
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return false; // Action not found
	if (body->child.front().child.empty() == true) return false; // Zero parameters 
	out_parameter = body->child.front().child.begin();
	const list<Sys::Xml>::iterator pend = body->child.front().child.end();
	for (; out_parameter != pend; out_parameter++)
	{
		if (out_parameter->name == name) return true;
	}
	return false;
}

bool SoapEnvelope::GetParameterIterator(int parameter_index, list<Sys::Xml>::iterator& out_parameter)
{
	list<Sys::Xml>::iterator body;
	if (GetChildByNoPrefixName(L"Body", body) == false) return false;
	if (body->child.empty() == true) return false; // Action not found
	if (body->child.front().child.empty() == true) return false; // Zero parameters 
	out_parameter = body->child.front().child.begin();
	const list<Sys::Xml>::iterator pend = body->child.front().child.end();
	int i;
	for (i = 0; out_parameter != pend; out_parameter++, i++)
	{
		if (i == parameter_index) return true;
	}
	return false;
}

bool SoapEnvelope::SetParameterName(int index, const wchar_t* name)
{
	list<Sys::Xml>::iterator p;
	if (GetParameterIterator(index, p) == false) return false;
	p->name = name;
	return true;
}

bool SoapEnvelope::SetParameterName(int index, const wstring& name)
{
	return SetParameterName(index, name.c_str());
}

bool SoapEnvelope::GetParameterName(int index, wstring& out_name)
{
	list<Sys::Xml>::iterator p;
	if (GetParameterIterator(index, p) == false) return false;
	out_name = p->name;
	return true;
}

bool SoapEnvelope::SetParameterValue(int index, const wchar_t* value)
{
	list<Sys::Xml>::iterator p;
	if (GetParameterIterator(index, p) == false) return false;
	p->value = value;
	return true;
}

bool SoapEnvelope::SetParameterValue(int index, const wstring& value)
{
	return SetParameterValue(index, value.c_str());
}

bool SoapEnvelope::SetParameterValue(const wchar_t* name, const wchar_t* value)
{
	list<Sys::Xml>::iterator p; 
	if (GetParameterIterator(name, p) == false) return false;
	p->value = value;
	return true;
}

bool SoapEnvelope::SetParameterValue(const wstring& name, const wstring& value)
{
	return SetParameterValue(name.c_str(), value.c_str());
}

bool SoapEnvelope::SetParameterValue(const wchar_t* name, const int value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return SetParameterValue(name, tmp.c_str());
}

bool SoapEnvelope::SetParameterValue(const wstring& name, const int value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return SetParameterValue(name, tmp);
}

bool SoapEnvelope::SetParameterValue(const wchar_t* name, const double value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return SetParameterValue(name, tmp.c_str());
}

bool SoapEnvelope::SetParameterValue(const wstring& name, const double value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return SetParameterValue(name, tmp);
}

bool SoapEnvelope::SetParameterValue(const wchar_t* name, const bool value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return SetParameterValue(name, tmp.c_str());
}

bool SoapEnvelope::SetParameterValue(const wstring& name, const bool value)
{
	wstring tmp;
	Sys::Convert::ToString(value, tmp);
	return SetParameterValue(name, tmp);
}

bool SoapEnvelope::GetParameterValue(const wchar_t* name, wstring& out_value)
{
	out_value.clear();
	list<Sys::Xml>::iterator p;
	if (GetParameterIterator(name, p) == false) return false;
	out_value = p->value;
	return true;
}

bool SoapEnvelope::GetParameterValue(const wstring& name, wstring& out_value)
{
	return GetParameterValue(name.c_str(), out_value);
}

bool SoapEnvelope::GetParameterValue(const wchar_t* name, int& out_value)
{
	wstring tmp;
	if (GetParameterValue(name, tmp) == true)
	{
		out_value = Sys::Convert::ToInt(tmp);
		return true;
	}
	out_value = 0;
	return false; 
}

bool SoapEnvelope::GetParameterValue(const wstring& name, int& out_value)
{
	return GetParameterValue(name.c_str(), out_value);
}

bool SoapEnvelope::GetParameterValue(const wchar_t* name, double& out_value)
{
	wstring tmp;
	if (GetParameterValue(name, tmp) == true)
	{
		out_value = Sys::Convert::ToDouble(tmp);
		return true;
	}
	out_value = 0.0;
	return false; 
}

bool SoapEnvelope::GetParameterValue(const wstring& name, double& out_value)
{
	return GetParameterValue(name.c_str(), out_value);
}

bool SoapEnvelope::GetParameterValue(const wchar_t* name, bool& out_value)
{
	wstring tmp;
	if (GetParameterValue(name, tmp) == true)
	{
		out_value = Sys::Convert::ToBool(tmp);
		return true;
	}
	out_value = false;
	return false; 
}

bool SoapEnvelope::GetParameterValue(const wstring& name, bool& out_value)
{
	return GetParameterValue(name.c_str(), out_value);
}


bool SoapEnvelope::GetParameterValue(int index, wstring& out_value)
{
	list<Sys::Xml>::iterator p;
	if (GetParameterIterator(index, p) == false) return false;
	out_value = p->value;
	return true;
}

bool SoapEnvelope::GetParameterValue(int index, int& out_value)
{
	wstring tmp;
	if (GetParameterValue(index, tmp) == true)
	{
		out_value = Sys::Convert::ToInt(tmp);
		return true;
	}
	out_value = 0;
	return false;
}

bool SoapEnvelope::GetParameterValue(int index, double& out_value)
{
	wstring tmp;
	if (GetParameterValue(index, tmp) == true)
	{
		out_value = Sys::Convert::ToDouble(tmp);
		return true;
	}
	out_value = 0.0;
	return false;
}

bool SoapEnvelope::GetParameterValue(int index, bool& out_value)
{
	wstring tmp;
	if (GetParameterValue(index, tmp) == true)
	{
		out_value = Sys::Convert::ToBool(tmp);
		return true;
	}
	out_value = false;
	return false;
}

//_____________________________________________________________________ BoolArray
BoolArray::BoolArray(void)
{
	data =NULL;
	count = 0;
}

BoolArray::BoolArray(int bitCount)
{
	data =NULL;
	count = 0;
	this->Create(bitCount);
}

BoolArray::~BoolArray(void)
{
	Delete();
}

int BoolArray::GetCount() const
{
	return count;
}

BoolArray::BoolArray(const BoolArray& init) // Copy constructor
{
	data =NULL;
	count = 0;
	Copy(init);
}

BoolArray& BoolArray::operator =(const BoolArray& init) //Operator =
{
	Delete();
	Copy(init);
	return *this;
}

void BoolArray::Copy(const BoolArray &init)
{
	if (init.data)
	{
		this->Create(init.count);
		const int bytes = count/8 + 1;
		memcpy(data, init.data, bytes);
	}
}

void BoolArray::Delete(void)
{
	if (data) delete [] data;
	data = NULL;
	count = 0;
}

int BoolArray::GetActiveBitCount()
{
	int n = 0;
	for(int i=0; i<count; i++)
		if (GetBit(i)==1) n++;
	return n;
}

void BoolArray::GetString(wchar_t* buffer, int bufferSize)
{
	buffer[0]='\0';

	for(int i=0; i<count && i<bufferSize-1; i++)
	{
		if (GetBit(i)==1)
			lstrcat(buffer, L"1");
		else
			lstrcat(buffer, L"0");
	}
}

void BoolArray::Show(HWND hWnd, const wchar_t* caption)
{
	if (count<=0)
	{
		::MessageBoxW(hWnd, L"-", caption, MB_OK | MB_ICONINFORMATION);
		return;
	}

	wchar_t *texto = new wchar_t[count+1 + count/8 +1];
	texto[0]='\0';
	for(int i=0; i<count; i++)
	{
		if (i%8 == 0 && i>0) lstrcatW(texto, L" "); // a space between each byte
		if (GetBit(i)==1)
			lstrcatW(texto, L"1");
		else
			lstrcatW(texto, L"0");
	}

	::MessageBoxW(hWnd, texto, caption, MB_OK | MB_ICONINFORMATION);
	if (texto) delete [] texto;
}

bool BoolArray::Create(int bitCount)
{
	Delete();
	this->count = bitCount;
	int bytes = count/8 + 1;
	data = new char[bytes];
	if (data != NULL) memset(data, 0, bytes);
	return (data!=NULL);
}

bool BoolArray::IsOk()
{
	return data!=NULL;
}

__int8 BoolArray::GetInt8(int arrayIndex) const
{
	if (arrayIndex < 0)  throw L"Sys::BoolArray::GetInt8 invalid index";
	if (arrayIndex >= count/8) throw L"Sys::BoolArray::GetInt8 invalid index";
	__int8 value = -1;
	memcpy(&value, &data[arrayIndex], 1);
	return value;
}

__int16 BoolArray::GetInt16(int arrayIndex) const
{
	if (arrayIndex < 0)  throw L"Sys::BoolArray::GetInt16 invalid index";
	if (arrayIndex >= count/16) throw L"Sys::BoolArray::GetInt16 invalid index";
	__int16 value = -1;
	memcpy(&value, &data[arrayIndex*2], 2);
	return value;
}

__int32 BoolArray::GetInt32(int arrayIndex) const
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::GetInt32 invalid index";
	if (arrayIndex >= count/32) throw L"Sys::BoolArray::GetInt32 invalid index";
	__int32 value = -1;
	memcpy(&value, &data[arrayIndex*4], 4);
	return value;
}

__int64 BoolArray::GetInt64(int arrayIndex) const
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::GetInt64 invalid index";
	if (arrayIndex >= count/64) throw L"Sys::BoolArray::GetInt64 invalid index";
	__int64 value = -1;
	memcpy(&value, &data[arrayIndex*8], 8);
	return value;
}

void BoolArray::SetInt8(int arrayIndex, __int8 value)
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::SetInt8 invalid index";
	if (arrayIndex >= count/8) throw L"Sys::BoolArray::SetInt8 invalid index";
	memcpy(&data[arrayIndex], &value, 1);
}

void BoolArray::SetInt16(int arrayIndex, __int16 value)
{
	if (arrayIndex < 0)  throw L"Sys::BoolArray::SetInt16 invalid index";
	if (arrayIndex >= count/16) throw L"Sys::BoolArray::SetInt16 invalid index";
	memcpy(&data[arrayIndex*2], &value, 2);
}

void BoolArray::SetInt32(int arrayIndex, __int32 value)
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::SetInt32 invalid index";
	if (arrayIndex >= count/32) throw L"Sys::BoolArray::SetInt32 invalid index";
	memcpy(&data[arrayIndex*4], &value, 4);
}

void BoolArray::SetInt64(int arrayIndex, __int64 value)
{
	if (arrayIndex < 0) throw L"Sys::BoolArray::SetInt64 invalid index";
	if (arrayIndex >= count/64) throw L"Sys::BoolArray::SetInt64 invalid index";
	memcpy(&data[arrayIndex*8], &value, 8);
}

// It copies the specified bits from one array to the other one in the same position in both arrays
bool BoolArray::CopyBits(const BoolArray& source, int indexStart, int indexEnd)
{
	if (indexStart < 0) return false;
	if (indexEnd >= count ) return false;
	if (indexStart > indexEnd) return false;
	if (source.GetCount() <= indexEnd) return false;
	const int nstart = indexStart/8;
	const int rstart = indexStart%8;
	const int nend = indexEnd/8;
	const int rend = indexEnd%8;
	const int ndelta = nend-nstart;

	int i;

	if (ndelta == 0) //______________________________ In the same byte block
	{
		if (rstart == 0 && rend == 7) // One block
		{
			data[nstart] = source.data[nstart];
		}
		else
		{
			for(i = indexStart; i <= indexEnd; i++) // bit a bit
			{
				SetBit(i, source.GetBit(i));
			}
		}
	}
	else if (ndelta == 1)//____________________________ In two consecutive byte blocks
	{
		//_________________ First Bits
		if (rstart == 0) // One block
		{
			data[nstart] = source.data[nstart];
		}
		else
		{
			for(i = indexStart; i%8 != 0; i++)
			{
				SetBit(i, source.GetBit(i));
			}
		}
		//_________________ Last Bits
		if (rend == 7) // One block
		{
			data[nend] = source.data[nend];
		}
		else
		{
			for(i = indexEnd; i >0; i--)
			{
				SetBit(i, source.GetBit(i));
				if (i%8 == 0) break;
			}
		}
	}
	else //________________________________________ In three or more consecutive byte blocks
	{
		//_________________ First Bits
		if (rstart == 0) // One block
		{
			data[nstart] = source.data[nstart];
		}
		else
		{
			for(i = indexStart; i%8 != 0; i++)
			{
				SetBit(i, source.GetBit(i));
			}
		}
		//_______________ Copy Byte to Byte
		for(i = nstart+1; i < nend; i++)
		{
			data[i] = source.data[i];
		}
		//_________________ Last Bits
		if (rend == 7) // One block
		{
			data[nend] = source.data[nend];
		}
		else
		{
			for(i = indexEnd; i >0; i--)
			{
				SetBit(i, source.GetBit(i));
				if (i%8 == 0) break;
			}
		}
	}
	return true;
}

bool BoolArray::GetBit(int bitIndex) const
{
	const int n = bitIndex/8;
	const int r = bitIndex%8;
	char c = data[n];
	char tmp = (1<<r);
	return ( (c & tmp) != 0);
}

void BoolArray::SetBit(int bitIndex, bool value)
{
	const int n = bitIndex/8;
	const int r = bitIndex%8;
	if (value)
		data[n] = data[n] | (1<<r);
	else
		data[n] = data[n] & ~(1<<r);
}

void BoolArray::FlipBit(int bitIndex)
{
	const int n = bitIndex/8;
	const int r = bitIndex%8;
	const char c = data[n];
	const char tmp = (1<<r);
	bool value =  ( (c & tmp) != 0);

	if (value==false)
		data[n] = data[n] | (1<<r);
	else
		data[n] = data[n] & ~(1<<r);
}

bool BoolArray::operator==(const Sys::BoolArray& init) const
{
	if (this->count != init.count) return false;
	int n = count/8+1;
	for(int i = 0; i<n; i++)
	{
		if (data[i]!=init.data[i]) return false;
	}
	return true;
}

//______________________________________________________________________ HhpFile
HhpFile::HhpFile()
{
}

HhpFile::~HhpFile()
{
	file.WriteText("\r\n[INFOTYPES]");
}

bool HhpFile::Create(const wchar_t* path, const wchar_t* productName, const wchar_t* title, bool includeIndexFile)
{
	wchar_t text[1024];
	string asciiText;
	_snwprintf_s(text, 1024, _TRUNCATE, L"%s\\%s.hhp", path, productName);
	if (file.CreateForWritting(text) == false) return false;

	file.WriteText("[OPTIONS]\r\nAuto Index=Yes\r\n");
	file.WriteText("Compatibility=1.1 or later\r\n");
	Sys::Convert::WstringToString(productName, asciiText);
	//________________________________________ Compiled file
	file.WriteText("Compiled file=");
	file.WriteText(asciiText);
	file.WriteText(".chm\r\n");
	//________________________________________ Contents file
	file.WriteText("Contents file=");
	file.WriteText(asciiText);
	file.WriteText(".hhc\r\n");
	//
	file.WriteText("Default topic=index.htm\r\n");
	file.WriteText("Display compile progress=Yes\r\n");
	//________________________________________ Log file
	file.WriteText("Error log file=");
	file.WriteText(asciiText);
	file.WriteText(".log\r\n");
	//
	file.WriteText("Full-text search=Yes\r\n");
	//________________________________________ Index file
	if (includeIndexFile == true)
	{
		file.WriteText("Index file=");
		file.WriteText(asciiText);
		file.WriteText(".hhk\r\n");
	}
	file.WriteText("Language=0x409 English (United States)\r\n");
	//_______________________________________ Title
	Sys::Convert::WstringToString(title, asciiText);
	file.WriteText("Title=");
	file.WriteText(asciiText);
	file.WriteText("\r\n");

	file.WriteText("\r\n\r\n[FILES]\r\n");
	return true;
}

bool HhpFile::Create(const wstring& path, const wstring& productName, const wstring& title, bool includeIndexFile)
{
	return Create(path.c_str(), productName.c_str(), title.c_str(), includeIndexFile);
}

void HhpFile::AddItem(const wchar_t* filename)
{
	string asciiFilename;
	Sys::Convert::WstringToString(filename, asciiFilename);
	file.WriteText(asciiFilename);
	file.WriteText("\r\n");
}

void HhpFile::AddItem(const wstring& filename)
{
	AddItem(filename.c_str());
}

//______________________________________________________________________ HhcFile
HhcFile::HhcFile()
{
	indentLevel = 0;
}

HhcFile::~HhcFile()
{
	file.WriteText("</UL>\r\n</BODY>\r\n</HTML>");
}

bool HhcFile::Create(const wchar_t* filename, bool useFolderImage)
{
	indentLevel = 0;
	char * head = "<HTML>\r\n\
<HEAD>\r\n\
<meta name=\"GENERATOR\" content=\"Microsoft&reg; HTML Help Workshop 4.1\">\r\n\
<!-- Sitemap 1.0 -->\r\n\
</HEAD><BODY>\r\n\
<OBJECT type=\"text/site properties\">\r\n\
	<param name=\"ImageType\" value=\"Folder\">\r\n\
</OBJECT>\r\n\
<UL>\r\n";
	if (file.CreateForWritting(filename) == false) return false;
	if (file.WriteText(head)==false) return false;
	indentLevel++;
	return true;
}

void HhcFile::AddTabs()
{
	for(int i=0; i<indentLevel; i++) file.WriteText("\t");
}

bool HhcFile::Create(const wstring& filename, bool useFolderImage)
{
	return Create(filename.c_str(), useFolderImage);
}

void HhcFile::AddFolder(const wchar_t* name)
{
	AddFolder(name, 0);
}

void HhcFile::AddFolder(const wchar_t* name, int imageIndex)
{
	AddFolderItem(name, NULL, imageIndex);
	AddTabs();
	file.WriteText("<UL>\r\n");
	indentLevel++;
}

void HhcFile::CloseFolder()
{
	AddTabs();
	file.WriteText("</UL>\r\n");  
	indentLevel--;
}

void HhcFile::AddFolderItem(const wchar_t* itemName, const wchar_t* filename)
{
	AddFolderItem(itemName, filename, 0);
}

void HhcFile::AddFolderItem(const wchar_t* itemName, const wchar_t* filename, int imageIndex)
{
	AddTabs();
	wchar_t buffer[1024];
	string asciiText;

	_snwprintf_s(buffer, 1024, _TRUNCATE, L"<LI><OBJECT type=\"text/sitemap\">\r\n");
	Sys::Convert::WstringToString(buffer, asciiText);
	file.WriteText(asciiText);
	//___________________________________________________________________ itemName
	AddTabs();
	_snwprintf_s(buffer, 1024, _TRUNCATE, L"\t<param name=\"Name\" value=\"%s\">\r\n", itemName);
	Sys::Convert::WstringToString(buffer, asciiText);
	file.WriteText(asciiText);
	//___________________________________________________________________ filename
	if (filename != NULL)
	{
		AddTabs();
		_snwprintf_s(buffer, 1024, _TRUNCATE, L"\t<param name=\"Local\" value=\"%s\">\r\n", filename);
		Sys::Convert::WstringToString(buffer, asciiText);
		file.WriteText(asciiText);
	}
	if (0 < imageIndex && imageIndex < 43)
	{
		AddTabs();
		_snwprintf_s(buffer, 1024, _TRUNCATE, L"\t<param name=\"ImageNumber\" value=\"%d\">\r\n", imageIndex);
		Sys::Convert::WstringToString(buffer, asciiText);
		file.WriteText(asciiText);
	}
	AddTabs();
	file.WriteText("</OBJECT>\r\n");
}

//______________________________________________________________________ HhkFile
HhkFile::HhkFile()
{
	Sys::TextAssistant::GetStopWordsInEnglish(englishWords);
	Sys::TextAssistant::GetStopWordsInSpanish(spanishWords);
}

HhkFile::~HhkFile()
{
}

void HhkFile::AppendKeywordObject(const wstring& docText, wstring& whtml)
{
	wstring tmp(docText);
	set<wstring> wordList;
	Sys::TextAssistant::ToLower(tmp);
	Sys::TextAssistant::ReplaceAccents(tmp);
	Sys::TextAssistant::GetWordList(tmp.c_str(), wordList);
	//
	set<wstring>::iterator p;
	wstring keyword;
	set<wstring>::const_iterator wend = wordList.end();
	wchar_t text[512];
	for (p = wordList.begin(); p != wend; p++)
	{
		keyword = *p;
		if (englishWords.find(keyword) != englishWords.end()) continue;
		if (spanishWords.find(keyword) != spanishWords.end()) continue;
		if (IsValidKeyword(keyword) == false) continue;
		whtml += L"<object type=\"application/x-oleobject\" classid=\"clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e\">\r\n";
		//
		Sys::TextAssistant::FirstUppercase(keyword);
		_snwprintf_s(text, 512, _TRUNCATE, L"<param name=\"Keyword\" value=\"%s\">\r\n", keyword.c_str());
		whtml += text;
		whtml += L"</object>\r\n";
	}
}

bool HhkFile::IsValidKeyword(const wstring& input)
{
	const size_t len = input.size();
	if (len == 1) return false;
	if (len == 2 && input[0] == '@' && input[1] == '@') return false;
	if (len >= 2)
	{
		//_________________________________________________ @@
		if (input[0] == '@')
		{
			if (input[1] == '@')
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		//_________________________________________________ ##
		if (input[0] == '#' && input[1] == '#') return false;
	}

	for (register size_t i = 0; i < len; i++)
	{
		if ('0' <= input[i] && input[i] <= '9') return false;
		if (input[i] == '_') return false;
		if (input[i] == '-') return false;
		if (input[i] == '\'') return false;
		if (input[i] == '~') return false;
		if (input[i] == '"') return false;
		if (input[i] == '^') return false;
		if (input[i] == '$') return false;
	}
	return true;
}


//_____________________________________________________________________ Win::Components::Cursor
Cursor::Cursor(void)
{
	hcursor = NULL;
	deleteCursor = true;
}

Cursor::~Cursor(void)
{
	Delete();
}

void Cursor::CreateDragDrop(HINSTANCE hInstance)
{
	BYTE andCursor[] = 
	{ 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 1 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 2 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 3 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 4 

		0xFF, 0xFF, 0xFF, 0xFF,   // line 5 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 6 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 7 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 8 

		0xFF, 0xFF, 0x3F, 0xFF,   // line 9 
		0xFF, 0xFF, 0x1F, 0xFF,   // line 10 
		0xFF, 0xFF, 0x0F, 0xFF,   // line 11 
		0xFF, 0xFF, 0x07, 0xFF,   // line 12 

		0xFF, 0xFF, 0x03, 0xFF,   // line 13 
		0xFF, 0xFF, 0x01, 0xFF,   // line 14 
		0xFF, 0xFF, 0x00, 0xFF,   // line 15 
		0xFF, 0xFF, 0x00, 0x7F,   // line 16 

		0xFF, 0xFF, 0x00, 0x3F,   // line 17 
		0xFF, 0xFF, 0x00, 0x1F,   // line 18 
		0xFF, 0xFF, 0x00, 0x0F,   // line 19 
		0xFF, 0xFF, 0x00, 0xFF,   // line 20 

		0xFF, 0xFF, 0x00, 0xFF,   // line 21 
		0xFF, 0xFF, 0x18, 0x7F,   // line 22 
		0xFF, 0xFF, 0x38, 0x7F,   // line 23 
		0xFF, 0xFF, 0x64, 0x00,   // line 24 

		0xFF, 0xFF, 0xE0, 0x20,   // line 25 
		0xFF, 0xFF, 0xE6, 0x1C,   // line 26 
		0xFF, 0xFF, 0xE6, 0x1C,   // line 27 
		0xFF, 0xFF, 0xE7, 0x7C,   // line 28 

		0xFF, 0xFF, 0xE7, 0xFC,   // line 29 
		0xFF, 0xFF, 0xE7, 0xFC,   // line 30 
		0xFF, 0xFF, 0xE0, 0x00,   // line 31 
		0xFF, 0xFF, 0xE0, 0x00    // line 32 
	};

	BYTE xorCursor[] = 
	{ 
		0x00, 0x00, 0x00, 0x00,   // line 1 
		0x00, 0x00, 0x00, 0x00,   // line 2 
		0x00, 0x00, 0x00, 0x00,   // line 3 
		0x00, 0x00, 0x00, 0x00,   // line 4 

		0x00, 0x00, 0x00, 0x00,   // line 5 
		0x00, 0x00, 0x00, 0x00,   // line 6 
		0x00, 0x00, 0x00, 0x00,   // line 7 
		0x00, 0x00, 0x00, 0x00,   // line 8 

		0x00, 0x00, 0x00, 0x00,   // line 9 
		0x00, 0x00, 0x40, 0x00,   // line 10 
		0x00, 0x00, 0x60, 0x00,   // line 11 
		0x00, 0x00, 0x70, 0x00,   // line 12 

		0x00, 0x00, 0x78, 0x00,   // line 13 
		0x00, 0x00, 0x7C, 0x00,   // line 14 
		0x00, 0x00, 0x7E, 0x00,   // line 15 
		0x00, 0x00, 0x7F, 0x00,   // line 16 

		0x00, 0x00, 0x7F, 0x80,   // line 17 
		0x00, 0x00, 0x7F, 0xC0,   // line 18 
		0x00, 0x00, 0x7E, 0x00,   // line 19 
		0x00, 0x00, 0x7E, 0x00,   // line 20 

		0x00, 0x00, 0x66, 0x00,   // line 21 
		0x00, 0x00, 0x43, 0x00,   // line 22 
		0x00, 0x00, 0x03, 0x00,   // line 23 
		0x00, 0x00, 0x09, 0xAA,   // line 24 

		0x00, 0x00, 0x15, 0x95,   // line 25 
		0x00, 0x00, 0x08, 0xC2,   // line 26 
		0x00, 0x00, 0x10, 0x81,   // line 27 
		0x00, 0x00, 0x08, 0x02,   // line 28 

		0x00, 0x00, 0x10, 0x01,   // line 29 
		0x00, 0x00, 0x08, 0x02,   // line 30 
		0x00, 0x00, 0x15, 0x55,   // line 31 
		0x00, 0x00, 0x0A, 0xAA    // line 32 
	};
	Delete();
	deleteCursor = true;
	hcursor = ::CreateCursor(hInstance,   // app. instance 
             19,                // horizontal position of hot spot 
             2,                 // vertical position of hot spot 
             32,                // cursor width 
             32,                // cursor height 
             andCursor,     // AND mask 
             xorCursor );   // XOR mask 
}

void Cursor::CreateHorzSplit(HINSTANCE hInstance)
{
	BYTE andCursor[] = 
	{ 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 1 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 2 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 3 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 4 

		0xFF, 0xFF, 0xFF, 0xFF,   // line 5 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 6 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 7 
		0xFF, 0xFE, 0xFF, 0xFF,   // line 8 

		0xFF, 0xFC, 0x7F, 0xFF,   // line 9 
		0xFF, 0xF8, 0x3F, 0xFF,   // line 10 
		0xFF, 0xF0, 0x1F, 0xFF,   // line 11 
		0xFF, 0xF8, 0x3F, 0xFF,   // line 12 

		0xFE, 0x00, 0x00, 0xFF,   // line 13 
		0xFE, 0x00, 0x00, 0xFF,   // line 14 
		0xFE, 0x00, 0x00, 0xFF,   // line 15 
		0xFE, 0x00, 0x00, 0xFF,   // line 16 

		0xFE, 0x00, 0x00, 0xFF,   // line 17 
		0xFE, 0x00, 0x00, 0xFF,   // line 18 
		0xFF, 0xF8, 0x3F, 0xFF,   // line 19 
		0xFF, 0xF0, 0x1F, 0xFF,   // line 20 

		0xFF, 0xF8, 0x3F, 0xFF,   // line 21 
		0xFF, 0xFC, 0x7F, 0xFF,   // line 22 
		0xFF, 0xFE, 0xFF, 0xFF,   // line 23 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 24 

		0xFF, 0xFF, 0xFF, 0xFF,   // line 25 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 26 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 27 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 28 

		0xFF, 0xFF, 0xFF, 0xFF,   // line 29 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 30 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 31 
		0xFF, 0xFF, 0xFF, 0xFF    // line 32 
	};
 

	BYTE xorCursor[] = 
	{ 
		0x00, 0x00, 0x00, 0x00,   // line 1 
		0x00, 0x00, 0x00, 0x00,   // line 2 
		0x00, 0x00, 0x00, 0x00,   // line 3 
		0x00, 0x00, 0x00, 0x00,   // line 4 

		0x00, 0x00, 0x00, 0x00,   // line 5 
		0x00, 0x00, 0x00, 0x00,   // line 6 
		0x00, 0x00, 0x00, 0x00,   // line 7 
		0x00, 0x01, 0x00, 0x00,   // line 8 

		0x00, 0x02, 0x80, 0x00,   // line 9 
		0x00, 0x04, 0x40, 0x00,   // line 10 
		0x00, 0x08, 0x20, 0x00,   // line 11 
		0x00, 0x06, 0xC0, 0x00,   // line 12 

		0x01, 0xFE, 0xFF, 0x00,   // line 13 
		0x01, 0x00, 0x01, 0x00,   // line 14 
		0x01, 0xFF, 0xFF, 0x00,   // line 15 
		0x01, 0xFF, 0xFF, 0x00,   // line 16 

		0x01, 0x00, 0x01, 0x00,   // line 17 
		0x01, 0xFE, 0xFF, 0x00,   // line 18 
		0x00, 0x06, 0xC0, 0x00,   // line 19 
		0x00, 0x08, 0x20, 0x00,   // line 20 

		0x00, 0x04, 0x40, 0x00,   // line 21 
		0x00, 0x02, 0x80, 0x00,   // line 22 
		0x00, 0x01, 0x00, 0x00,   // line 23 
		0x00, 0x00, 0x00, 0x00,   // line 24 

		0x00, 0x00, 0x00, 0x00,   // line 25 
		0x00, 0x00, 0x00, 0x00,   // line 26 
		0x00, 0x00, 0x00, 0x00,   // line 27 
		0x00, 0x00, 0x00, 0x00,   // line 28 

		0x00, 0x00, 0x00, 0x00,   // line 29 
		0x00, 0x00, 0x00, 0x00,   // line 30 
		0x00, 0x00, 0x00, 0x00,   // line 31 
		0x00, 0x00, 0x00, 0x00    // line 32 
	};
	Delete();
	deleteCursor = true;
	hcursor = ::CreateCursor(hInstance,   // app. instance 
             19,                // horizontal position of hot spot 
             19,                 // vertical position of hot spot 
             32,                // cursor width 
             32,                // cursor height 
             andCursor,     // AND mask 
             xorCursor );   // XOR mask 
}

void Cursor::CreateVertSplit(HINSTANCE hInstance)
{
	BYTE andCursor[] = 
	{ 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 1 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 2 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 3 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 4 

		0xFF, 0xFF, 0xFF, 0xFF,   // line 5 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 6 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 7 
		0xFF, 0xFE, 0xFF, 0xFF,   // line 8 

		0xFF, 0xF8, 0x1F, 0xFF,   // line 9 
		0xFF, 0xF8, 0x1F, 0xFF,   // line 10 
		0xFF, 0xF8, 0x1F, 0xFF,   // line 11 
		0xFF, 0xF8, 0x1F, 0xFF,   // line 12 

		0xFF, 0xD8, 0x1B, 0xFF,   // line 13 
		0xFF, 0x88, 0x11, 0xFF,   // line 14 
		0xFF, 0x00, 0x00, 0xFF,   // line 15 
		0xFE, 0x00, 0x00, 0x7F,   // line 16 

		0xFF, 0x00, 0x00, 0xFF,   // line 17 
		0xFF, 0x88, 0x11, 0xFF,   // line 18 
		0xFF, 0xD8, 0x1B, 0xFF,   // line 19 
		0xFF, 0xF8, 0x1F, 0xFF,   // line 20 

		0xFF, 0xF8, 0x1F, 0xFF,   // line 21 
		0xFF, 0xF8, 0x1F, 0xFF,   // line 22 
		0xFF, 0xF8, 0x1F, 0xFF,   // line 23 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 24 

		0xFF, 0xFF, 0xFF, 0xFF,   // line 25 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 26 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 27 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 28 

		0xFF, 0xFF, 0xFF, 0xFF,   // line 29 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 30 
		0xFF, 0xFF, 0xFF, 0xFF,   // line 31 
		0xFF, 0xFF, 0xFF, 0xFF    // line 32 
	};
 
	// Yin-shaped cursor XOR mask 

	BYTE xorCursor[] = 
	{ 
		0x00, 0x00, 0x00, 0x00,   // line 1 
		0x00, 0x00, 0x00, 0x00,   // line 2 
		0x00, 0x00, 0x00, 0x00,   // line 3 
		0x00, 0x00, 0x00, 0x00,   // line 4 

		0x00, 0x00, 0x00, 0x00,   // line 5 
		0x00, 0x00, 0x00, 0x00,   // line 6 
		0x00, 0x00, 0x00, 0x00,   // line 7 
		0x00, 0x01, 0x00, 0x00,   // line 8 

		0x00, 0x07, 0xE0, 0x00,   // line 9 
		0x00, 0x05, 0xA0, 0x00,   // line 10 
		0x00, 0x05, 0xA0, 0x00,   // line 11 
		0x00, 0x05, 0xA0, 0x00,   // line 12 

		0x00, 0x25, 0xA4, 0x00,   // line 13 
		0x00, 0x55, 0xAA, 0x00,   // line 14 
		0x00, 0x9D, 0xB9, 0x00,   // line 15 
		0x01, 0x01, 0x80, 0x80,   // line 16 

		0x00, 0x9D, 0xB9, 0x00,   // line 17 
		0x00, 0x55, 0xAA, 0x00,   // line 18 
		0x00, 0x25, 0xA4, 0x00,   // line 19 
		0x00, 0x05, 0xA0, 0x00,   // line 20 

		0x00, 0x05, 0xA0, 0x00,   // line 21 
		0x00, 0x05, 0xA0, 0x00,   // line 22 
		0x00, 0x07, 0xE0, 0x00,   // line 23 
		0x00, 0x00, 0x00, 0x00,   // line 24 

		0x00, 0x00, 0x00, 0x00,   // line 25 
		0x00, 0x00, 0x00, 0x00,   // line 26 
		0x00, 0x00, 0x00, 0x00,   // line 27 
		0x00, 0x00, 0x00, 0x00,   // line 28 

		0x00, 0x00, 0x00, 0x00,   // line 29 
		0x00, 0x00, 0x00, 0x00,   // line 30 
		0x00, 0x00, 0x00, 0x00,   // line 31 
		0x00, 0x00, 0x00, 0x00    // line 32 
	};
	Delete();
	deleteCursor = true;
	hcursor = ::CreateCursor(hInstance,   // app. instance 
             19,                // horizontal position of hot spot 
             19,                 // vertical position of hot spot 
             32,                // cursor width 
             32,                // cursor height 
             andCursor,     // AND mask 
             xorCursor );   // XOR mask 
}

void Cursor::Delete()
{
	if (deleteCursor)
	{
		if (hcursor) ::DestroyCursor(hcursor);
	}
	hcursor = NULL;
}

HCURSOR Cursor::GetHCursor()
{
	return hcursor;
}

HCURSOR Cursor::Load(HINSTANCE hinst, LPCTSTR lpszName, int cxDesired, int cyDesired, UINT fuLoad)
{
	this->Delete();
	deleteCursor = true;
	if (hinst==NULL) return 0;
	hcursor = (HCURSOR)::LoadImage(hinst, lpszName, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
	return hcursor;
}

HCURSOR Cursor::Load(HINSTANCE hinst, int cursor_id)
{
	this->Delete();
	deleteCursor = true;
	if (hinst==NULL) return 0;
	hcursor = (HCURSOR)::LoadImage(hinst, MAKEINTRESOURCE(cursor_id), IMAGE_CURSOR, 0, 0, 0);
	return hcursor;
}

HCURSOR Cursor::Load(LPCTSTR lpszName)
{
	this->Delete();
	deleteCursor = false;
	hcursor = (HCURSOR)::LoadCursor(NULL, lpszName);//::LoadImage(NULL, MAKEINTRESOURCE(lpszName), IMAGE_CURSOR, 0, 0, 0);
	return hcursor;
}

Cursor::operator HCURSOR()
{
	return hcursor;
}

//__________________________________________________________ Win::Components::Icon
Icon::Icon()
{
	hIcon = NULL;
}

Icon::~Icon()
{
	Delete();
}

void Icon::Copy(const Sys::Icon& init)
{
	if (init.hIcon == NULL) return; // Nothing to copy
	hIcon = ::CopyIcon(init.hIcon);
}

bool Icon::GetInformation(int& out_width, int& out_height, int& out_bitsPerPixel)
{
	ICONINFO iconInfo;
	if (::GetIconInfo(hIcon, &iconInfo) == 0) return false;
	BITMAP bitmap;
	if (iconInfo.hbmColor)
	{
		if (GetObject(iconInfo.hbmColor, sizeof(BITMAP), &bitmap) <= 0) return false;
		out_width = bitmap.bmWidth;
		out_height = bitmap.bmHeight;
		out_bitsPerPixel = bitmap.bmBitsPixel;
		//::DeleteObject(iconInfo.hbmColor);
		return true;
	}
	else if (iconInfo.hbmMask)
	{
		if (GetObject(iconInfo.hbmMask, sizeof(BITMAP), &bitmap) <= 0) return false;
		out_width = bitmap.bmWidth;
		out_height = bitmap.bmHeight;
		out_bitsPerPixel = bitmap.bmBitsPixel;
		//::DeleteObject(iconInfo.hbmColor);
		return true;
	}
	return false;
}

Icon::Icon(const Sys::Icon& init)
{
	hIcon = NULL;
	Copy(init);
}

Sys::Icon& Icon::operator=(const Sys::Icon& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Icon::Delete()
{
	if (hIcon) ::DestroyIcon(hIcon);
	hIcon = NULL;
}
HICON Icon::GetHIcon()
{
	return hIcon;
}


HICON Icon::Load(HINSTANCE hInstance, LPCTSTR lpszName, int cxDesired, int cyDesired, UINT fuLoad)
{
	if (hIcon) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadImage(hInstance, lpszName, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
	return hIcon;
}

HICON Icon::Load(HINSTANCE hInstance, int icon_id)
{
	if (hIcon != NULL) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadImage(hInstance, MAKEINTRESOURCE(icon_id), IMAGE_ICON, 0, 0, 0);
	return hIcon;
}

HICON Icon::LoadApplicationIcon(HINSTANCE hInstance)
{
	if (hIcon != NULL) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadIcon(NULL, IDI_APPLICATION);
	return hIcon;
}

HICON Icon::LoadHandIcon(HINSTANCE hInstance)
{
	if (hIcon != NULL) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadIcon(NULL, IDI_HAND);
	return hIcon;
}

HICON Icon::LoadQuestionIcon(HINSTANCE hInstance)
{
	if (hIcon != NULL) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadIcon(NULL, IDI_QUESTION);
	return hIcon;
}

HICON Icon::LoadExclamationIcon(HINSTANCE hInstance)
{
	if (hIcon != NULL) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadIcon(NULL, IDI_EXCLAMATION);
	return hIcon;
}

HICON Icon::LoadAsteriskIcon(HINSTANCE hInstance)
{
	if (hIcon != NULL) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadIcon(NULL, IDI_ASTERISK);
	return hIcon;
}

HICON Icon::LoadWinLogoIcon(HINSTANCE hInstance)
{
	if (hIcon != NULL) ::DestroyIcon(hIcon);
	hIcon = (HICON)::LoadIcon(NULL, IDI_WINLOGO);
	return hIcon;
}

Icon::operator HICON()
{
	return hIcon;
}

//__________________________________________________________ Win::Components::Bitmap
Bitmap::Bitmap()
{
	hbitmap = NULL;
}

Bitmap::~Bitmap()
{
	if (hbitmap) ::DeleteObject(hbitmap);
}

Bitmap::operator HBITMAP()
{
	return hbitmap;
}

HBITMAP Bitmap::Load(HINSTANCE hinst, LPCTSTR lpszName, int cxDesired, int cyDesired, UINT fuLoad)
{
	if (hbitmap) ::DeleteObject(hbitmap);
	hbitmap = (HBITMAP)::LoadImage(hinst, lpszName, IMAGE_BITMAP, cxDesired, cyDesired, fuLoad);
	return hbitmap;
}

HBITMAP Bitmap::GetHBitmap()
{
	return hbitmap;
}

HBITMAP Bitmap::Load(HINSTANCE hinst, int icon_id)
{
	if (hbitmap) ::DeleteObject(hbitmap);
	hbitmap = (HBITMAP)::LoadImage(hinst, MAKEINTRESOURCE(icon_id), IMAGE_BITMAP, 0, 0, 0);
	return hbitmap;
}

//#ifdef  WIN_SOCKETS_SUPPORT
////____________________________________________________________________ Sys::WinINet
//WinINet::WinINet()
//{
//	hSession = NULL;
//	hConnection = NULL;
//	//
//	wstring full_filename;
//	Sys::Information::getCurrentProgramFileName(full_filename);
//	wstring filename;
//	Sys::TextAssistant::ExtractFileName(full_filename.c_str(), false, filename);
//	hSession = ::InternetOpen(filename.c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
//	//hSession = ::InternetOpen(filename.c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, INTERNET_FLAG_ASYNC);
//}
//
//WinINet::WinINet(const wchar_t* agent, DWORD accessType, const wchar_t* proxyName, const wchar_t* proxyBypass, DWORD flags)
//{
//	hSession = NULL;
//	hConnection = NULL;
//	//
//	hSession = ::InternetOpen(agent, accessType, proxyName, proxyBypass, flags);
//}
//
//WinINet::~WinINet()
//{
//	if (hConnection != NULL) ::InternetCloseHandle(hConnection);
//	if (hSession != NULL) ::InternetCloseHandle(hSession);
//}
//
//HINTERNET WinINet::Connect(const wchar_t* serverName, INTERNET_PORT serverPort, const wchar_t* username, const wchar_t* password,
//	DWORD service, DWORD flags, DWORD_PTR context)
//{
//	if (hSession == NULL) return NULL;
//	CloseConnection();
//	hConnection = ::InternetConnect(hSession, serverName, serverPort, username, password, service, flags, context);
//	return hConnection;
//}
//
//HINTERNET WinINet::ConnectFtp(const wchar_t* serverName, INTERNET_PORT serverPort, const wchar_t* username, const wchar_t* password)
//{
//	if (hSession == NULL) return NULL;
//	CloseConnection();
//	hConnection = ::InternetConnect(hSession, serverName, serverPort, username, password, INTERNET_SERVICE_HTTP, 0, NULL);
//	return hConnection;
//}
//
//HINTERNET WinINet::ConnectHttp(const wchar_t* serverName, INTERNET_PORT serverPort, const wchar_t* username, const wchar_t* password)
//{
//	if (hSession == NULL) return NULL;
//	CloseConnection();
//	hConnection = ::InternetConnect(hSession, serverName, serverPort, username, password, INTERNET_SERVICE_HTTP, 0, NULL);
//	return hConnection;
//}
//
//void WinINet::CloseSession()
//{
//	if (hSession != NULL) ::InternetCloseHandle(hSession);
//	hSession = NULL;
//}
//
//void WinINet::CloseConnection()
//{
//	if (hConnection != NULL) ::InternetCloseHandle(hConnection);
//	hConnection = NULL;
//}
//
//void WinINet::CloseAll()
//{
//	if (hConnection != NULL) ::InternetCloseHandle(hConnection);
//	hConnection = NULL;
//	//
//	if (hSession != NULL) ::InternetCloseHandle(hSession);
//	hSession = NULL;
//}
//
//HINTERNET WinINet::GetConnection()
//{
//	return hConnection;
//}
//
//HINTERNET WinINet::GetSession()
//{
//	return hSession;
//}
//
////____________________________________________________________________ Sys::HttpRequest
//HttpRequest::HttpRequest()
//{
//	hHttpRequest = NULL;
//}
//
//HttpRequest::~HttpRequest()
//{
//	if (hHttpRequest != NULL) ::InternetCloseHandle(hHttpRequest);
//	hHttpRequest = NULL;
//}
//
//HINTERNET HttpRequest::Create(Sys::WinINet& wininet, const wchar_t* verb, const wchar_t* objectName, const wchar_t* version, const wchar_t* referer,
//	const wchar_t** acceptType, DWORD flags, DWORD_PTR context)
//{
//	if (hHttpRequest != NULL) ::InternetCloseHandle(hHttpRequest);
//	hHttpRequest = NULL;
//	//
//	hHttpRequest = ::HttpOpenRequest(wininet.GetConnection(), verb, objectName, version, referer, acceptType, flags, context);
//	return hHttpRequest;
//}
//
//void HttpRequest::Close()
//{
//	if (hHttpRequest != NULL) ::InternetCloseHandle(hHttpRequest);
//	hHttpRequest = NULL;
//}
//
//bool HttpRequest::Send(const wchar_t* header, DWORD headersLength, LPVOID optional, DWORD optionalLength)
//{
//	return (::HttpSendRequest(hHttpRequest, header, headersLength, optional, optionalLength) == TRUE);
//}
//
//DWORD HttpRequest::ErrorDlg(HWND  hWnd, DWORD dwError, DWORD flags, LPVOID *lppvData)
//{
//	return ::InternetErrorDlg(hWnd, hHttpRequest, dwError, flags, lppvData);
//}
//
//bool HttpRequest::QueryInfo(DWORD infoLevel, LPVOID buffer, LPDWORD bufferLength, LPDWORD index)
//{
//	return (::HttpQueryInfo(hHttpRequest, infoLevel, buffer, bufferLength, index) == TRUE);
//}
//
//bool HttpRequest::SetOption(DWORD option, LPVOID buffer, DWORD bufferLength)
//{
//	return (::InternetSetOption(hHttpRequest, option, buffer, bufferLength) == TRUE);
//}
//
//bool HttpRequest::SetUsername(const wchar_t* username)
//{
//	return (::InternetSetOption(hHttpRequest, INTERNET_OPTION_USERNAME, (LPVOID)username, (DWORD)(wcslen(username)+1)) == TRUE);
//}
//
//bool HttpRequest::SetPassword(const wchar_t* password)
//{
//	return (::InternetSetOption(hHttpRequest, INTERNET_OPTION_PASSWORD, (LPVOID)password, (DWORD)(wcslen(password)+1)) == TRUE);
//}
//
//bool HttpRequest::SetProxyUsername(const wchar_t* username)
//{
//	return (::InternetSetOption(hHttpRequest, INTERNET_OPTION_PROXY_USERNAME, (LPVOID)username, (DWORD)(wcslen(username)+1)) == TRUE);
//}
//
//bool HttpRequest::SetProxyPassword(const wchar_t* password)
//{
//	return (::InternetSetOption(hHttpRequest, INTERNET_OPTION_PROXY_PASSWORD, (LPVOID)password, (DWORD)(wcslen(password)+1)) == TRUE);
//}
//
//bool HttpRequest::Read(LPVOID buffer, DWORD numberOfBytesToRead, LPDWORD numberOfBytesToRead)
//{
//	return (::InternetReadFile(hHttpRequest, buffer, numberOfBytesToRead, numberOfBytesToRead) == TRUE);
//}
//
//#endif

} //____________________________________________________ namespace Sys::End

namespace Mt //________________________________________ namespace Mt::Ini
{
//__________________________________________OverlappedE

//__________________________________________Deque
int Deque::Insert(char *data, int count)
{
	::EnterCriticalSection(&cs);
	int actual = MT_DEQUE_MAX_SIZE-(int)queue.size();
	actual = (actual<0) ? 0 : count;
	for(int i = 0; i<actual; i++) queue.push_back(*data++);
	::LeaveCriticalSection(&cs);
	return actual;
}

int Deque::Extract(char *data, int MAXIMUM)
{
	int i = 0;
	::EnterCriticalSection(&cs);
	while(i<MAXIMUM && queue.size())
	{
		data[i++]=queue.front();
		queue.pop_front();
	}
	::LeaveCriticalSection(&cs);
	return i;
}

int Deque::Peek(char *data, int MAXIMUM)
{
	int i = 0;
	::EnterCriticalSection(&cs);
	if (MAXIMUM>(int)queue.size()) MAXIMUM = (int)queue.size();
	for(i=0; i<MAXIMUM; i++) data[i]=queue.begin()[i];
	::LeaveCriticalSection(&cs);
	return i;
}

int Deque::Extract()
{
	int value = -1;
	::EnterCriticalSection(&cs);
	if (queue.size())
	{
		value = queue.front() & 0xff;
		queue.pop_front();
	}
	::LeaveCriticalSection(&cs);
	return value;
}
//____________________________________________________________EventI
static void DisplayLastError(HWND hWnd, wchar_t* pWhere)
{
	if (pWhere==NULL) pWhere = L"Error";
	LPVOID lpMsgBuf;
	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox(hWnd, (LPCTSTR)lpMsgBuf, pWhere, MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}
//____________________________________________________________CriticalSection
//____________________________________________________________EventI
//____________________________________________________________Gate
//____________________________________________________________MultipleObjects
//____________________________________________________________Long
//____________________________________________________________Bool
//____________________________________________________________IOCport
//____________________________________________________________IOCportTimer
	IOCportTimer::IOCportTimer(void)
{
	m_h = NULL;
	m_group.completionKey = 0;
	m_group.iocp = NULL;
	m_group.running = false;
	m_group.handle = NULL;
}

IOCportTimer::~IOCportTimer(void)
{

}

bool IOCportTimer::Start(Mt::IOCport* iocp, ULONG_PTR completionKey, int iniMillisec, int repeatMillisec)
{
	if (m_group.running) return false;

	LARGE_INTEGER li;
	Destructor();

	m_h = CreateWaitableTimer(NULL, FALSE, NULL);
	if (m_h == NULL) return false;

	li.QuadPart = (-10000)*iniMillisec;
	SetWaitableTimer(m_h, &li, repeatMillisec, NULL, NULL, FALSE);
	m_group.completionKey = completionKey;
	m_group.iocp = iocp;
	m_group.running = true;
	m_group.handle = m_h;
	_beginthread(Repeat, 0, &m_group);

	return true;
}

void IOCportTimer::Repeat(PVOID pvoid)
{
	IOCportTimer::group_* pGroup = (IOCportTimer::group_*)pvoid;
	DWORD dwResult = 0;

	while(pGroup->running)
	{
		dwResult = WaitForSingleObject(pGroup->handle, INFINITE);
		{
			switch(dwResult)
			{
			case WAIT_OBJECT_0:
				pGroup->iocp->PostStatus(pGroup->completionKey);
				break;
			case WAIT_ABANDONED:
				break;
			case WAIT_TIMEOUT:
				break;
//			default:
//				Mt::IOCportTimer::DisplayLastError(L"IOCportTimer::Repeat", false);
			}
		}
	}
	if (pGroup->handle)
	{
		CloseHandle(pGroup->handle);
	}
}

void IOCportTimer::DisplayLastError(const wchar_t* pszWhere, bool bServiceNotification)
{
	LPVOID lpMsgBuf;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, pszWhere, 
		bServiceNotification ? MB_SERVICE_NOTIFICATION : MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}

void IOCportTimer::Stop()
{
	m_group.running = false;
	m_h = NULL;
}

void IOCportTimer::Destructor()
{
	if (m_h)
	{
		CloseHandle(m_h);
		m_h = NULL;
	}
}

//____________________________________________________________StringTs
StringTs::StringTs(void)
{
	pData = NULL;
	::InitializeCriticalSection(&cs);
}

StringTs::~StringTs(void)
{
	::EnterCriticalSection(&cs);
	if (pData) delete [] pData;
	::LeaveCriticalSection(&cs);
	//
	::DeleteCriticalSection(&cs);
}

bool StringTs::Set(const wchar_t* text)
{
	bool ok = false;
	if (text==NULL) return false;
	::EnterCriticalSection(&cs);
	if (pData) delete [] pData;
	pData = new wchar_t[lstrlen(text)+1];
	if (pData) ok = true;
	lstrcpy(pData, text);
	::LeaveCriticalSection(&cs);
	return ok;
}

int StringTs::GetLength()
{
	if (pData==NULL) return 0;
	int n;
	::EnterCriticalSection(&cs);
	n = lstrlen(pData);
	::LeaveCriticalSection(&cs);
	return n;
}

bool StringTs::CopyData(wchar_t* buffer, int bufferSize)
{
	if (buffer==NULL) return false;
	if (pData==NULL)
	{
		buffer[0]='\0';
		return true;
	}
	int n;
	::EnterCriticalSection(&cs);
	n = lstrlen(pData)+1;
	if (bufferSize<n) n = bufferSize;
	lstrcpyn(buffer, pData, n);
	::LeaveCriticalSection(&cs);
	return true;
}



//Example:
//	wchar_t *info=NULL;
//	stringts.CreateCopyData(&info);
//	edit.SetWindowText(info);
//	if (info) delete [] info;
int StringTs::CreateCopyData(wchar_t** buffer) //It allocates new memory that must be released manually
{
	int length = 0;
	::EnterCriticalSection(&cs);
	if (pData)
	{
		length = lstrlen(pData);
		*buffer = new wchar_t[length+1];
		lstrcpy(*buffer, pData);
	}
	::LeaveCriticalSection(&cs);
	return length;
}

//Example:
//	wchar_t *info=NULL;
//	stringts.ExtractCopyData(&info);
//	edit.SetWindowText(info);
//	if (info) delete [] info;
int StringTs::ExtractCopyData(wchar_t** buffer) //It allocates new memory that must be released manually
{
	int length = 0;
	::EnterCriticalSection(&cs);
	if (pData)
	{
		length = lstrlen(pData);
		*buffer = new wchar_t[length+1];
		lstrcpy(*buffer, pData);
		delete [] pData;
		pData = NULL;
	}
	::LeaveCriticalSection(&cs);
	return length;
}

//____________________________________________________________ WstringTs
WstringTs::WstringTs(void)
{
	::InitializeCriticalSection(&cs);
}

WstringTs::~WstringTs(void)
{
	::EnterCriticalSection(&cs);
	data.clear();
	::LeaveCriticalSection(&cs);
	//
	::DeleteCriticalSection(&cs);
}

void WstringTs::Set(const wstring& text)
{
	::EnterCriticalSection(&cs);
	data = text;
	::LeaveCriticalSection(&cs);
}

void WstringTs::Concat(const wstring& text)
{
	::EnterCriticalSection(&cs);
	data += text;
	::LeaveCriticalSection(&cs);
}

void WstringTs::Get(wstring& out_text)
{
	::EnterCriticalSection(&cs);
	out_text = data;
	::LeaveCriticalSection(&cs);
}

void WstringTs::GetAndClear(wstring& out_text)
{
	::EnterCriticalSection(&cs);
	out_text = data;
	data.clear();
	::LeaveCriticalSection(&cs);
}

bool WstringTs::SetTry(const wstring& text)
{
	if (::TryEnterCriticalSection(&cs)==0) return false;
	data = text;
	::LeaveCriticalSection(&cs);
	return true;
}

bool WstringTs::ConcatTry(const wstring& text)
{
	if (::TryEnterCriticalSection(&cs)==0) return false;
	data += text;
	::LeaveCriticalSection(&cs);
	return true;
}

bool WstringTs::GetTry(wstring& out_text)
{
	if (::TryEnterCriticalSection(&cs)==0) return false;
	out_text = data;
	::LeaveCriticalSection(&cs);
	return true;
}

bool WstringTs::GetAndClearTry(wstring& out_text)
{
	if (::TryEnterCriticalSection(&cs)==0) return false;
	out_text = data;
	data.clear();
	::LeaveCriticalSection(&cs);
	return true;
}

//____________________________________________________________IOCport

//____________________________________________________________IOCportTimer

//____________________________________________________________ InputOutputRequest
//____________________________________________________________ InputOutputRequestX
InputOutputRequestX::InputOutputRequestX() 
{
	Internal = InternalHigh = 0;   
	Offset = OffsetHigh = 0;   
	hEvent = NULL;
	bufferSize = 0;
	dataA = NULL;
	dataB = NULL;
	//
	bytesA = 0;
	bytesB = 0;
	sizeint = (int)( log((double)sizeof(int)) / log(2.0) );
}

InputOutputRequestX::~InputOutputRequestX() 
{
	if (dataA != NULL) ::VirtualFree(dataA, 0, MEM_RELEASE);
	if (dataB != NULL) ::VirtualFree(dataB, 0, MEM_RELEASE);
	//if (dataA != NULL) delete [] dataA;
	//if (dataB != NULL) delete [] dataB;
}

bool InputOutputRequestX::AllocBuffer(SIZE_T bufferSize) 
{
	if (dataA != NULL) ::VirtualFree(dataA, 0, MEM_RELEASE);
	if (dataB != NULL) ::VirtualFree(dataB, 0, MEM_RELEASE);
	//if (dataA != NULL) delete [] dataA;
	//if (dataB != NULL) delete [] dataB;
	this->bufferSize = 0;
	//
	dataA = ::VirtualAlloc(NULL, bufferSize, MEM_COMMIT, PAGE_READWRITE);
	dataB = ::VirtualAlloc(NULL, bufferSize, MEM_COMMIT, PAGE_READWRITE);
	//dataA = new char[bufferSize];
	//dataB = new char[bufferSize];
	bool ok = (dataA != NULL) && (dataB != NULL);
	this->bufferSize = bufferSize;
	return ok;
}

// Compares the content of dataA and dataB
// it returns -1, if error
// it returns 0, if they are different
// it returns 1, if they are equal
int InputOutputRequestX::CompareAandB()
{
	register int i = 0;
	unsigned char * pa;
	unsigned char * pb;

	//________________________________ Compare
	if (bytesA != bytesB) return -1;

	const int count = bytesA >> sizeint; //readA / sizeint;
	const int remain = bytesA - (count << sizeint); //readA % sizeint;
	register int *ia = (int*)dataA;
	register int *ib = (int*)dataB;
	const int count4 = count/4;
	const int remain4 = count%4;
	bool different;
	for(i = 0; i  < count4; i++)
	{
		different = (*ia != *ib);
		ia++;
		ib++;
		//
		different |= (*ia != *ib);
		ia++;
		ib++;
		//
		different |= (*ia != *ib);
		ia++;
		ib++;
		//
		different |= (*ia != *ib);
		ia++;
		ib++;
		//
		if (different == true) return 0;
	}
	//_______________________________
	for(i = 0; i  < remain4; i++, ia++, ib++)
	{
		if (*ia != *ib) return 0;
	}
	//_______________________________
	pa = (unsigned char*)ia;
	pb = (unsigned char*)ib;
	for(i = remain; i != 0; i--, pa++, pb++)
	{
		if (*pa != *pb) return 0;
	}
	return 1;
}

//bool InputOutputRequestX::ReadA(HANDLE hDevice) 
//{
//	return (::ReadFile(hDevice, dataA, bufferSize, NULL, this) == TRUE);
//}

//bool InputOutputRequestX::ReadB(HANDLE hDevice) 
//{
//	return (::ReadFile(hDevice, dataB, bufferSize, NULL, this) == TRUE);
//}

bool InputOutputRequestX::ReadA(HANDLE hDevice, LARGE_INTEGER offset ) 
{
	Offset  = offset.LowPart;
	OffsetHigh = offset.HighPart;
	return (::ReadFile(hDevice, dataA, (DWORD)bufferSize, NULL, this) == TRUE);
}

bool InputOutputRequestX::ReadB(HANDLE hDevice, LARGE_INTEGER offset ) 
{
	Offset  = offset.LowPart;
	OffsetHigh = offset.HighPart;
	return (::ReadFile(hDevice, dataB, (DWORD)bufferSize, NULL, this) == TRUE);
}

//bool InputOutputRequestX::WriteA(HANDLE hDevice) 
//{
//	return (::WriteFile(hDevice, dataA, bufferSize, NULL, this) == TRUE);
//}

//bool InputOutputRequestX::WriteB(HANDLE hDevice) 
//{
//	return (::WriteFile(hDevice, dataB, bufferSize, NULL, this) == TRUE);
//}

//bool InputOutputRequestX::WriteA(HANDLE hDevice, LARGE_INTEGER offset) 
//{
//	Offset = offset.LowPart;
//	OffsetHigh = offset.HighPart;
//	return (::WriteFile(hDevice, dataA, bufferSize, NULL, this) == TRUE);
//}

//bool InputOutputRequestX::WriteB(HANDLE hDevice, LARGE_INTEGER offset) 
//{
//	Offset = offset.LowPart;
//	OffsetHigh = offset.HighPart;
//	return (::WriteFile(hDevice, dataB, bufferSize, NULL, this) == TRUE);
//}

//____________________________________________________________ InputOutputRequestX

//____________________________________________________________Service
int Service::m_nObjectCount = 0;
bool Service::m_bFirstService = true;

Service::Service(void)
{
	m_nObjectCount++;
	m_bDebug = false;
	m_type = 0;
	m_pData = NULL;
	ZeroMemory(&m_ServiceStatus, sizeof(SERVICE_STATUS));
}

Service::~Service(void)
{
}

bool Service::Remove() 
{
	SC_HANDLE hSCM = NULL;
	SC_HANDLE hService = NULL;
   
	hSCM =  OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	if (hSCM==NULL)
	{
		DisplayLastError_(L"Remove::OpenSCManager(...)");
		return false;
	}  

   hService = OpenService(hSCM, GetName(), DELETE);
   if (hService==NULL)
	{
		DisplayLastError_(L"Remove::OpenService(...)");
		return false;
	}
	DeleteService(hService);
   CloseServiceHandle(hService);
   CloseServiceHandle(hSCM);
   return true;
}

void Service::DisplayLastError_(const wchar_t* pszWhere)
{
	wchar_t sz[512];
	LPVOID lpMsgBuf;

	if (pszWhere) 
	{
		_snwprintf_s(sz, 512, _TRUNCATE, L"%s %s", GetName(), pszWhere);
	}
	else
	{
		_snwprintf_s(sz, 512, _TRUNCATE, L"%s", GetName());
	}

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, sz, MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}

void Service::DisplayLastError(const wchar_t* pszWhere, bool bServiceNotification)
{
	LPVOID lpMsgBuf;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, pszWhere, 
		bServiceNotification ? MB_SERVICE_NOTIFICATION : MB_OK | MB_ICONERROR);
	LocalFree( lpMsgBuf );
}

wchar_t* Service::GetDisplayName()
{
	return L"Unknown Service Display Name.";
}

wchar_t* Service::GetName()
{
	return L"UnknownServiceName.";
}

wchar_t* Service::GetDescription()
{
	return L"Provides unknown services.";
}

// pszUserName => DomainName\UserName
bool Service::Install(const wchar_t* pszUserName, const wchar_t* pszPassword) 
{
	wchar_t szModulePathname[512];
	SC_HANDLE hSCM = NULL;
	SC_HANDLE hService = NULL;
	SERVICE_DESCRIPTION sd;
   
	hSCM =  OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
	if (hSCM==NULL)
	{
		DisplayLastError_(L"Install::OpenSCManager(...)");
		return false;
	}
   GetModuleFileName(NULL, szModulePathname, 512);
   lstrcat(szModulePathname, L" -service");   

   hService = CreateService(hSCM, GetName(), GetDisplayName(),
         SERVICE_ALL_ACCESS,//  SERVICE_CHANGE_CONFIG
		 (m_nObjectCount == 1) ? SERVICE_WIN32_OWN_PROCESS : SERVICE_WIN32_SHARE_PROCESS, 
         SERVICE_AUTO_START, // SERVICE_DEMAND_START
		 SERVICE_ERROR_IGNORE,
         szModulePathname, NULL, NULL, NULL, pszUserName, pszPassword);
   if (hService==NULL)
	{
		DisplayLastError_(L"Install::CreateService(...)");
		return false;
	}
	sd.lpDescription 	= GetDescription();
	ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &sd);
	CloseServiceHandle(hService);
	CloseServiceHandle(hSCM);
   return true;
}

DWORD WINAPI Service::HandlerEx(DWORD control, DWORD type, PVOID pData, PVOID pContext) 
{
	DWORD result = ERROR_CALL_NOT_IMPLEMENTED;
	Mt::Service* pService = (Mt::Service*)pContext;

   switch (control) 
   {
   case SERVICE_CONTROL_STOP:
	   result = pService->OnControlStop(type, pData);
	   break;
   case SERVICE_CONTROL_SHUTDOWN:
		result = pService->OnControlShutdown(type, pData);
		break;
   case SERVICE_CONTROL_PAUSE:
		result = pService->OnControlPause(type, pData);
		break;
   case SERVICE_CONTROL_CONTINUE:
		result = pService->OnControlContinue(type, pData);
		break;
   case SERVICE_CONTROL_INTERROGATE:
		result = pService->OnControlInterrogate(type, pData);
	   break;
   case SERVICE_CONTROL_PARAMCHANGE:
		result = pService->OnControlParamChange(type, pData);
		break;
   case SERVICE_CONTROL_DEVICEEVENT:
	   result = pService->OnControlDeviceEvent(type, pData);
	   break;
   case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
	   result = pService->OnControlHardwareProfileChange(type, pData);
	   break;
   case SERVICE_CONTROL_POWEREVENT:
	   result = pService->OnControlPowerEvent(type, pData);
	   break;
	//case 128:   // User-define code just for testing
	//   break; ...
	//case 255:   // User-define code just for testing
	//   break;
   }

   return result;
}

DWORD Service::OnControlStop(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOPPED) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_STOP);
	return NO_ERROR;
}

DWORD Service::OnControlPause(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_PAUSED) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_PAUSE);
	return NO_ERROR;
}

DWORD Service::OnControlContinue(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_RUNNING) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_CONTINUE);
	return NO_ERROR;
}

DWORD Service::OnControlShutdown(DWORD type, PVOID pData)
{
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOPPED) return NO_ERROR;
	if (m_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) return NO_ERROR;
	m_type = type;
	m_pData = pData;
	m_gate.WaitToOpen();
	m_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	inputOutputCompletionPort.PostStatus(Mt::Service::Control, SERVICE_CONTROL_SHUTDOWN);
	return NO_ERROR;
}

DWORD Service::OnControlInterrogate(DWORD type, PVOID pData)
{
	::SetServiceStatus(m_hss, &m_ServiceStatus);
	return NO_ERROR;
}

DWORD Service::OnControlParamChange(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD Service::OnControlDeviceEvent(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD Service::OnControlHardwareProfileChange(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD Service::OnControlPowerEvent(DWORD type, PVOID pData)
{
	return ERROR_CALL_NOT_IMPLEMENTED;
}

void WINAPI Service::ServiceMain(DWORD dwArgc, PTSTR* pszArgv)
{
	DWORD dwControl = 0;
	OVERLAPPED *po = NULL;
	Mt::Service::CompletionKey ck = Mt::Service::Control;

	m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;

	if (m_bDebug == false) 
	{
		m_hss = RegisterServiceCtrlHandlerEx(GetName(), HandlerEx, this);
		if (m_hss == 0) 
		{
			m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
			m_ServiceStatus.dwWin32ExitCode = ERROR_INVALID_HANDLE;
			m_ServiceStatus.dwServiceSpecificExitCode = 0;
			m_ServiceStatus.dwCheckPoint = 0; 
			m_ServiceStatus.dwWaitHint = 0;
			if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
		return;
		}
	}
	m_ServiceStatus.dwControlsAccepted 
		= SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN; // | SERVICE_ACCEPT_PAUSE_CONTINUE
	m_ServiceStatus.dwServiceType 
		= (m_nObjectCount == 1) ? SERVICE_WIN32_OWN_PROCESS : SERVICE_WIN32_SHARE_PROCESS;

	m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 1; 
	m_ServiceStatus.dwWaitHint = 2000;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	OnStart(dwArgc, pszArgv);
	m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
	m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
	m_ServiceStatus.dwServiceSpecificExitCode = 0;
	m_ServiceStatus.dwCheckPoint = 0; 
	m_ServiceStatus.dwWaitHint = 0;
	if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
	m_gate.Open();

	while (m_ServiceStatus.dwCurrentState != SERVICE_STOPPED)
	{
		// Sleep until a control code comes in or a client connects
		//inputOutputCompletionPort.GetStatus((ULONG_PTR *)&ck, &dwControl, &po);
		inputOutputCompletionPort.GetStatus((ULONG_PTR&)ck, dwControl, &po);
		switch(ck)
		{
		case Mt::Service::Control:
			switch(dwControl)
			{
				case SERVICE_CONTROL_CONTINUE:
					OnContinue();
					m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
					m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
					m_ServiceStatus.dwServiceSpecificExitCode = 0;
					m_ServiceStatus.dwCheckPoint = 0; 
					m_ServiceStatus.dwWaitHint = 0;
					if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
					m_gate.Open();
					break;
				case SERVICE_CONTROL_PAUSE:
					OnPause();
					m_ServiceStatus.dwCurrentState = SERVICE_PAUSED;
					m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
					m_ServiceStatus.dwServiceSpecificExitCode = 0;
					m_ServiceStatus.dwCheckPoint = 0; 
					m_ServiceStatus.dwWaitHint = 0;
					if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
					m_gate.Open();
					break;
				case SERVICE_CONTROL_STOP:
					OnStop();
					m_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
					m_ServiceStatus.dwWin32ExitCode = NO_ERROR;
					m_ServiceStatus.dwServiceSpecificExitCode = 0;
					m_ServiceStatus.dwCheckPoint = 0; 
					m_ServiceStatus.dwWaitHint = 0;
					if (m_bDebug==false) ::SetServiceStatus(m_hss, &m_ServiceStatus);
					m_gate.Open();
					break;
			}
			break;
		case Mt::Service::Server:
			if (m_ServiceStatus.dwCurrentState != SERVICE_PAUSED)
			{
				OnRequestProcessing();
			}
			break;
		}
	}
}

void Service::OnStart(DWORD dwArgc, PTSTR* pszArgv)
{
	// Initialization of the servide
}

void Service::OnStop()
{
	// Cleaning up
}

void Service::OnPause()
{
}

void Service::OnContinue()
{
}

void Service::OnRequestProcessing()
{
	// This is where the actual work is done
}

void Service::Run(const wchar_t* pszUserName, const wchar_t* pszPassword, wchar_t* lpCmdLine, LPSERVICE_MAIN_FUNCTION pServiceFunction)
{
	if (lpCmdLine != NULL)
	{
		if (lstrlen(lpCmdLine)>0)
		{
			if (_tcsstr(L"-install", lpCmdLine)!=NULL || _tcsstr(L"-INSTALL", lpCmdLine)!=NULL) 
			{
				this->Install(pszUserName, pszPassword);
			}
			if (_tcsstr(L"-remove", lpCmdLine)!=NULL || _tcsstr(L"-REMOVE", lpCmdLine)!=NULL)
			{
				this->Remove();
			}
			if (_tcsstr(L"-debug", lpCmdLine)!=NULL || _tcsstr(L"-DEBUG", lpCmdLine)!=NULL)
			{
				m_bDebug = true;
			}
			if (_tcsstr(L"-list", lpCmdLine)!=NULL || _tcsstr(L"-LIST", lpCmdLine)!=NULL) 
			{
				MessageBox(NULL, GetDescription(), GetName(), MB_OK);
			}
		}
		else
		{
			if (m_bFirstService)
			{
				m_bFirstService = false;
				wchar_t szBuffer[512];
				wchar_t szModulePathname[512];
				wchar_t *sz =  L"[-install] [-remove] [-debug] [-list]  \
[-service]\r\n\
	-install   Installs the service in the SCM's database.\r\n\
	-remove   Removes the service from the SCM's database.\r\n\
	-debug  Runs the service as a normal process for debugging.\r\n\
	-list  List all services.\r\n\
	-service   Runs the process as a service (should only be set in the SCM's database).";

				GetModuleFileName(NULL, szModulePathname, 512);

	_snwprintf_s(szBuffer, 512, _TRUNCATE, L"Usage: \r\n%s\r\n%s", szModulePathname, sz);

				
				::MessageBox(NULL, szBuffer, L"Service Setup", MB_OK);
			}
		}
	}
}
//____________________________________________________________ IThread

//____________________________________________________________ ISuspendedThread

//____________________________________________________________ ThreadObject
ThreadObject::ThreadObject(void)
{
	hThread = NULL;
	threadId = 0;
	ithread = NULL;
	dotCount = 0;
	hWnd = NULL;
	message = WM_USER;
	work_id = 0;
}

ThreadObject::~ThreadObject(void)
{
	if (hThread) this->WaitForExit();
}

bool ThreadObject::StartThread(HWND hWnd, UINT uMsg, LPARAM work_id, IThread& ithread)
{
	if (work_id <= 0) return false;
	this->ithread = &ithread;
	running.Set(true);
	progress.Set(0.0);
	stopwatch.Start();
	resetTime.Set(false);
	dotCount = 0;
	this->hWnd = hWnd;
	this->message = message;
	this->work_id = work_id;
	hThread=(HANDLE)_beginthreadex(NULL, 0, PrivateThreadFunc, (LPVOID)this, 0, &threadId);
	return (hThread!=NULL);
}

void ThreadObject::WaitForExit()
{
	::WaitForSingleObject(hThread, INFINITE);
	::CloseHandle(hThread);
	hThread = NULL;
	running.Set(false);
	ithread = NULL;
	hWnd = NULL;
	message = WM_USER;
}

unsigned WINAPI ThreadObject::PrivateThreadFunc(LPVOID param)
{
	ThreadObject* pto = (ThreadObject*)param;
	if (pto->ithread == NULL) return 0;
	DWORD result = pto->ithread->ThreadFunc(pto->running, pto->progress, pto->resetTime);
	pto->running.Set(false);
	if (pto->hWnd != NULL)
	{
		::PostMessage(pto->hWnd, pto->message, (WPARAM)result, MAKELPARAM(pto->work_id, WIN_THREAD_STOPPED)); // Notify the main thread that we are done!
	}
	//_endthreadex(0);
	return result;
}

// Returns the progress and text information about the progress of the thread
double ThreadObject::GetProgressInfo(wchar_t* buffer, int buffer_len)
{
	bool reset_time;
	if (resetTime.GetTry(reset_time))
	{
		if (reset_time) 
		{
			stopwatch.Start();
			resetTime.Set(false);
		}
	}
	double dprogress = 0.0;
	//______________________________________________________ Try to get progress
	if (this->progress.GetTry(dprogress) == false)
	{
		_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Running...");
		return 0.0;
	}	
	
	//______________________________________________________ Get the number of seconds the thread has been running
	const double seconds = stopwatch.GetSeconds();
	if (seconds == 0)
	{
		_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Initializing...");
		return 0.0;
	}
	else
	{
		//______________________________________________________ Progress is not available
		if (dprogress==0.0)
		{
			dotCount++;
			if (dotCount > 22) dotCount = 0;
			int i;
			for(i = 0; i < dotCount && i < (buffer_len-1); i++)
			{
				buffer[i] = '*';
			}
			buffer[i] = '\0';
			return 0.0;
		}
	}
	if (dprogress >100.0) dprogress = 99.9;
	const unsigned int remainingSeconds = (int)(seconds*(100.0-dprogress)/dprogress);
	//const unsigned int remainingSeconds = (int)(100.0*seconds/dprogress-seconds);
	const int remainingSec = remainingSeconds%3600;
	const int minOut = remainingSec/60;
	const int secOut = remainingSec%60; 
	const int hrOut = remainingSeconds/3600;
	const int dayOut = hrOut/24;
	const int hrLeft = hrOut%24;
	if (remainingSeconds==0)
	{
		if (buffer_len > 0) buffer[0]='\0';
		return 100.0;
	}
	else if (remainingSeconds<60)
	{
		_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d seconds", secOut);
	}
	else if (remainingSeconds<3600)
	{
		if (5 < secOut)
		{
			if (minOut+1 == 1)
			{
				_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: 1 minute");
			}
			else
			{
				_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d minutes", minOut+1);
			}
		}
		else
		{
			if (minOut == 1)
			{
				_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: 1 minute");
			}
			else
			{
				_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d minutes", minOut);
			}
		}
		//if (minOut < 10 && 5 < secOut)
		//	_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left:  %d minutes", minOut+1);
		//else if (minOut < 10)
		//	_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left:  %d minute", minOut);
		//else
		//	_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left:  %d minutes", minOut);
	}
	else if (remainingSeconds<86400)
	{
		if (hrOut==1 && minOut==1)
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d hr+%d min", hrOut, minOut);
		else if (hrOut==1 && minOut!=1)
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d hr+%d mins", hrOut, minOut);
		else if (hrOut!=1 && minOut==1)
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d hrs+%d min", hrOut, minOut);
		else
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d hrs+%d mins", hrOut, minOut);
	}
	else
	{
		if (dayOut==1 && hrLeft==1)
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d day+%d hr", dayOut, hrLeft);
		else if (dayOut==1 && hrLeft!=1)
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d day+%d hrs", dayOut, hrLeft);
		else if (dayOut!=1 && hrLeft==1)
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d days+%d hr", dayOut, hrLeft);
		else
			_snwprintf_s(buffer, buffer_len, _TRUNCATE, L"Time left: %d days+%d hrs", dayOut, hrLeft);
	}
	return dprogress;
}

//____________________________________________________________ SuspendedThread
SuspendedThread::SuspendedThread(void)
{
	busy.Set(false);
	terminate.Set(false);
	ithread = NULL;
	work_id = 1;
	message = WM_USER;
	//_________________________________________________________ Start Thread
	hThread = (HANDLE)_beginthreadex(NULL, 0, PrivateThreadFunc, (LPVOID)this, 0, &threadId);
}

SuspendedThread::~SuspendedThread(void)
{
	//___________________________________________ Terminate thread cleanly
	terminate.Set(true);
	eventRequest.Set();
	::WaitForSingleObject(hThread, INFINITE);
	::CloseHandle(hThread);
}

bool SuspendedThread::IsBusy()
{
	return busy.Get();
}

bool SuspendedThread::WakeUpAndWork(HWND hWnd, UINT uMsg, LPARAM work_id, ISuspendedThread& ithread)
{
	if (work_id == 0) return false;
	if (busy == true) return false;
	//_____________________________________________________
	busy.Set(true);
	this->ithread = &ithread;
	this->hWnd = hWnd;
	this->work_id = work_id;
	eventRequest.Set();
	return true;
}

unsigned WINAPI SuspendedThread::PrivateThreadFunc(LPVOID param)
{
	SuspendedThread* pto = (SuspendedThread*)param;
	DWORD result = -1;
	while (true)
	{
		pto->eventRequest.Wait(); // Suspend the thread
		if (pto->terminate == true) break; // Be sure we can cleanly terminate the thread
		if (pto->ithread == NULL) return 0;
		//pto->busy = true;
		result = pto->ithread->ThreadFunc();
		pto->busy.Set(false);
		::PostMessage(pto->hWnd, pto->message, (WPARAM)result, MAKELPARAM(pto->work_id, WIN_THREAD_STOPPED)); // Notify the main thread that we are done!
	}
	return 0;
}

//____________________________________________________________OverlappedE


#ifdef WIN_SOCKETS_SUPPORT
//____________________________________________________________________ Smtp
Smtp::Smtp()
{
	errorDescr[0] = '\0';
	_port = 25;
	_isSSL = false;
	_protocol = SP_PROT_TLS1;
}

Smtp::~Smtp()
{
}

void Smtp::GetTimeHeader(char* buffer, int bufferSize)
{
	const char* days[]={"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	const char* months[]={"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	
	//_______________________________ Get Date and Time
	SYSTEMTIME now;
	::GetLocalTime(&now);

	//_______________________________ Get Time Zone
	TIME_ZONE_INFORMATION timeZoneInfo;
	const DWORD zoneId = ::GetTimeZoneInformation(&timeZoneInfo);
	
	int hours=(int)(timeZoneInfo.Bias/60);
	int minutes=(int)(timeZoneInfo.Bias%60);
	if (zoneId==TIME_ZONE_ID_STANDARD)
	{
		hours+=(int)(timeZoneInfo.StandardBias/60);
		minutes+=(int)(timeZoneInfo.StandardBias%60);
	}
	else
	{
		hours+=(int)(timeZoneInfo.DaylightBias/60);
		minutes+=(int)(timeZoneInfo.DaylightBias%60);
	}
	const char zone = (hours<0) ? '+' : '-';
	//const int year = now.wYear - (now.wYear/100)*100;
	_snprintf_s(buffer, bufferSize, _TRUNCATE, "Date: %s, %d %s %02d %02d:%02d:%02d %c%02d%02d\r\n", 
		days[now.wDayOfWeek], now.wDay, months[now.wMonth-1], now.wYear,
		now.wHour, now.wMinute, now.wSecond, zone, hours, minutes);
}

void Smtp::GetTimeHeader(wchar_t* buffer, int bufferSize)
{
	const wchar_t* days[] = { L"Sun", L"Mon", L"Tue", L"Wed", L"Thu", L"Fri", L"Sat" };
	const wchar_t* months[] = { L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun", L"Jul", L"Aug", L"Sep", L"Oct", L"Nov", L"Dec" };

	//_______________________________ Get Date and Time
	SYSTEMTIME now;
	::GetLocalTime(&now);

	//_______________________________ Get Time Zone
	TIME_ZONE_INFORMATION timeZoneInfo;
	const DWORD zoneId = ::GetTimeZoneInformation(&timeZoneInfo);

	int hours = (int)(timeZoneInfo.Bias / 60);
	int minutes = (int)(timeZoneInfo.Bias % 60);
	if (zoneId == TIME_ZONE_ID_STANDARD)
	{
		hours += (int)(timeZoneInfo.StandardBias / 60);
		minutes += (int)(timeZoneInfo.StandardBias % 60);
	}
	else
	{
		hours += (int)(timeZoneInfo.DaylightBias / 60);
		minutes += (int)(timeZoneInfo.DaylightBias % 60);
	}
	const wchar_t zone = (hours<0) ? '+' : '-';
	//const int year = now.wYear - (now.wYear/100)*100;
	_snwprintf_s(buffer, bufferSize, _TRUNCATE, L"Date: %s, %d %s %02d %02d:%02d:%02d %c%02d%02d\r\n",
		days[now.wDayOfWeek], now.wDay, months[now.wMonth - 1], now.wYear,
		now.wHour, now.wMinute, now.wSecond, zone, hours, minutes);
}


bool Smtp::IsOk(const wchar_t* errorDescription, Sys::Socket& skt, Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	bool brunning = false;

	if (errorDescription == NULL) // Everything is OK
	{
		if (running.GetTry(brunning))
		{
			if (brunning == false) // User has requested to stop
			{
				SendQuit(skt);
				skt.Disconnect();
				running.Set(false);
				progress.Set(false);
			}
		}
		return true;
	}
	_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", errorDescription);
	SendQuit(skt);
	skt.Disconnect();
	running.Set(false);
	progress.Set(false);
	return false;
}

bool Smtp::IsOk(const wchar_t* errorDescription, const string& response, Sys::Socket& skt, Mt::BoolTs& running, Mt::DoubleTs& progress, Sys::SecuritySupportProvider& ssp)
{
	bool brunning = false;

	if (errorDescription == NULL) // Everything is OK
	{
		if (running.GetTry(brunning))
		{
			if (brunning == false) // User has requested to stop
			{
				SendQuit(skt, ssp);
				ssp.DisconnectFromServer(skt);
				skt.Disconnect();
				running.Set(false);
				progress.Set(false);
			}
		}
		return true;
	}
	if (response.empty() == true)
	{
		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", errorDescription);
	}
	else
	{
		wstring wresponse;
		Sys::Convert::StringToWstring(response, wresponse);
		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s %s", errorDescription, wresponse.c_str());
	}
	SendQuit(skt, ssp);
	ssp.DisconnectFromServer(skt);
	skt.Disconnect();
	running.Set(false);
	progress.Set(false);
	return false;
}

DWORD Smtp::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	if (_isSSL == true) return SSLSendMail(running, progress, resetTime);
	return SendMail(running, progress, resetTime);
}

DWORD Smtp::SendMail(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	running.SetTry(true);
	progress.SetTry(0.0);
	errorDescr[0] = '\0';
	if (emailList.size() == 0)
	{
		running.Set(false);
		progress.Set(100.0);
		return 0;
	}

	const int count = emailList.size();
	if (count == 0) return 0;
	const wchar_t * error = NULL;

	//_________________________________________________________________________ CONNECTED
	Sys::Socket skt;
	wstring server_name;
	Sys::Convert::StringToWstring(serverName, server_name);
	if (skt.Connect(server_name.c_str(), _port) == SOCKET_ERROR)
	{
		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", skt.GetLastErrorDesc());
		SendQuit(skt);
		skt.Disconnect();
		running.Set(false);
		progress.Set(false);
		return 0;
	}
	//
	error = (skt.ReceiveCode() == 220) ? NULL: L"Unable to connect";
	if (IsOk(error, skt, running, progress) == false) return 0;
	//_______________________________________________________________________ SendHELO
	error = (SendHELO(skt) == true) ? NULL: L"Unable to SendHELO 1";
	if (IsOk(error, skt, running, progress) == false) return 0;
	//
	error = (skt.ReceiveCode() == 250) ? NULL: L"Unable to SendHELO 2";
	if (IsOk(error, skt, running, progress) == false) return 0;

	//_______________________________________________________________________ SendAUTH
	if (username.length() > 0)
	{
		error = (SendAUTH(skt) == true)   ? NULL: L"Unable to send SendAUTH 1";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		error = (skt.ReceiveCode() == 334) ? NULL: L"Unable to SendAUTH 2";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendUsername
		error = (SendUsername(skt) == true)  ? NULL: L"Unable to send SendUsername 1";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		error = (skt.ReceiveCode() == 334) ? NULL: L"Unable to SendUsername 2";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		//___________________________________________________________________ SendPassword
		error = (SendPassword(skt) == true)  ? NULL: L"Unable to send SendPassword 1";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		error = (skt.ReceiveCode() == 235) ? NULL: L"Unable to SendPassword 2";
		if (IsOk(error, skt, running, progress) == false) return 0;
	}

	int i;
	//_______________________________________________________________________________________________ MAIN LOOP FOR EACH EMAIL
	for(i = 0; i < count; i++)
	{
		if (emailList[i].sent == true) continue;
		//___________________________________________________________________ SendMAILFrom
		error = (SendMAILFrom(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendMAILFrom 1";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		error = (skt.ReceiveCode() == 250) ? NULL: L"Unable to SendMAILFrom 2";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendRCPTTo
		error = (SendRCPTTo(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendRCPTTo 1";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		error = (skt.ReceiveCode() == 250) ? NULL: L"Unable to SendRCPTTo 2";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendDATA
		error = (SendDATA(skt) == true)  ? NULL: L"Unable to send SendDATA";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendTimeHeader
		error = (SendTimeHeader(skt) == true)  ? NULL: L"Unable to send SendTimeHeader 1";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		error = (skt.ReceiveCode() == 354) ? NULL: L"Unable to SendTimeHeader 2";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendFrom
		error = (SendFrom(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendFrom";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendSender
		error = (SendSender(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendSender";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendReplyTo
		error = (SendReplyTo(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendReplyTo";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendSubject
		error = (SendSubject(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendSubject";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendTo
		error = (SendTo(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendSubject";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendMime
		error = (SendMime(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendMime";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendMultipartMixed
		error = (SendMultipartMixed(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendMultipartMixed";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendBodyFrontier
		error = (SendBodyFrontier(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendBodyFrontier";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendBodyContentType
		error = (SendBodyContentType(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendBodyContentType";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendBlankLine
		error = (SendBlankLine(skt) == true)  ? NULL: L"Unable to send SendBlankLine";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendBody
		error = (SendBody(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendBody";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendBlankLine
		error = (SendBlankLine(skt) == true)  ? NULL: L"Unable to send SendBlankLine";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendAttachmentFrontier
		error = (SendAttachmentFrontier(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendAttachmentFrontier";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendAttachmentContentType
		error = (SendAttachmentContentType(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendAttachmentContentType";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendAttachmentTransferEncoding
		error = (SendAttachmentTransferEncoding(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendAttachmentTransferEncoding";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendAttachmentContentDisposition
		error = (SendAttachmentContentDisposition(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendAttachmentContentDisposition";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendBlankLine
		error = (SendBlankLine(skt) == true)  ? NULL: L"Unable to send SendBlankLine";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendAttachment
		error = (SendAttachment(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendAttachment";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendBlankLine
		error = (SendBlankLine(skt) == true)  ? NULL: L"Unable to send SendBlankLine";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendAttachmentEnd
		error = (SendAttachmentEnd(skt, emailList[i]) == true)  ? NULL: L"Unable to send SendAttachmentEnd";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//___________________________________________________________________ SendDATAEnd
		error = (SendDATAEnd(skt) == true)  ? NULL: L"Unable to send SendDATAEnd 1";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		error = (skt.ReceiveCode() == 250) ? NULL: L"Unable to SendDATAEnd 2";
		if (IsOk(error, skt, running, progress) == false) return 0;
		//
		emailList[i].sent = true;
		progress.SetTry(((double)i)/count);
	}

	//___________________________________________________________________ SendQuit
	if (SendQuit(skt) == true)
	{
		error = (skt.ReceiveCode() == 221) ? NULL: L"Unable to SendQuit";
		if (IsOk(error, skt, running, progress) == false) return 0;
	}
	skt.Disconnect();
	running.Set(false);
	return 0;
}

DWORD Smtp::SSLSendMail(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	running.SetTry(true);
	progress.SetTry(0.0);
	errorDescr[0] = '\0';
	if (emailList.size() == 0)
	{
		running.Set(false);
		progress.Set(100.0);
		return 0;
	}

	//_____________________________________________________________________ Create Credentials
	Sys::SecuritySupportProvider ssp;
	SECURITY_STATUS status;
	status = ssp.CreateCredentials(_protocol);
	if (status != SEC_E_OK)
	{
		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", ssp.GetErrorDescr(status));
		running.Set(false);
		progress.Set(false);
		return 0;
	}

	const int count = emailList.size();
	if (count == 0) return 0;
	const wchar_t * error = NULL;

	//_________________________________________________________________________ CONNECTED
	wstring server_name;
	Sys::Socket skt;
	Sys::Convert::StringToWstring(serverName, server_name);
	if (skt.Connect(server_name.c_str(), _port) == SOCKET_ERROR)
	{
		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", skt.GetLastErrorDesc());
		SendQuit(skt);
		skt.Disconnect();
		running.Set(false);
		progress.Set(false);
		return 0;
	}

	//____________________________________________________________________ Handshake
	status = ssp.ClientHandshake(skt, server_name.c_str());
	if (status != SEC_E_OK)
	{
		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", ssp.GetErrorDescr(status));
		skt.Disconnect();
		running.Set(false);
		progress.Set(false);
		return 0;
	}
	//____________________________________________________________________ Get Certificate
	Sys::SecurityCertificate certificate;
	status = ssp.GetCertificate(certificate);
	if (status != SEC_E_OK)
	{
		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", ssp.GetErrorDescr(status));
		skt.Disconnect();
		running.Set(false);
		progress.Set(false);
		return 0;
	}
	//____________________________________________________________________ Display Certificate
	//wstring info;
	//certificate.GetDisplayInfo(true, info);
	//::MessageBox(NULL, info.c_str(), L"Certificate Info", MB_OK);
	//____________________________________________________________________ Verify Certificate
	const int verify = certificate.Verify(server_name.c_str(), 0);
	if (verify != S_OK)
	{
		if (verify == S_FALSE)
		{
			Sys::GetLastErrorInformation(errorDescr, 256);
		}
		else
		{
			_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", certificate.GetErrorDesc(verify));
		}
		skt.Disconnect();
		running.Set(false);
		progress.Set(false);
		return 0;
	}
	//___________________________________________________________________ Display Connection Info
	//ssp.GetConnectionInfo(info);
	//this->MessageBox(info, L"Connection Info", MB_OK);
	string response;
	string empty;
	//
	error = (ssp.ReceiveCode(skt, response) == 220) ? NULL: L"Unable to connect";
	if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
	//_______________________________________________________________________ SendHELO
	error = (SendHELO(skt, ssp) == true) ? NULL: L"Unable to SendHELO 1";
	if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
	//
	error = (ssp.ReceiveCode(skt, response) == 250) ? NULL: L"Unable to SendHELO 2";
	if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;

	//_______________________________________________________________________ SendAUTH
	if (username.length() > 0)
	{
		error = (SendAUTH(skt, ssp) == true)   ? NULL: L"Unable to send SendAUTH 1";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//
		error = (ssp.ReceiveCode(skt, response) == 334) ? NULL: L"Unable to SendAUTH 2";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendUsername
		error = (SendUsername(skt, ssp) == true)  ? NULL: L"Unable to send SendUsername 1";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//
		error = (ssp.ReceiveCode(skt, response) == 334) ? NULL: L"Unable to SendUsername 2";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
		//
		//___________________________________________________________________ SendPassword
		error = (SendPassword(skt, ssp) == true)  ? NULL: L"Unable to send SendPassword 1";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//
		error = (ssp.ReceiveCode(skt, response) == 235) ? NULL: L"Unable to SendPassword 2";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
	}

	int i;
	//_______________________________________________________________________________________________ MAIN LOOP FOR EACH EMAIL
	for(i = 0; i < count; i++)
	{
		if (emailList[i].sent == true) continue;
		//___________________________________________________________________ SendMAILFrom
		error = (SendMAILFrom(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendMAILFrom 1";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//
		error = (ssp.ReceiveCode(skt, response)  == 250) ? NULL: L"Unable to SendMAILFrom 2";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendRCPTTo
		error = (SendRCPTTo(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendRCPTTo 1";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//
		error = (ssp.ReceiveCode(skt, response)  == 250) ? NULL: L"Unable to SendRCPTTo 2";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendDATA
		error = (SendDATA(skt, ssp) == true)  ? NULL: L"Unable to send SendDATA";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//_______________________________________________
		error = (ssp.ReceiveCode(skt, response)  == 354) ? NULL: L"Unable to SendTimeHeader 2";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendTimeHeader
		error = (SendTimeHeader(skt, ssp) == true)  ? NULL: L"Unable to send SendTimeHeader 1";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendFrom
		error = (SendFrom(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendFrom";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendSender
		error = (SendSender(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendSender";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendReplyTo
		error = (SendReplyTo(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendReplyTo";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendSubject
		error = (SendSubject(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendSubject";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendTo
		error = (SendTo(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendSubject";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendMime
		error = (SendMime(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendMime";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendMultipartMixed
		error = (SendMultipartMixed(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendMultipartMixed";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendBodyFrontier
		error = (SendBodyFrontier(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendBodyFrontier";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendBodyContentType
		error = (SendBodyContentType(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendBodyContentType";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendBlankLine
		error = (SendBlankLine(skt, ssp) == true)  ? NULL: L"Unable to send SendBlankLine";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//___________________________________________________________________ SendBody
		error = (SendBody(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendBody";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//
		if (emailList[i].attachmentFileName.empty() == false)
		{
			//___________________________________________________________________ SendBlankLine
			error = (SendBlankLine(skt, ssp) == true)  ? NULL: L"Unable to send SendBlankLine";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendAttachmentFrontier
			error = (SendAttachmentFrontier(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendAttachmentFrontier";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendAttachmentContentType
			error = (SendAttachmentContentType(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendAttachmentContentType";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendAttachmentTransferEncoding
			error = (SendAttachmentTransferEncoding(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendAttachmentTransferEncoding";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendAttachmentContentDisposition
			error = (SendAttachmentContentDisposition(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendAttachmentContentDisposition";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendBlankLine
			error = (SendBlankLine(skt, ssp) == true)  ? NULL: L"Unable to send SendBlankLine";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendAttachment
			error = (SendAttachment(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendAttachment";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendBlankLine
			error = (SendBlankLine(skt, ssp) == true)  ? NULL: L"Unable to send SendBlankLine";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
			//___________________________________________________________________ SendAttachmentEnd
			error = (SendAttachmentEnd(skt, emailList[i], ssp) == true)  ? NULL: L"Unable to send SendAttachmentEnd";
			if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		}
		//___________________________________________________________________ SendDATAEnd
		error = (SendDATAEnd(skt, ssp) == true)  ? NULL: L"Unable to send SendDATAEnd 1";
		if (IsOk(error, empty, skt, running, progress, ssp) == false) return 0;
		//
		error = (ssp.ReceiveCode(skt, response)  == 250) ? NULL: L"Unable to SendDATAEnd 2";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
		//
		emailList[i].sent = true;
		progress.SetTry(((double)i)/count);
	}

	//___________________________________________________________________ SendQuit
	if (SendQuit(skt, ssp) == true)
	{
		error = (ssp.ReceiveCode(skt, response) == 221) ? NULL: L"Unable to SendQuit";
		if (IsOk(error, response, skt, running, progress, ssp) == false) return 0;
	}
	//___________________________________________________________________ Disconnect
	ssp.DisconnectFromServer(skt);
	skt.Disconnect();
	running.Set(false);
	return 0;
}

const wchar_t* Smtp::TestConnection(const wchar_t* smtpServerName)
{
	Sys::Socket skt;
	if (skt.Connect(smtpServerName, 25) == SOCKET_ERROR) return skt.GetLastErrorDesc();
	if (skt.ReceiveCode() != 220) return L"Incorrect response from the server";
	SendQuit(skt);
	skt.Disconnect();
	return NULL;
}

void Smtp::Setup(const wchar_t* smtpServerName, const wchar_t* username, const wchar_t* password, int port, bool isSSL, DWORD protocol)
{
	Sys::Convert::WstringToString(smtpServerName, this->serverName);
	Sys::Convert::WstringToString(username, this->username);
	Sys::Convert::WstringToString(password, this->password);
	_port = port;
	_isSSL = isSSL;
	_protocol = protocol;
}

wchar_t* Smtp::GetErrorDescr()
{
	return errorDescr;
}

bool Smtp::SendHELO(Sys::Socket& skt)
{
	string myComputer;
	wstring wmyComputer;
	Sys::Information::getComputerName(wmyComputer);
	Sys::Convert::WstringToString(wmyComputer, myComputer);
	//
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "HELO %s\r\n", myComputer.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendHELO(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	string myComputer;
	wstring wmyComputer;
	Sys::Information::getComputerName(wmyComputer);
	Sys::Convert::WstringToString(wmyComputer,myComputer);
	//
	char buffer[256];
	_snprintf_s(buffer,256,_TRUNCATE,"HELO %s\r\n", myComputer.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAUTH(Sys::Socket& skt)
{
	if (skt.Send("AUTH LOGIN\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendAUTH(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	if (ssp.Send(skt, "AUTH LOGIN\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendUsername(Sys::Socket& skt)
{
	string request;
	Sys::Convert::Base64BitEncode(username.c_str(), username.length(), request);
	request += "\r\n";
	if (skt.Send(request.c_str()) <= 0) return false;
	return true;
}

bool Smtp::SendUsername(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	string request;
	Sys::Convert::Base64BitEncode(username.c_str(), username.length(), request);
	request += "\r\n";
	if (ssp.Send(skt, request.c_str()) <= 0) return false;
	return true;
}

bool Smtp::SendPassword(Sys::Socket& skt)
{
	string request;
	Sys::Convert::Base64BitEncode(password.c_str(), password.length(), request);
	request += "\r\n";
	if (skt.Send(request.c_str()) <= 0) return false;
	return true;
}

bool Smtp::SendPassword(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	string request;
	Sys::Convert::Base64BitEncode(password.c_str(), password.length(), request);
	request += "\r\n";
	if (ssp.Send(skt, request.c_str()) <= 0) return false;
	return true;
}

bool Smtp::SendMAILFrom(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string from;
	Sys::Convert::WstringToString(email.fromEmail, from);
	_snprintf_s(buffer, 256, _TRUNCATE, "MAIL FROM: <%s>\r\n", from.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendMAILFrom(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string from;
	Sys::Convert::WstringToString(email.fromEmail, from);
	_snprintf_s(buffer, 256, _TRUNCATE, "MAIL FROM: <%s>\r\n", from.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendRCPTTo(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string to;
	Sys::Convert::WstringToString(email.toEmail, to);
	_snprintf_s(buffer, 256, _TRUNCATE, "RCPT TO: <%s>\r\n", to.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendRCPTTo(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string to;
	Sys::Convert::WstringToString(email.toEmail, to);
	_snprintf_s(buffer, 256, _TRUNCATE, "RCPT TO: <%s>\r\n", to.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendTimeHeader(Sys::Socket& skt)
{
	char buffer[256];
	GetTimeHeader(buffer, 256);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendTimeHeader(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	GetTimeHeader(buffer, 256);
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendFrom(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.fromName, name);
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "From: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendFrom(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.fromName, name);
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "From: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendSender(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string address;
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "Sender: %s\r\n", address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendSender(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string address;
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "Sender: %s\r\n", address.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendReplyTo(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.fromName, name);
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "Reply-to: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendReplyTo(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.fromName, name);
	Sys::Convert::WstringToString(email.fromEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "Reply-to: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendSubject(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string subject;
	Sys::Convert::WstringToString(email.subject, subject);
	_snprintf_s(buffer, 256, _TRUNCATE, "Subject: %s\r\n", subject.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendSubject(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string subject;
	Sys::Convert::WstringToString(email.subject, subject);
	_snprintf_s(buffer, 256, _TRUNCATE, "Subject: %s\r\n", subject.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendTo(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.toName, name);
	Sys::Convert::WstringToString(email.toEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "To: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendTo(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string name;
	string address;
	Sys::Convert::WstringToString(email.toName, name);
	Sys::Convert::WstringToString(email.toEmail, address);
	_snprintf_s(buffer, 256, _TRUNCATE, "To: \"%s\" <%s>\r\n", name.c_str(), address.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendMime(Sys::Socket& skt, const Sys::EMail& email)
{
	if (skt.Send("MIME-Version: 1.0\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendMime(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (ssp.Send(skt, "MIME-Version: 1.0\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendMultipartMixed(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-Type: multipart/mixed; boundary=\"%s\"\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendMultipartMixed(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-Type: multipart/mixed; boundary=\"%s\"\r\n",  WIN_SMTP_BOUNDARY);
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendBodyFrontier(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendBodyFrontier(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s\r\n",  WIN_SMTP_BOUNDARY);
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendBodyContentType(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.isHtmlFormat == true)
	{
		if (skt.Send("Content-type: text/html; charset=ISO-8859-1\r\n") <= 0) return false;
	}
	else
	{
		if (skt.Send("Content-type: text/plain\r\n") <= 0) return false;
	}
	return true;
}

bool Smtp::SendBodyContentType(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.isHtmlFormat == true)
	{
		if (ssp.Send(skt, "Content-type: text/html; charset=ISO-8859-1\r\n") <= 0) return false;
	}
	else
	{
		if (ssp.Send(skt, "Content-type: text/plain\r\n") <= 0) return false;
	}
	return true;
}

bool Smtp::SendAttachmentFrontier(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentFrontier(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s\r\n",  WIN_SMTP_BOUNDARY);
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentContentType(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	wchar_t ext[32];
	if (Sys::TextAssistant::ExtractFileExt(email.attachmentFileName.c_str(), ext, 32) == false) return false;
	const wchar_t * wContentType = Web::Http::GetMimeContentType(ext);
	string contentType;
	Sys::Convert::WstringToString(wContentType, contentType);
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-type: %s\r\n", contentType.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentContentType(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	wchar_t ext[32];
	if (Sys::TextAssistant::ExtractFileExt(email.attachmentFileName.c_str(), ext, 32) == false) return false;
	const wchar_t * wContentType = Web::Http::GetMimeContentType(ext);
	string contentType;
	Sys::Convert::WstringToString(wContentType, contentType);
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-type: %s\r\n", contentType.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentContentDisposition(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	string filename;
	string name;
	Sys::Convert::WstringToString(email.attachmentFileName, filename);
	size_t pos = filename.find_last_of('\\');
	if (pos != std::wstring::npos)
	{
		name.assign(filename.begin()+pos+1, filename.end());
	}
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-Disposition: attachment; filename=\"%s\";\r\n", name.c_str());
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentContentDisposition(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	string filename;
	string name;
	Sys::Convert::WstringToString(email.attachmentFileName, filename);
	size_t pos = filename.find_last_of('\\');
	if (pos != std::wstring::npos)
	{
		name.assign(filename.begin()+pos+1, filename.end());
	}
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "Content-Disposition: attachment; filename=\"%s\";\r\n", name.c_str());
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentTransferEncoding(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	if (skt.Send("Content-Transfer-Encoding: base64\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentTransferEncoding(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	if (ssp.Send(skt, "Content-Transfer-Encoding: base64\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendAttachment(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	//_______________________________________________ Load the File
	string fileContent;
	string encodedContent;
	if (Sys::FileAssistant::TextLoad(email.attachmentFileName, fileContent) == false) return false;
	const int len = fileContent.length();
	if (len <= 0) return false;
	//_______________________________________________ Encode the file content
	Sys::Convert::Base64BitEncode(fileContent.c_str(), fileContent.length(), encodedContent);
	//_______________________________________________ empty line
	//if (skt.Send("\r\n") <= 0) return false;
	//_______________________________________________ Send line by line
	char buffer[256];
	char* start = NULL;
	int bytesRead = 0;
	const int newlen = encodedContent.length();
	for(int i=0; i<newlen; i+=250)
	{
		start = (char*)encodedContent.c_str();
		start += i;
		strncpy_s(buffer, 256, start, 250);
		buffer[250]='\0';
		strcat_s(buffer, 256, "\r\n");
		if (skt.Send(buffer) <= 0) return false;
	}
	return true;
}

bool Smtp::SendAttachment(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	//_______________________________________________ Load the File
	string fileContent;
	string encodedContent;
	if (Sys::FileAssistant::TextLoad(email.attachmentFileName, fileContent) == false) return false;
	const int len = fileContent.length();
	if (len <= 0) return false;
	//_______________________________________________ Encode the file content
	Sys::Convert::Base64BitEncode(fileContent.c_str(), fileContent.length(), encodedContent);
	//_______________________________________________ empty line
	//if (skt.Send("\r\n") <= 0) return false;
	//_______________________________________________ Send line by line
	char buffer[256];
	char* start = NULL;
	int bytesRead = 0;
	const int newlen = encodedContent.length();
	for(int i=0; i<newlen; i+=250)
	{
		start = (char*)encodedContent.c_str();
		start += i;
		strncpy_s(buffer, 256, start, 250);
		buffer[250]='\0';
		strcat_s(buffer, 256, "\r\n");
		if (ssp.Send(skt, buffer) <= 0) return false;
	}
	return true;
}

bool Smtp::SendAttachmentEnd(Sys::Socket& skt, const Sys::EMail& email)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s--\r\n",  WIN_SMTP_BOUNDARY);
	if (skt.Send(buffer) <= 0) return false;
	return true;
}

bool Smtp::SendAttachmentEnd(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	if (email.attachmentFileName.length() <= 0) return true;
	char buffer[256];
	_snprintf_s(buffer, 256, _TRUNCATE, "--%s--\r\n",  WIN_SMTP_BOUNDARY);
	if (ssp.Send(skt, buffer) <= 0) return false;
	return true;
}

bool Smtp::SendBlankLine(Sys::Socket& skt)
{
	if (skt.Send("\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendBlankLine(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	if (ssp.Send(skt, "\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendDATA(Sys::Socket& skt)
{
	if (skt.Send("DATA\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendDATA(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	if (ssp.Send(skt, "DATA\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendBody(Sys::Socket& skt, const Sys::EMail& email)
{
	char buffer[256];
	string body;
	Sys::Convert::WstringToString(email.body, body);
	const int len = body.length();
	char* start = NULL;
	for(int i=0; i<len; i+=250)
	{
		start = (char*)body.c_str();
		start += i;
		strncpy_s(buffer, 256, start, 250);
		buffer[250]='\0';
		Sys::Socket::RemoveReturn(buffer);
		strcat_s(buffer, 256, "\r\n");
		if (skt.Send(buffer) <= 0) return false;
	}
	return true;
}

bool Smtp::SendBody(Sys::Socket& skt, const Sys::EMail& email, Sys::SecuritySupportProvider& ssp)
{
	char buffer[256];
	string body;
	Sys::Convert::WstringToString(email.body, body);
	const int len = body.length();
	char* start = NULL;
	for(int i=0; i<len; i+=250)
	{
		start = (char*)body.c_str();
		start += i;
		strncpy_s(buffer, 256, start, 250);
		buffer[250]='\0';
		Sys::Socket::RemoveReturn(buffer);
		strcat_s(buffer, 256, "\r\n");
		if (ssp.Send(skt, buffer) <= 0) return false;
	}
	return true;
}

bool Smtp::SendQuit(Sys::Socket& skt)
{
	if (skt.Send("QUIT\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendQuit(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	if (ssp.Send(skt, "QUIT\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendDATAEnd(Sys::Socket& skt)
{
	if (skt.Send("\r\n.\r\n") <= 0) return false;
	return true;
}

bool Smtp::SendDATAEnd(Sys::Socket& skt, Sys::SecuritySupportProvider& ssp)
{
	if (ssp.Send(skt, "\r\n.\r\n") <= 0) return false;
	return true;
}

/*
int get_smtp_line( void )
{
  TCHAR ch = '.';
  TCHAR in_data [MAXOUTLINE];
  TCHAR * index;
  int retval = 0;

  index = in_data;

  while (ch != '\n')
  {
   if( (retval = (*pgensock_getTCHAR) (SMTPSock, 0, &ch) ) )
   {
      gensock_error ("gensock_getTCHAR", retval);
      return -1;
    }
    else
    {
      *index = ch;
      index++;
    }
  }

  /* this is to support multi-line responses, common with */
  /* servers that speak ESMTP *

  /* I know, I know, it's a hack 8^) *
  if( in_data[3] == '-' ) return( get_smtp_line() );
  else return atoi(in_data);
}


int transform_and_send_edit_data( socktag sock, TCHAR * editptr )
{
  TCHAR *index;
  TCHAR *header_end;
  TCHAR previous_TCHAR = 'x';
  unsigned int send_len;
  int retval;
  BOOL done = 0;

  send_len = llstrlen(editptr);
  index = editptr;

  header_end = _tcsstr (editptr, "\r\n\r\n");

  while (!done)
  {
    // room for extra TCHAR for double dot on end case
    while ((unsigned int) (index - editptr) < send_len)
    {
      switch (*index)
      {
       case '.':
	             if (previous_TCHAR == '\n')
	              /* send _two_ dots... *
	              if ((retval = (*pgensock_put_data_buffered) (sock, index, 1))) return (retval);
	  	         if ((retval = (*pgensock_put_data_buffered) (sock, index, 1))) return (retval);
	             break;
       case '\r':
	             // watch for soft-breaks in the header, and ignore them
                 if (index < header_end && (strncmp (index, "\r\r\n", 3) == 0))
	               index += 2;
	             else
	              if (previous_TCHAR != '\r')
	               if ((retval = (*pgensock_put_data_buffered) (sock, index, 1)))
	                return (retval);
	              // soft line-break (see EM_FMTLINES), skip extra CR *
				 break;
	   default:
	           if ((retval = (*pgensock_put_data_buffered) (sock, index, 1)))
	            return (retval);
      }
      previous_TCHAR = *index;
      index++;
    }
    if( (unsigned int) (index - editptr) == send_len) done = 1;
  }

  // this handles the case where the user doesn't end the last
  // line with a <return>

  if (editptr[send_len-1] != '\n')
  {
    if ((retval = (*pgensock_put_data_buffered) (sock, "\r\n.\r\n", 5)))
      return (retval);
  }
  else
    if ((retval = (*pgensock_put_data_buffered) (sock, ".\r\n", 3)))
      return (retval);

  /* now make sure it's all sent... *
  if ((retval = (*pgensock_put_data_flush)(sock))) return (retval);
  return (TRUE);
}*/

//_____________________________________________________________________ SmtpAsync
//SmtpAsync::SmtpAsync()
//{
//	hWnd = NULL;
//	state = WIN_SOCKET_INITIAL;
//	buffer[0] = '\0';
//	errorDescr[0] = '\0';
//}
//
//SmtpAsync::~SmtpAsync()
//{
//}
//
//wchar_t* SmtpAsync::TestConnection(HWND hWnd, const wchar_t* smtpServerName)
//{
//	return NULL;
//}
//
//bool SmtpAsync::SendEmail(HWND hWnd, const vector<Sys::EMail>& emailList, const wchar_t* smtpServerName, const wchar_t* username, const wchar_t* password)
//{
//	this->hWnd = hWnd;
//	state = WIN_SOCKET_INITIAL;
//	errorDescr[0] = '\0';
//	messageIndex = 0;
//	Sys::Convert::WstringToString(smtpServerName, serverName);
//	Sys::Convert::WstringToString(username, this->username);
//	Sys::Convert::WstringToString(password, this->password);
//	this->emailList = emailList;
//	return (0 != ::WSAAsyncGetHostByName(hWnd, WM_SOCKETHOSTNAME, serverName.c_str(), buffer, MAXGETHOSTSTRUCT));
//}
//
//// Call this on Window_SocketNotify(Win::Event& e)
//int SmtpAsync::OnSocketNotify(LPARAM lParam)
//{
//	WORD socketEvent = WSAGETSELECTEVENT(lParam);
//	WORD socketError = WSAGETSELECTERROR(lParam);
//
//	//e.returnValue = TRUE;
//	if (socketError)
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", sock.GetErrorDescr(socketError));
//		return -1;
//	}
//
//	switch(socketEvent)
//	{
//	case FD_CONNECT:
//		OnFdConnect();
//		break; 
//	case FD_READ: 
//		OnFdRead(-1);
//		break;
//	case FD_WRITE: 
//		OnFdWrite(true);
//		break;
//	case FD_CLOSE:
//		break;
//	}
//	return 0;
//}
//
//// Call this on Window_SocketHostname
//bool SmtpAsync::OnSocketHostname()
//{
//	if (strlen(buffer)<=0) 
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"Server hostname is empty");
//		return false;
//	}
//	//______________________________ IP address was found
//	HOSTENT * pHost = NULL;
//	pHost = (hostent*)buffer;	
//	char* ipAddress =inet_ntoa(  *(LPIN_ADDR)*(pHost->h_addr_list) );
//	if (ipAddress == NULL)
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"Server IP Address is empty");
//		return false;
//	}
//	state = WIN_SOCKET_HOSTNAME;
//
//
//	//_________________________________ Connect Request
//	wstring ip_address;
//	Sys::Convert::StringToWstring(ipAddress, ip_address);
//	const wchar_t* error = sock.ConnectAsync(hWnd, 25, ip_address.c_str());
//
//	if (error)
//	{
//		_snwprintf_s(errorDescr, 256, _TRUNCATE, L"%s", error);
//		return false;
//	}
//	return true;
//}
//
//bool SmtpAsync::OnFdConnect()
//{
//	state = WIN_SOCKET_CONNECTED;
//	const int code = sock.ReceiveCodeAsync();
//	if (code < 0) return OnFdRead(code);
//	return true;
//}
//
//bool SmtpAsync::OnFdRead(int code)
//{
//	if (code < 0) code = sock.ReceiveCode();
//
//	switch(state)
//	{
//	case WIN_SOCKET_CONNECTED:
//		if (code == 220)
//		{
//			state = WIN_SOCKET_WELCOME;
//			if (SendHELO(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_WELCOME:
//		if (code == 250)
//		{
//			state = WIN_SOCKET_HELO;
//			if (SendAUTH(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_HELO:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_AUTH;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_AUTH:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_USERNAME;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_USERNAME:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_PASSWORD;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_PASSWORD:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_MAILFROM;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_MAILFROM:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_RCPTTO;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//	case WIN_SOCKET_RCPTTO:
//		if (code == 334)
//		{
//			state = WIN_SOCKET_DATA;
//			if (SendUsername(sock) == true) return OnFdWrite(false);
//		}
//		break;
//////_____________________________________________ DATA
////#define WIN_SOCKET_DATA 11
////#define WIN_SOCKET_TIMEHEADER 12
////#define WIN_SOCKET_FROM 13
////#define WIN_SOCKET_SENDER 14
////#define WIN_SOCKET_REPLYTO 15
////#define WIN_SOCKET_SUBJECT 16
////#define WIN_SOCKET_TO 17
////#define WIN_SOCKET_MIME 18
////#define WIN_SOCKET_MULTIPART_MIXED 19
//////____________________________________________ BODY
////#define WIN_SOCKET_BODY_FRONTIER 20
////#define WIN_SOCKET_BODY_CONTENT_TYPE 21
////#define WIN_SOCKET_BODY_BLANK1 22
////#define WIN_SOCKET_BODY 23
////#define WIN_SOCKET_BODY_BLANK2 24
//////____________________________________________ ATTACHMENT
////#define WIN_SOCKET_ATTACH_FRONTIER 25
////#define WIN_SOCKET_ATTACH_CONTENT_TYPE 26
////#define WIN_SOCKET_ATTACH_CONTENT_DISPOSITION 27
////#define WIN_SOCKET_ATTACH_TRANSFER_ENCODING 28
////#define WIN_SOCKET_ATTACH_BLANK1 29
////#define WIN_SOCKET_ATTACH 30
////#define WIN_SOCKET_ATTACH_BLANK2 31
////#define WIN_SOCKET_ATTACH_END 32
//////
////#define WIN_SOCKET_DATA_END 33
////#define WIN_SOCKET_QUIT 34
////#define WIN_SOCKET_DONE 35
//	}
//	return true;
//}
//
//bool SmtpAsync::OnFdWrite(bool write)
//{
//	int code;
//	switch(state)
//	{
//	case WIN_SOCKET_WELCOME:
//		if (write == false || SendHELO(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_HELO:
//		if (write == false || SendAUTH(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_AUTH:
//		if (write == false || SendUsername(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_USERNAME:
//		if (write == false || SendPassword(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_PASSWORD:
//		if (write == false || SendMAILFrom(sock, emailList[messageIndex]) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_MAILFROM:
//		if (write == false || SendRCPTTo(sock, emailList[messageIndex]) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	case WIN_SOCKET_RCPTTO:
//		if (write == false || SendUsername(sock) == true)
//		{
//			code = sock.ReceiveCodeAsync();
//			if (code < 0) return OnFdRead(code);
//		}
//		return false;
//	}
//////_____________________________________________ DATA
////#define WIN_SOCKET_DATA 11
////#define WIN_SOCKET_TIMEHEADER 12
////#define WIN_SOCKET_FROM 13
////#define WIN_SOCKET_SENDER 14
////#define WIN_SOCKET_REPLYTO 15
////#define WIN_SOCKET_SUBJECT 16
////#define WIN_SOCKET_TO 17
////#define WIN_SOCKET_MIME 18
////#define WIN_SOCKET_MULTIPART_MIXED 19
//////____________________________________________ BODY
////#define WIN_SOCKET_BODY_FRONTIER 20
////#define WIN_SOCKET_BODY_CONTENT_TYPE 21
////#define WIN_SOCKET_BODY_BLANK1 22
////#define WIN_SOCKET_BODY 23
////#define WIN_SOCKET_BODY_BLANK2 24
//////____________________________________________ ATTACHMENT
////#define WIN_SOCKET_ATTACH_FRONTIER 25
////#define WIN_SOCKET_ATTACH_CONTENT_TYPE 26
////#define WIN_SOCKET_ATTACH_CONTENT_DISPOSITION 27
////#define WIN_SOCKET_ATTACH_TRANSFER_ENCODING 28
////#define WIN_SOCKET_ATTACH_BLANK1 29
////#define WIN_SOCKET_ATTACH 30
////#define WIN_SOCKET_ATTACH_BLANK2 31
////#define WIN_SOCKET_ATTACH_END 32
//////
////#define WIN_SOCKET_DATA_END 33
////#define WIN_SOCKET_QUIT 34
////#define WIN_SOCKET_DONE 35
//	return true;
//}


#endif


} //____________________________________________________ namespace Mt::End

namespace Math //________________________________________ namespace Math::Ini
{
//_____________________________________________________________________ IFunction
//_____________________________________________________________________ IFunctionC
//_____________________________________________________________________ IFunctionD
//_____________________________________________________________________ IMultiVarFunc
//_____________________________________________________________________ IMultiVarFuncD
//_____________________________________________________________________ Point
//_____________________________________________________________________ DPoint
//_____________________________________________________________________ ISimmAnneal
//_____________________________________________________________________ SimAnnealParam
SimAnnealParam::SimAnnealParam()
{
	numTemps = 250;
	numIterations = 100;
	initialTemp = 100;
	finalTemp = 1.0e-06;
	isCoolingScheduleLinear = false;
	cycles = 10;
	goal = 1.0e-10;
}

SimAnnealParam::~SimAnnealParam()
{
}

//_____________________________________________________________________ IGenetic
//_____________________________________________________________________ GeneticParam
GeneticParam::GeneticParam()
{
	initPopulationSize = 100;
	numGenerations = 100;
	overPopulation = 1.5;
	mutationProbability = 0.001;
	crossoverProbability = 0.85;
	goal = 1.0e-10;
}

GeneticParam::~GeneticParam()
{
}

//_____________________________________________________________________ Oper
Oper::Oper()
{
}

Oper::~Oper()
{
}

bool Oper::IsPrime(int x)
{
	if (x<=1) return false;
	if (x%2==0) return false;
	const int root = (int)(sqrt((double)x)+0.5);
	for(int i = 3; i<= root; i+=2)
	{
		if (x%i==0) return false;
	}
	return true;
}


double Oper::ArcTangent(double y, double x)
{
	if (y == 0.0)
	{
		if (x >= 0) return 0;
		return M_PI;
	}
	else if (y > 0.0) return atan2(y, x);
	return 2.0*M_PI + atan2(y, x);
}

double Oper::Round(double value, int decimalCount)
{
	const double base = pow(10.0, decimalCount);
	int intValue = (int)(base*value+0.5);
	return (double)intValue/base;
}

double Oper::DotProduct(const valarray<double>& input_a, const valarray<double>& input_b)
{
	const int length = (int)input_a.size();
	if (length != input_b.size()) throw L"Statistics::DotProduct input vectors need to be of the same size";
	double sum = 0.0;

	for(int i=0; i< length; i++)
	{
		sum += ( input_a[i] * input_b[i]);
	}

	return sum;
}

double Oper::ComputeMse(const MATRIX& input_a, const MATRIX& input_b)
{
	double mse = 0.0;
	const unsigned int rows = (int)input_a.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = (int)input_a[0].size();
	if (rows!= input_b.size()) return -1.0e100;
	if (cols!= input_b[0].size()) return -1.0e100;
	unsigned int i, j;
	double div=0.0;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			div = input_a[i][j]-input_b[i][j];
			mse+= (div*div);
		}
	}
	return mse/(rows*cols);
}

wchar_t* Oper::ConfusionMatrix(const MATRIX& output, const MATRIX& target, MATRIX& confusionMatrix, double threshold)
{
	double mse = 0.0;
	const int rows = (int)output.size();
	if (rows==0) return L"Matrix is empty";
	//
	const int cols = (int)output[0].size();
	if (rows!= target.size()) return L"Both matrices must be the same size";
	if (cols!= target[0].size()) return L"Both matrices must be the same size";
	int i, j;
	
	int count;
	//____________________________ Check the target (0 0 1 0 0 ...)
	for(i=0; i<rows; i++)
	{
		count = 0;
		for(j=0; j<cols; j++)
		{
			if (target[i][j] != 0.0) count++;
		}
		if (count == 0) continue; // 0, 0, 0, 0, ... 0
		if (count != 1) return L"The target matrix must have zero or only one \"1\" per row";
	}
	//____________________________ Prepare confusionMatrix
	const int classCount = cols +1;
	try
	{
		if (confusionMatrix.size() != classCount) confusionMatrix.resize(classCount);
		for(i = 0; i<classCount; i++)
		{
			if (confusionMatrix[i].size() != classCount) confusionMatrix[i].resize(classCount);
			for(j = 0; j<classCount; j++)
			{
				confusionMatrix[i][j] = 0.0;
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}

	//____________________________ Compute confusionMatrix
	int output_index = -1;
	int target_index = -1;
	for(i=0; i<rows; i++)
	{
		output_index = Math::Oper::GetClass(output[i], threshold);
		target_index = Math::Oper::GetClass(target[i], threshold);
		confusionMatrix[target_index][output_index] ++;
	}
	return NULL;
}

wchar_t* Oper::ConfusionMatrix(const MATRIXC& output, const MATRIXC& target, MATRIX& confusionMatrix, double threshold)
{
	double mse = 0.0;
	const int rows = (int)output.size();
	if (rows==0) return L"Matrix is empty";
	//
	const int cols = (int)output[0].size();
	if (rows!= target.size()) return L"Both matrices must be the same size";
	if (cols!= target[0].size()) return L"Both matrices must be the same size";
	int i, j;
	
	int count;
	//____________________________ Check the target (0 0 1 0 0 ...)
	for(i=0; i<rows; i++)
	{
		count = 0;
		for(j=0; j<cols; j++)
		{
			if (target[i][j].real() != 0.0 || target[i][j].imag() != 0.0) count++;
		}
		if (count == 0) continue; // 0, 0, 0, 0, ... 0
		if (count != 1) return L"The target matrix must have zero or only one \"1\" per row";
	}
	//____________________________ Prepare confusionMatrix
	const int classCount = cols +1;
	try
	{
		if (confusionMatrix.size() != classCount) confusionMatrix.resize(classCount);
		for(i = 0; i<classCount; i++)
		{
			if (confusionMatrix[i].size() != classCount) confusionMatrix[i].resize(classCount);
			for(j = 0; j<classCount; j++)
			{
				confusionMatrix[i][j] = 0.0;
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}

	//____________________________ Compute confusionMatrix
	int output_index = -1;
	int target_index = -1;
	for(i=0; i<rows; i++)
	{
		output_index = Math::Oper::GetClass(output[i], threshold);
		target_index = Math::Oper::GetClass(target[i], threshold);
		confusionMatrix[target_index][output_index] ++;
	}
	return NULL;
}

int Oper::GetClass(const valarray<double>& inputRow, double threshold)
{
	const int len = (int)inputRow.size();
	if (len == 0) return 0;
	int i = 0;
	double maximum = inputRow[0];
	int class_index = 0;
	for(int i = 1; i<len; i++)
	{
		if (inputRow[i] > maximum)
		{
			maximum = inputRow[i];
			class_index = i;
		}
	}
	if (maximum > threshold) return class_index;
	return len;
}

int Oper::GetClass(const valarray<complex<double> >& inputRow, double threshold)
{
	const int len = (int)inputRow.size();
	if (len == 0) return 0;
	int i = 0;
	double maximum = sqrt(inputRow[0].real()*inputRow[0].real() + inputRow[0].imag()*inputRow[0].imag());
	double magnitude;
	int class_index = 0;
	for(int i = 1; i<len; i++)
	{
		magnitude = sqrt(inputRow[i].real()*inputRow[i].real() + inputRow[i].imag()*inputRow[i].imag());
		if (magnitude > maximum)
		{
			maximum = magnitude;
			class_index = i;
		}
	}
	if (maximum > threshold) return class_index;
	return len;
}

wchar_t* Oper::GetClass(const MATRIX input, valarray<int>& classes, double threshold)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		classes.resize(0);
		return L"Matrix is empty";
	}
	if (classes.size() != rows)
	{
		try
		{
			classes.resize(rows);
		}
		catch(const std::bad_alloc& )
		{
			return L"No enough memory";
		}
		for(int i = 0; i<rows; i++)
		{
			classes[i] = Math::Oper::GetClass(input[i], threshold);
		}
	}
	return NULL;
}

wchar_t* Oper::GetClass(const MATRIX input, valarray<double>& classes, double threshold)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		classes.resize(0);
		return L"Matrix is empty";
	}
	if (classes.size() != rows)
	{
		try
		{
			classes.resize(rows);
		}
		catch(const std::bad_alloc& )
		{
			return L"No enough memory";
		}
		for(int i = 0; i<rows; i++)
		{
			classes[i] = Math::Oper::GetClass(input[i], threshold);
		}
	}
	return NULL;
}

wchar_t* Oper::GetClass(const MATRIXC input, valarray<double>& classes, double threshold)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		classes.resize(0);
		return L"Matrix is empty";
	}
	if (classes.size() != rows)
	{
		try
		{
			classes.resize(rows);
		}
		catch(const std::bad_alloc& )
		{
			return L"No enough memory";
		}
		for(int i = 0; i<rows; i++)
		{
			classes[i] = Math::Oper::GetClass(input[i], threshold);
		}
	}
	return NULL;
}


void Oper::AddValue(MATRIX& in_out, double value)
{
	const unsigned int rows = (int)in_out.size();
	if (rows==0) return;
	//
	const unsigned int cols = (int)in_out[0].size();
	if (cols==0) return;
	
	unsigned int i, j;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			in_out[i][j]+=value;
		}
	}
}

void Oper::MultiplyBy(MATRIX& in_out, double value)
{
	const unsigned int rows = (int)in_out.size();
	if (rows==0) return;
	//
	const unsigned int cols = (int)in_out[0].size();
	if (cols==0) return;
	
	unsigned int i, j;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			in_out[i][j]*=value;
		}
	}
}

void Oper::DivideBy(MATRIX& in_out, double value)
{
	const unsigned int rows = (int)in_out.size();
	if (rows==0) return;
	//
	const unsigned int cols = (int)in_out[0].size();
	if (cols==0) return;
	
	unsigned int i, j;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			in_out[i][j]/=value;
		}
	}
}

bool Oper::CopyToClipboard(HWND hWnd, const MATRIX& input)
{
	const unsigned int rows = (int)input.size();
	if (rows==0) return true;
	//
	const unsigned int cols = (int)input[0].size();
	if (cols==0) return true;
	
	unsigned int i, j;

	const int length = rows*cols*MATH_MATRIX_TEXTDOUBLE+2*rows;
	HGLOBAL hGlobal;
	wchar_t* pGlobal;
	bool bOk = false;
	wchar_t texto[MATH_MATRIX_TEXTDOUBLE];

	hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (length+1)*sizeof(wchar_t));
	if (hGlobal)
	{
		pGlobal = (wchar_t*)GlobalLock(hGlobal);
		pGlobal[0]='\0';
		for(i=0; i<rows; i++)
		{
			for(j=0; j<cols; j++)
			{
				if (j<cols-1)
				{
					_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\t", input[i][j]);	
				}
				else
				{
					_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\r\n", input[i][j]);
				}
				lstrcat(pGlobal, texto);	
			}
		}

		GlobalUnlock(hGlobal);
		if (OpenClipboard(hWnd))
		{
			if (EmptyClipboard())
			{
				bOk = (SetClipboardData(CF_UNICODETEXT, hGlobal) != NULL);
			}
			CloseClipboard();
		}
	}
	return bOk;
}

bool Oper::CopyRowToClipboard(HWND hWnd, const MATRIX& input, int row_index)
{
	const unsigned int rows = (int)input.size();
	if (rows==0) return true;
	//
	const unsigned int cols = (int)input[0].size();
	if (cols==0) return true;
	
	unsigned int j;

	if (row_index<0 || (unsigned int)row_index>= rows) return false;
	const int length = cols*MATH_MATRIX_TEXTDOUBLE;
	HGLOBAL hGlobal;
	wchar_t* pGlobal;
	bool bOk = false;
	wchar_t texto[MATH_MATRIX_TEXTDOUBLE];

	hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (length+1)*sizeof(wchar_t));
	if (hGlobal)
	{
		pGlobal = (wchar_t*)GlobalLock(hGlobal);
		pGlobal[0]='\0';

		for(j=0; j<cols; j++)
		{
			if (j<cols-1)
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\t", input[row_index][j]);	
			}
			else
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g", input[row_index][j]);
			}
			lstrcat(pGlobal, texto);	
		}

		GlobalUnlock(hGlobal);
		if (OpenClipboard(hWnd))
		{
			if (EmptyClipboard())
			{
				bOk = (SetClipboardData(CF_UNICODETEXT, hGlobal) != NULL);
			}
			CloseClipboard();
		}
	}
	return bOk;
}

bool Oper::CopyColToClipboard(HWND hWnd, const MATRIX& input, int col_index)
{
	const unsigned int rows = (int)input.size();
	if (rows==0) return true;
	//
	const unsigned int cols = (int)input[0].size();
	if (cols==0) return true;
	
	unsigned int i;
	if (col_index<0 || (unsigned int)col_index>= cols) return false;
	const int length = rows*MATH_MATRIX_TEXTDOUBLE+2*rows;
	HGLOBAL hGlobal;
	wchar_t* pGlobal;
	bool bOk = false;
	wchar_t texto[MATH_MATRIX_TEXTDOUBLE];

	hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (length+1)*sizeof(wchar_t));
	if (hGlobal)
	{
		pGlobal = (wchar_t*)GlobalLock(hGlobal);
		pGlobal[0]='\0';
		for(i=0; i<rows; i++)
		{
			if (i<rows-1)
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g\r\n", input[i][col_index]);	
			}
			else
			{
				_snwprintf_s(texto, MATH_MATRIX_TEXTDOUBLE, _TRUNCATE, L"%g", input[i][col_index]);
			}
			lstrcat(pGlobal, texto);	
		}

		GlobalUnlock(hGlobal);
		if (OpenClipboard(hWnd))
		{
			if (EmptyClipboard())
			{
				bOk = (SetClipboardData(CF_UNICODETEXT, hGlobal) != NULL);
			}
			CloseClipboard();
		}
	}
	return bOk;
}

bool Oper::InsertRow(MATRIX& in_out, int rowIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int)(in_out.size() == 0 ? 0: in_out[0].size());
	if (rowIndex <0 || rowIndex>= rows) return false;

	valarray<double> newRow(cols);
	MATRIX::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.insert(p, newRow);
	return true;
}

bool Oper::InsertRow(MATRIXC& in_out, int rowIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int)(in_out.size() == 0 ? 0: in_out[0].size());
	if (rowIndex <0 || rowIndex>= rows) return false;

	valarray<complex<double> > newRow(cols);
	MATRIXC::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.insert(p, newRow);
	return true;
}

bool Oper::InsertCell(valarray<double>& in_out, int index)
{
	const int rows = (int)in_out.size();
	if (index <0 || index> rows) return false;

	valarray<double> tmp(in_out);
	in_out.resize(rows+1);
	int i = 0, j = 0;
	for(i = 0; i<rows+1; i++)
	{
		if (i<index)
		{
			in_out[i] = tmp[j++];
		}
		else if (i==index)
		{
			in_out[i] = 0.0;
		}
		else
		{
			in_out[i] = tmp[j++];
		}
	}
	return true;
}

bool Oper::InsertCell(valarray<complex<double> >& in_out, int index)
{
	const int rows = (int)in_out.size();
	if (index <0 || index> rows) return false;

	valarray<complex<double> > tmp(in_out);
	in_out.resize(rows+1);
	int i = 0, j = 0;
	for(i = 0; i<rows+1; i++)
	{
		if (i<index)
		{
			in_out[i] = tmp[j++];
		}
		else if (i==index)
		{
			in_out[i] = 0.0;
		}
		else
		{
			in_out[i] = tmp[j++];
		}
	}
	return true;
}

bool Oper::DeleteCell(valarray<double>& in_out, int index)
{
	const int rows = (int)in_out.size();
	if (index <0 || index>= rows) return false;

	valarray<double> tmp(in_out);
	in_out.resize(rows-1);
	int i = 0, j = 0;
	for(j = 0; j<rows; j++)
	{
		if (j != index)
		{
			in_out[i++] = tmp[j];
		}
	}
	return true;
}

bool Oper::DeleteCell(valarray<complex<double> >& in_out, int index)
{
	const int rows = (int)in_out.size();
	if (index <0 || index>= rows) return false;

	valarray<complex<double> >tmp(in_out);
	in_out.resize(rows-1);
	int i = 0, j = 0;
	for(j = 0; j<rows; j++)
	{
		if (j != index)
		{
			in_out[i++] = tmp[j];
		}
	}
	return true;
}

bool Oper::InsertCol(MATRIX& in_out, int colIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;
	int i = 0, j = 0, k = 0;
	valarray<double> tmp(cols+1);

	for(i=0; i<rows; i++)
	{
		//if (tmp==NULL) return false;
		for(j=0, k=0; j<cols; j++)
		{
			if (j<colIndex)
			{
				tmp[k++] = in_out[i][j];
			}
			else if (j==colIndex)
			{
				tmp[k++] = 0.0;
				tmp[k++] = in_out[i][j];
			}
			else //j>colIndex
			{
				tmp[k++] = in_out[i][j];
			}
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::InsertCol(MATRIXC& in_out, int colIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;
	int i = 0, j = 0, k = 0;
	valarray<complex <double> >tmp(cols+1);

	for(i=0; i<rows; i++)
	{
		//if (tmp==NULL) return false;
		for(j=0, k=0; j<cols; j++)
		{
			if (j<colIndex)
			{
				tmp[k++] = in_out[i][j];
			}
			else if (j==colIndex)
			{
				tmp[k++] = 0.0;
				tmp[k++] = in_out[i][j];
			}
			else //j>colIndex
			{
				tmp[k++] = in_out[i][j];
			}
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::DeleteRow(MATRIX& in_out, int rowIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int) (in_out.size() == 0 ? 0: in_out[0].size());
	if (rowIndex <0 || rowIndex>= rows) return false;

	MATRIX::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.erase(p);
	return true;
}

bool Oper::DeleteRow(MATRIXC& in_out, int rowIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int)(in_out.size() == 0 ? 0: in_out[0].size());
	if (rowIndex <0 || rowIndex>= rows) return false;

	MATRIXC::iterator p = in_out.begin();
	p+= rowIndex;
	if (p == in_out.end()) return false;
	in_out.erase(p);
	return true;
}

bool Oper::DeleteCol(MATRIX& in_out, int colIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;

	if (cols==1) 
	{
		in_out.clear();
		return true;
	}

	int i, j, k=0;
	valarray<double> tmp(cols-1);

	for(i=0; i<rows; i++)
	{
		k = 0;
		for(j=0; j<cols; j++)
		{
			if (j != colIndex) tmp[k++] = in_out[i][j];
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::DeleteCol(MATRIXC& in_out, int colIndex)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	if (colIndex <0 || colIndex>= cols) return false;

	if (cols==1) 
	{
		in_out.clear();
		return true;
	}

	int i, j, k=0;
	valarray<complex<double> >tmp(cols-1);

	for(i=0; i<rows; i++)
	{
		k = 0;
		for(j=0; j<cols; j++)
		{
			if (j != colIndex) tmp[k++] = in_out[i][j];
		}
		in_out[i] = tmp;
	}
	return true;
}

bool Oper::AppendDown(MATRIX& in_out, const MATRIX& in_B)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	const int rowsB = (int)in_B.size();
	const int colsB = (int)in_B.size() == 0 ? 0 : (int)in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}


	if (cols != colsB && rows != 0 && cols != 0) return false;
	try
	{
		in_out.resize(rows + rowsB);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(int i=0; i<rowsB; i++)
	{
		in_out[i+rows] = in_B[i];
	}
	return true;
}

bool Oper::AppendDown(MATRIXC& in_out, const MATRIXC& in_B)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	const int rowsB = (int)in_B.size();
	const int colsB = (int)in_B.size() == 0 ? 0 : (int)in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}

	if (cols != colsB && rows != 0 && cols != 0) return false;
	try
	{
		in_out.resize(rows + rowsB);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(int i=0; i<rowsB; i++)
	{
		in_out[i+rows] = in_B[i];
	}
	return true;
}

bool Oper::AppendRight(MATRIX& in_out, const MATRIX& in_B)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	const int rowsB = (int)in_B.size();
	const int colsB = (int)in_B.size() == 0 ? 0 : (int)in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}

	if (rows != rowsB && rows != 0 && cols != 0) return false;

	try
	{
		const int newColCount = cols+colsB;
		valarray<double> tmp(newColCount);

		int i, j;
		for(i=0; i<rows; i++)
		{
			for(j=0; j<cols; j++)
			{
				tmp[j] = in_out[i][j];
			}
			for(j=0; j<colsB; j++)
			{
				tmp[j+cols] = in_B[i][j];
			}
			in_out[i] = tmp;
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::AppendRight(MATRIXC& in_out, const MATRIXC& in_B)
{
	const int rows = (int)in_out.size();
	const int cols = (int)in_out.size() == 0 ? 0 : (int)in_out[0].size();
	const int rowsB = (int)in_B.size();
	const int colsB = (int)in_B.size() == 0 ? 0 : (int)in_B[0].size();

	//___________________________ If matrix is empty, just copy the new data
	if (rows == 0 && cols == 0)
	{
		in_out = in_B;
		return true;
	}

	if (rows != rowsB && rows != 0 && cols != 0) return false;

	try
	{
		const int newColCount = cols+colsB;
		valarray<complex<double> > tmp(newColCount);

		int i, j;
		for(i=0; i<rows; i++)
		{
			for(j=0; j<cols; j++)
			{
				tmp[j] = in_out[i][j];
			}
			for(j=0; j<colsB; j++)
			{
				tmp[j+cols] = in_B[i][j];
			}
			in_out[i] = tmp;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

void Oper::NormalizeRows(MATRIX& in_out)
{
	const int rows = (int)in_out.size();
	if (rows == 0) return;
	const int cols = (int)in_out[0].size();
	if (cols == 0) return;
	int i, j;
	double value;

	double maximum;
	for(i = 0; i<rows; i++)
	{
		//_____________________________ Find minimum and maximum
		maximum = fabs(in_out[i][0]);
		for(j = 1; j<cols; j++)
		{
			value = fabs(in_out[i][j]);
			if (value > maximum) maximum = value;
		}
		if (maximum == 0.0) maximum = 1.0e-100;
		//_____________________________ Normalize
		for(j = 0; j<cols; j++)
		{
			in_out[i][j] /= maximum;
		}
	}
}

void Oper::NormalizeCols(MATRIX& in_out)
{
	const int rows = (int)in_out.size();
	if (rows == 0) return;
	const int cols = (int)in_out[0].size();
	if (cols == 0) return;
	int i, j;
	double value;

	double maximum;
	for(j = 0; j<cols; j++)
	{
		//_____________________________ Find minimum and maximum
		maximum = fabs(in_out[0][j]);
		for(i = 1; i<rows; i++)
		{
			value = fabs(in_out[i][j]);
			if (value > maximum) maximum = value;
		}
		if (maximum == 0.0) maximum = 1.0e-100;
		//_____________________________ Normalize
		for(i = 0; i<rows; i++)
		{
			in_out[i][j] /= maximum;
		}
	}
}

bool Oper::GetRows(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	const int len = (int)indexes.size();
	if (len == 0) return true;
	const int rows = (int)input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//___________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i] < 0) continue;
		if (indexes[i] >= rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = (int)setint.size();
	output.resize(newlen);
	
	for(i = 0, j = 0; i<rows; i++)
	{
		if (setint.find(i) == setint.end()) continue;
		output[j] = input[i];
		j++;
	}
	return true;
}

bool Oper::GetCols(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	MATRIX tmp;
	if (Math::Oper::Transpose(input, output) == false) return false;
	if (Math::Oper::GetRows(output, tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::DeleteRows(MATRIX& input, const valarray<int> indexes)
{
	const int len = (int)indexes.size();
	if (len == 0) return true;
	const int rows = (int)input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = rows - (int)setint.size();
	try
	{
		MATRIX tmp(input);
		input.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			input[j] = tmp[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(MATRIX& input, const valarray<int> indexes)
{
	MATRIX tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, input) == false) return false;
	return true;
}

bool Oper::DeleteRows(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	const int len = (int)indexes.size();
	if (len == 0)
	{
		output.clear();
		return true;
	}
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return true;
	}
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = rows - (int)setint.size();
	try
	{
		output.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			output[j] = input[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(const MATRIX& input, MATRIX& output, const valarray<int> indexes)
{
	MATRIX tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::GetRows(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	const int len = (int)indexes.size();
	if (len == 0) return true;
	const int rows = (int)input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//___________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i] < 0) continue;
		if (indexes[i] >= rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = (int)setint.size();
	output.resize(newlen);
	
	for(i = 0, j = 0; i<rows; i++)
	{
		if (setint.find(i) == setint.end()) continue;
		output[j] = input[i];
		j++;
	}
	return true;
}

bool Oper::GetCols(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	MATRIXC tmp;
	if (Math::Oper::Transpose(input, output) == false) return false;
	if (Math::Oper::GetRows(output, tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::DeleteRows(MATRIXC& input, const valarray<int> indexes)
{
	const int len = (int)indexes.size();
	if (len == 0) return true;
	const int rows = (int)input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = (int)setint.size();
	try
	{
		MATRIXC tmp(input);
		input.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			input[j] = tmp[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(MATRIXC& input, const valarray<int> indexes)
{
	MATRIXC tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, input) == false) return false;
	return true;
}

bool Oper::DeleteRows(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	const int len = (int)indexes.size();
	if (len == 0) return true;
	const int rows = (int)input.size();
	if (rows == 0) return true;
	set<int> setint;
	int i, j;
	//_____________________________ be sure indexes are unique and valid
	for(i = 0; i<len; i++)
	{
		if (indexes[i]<0) continue;
		if (indexes[i]>=rows) continue;
		setint.insert(indexes[i]);
	}
	const int newlen = (int)setint.size();
	try
	{
		output.resize(newlen);
		for(i = 0, j = 0; i<rows; i++)
		{
			if (setint.find(i) != setint.end()) continue;
			output[j] = input[i]; 
			j++;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::DeleteCols(const MATRIXC& input, MATRIXC& output, const valarray<int> indexes)
{
	MATRIXC tmp;
	if (Math::Oper::Transpose(input, tmp) == false) return false;
	if (Math::Oper::DeleteRows(tmp, indexes) == false) return false;
	if (Math::Oper::Transpose(tmp, output) == false) return false;
	return true;
}

bool Oper::GetRow(const MATRIX& input, valarray<double>& output, int index)
{
	const int rows = (int)input.size();
	if (rows == 0) return false;
	const int cols = (int)input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >=rows) return false;
	try
	{
		output.resize(cols);
		for(int i = 0; i < cols; i++)
		{
			output[i] = input[index][i];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::GetCol(const MATRIX& input, valarray<double>& output, int index)
{
	const int rows = (int)input.size();
	if (rows == 0) return false;
	const int cols = (int)input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >= cols) return false;
	try
	{
		output.resize(rows);
		for(int i = 0; i < rows; i++)
		{
			output[i] = input[i][index];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::GetRow(const MATRIXC& input, valarray<complex<double> >& output, int index)
{
	const int rows = (int)input.size();
	if (rows == 0) return false;
	const int cols = (int)input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >=rows) return false;
	try
	{
		output.resize(cols);
		for(int i = 0; i < cols; i++)
		{
			output[i] = input[index][i];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::GetCol(const MATRIXC& input, valarray<complex<double> >& output, int index)
{
	const int rows = (int)input.size();
	if (rows == 0) return false;
	const int cols = (int)input[0].size();
	if (cols == 0) return false;
	if (index < 0 || index >= cols) return false;
	try
	{
		output.resize(rows);
		for(int i = 0; i < rows; i++)
		{
			output[i] = input[i][index];
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

wchar_t* Oper::Product(const valarray<double>& input_a, const MATRIX& input_b, int rowb_index, MATRIX& output)
{
	const int rows_a = (int)input_a.size();
	const int rows_b = (int)input_b.size();
	const int cols_b = rows_b == 0 ? 0 : (int)input_b[0].size();
	if (rowb_index<0) return L"The row index for the input matrix must be bigger than or equal to zero";
	if (rowb_index>=rows_b) return L"The row index for the input matrix is bigger than or equal to the number of rows of the matrix";
	output.resize(rows_a);
	int i, j;
	for(i = 0; i<rows_a; i++)
	{
		output[i].resize(cols_b);
		for(j = 0; j<cols_b; j++)
		{
			output[i][j] = input_a[i] * input_b[rowb_index][j];
		}
	}
	return NULL;
}

wchar_t* Oper::Product(const valarray<complex<double> >& input_a, const MATRIXC& input_b, int rowb_index, MATRIXC& output)
{
	const int rows_a = (int)input_a.size();
	const int rows_b = (int)input_b.size();
	const int cols_b = rows_b == 0 ? 0 : (int)input_b[0].size();
	if (rowb_index<0) return L"The row index for the input matrix must be bigger than or equal to zero";
	if (rowb_index>=rows_b) return L"The row index for the input matrix is bigger than or equal to the number of rows of the matrix";
	output.resize(rows_a);
	int i, j;
	for(i = 0; i<rows_a; i++)
	{
		output[i].resize(cols_b);
		for(j = 0; j<cols_b; j++)
		{
			output[i][j] = input_a[i] * input_b[rowb_index][j];
		}
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIX& input_a, const valarray<double>& input_b, valarray<double>& output)
{
	const unsigned int m = (int)input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = (int)input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = (int)input_b.size();

	if (n != p) return L"The number of columns in the Matrix is different from the vector size";

	output.resize(m);

	unsigned int i, k;
	double d;
	for(i= 0; i<m; i++)
	{
		d=0;
		for(k=0; k<n; k++)
		{
			d+=(input_a[i][k]*input_b[k]);
		}
		output[i]=d;
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIXC& input_a, const valarray<complex <double> >& input_b, valarray<complex <double> >& output)
{
	const unsigned int m = (int)input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = (int)input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = (int)input_b.size();

	if (n != p) return L"The number of columns in the Matrix is different from the vector size";

	output.resize(m);

	unsigned int i, k;
	complex<double> d;
	for(i= 0; i<m; i++)
	{
		d=0;
		for(k=0; k<n; k++)
		{
			d+=(input_a[i][k]*input_b[k]);
		}
		output[i]=d;
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIX& input_a, const valarray<double>& input_b, MATRIX& output)
{
	const unsigned int m = (int)input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = (int)input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = (int)input_b.size();

	if (n != p) return L"The number of columns in the Matrix is different from the vector size";

	output.resize(m);
	unsigned int i, k;
	for(i=0; i<m; i++) output[i].resize(1);
	double d;

	for(i= 0; i<m; i++)
	{
		d=0;
		for(k=0; k<n; k++)
		{
			d+=(input_a[i][k]*input_b[k]);
		}
		output[i][0]=d;
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIX& input_a, const MATRIX& input_b, MATRIX& output)
{

	const unsigned int m = (int)input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = (int)input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = (int)input_b.size();
	if (p==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int q = (int)input_b[0].size();
	if (q==0)
	{
		output.resize(0);
		return NULL;
	}

	if (n != p) return L"The number of columns in the first matrix is different from the number of rows in the second matrix";
	unsigned int i, j, k;

	output.resize(m);
	for(i=0; i<m; i++) output[i].resize(q);

	double d;
	for(i= 0; i<m; i++)
	{
		for (j=0; j<q; j++)
		{
			d=0;
			for(k=0; k<n; k++)
			{
				d+=(input_a[i][k]*input_b[k][j]);
			}
			output[i][j] = d;
		}
	}
	return NULL;
}

wchar_t* Oper::Product(const MATRIXC& input_a, const MATRIXC& input_b, MATRIXC& output)
{

	const unsigned int m = (int)input_a.size();
	if (m==0) 
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int n = (int)input_a[0].size();
	if (n==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int p = (int)input_b.size();
	if (p==0)
	{
		output.resize(0);
		return NULL;
	}

	const unsigned int q = (int)input_b[0].size();
	if (q==0)
	{
		output.resize(0);
		return NULL;
	}

	if (n != p) return L"The number of columns in the first matrix is different from the number of rows in the second matrix";
	unsigned int i, j, k;

	output.resize(m);
	for(i=0; i<m; i++) output[i].resize(q);

	complex<double> d;
	for(i= 0; i<m; i++)
	{
		for (j=0; j<q; j++)
		{
			d=0;
			for(k=0; k<n; k++)
			{
				d+=(input_a[i][k]*input_b[k][j]);
			}
			output[i][j] = d;
		}
	}
	return NULL;
}

bool Oper::Transpose(const MATRIX& input, MATRIX& output)
{
	const unsigned int rows = (int)input.size();
	if (rows==0)
	{
		output.resize(0);
		return true;
	}

	const unsigned int cols = (int)input[0].size();
	if (cols==0)
	{
		output.resize(0);
		return true;
	}
	
	unsigned int i, j;
	try
	{
		output.resize(cols);
		for(j=0; j<cols; j++) output[j].resize(rows);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			output[j][i]=input[i][j];
		}
	}
	return true;
}

bool Oper::Transpose(const MATRIXC& input, MATRIXC& output)
{
	const unsigned int rows = (int)input.size();
	if (rows==0)
	{
		output.resize(0);
		return true;
	}

	const unsigned int cols = (int)input[0].size();
	if (cols==0)
	{
		output.resize(0);
		return true;
	}
	
	unsigned int i, j;
	try
	{
		output.resize(cols);
		for(j=0; j<cols; j++) output[j].resize(rows);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			output[j][i]=input[i][j];
		}
	}
	return true;
}

bool Oper::GetMinMax(const MATRIXC& input, double& out_min, double& out_max)
{
	out_min = 0.0;
	out_max = 0.0;
	const int rows = (int)input.size();
	if (rows == 0) return false;
	const int cols = (int)input[0].size();
	if (cols == 0) return false;
	//_______________________________________________ Set initial minimum and maximum
	out_min = abs(input[0][0]);
	out_max = abs(input[0][0]);
	int i, j;
	double value;
	for(i = 0; i < rows; i++)
	{
		for(j = 0; j < cols; j++)
		{
			value = abs(input[i][j]);
			if (value > out_max) out_max = value;
			if (value < out_min) out_min = value;
		}
	}
	return true;
}
	
bool Oper::GetMinMax(const MATRIX& input, double& out_min, double& out_max)
{
	out_min = 0.0;
	out_max = 0.0;
	const int rows = (int)input.size();
	if (rows == 0) return false;
	const int cols = (int)input[0].size();
	if (cols == 0) return false;
	//_______________________________________________ Set initial minimum and maximum
	out_min = input[0][0];
	out_max = input[0][0];
	int i, j;
	double value;
	for(i = 0; i < rows; i++)
	{
		for(j = 0; j < cols; j++)
		{
			value = input[i][j];
			if (value > out_max) out_max = value;
			if (value < out_min) out_min = value;
		}
	}
	return true;
}

double Oper::GetMaximum(const MATRIX& input)
{
	const int rows = (int)input.size();
	if (rows == 0) return -1.0e100;
	const int cols = (int)input[0].size();
	if (cols == 0) return -1.0e100;
	double maximum = input[0][0];
	int i, j;
	double value;
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			value = input[i][j];
			if (value > maximum) maximum = value;
		}
	}
	return maximum;
}

double Oper::GetMinimum(const MATRIX& input)
{
	const int rows = (int)input.size();
	if (rows == 0) return 1.0e100;
	const int cols = (int)input[0].size();
	if (cols == 0) return 1.0e100;
	double minimum = input[0][0];
	int i, j;
	double value;
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			value = input[i][j];
			if (value < minimum) minimum = value;
		}
	}
	return minimum;
}

void Oper::SetTo(MATRIX& in_out, double value)
{
	const int rows = (int)in_out.size();
	const int cols = (rows == 0) ? 0 : (int)in_out[0].size();
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j <cols; j ++) in_out[i][j] = value;
	}
}

void Oper::SetTo(valarray<double>& in_out, double value)
{
	const int size = (int)in_out.size();
	for(int i = 0; i<size; i++) in_out[i] = value;
}

bool Oper::CreateMatrix(MATRIX& in_out, int rowCount, int colCount)
{
	try
	{
		in_out.resize(rowCount);
		for(int i = 0; i<rowCount; i++)
			in_out[i].resize(colCount);
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::AreTheyEqual(const MATRIX& a, const MATRIX& b)
{
	const int rowsA = (int)a.size();
	const int colsA = (rowsA == 0) ? 0 : (int)a[0].size();
	//
	const int rowsB = (int)b.size();
	const int colsB = (rowsB == 0) ? 0 : (int)b[0].size();
	//
	if (rowsA != rowsB) return false;
	if (colsA != colsB) return false;
	//
	int i, j;
	for(i = 0; i < rowsA; i++)
	{
		for(j = 0; j < colsA; j++)
		{
			if (a[i][j] != b[i][j]) return false;
		}
	}
	return true;
}

bool Oper::AreTheyEqual(const MATRIXC& a, const MATRIXC& b)
{
	const int rowsA = (int)a.size();
	const int colsA = (rowsA == 0) ? 0 : (int)a[0].size();
	//
	const int rowsB = (int)b.size();
	const int colsB = (rowsB == 0) ? 0 : (int)b[0].size();
	//
	if (rowsA != rowsB) return false;
	if (colsA != colsB) return false;
	//
	int i, j;
	for(i = 0; i < rowsA; i++)
	{
		for(j = 0; j < colsA; j++)
		{
			if (a[i][j] != b[i][j]) return false;
		}
	}
	return true;
}

bool Oper::CreateRandom(MATRIX& in_out, int rowCount, int colCount, double minValue, double maxValue)
{
	if (Math::Oper::CreateMatrix(in_out, rowCount, colCount) == false) return false;
	std::tr1::uniform_real<double> ur (minValue, maxValue);
	int i, j;
	for(i = 0; i < rowCount; i++)
	{
		for(j = 0; j < colCount; j++)
		{
			in_out[i][j] = ur(Math::Statistics::random_generator);
		}
	}
	return true;
}

bool Oper::CreateRandom(valarray<double>& in_out, int length, double minValue, double maxValue)
{
	try
	{
		in_out.resize(length);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	std::tr1::uniform_real<double> ur (minValue, maxValue);
	for(int i = 0; i < length; i++)
	{
		in_out[i] = ur(Math::Statistics::random_generator);
	}
	return true;
}

bool Oper::WrapVector(const valarray<double>& input, int colCount, MATRIX& output)
{
	const int len = (int)input.size();
	if (len<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	const int rows = len-colCount+1;
	if (rows<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	int i = 0, j = 0;
	try
	{
		output.resize(rows);
		for(i = 0; i<rows; i++)
		{
			output[i].resize(colCount);
			for(j = 0; j<colCount; j++)
			{
				output[i][j] = input[i+j];
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::WrapVector(const valarray<complex<double> >& input, int colCount, MATRIXC& output)
{
	const int len = (int)input.size();
	if (len<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	const int rows = len-colCount+1;
	if (rows<=0)
	{
		//____________________ nothing to do
		output.clear();
		return true;
	}
	int i = 0, j = 0;
	try
	{
		output.resize(rows);
		for(i = 0; i<rows; i++)
		{
			output[i].resize(colCount);
			for(j = 0; j<colCount; j++)
			{
				output[i][j] = input[i+j];
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::CreateMatrix(MATRIXC& in_out, int rowCount, int colCount)
{
	try
	{
		in_out.resize(rowCount);
		for(int i = 0; i<rowCount; i++)
			in_out[i].resize(colCount);
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool Oper::CreateRandomSet(valarray<double>& in_out, int length, int maxValue)
{
	if (length-1 > maxValue) return false;

	if (length-1 == maxValue) //___________________ return all the values from 0 to maxValue
	{
		try
		{
			in_out.resize(length);
		}
		catch(const std::bad_alloc& )
		{
			return false;
		}
		for(int i = 0; i<length; i++)
		{
			in_out[i] = i;
		}
		return true;
	}
	//_______________________________________
	try
	{
		in_out.resize(length);
		std::tr1::uniform_int<int> ur (0, maxValue);
		int count = 0;
		set<int> mySet;
		int value = -1;
		while(count<length)
		{
			value = ur(Math::Statistics::random_generator);
			mySet.insert(value);
			count = (int)mySet.size();
		}
		set<int>::iterator p = mySet.begin();
		for(int i = 0; i<length; i++, p++)
		{
			in_out[i] = *p;
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

double Oper::Sign(const double &a, const double &b)
{
	if (b < 0)
	{
		if (a < 0) return a;
		return -a;
	}
	if (a < 0) return -a; 
	return a;
}

// Given a set of points (x, y) it returns the value of m and b so that y = mx+b
// The function returns the mean squared error
double Oper::LineFitting(const valarray<double>& in_x, const valarray<double>& in_y, double &out_m, double &out_b)
{
	out_m = 0.0;
	out_b = 0.0;
	double mse = 9.99e300;
	const int len = (int)in_x.size();
	if (len != in_y.size()) return mse;
	double sum_x = in_x.sum();
	double sum_y = in_y.sum();
	const double mean_x = sum_x/len;
	double diff = 0.0;
	double nvariance_x = 0.0;

	int i;
	for (i=0; i<len; i++) 
	{
		diff = in_x[i] - mean_x;
		nvariance_x += diff*diff;
		out_m += diff * in_y[i];
	}
	out_m /= nvariance_x; 
	out_b = (sum_y - sum_x*out_m)/(double)len;
	//__________________________________ compute the mse
	mse = 0.0;
	for (i=0; i<len; i++)
	{
		diff = in_y[i] - (out_m * in_x[i] + out_b);
		mse += diff*diff;
	}
	return mse/len;
}

//____________________________________________________________ SimulatedAnnealing
SimulatedAnnealing::SimulatedAnnealing(void)
{
	numTemps=100;
	numIterations=100;
	initialTemp=100.0;
	finalTemp=1.0e-6;
	isCoolingScheduleLinear=false;
	cycles = 10;
	goal = 1.0e-10;
	solution = NULL;
	work1 = NULL; 
	work2 = NULL;
	error = NULL;
	stopWhenDone = true; 
}

SimulatedAnnealing::~SimulatedAnnealing(void)
{
}

DWORD SimulatedAnnealing::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	if (error == NULL) return 0;
	running.Set(true);
	double errorWork1 = SIMANNEAL_INITIAL_ERROR;

	//__________________________________ work2 will be used to test if the solution has be initialized
	work2->SimAnnealInitialize();
	double errorWork2 = fabs(work2->SimAnnealGetError());
	//
	double errorSolution = fabs(solution->SimAnnealGetError());
	if (errorSolution > errorWork2)
	{
		solution->SimAnnealInitialize();
		errorSolution = fabs(solution->SimAnnealGetError());
		if (errorWork2 < errorSolution)
		{
			//______________________ Copy Work 2 to current solution
			solution->SimAnnealCopy(*work2);
			errorSolution = errorWork2;
		}
	}

	int index_cycles, index_temp, index_iter;
	const int eval_compK = 200;

	progress.Set(0.0);
	error->Set(errorSolution);
	//___________________________________________________ Estimate K and prepare for annealing
	double k = EstimateK(eval_compK, running);
	//int no_eval = eval_compK;
	const int total_eval = eval_compK + cycles*numTemps*numIterations;
	progress.Set(100.0*eval_compK/(double)total_eval);
	double temperature, deltaError;
	int retries;
	bool brunning = false;
	bool improved = false;
	if (initialTemp == 0.0) initialTemp = 1.0;
	if (finalTemp > initialTemp) finalTemp = initialTemp/10.0;
	const double alpha = (isCoolingScheduleLinear == true) ? (initialTemp-finalTemp)/(numTemps-1.0) : pow(finalTemp/initialTemp, 1.0/(numTemps-1.0) );
	std::tr1::uniform_real<double> dist(0.0, 1.0);
	//___________________________________________________ Annealing  METHOD 3
	// work2 is the solution of the traditional algorithm.  solution keeps the best work2 ever during the simulation
	for(index_cycles=0; index_cycles<cycles; index_cycles++)
	{
		work2->SimAnnealCopy(*solution);
		errorWork2 = errorSolution;
		//
		improved = false;
		temperature = initialTemp;
		for (index_temp=0; index_temp<numTemps; index_temp++) 
		{  
			retries = 0;	
			//_____________________________ Iterate at this temperature
			for (index_iter=0; index_iter<numIterations; index_iter++)
			{ 
				progress.Set(100.0*(index_cycles*numTemps*numIterations+index_temp*numIterations+index_iter+eval_compK)/(double)total_eval);
				//
				work1->SimAnnealPerturb(*work2, temperature, initialTemp);
				errorWork1 = fabs(work1->SimAnnealGetError());
				//
				deltaError =  errorWork1 - errorWork2;

				if (deltaError <= 0 || dist(Math::Statistics::random_generator) < exp(-k*deltaError/temperature))
				{  
					improved = true;
					if (retries<5)
					{
						index_iter = 0;
						retries++;
					}
					//______________________ Copy Work1 to Work 2
					work2->SimAnnealCopy(*work1);
					errorWork2 = errorWork1;

					//______________________ Is Work2 better than current solution ?
					if (errorWork2 < errorSolution) 
					{
						//______________________ Copy Work 2 to current solution
						solution->SimAnnealCopy(*work2);
						errorSolution = errorWork2;
						//______________________ Report to main thread
						if (error != NULL) error->Set(errorSolution);
						//______________________ If we reach the goal, we return
						if (errorSolution<=goal)
						{
							error->Set(errorSolution);
							progress.Set(100.0);
							if (stopWhenDone == true) running.Set(false);
							return 0;
						}
					}
				}   
				if (running.GetTry(brunning))
				{
					if (brunning == false) // user has cancelled
					{
						error->Set(errorSolution);
						progress.Set(100.0);
						return 0;
					}
				}
			} //_______________________ End iterations
			if (isCoolingScheduleLinear == true)
			{
				temperature -= alpha;
			}
			else
			{
				temperature *= alpha;
			}
		} //_______________________ End temperatures
		if (improved == false) break;
	} //__________________________ End cycles
	error->Set(errorSolution);
	progress.Set(100.0);
	if (stopWhenDone == true) running.Set(false);
	return 0;
}

void SimulatedAnnealing::SetSimulationParameters(const Math::SimAnnealParam& in_param)
{
	this->numTemps = in_param.numTemps;
	this->numIterations = in_param.numIterations;
	this->initialTemp = in_param.initialTemp;
	this->finalTemp = in_param.finalTemp;
	this->isCoolingScheduleLinear = in_param.isCoolingScheduleLinear;
	this->cycles = in_param.cycles;
	this->goal = in_param.goal;
}

void SimulatedAnnealing::GetSimulationParameters(Math::SimAnnealParam& out_param)
{
	out_param.numTemps = this->numTemps;
	out_param.numIterations = this->numIterations;
	out_param.initialTemp = this->initialTemp;
	out_param.finalTemp = this->finalTemp;
	out_param.isCoolingScheduleLinear = this->isCoolingScheduleLinear;
	out_param.cycles = this->cycles;
	out_param.goal = this->goal;
}

void SimulatedAnnealing::Setup(Mt::DoubleTs& error, ISimAnneal& solution, ISimAnneal& work1, ISimAnneal& work2)
{
	this->error = &error;
	this->solution = &solution;
	this->work1 = &work1;
	this->work2 = &work2;
}

double SimulatedAnnealing::EstimateK(int N, Mt::BoolTs& running)
{
	double E = 1.0;
	double sum = 0.0;
	double sums = 0.0;

	for(int i = 0; i<N; i++)
	{
		work2->SimAnnealPerturb(*solution, initialTemp, initialTemp);
		E = fabs(work2->SimAnnealGetError());
		sum+=E;
		sums+=(E*E);
		if (running.Get()==false) return 1.0e100;
	}
	// return sums/(size-1.0) - (sum*sum)/(size*(size-1.0));
	const double variance  = sums/(N-1.0) - (sum*sum)/(N*(N-1.0));
	return -log(0.05)*initialTemp/sqrt(variance);
}

//____________________________________________________________ GeneticParam

//____________________________________________________________ GeneticIndividual
GeneticIndividual::GeneticIndividual()
{
	error = 1.0e100;
	fitness = 0.0;
}

GeneticIndividual::~GeneticIndividual()
{
}

GeneticIndividual::GeneticIndividual(const GeneticIndividual& init)
{
	error = 1.0e100;
	fitness = 0.0;
	Copy(init);
}

GeneticIndividual& GeneticIndividual::operator=(const GeneticIndividual& init)
{
	Copy(init);
	return *this;
}

void GeneticIndividual::Copy(const GeneticIndividual &init)
{
	this->bits = init.bits;
	this->error = init.error;
	this->fitness = init.fitness;
}

bool GeneticIndividual::operator<(const GeneticIndividual& input) const
{
	if (this->error < input.error) return true;
	return false;
}

//____________________________________________________________ GeneticAlgorithm
GeneticAlgorithm::GeneticAlgorithm()
{
	initPopulationSize = 100;
	numGenerations = 50;
	overPopulation = 1.5;
	mutationProbability = 0.0001;
	crossoverProbability = 0.85;
	goal = 0.0001;
	//blockSize = 1;
	//
	igenetic = NULL;
	stopWhenDone = true;
	error = NULL;
}

GeneticAlgorithm::~GeneticAlgorithm()
{
}

void GeneticAlgorithm::Delete()
{
	igenetic = NULL;
	poolA.clear();
	poolB.clear();
	poolOverPop.clear();
	bestIndividual.bits.Delete();
	bestIndividual.error = 1.0e100;
	bestIndividual.fitness = 0.0;
	error = NULL;
}

bool GeneticAlgorithm::Setup(Mt::DoubleTs& error, int individualSize, Math::IGenetic& igenetic)
{
	Delete();
	const int numIndividuals = initPopulationSize;
	if (bestIndividual.bits.Create(individualSize)==false) return false;

	//________________________________________________________ Over population
	if (overPopulation < 1.0) overPopulation = 1.5;
	//if (overPopulation > 2.0) overPopulation = 2.0;
	const int numOverIndividuals = (int)(numIndividuals*overPopulation+0.5);

	try
	{
		poolA.resize(numIndividuals);
		poolB.resize(numIndividuals);
		selection.resize(numIndividuals);
		poolOverPop.resize(numOverIndividuals);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	
	int i;
	//____________________________________ Create population
	for(i=0; i<numIndividuals; i++)
	{
		if (poolA[i].bits.Create(individualSize)==false) return false;
		if (poolB[i].bits.Create(individualSize)==false) return false;
	}
	
	for(list<Math::GeneticIndividual>::iterator p = poolOverPop.begin(); p != poolOverPop.end(); p++)
	{
		if (p->bits.Create(individualSize)==false) return false;
	}
	this->error = &error;
	this->igenetic = &igenetic;
	return true;
}

DWORD GeneticAlgorithm::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	if (igenetic == NULL || error == NULL)
	{
		if (stopWhenDone == true)
		{
			running.Set(false);
			return 0;
		}
	}
	progress.SetTry(0.0);
	const int numIndividuals = (int)poolA.size();

	//_________________________________________________________ Best Individual
	igenetic->GeneticSetFromBits(bestIndividual.bits);
	bestIndividual.error = fabs(igenetic->GeneticGetError());
	error->SetTry(bestIndividual.error);

	//_________________________________________________________ Create Population
	const int overPopulationSize = (int)poolOverPop.size();
	const double total = overPopulationSize + numIndividuals*numGenerations;
	bool brunning = false;

	for(list<Math::GeneticIndividual>::iterator p = poolOverPop.begin(); p != poolOverPop.end(); p++)
	{
		igenetic->GeneticInitialize(p->bits);
		igenetic->GeneticSetFromBits(p->bits);
		p->error = fabs(igenetic->GeneticGetError());
		if (running.GetTry(brunning))
		{
			if (brunning == false) return 0; // user has cancelled
		}
	}
	poolOverPop.sort();
	//______________________________________________________ Copy best individuals to poolA
	int i = 0;
	for(list<Math::GeneticIndividual>::iterator p = poolOverPop.begin(); p != poolOverPop.end()&& i<numIndividuals; p++, i++)
	{
		poolA[i] = *p;
	}
	progress.SetTry(100.0*numIndividuals*overPopulation/total);
	if (poolA[0].error < bestIndividual.error) // Best individual is the first in the pool 
	{
		bestIndividual.bits = poolA[0].bits;
		bestIndividual.error = poolA[0].error;
	}
	error->SetTry(bestIndividual.error); 
	bool firstTime = true;

	//________________________________________________________ Begin first generation
	bool usePoolA = true;
	int generation, individual;
	for(generation = 0; generation<numGenerations; generation++)
	{
		for(individual = 0; individual<numIndividuals; individual++)
		{
			progress.SetTry(100.0*(numIndividuals*overPopulation + generation*numIndividuals + individual)/total);
			if (usePoolA)
			{
				if (firstTime == false) // Skip computing poolA errors the first time as they have been already computed
				{
					igenetic->GeneticSetFromBits(poolA[individual].bits);
					poolA[individual].error = fabs(igenetic->GeneticGetError());
					if (poolA[individual].error < bestIndividual.error)
					{
						bestIndividual = poolA[individual]; 
						error->SetTry(bestIndividual.error);
					}
				}
				if (running.GetTry(brunning))
				{
					if (brunning == false) break;
				}
			}
			else
			{
				igenetic->GeneticSetFromBits(poolB[individual].bits);
				poolB[individual].error = fabs(igenetic->GeneticGetError());
				if (poolB[individual].error < bestIndividual.error)
				{
					bestIndividual = poolB[individual]; 
					error->SetTry(bestIndividual.error);
				}
				if (running.GetTry(brunning))
				{
					if (brunning == false) break;
				}
			}
		}
		//___________________________________________ End of Current Generation
		firstTime = false;
		if (usePoolA)
		{
			CreateNewGeneration(poolA, poolB);
			usePoolA = false;
		}
		else
		{
			CreateNewGeneration(poolB, poolA);
			usePoolA = true;
		}
	}

	//____________________________________________ End of Evolution
	error->SetTry(bestIndividual.error);
	igenetic->GeneticSetFromBits(bestIndividual.bits);
	if (stopWhenDone == true)
	{
		running.Set(false);
		return 0;
	}
	return 0;
}

void GeneticAlgorithm::CreateNewGeneration(vector<Math::GeneticIndividual>& parents, vector<Math::GeneticIndividual>& children)
{
	ComputeFitness(parents);
	ComputeChoices(parents); //It updates selection vector
	//_______________________________________________Generate the children
	const int numIndividuals = (int)parents.size();
	int numCrossover = (int)(crossoverProbability * numIndividuals+0.5); 
	bool bFirstChild = true; 
	int motherIndex = -1;
	int fatherIndex = -1;
	int count = numIndividuals;
	int i, j;

	for (i=0; i<numIndividuals; i++, numCrossover--) 
	{
		if (bFirstChild) SelectParents(count, motherIndex, fatherIndex); // Returns the mother index and the father index

		if (numCrossover > 0)
		{
			//__________________________ Crossovers
			Reproduce(parents[motherIndex], parents[fatherIndex], children[i], bFirstChild);	
		}
		else if (bFirstChild)
		{
			children[i] = parents[motherIndex];
		}
		else
		{
			children[i] = parents[fatherIndex];
		}

		bFirstChild = ! bFirstChild;
	}

	//________________________________________________________ Mutation
	std::tr1::uniform_real<double> probability(0.0, 1.0);
	const int individualSize = poolA[0].bits.GetCount();
	for(i=0; i<numIndividuals; i++)
	{
		for(j=0; j<individualSize; j++)
		{
			if (probability(Math::Statistics::random_generator) < mutationProbability)
			{
				children[i].bits.FlipBit(j);
			}
		}
	}
}

void GeneticAlgorithm::ComputeFitness(vector<Math::GeneticIndividual>& pool)
{
	const int numIndividuals = (int)poolA.size();
	int i;
	double avgFitness = 0.0;
	double maxFitness = -1.e30;
	double minFitness = 1.e30;
	double fitness;

	//_______________________________ Computer maximum, minimum and average (fitness)
	for (i=0; i<numIndividuals; i++) 
	{
		fitness = exp(-20.0 * pool[i].error);
		pool[i].fitness = fitness;
		avgFitness += fitness;
		if (fitness > maxFitness) maxFitness = fitness;
		if (fitness < minFitness) minFitness = fitness;
	}
	avgFitness /= (double) numIndividuals;

	//_______________________________ linear transformation y = m x + b
	double deltaFitness = maxFitness - avgFitness;
	double m = 1.0;
	double b = 0.0;
	const double favor_best = 3.1;
	if (deltaFitness > 1.e-20) 
	{ 
		m = (favor_best - 1.0) * avgFitness / deltaFitness;
		b = avgFitness * (maxFitness - favor_best * avgFitness) / deltaFitness;
	}

	//_______________________________ force positive fitness values
	if (m * minFitness + b < 0.0)
	{ 
		deltaFitness = avgFitness - minFitness;
		if (deltaFitness > 1.e-20) 
		{
			m = avgFitness / deltaFitness;
			b = -minFitness * avgFitness / deltaFitness;
		}
		else 
		{
			m = 1.0;
			b = 0.0;
		}
	}

	//____________________________________________ scale
	avgFitness = 0.0;
	for (i=0; i<numIndividuals; i++) 
	{
		fitness = m * pool[i].fitness + b;
		if (fitness < 0.0) fitness = 0.0;
		pool[i].fitness = fitness;
		avgFitness += fitness;
	}
	avgFitness /= (double) numIndividuals;

	//Normalize: fitness is the expected number of times the individual may be chosen
	for (i=0; i<numIndividuals; i++)
	{
		pool[i].fitness =  pool[i].fitness / avgFitness;
	}
}

void GeneticAlgorithm::ComputeChoices (vector<Math::GeneticIndividual>& pool)
{
	const int numIndividuals = (int)poolA.size();
	int i = 0, k = 0, expected = 0;
	std::tr1::uniform_int<int> distInd(0, numIndividuals-1);
	std::tr1::uniform_real<double> probability(0.0, 1.0);

	//________________________ assigns parents according to the integer part of their expected frequencies.
	for (i=0, k=0; i<numIndividuals; i++) 
	{
		expected = (int) pool[i].fitness; 
		pool[i].fitness = pool[i].fitness - expected; 
		while (expected--) selection[k++] = i;
	}

	//________________________ assigns parents according to the remaining part of their expected frequencies.
	while (k < numIndividuals) 
	{  
		i = distInd(Math::Statistics::random_generator);
		if (pool[i].fitness> 0.0) // Individuals still having a chance to be selected
		{   
			if (pool[i].fitness >= probability(Math::Statistics::random_generator)) 
			{ 
				selection[k++] = i; 
				pool[i].fitness = pool[i].fitness - 1.0; // reduce probabily of being selected
			}
		}
	}
}

void GeneticAlgorithm::Reproduce(const Math::GeneticIndividual& mother, const Math::GeneticIndividual& father, Math::GeneticIndividual& out_child, bool isFirstChild)
{
	static int combinationPoint1 = 0;
	static int combinationPoint2 = 0;
	const int individualSize = mother.bits.GetCount();

	if (isFirstChild) 
	{
		tr1::uniform_int<int> dist(0, individualSize-1); // We do not want croossover points at the ends
		//tr1::uniform_int<int> dist(1, individualSize-2); // We do not want croossover points at the ends
		
		const int a = dist(Math::Statistics::random_generator);
		const int b = dist(Math::Statistics::random_generator);

		//if (blockSize == 1)
		//{
		//	a = dist(Math::Statistics::random_generator);
		//	b = dist(Math::Statistics::random_generator);
		//	//do
		//	//{
		//	//	b = dist(Math::Statistics::random_generator);
		//	//}
		//	//while (a== b);
		//}
		//else
		//{
		//	do
		//	{
		//		a = dist(Math::Statistics::random_generator);
		//	}
		//	while (a%blockSize != 0);
		//	do
		//	{
		//		b = dist(Math::Statistics::random_generator);
		//	}
		//	while(b%blockSize != 0);
		//}

		if (a<b)
		{
			combinationPoint1 = a;
			combinationPoint2 = b;
		}
		else
		{
			combinationPoint1 = b;
			combinationPoint2 = a;
		}
		//_____________________________________________________ Create the first child
		out_child.bits = mother.bits;
		//if (combinationPoint1 == combinationPoint2) return;
		out_child.bits.CopyBits(father.bits, combinationPoint1, combinationPoint2);
	}
	else
	{
		//_____________________________________________________ Create the second child
		out_child.bits = father.bits;
		//if (combinationPoint1 == combinationPoint2) return;
		out_child.bits.CopyBits(mother.bits, combinationPoint1, combinationPoint2);
	}
}

void GeneticAlgorithm::SelectParents(int &count,  int &out_mother, int &out_father)
{

	//________________________________________ select mother
	std::tr1::uniform_int<int> disMother(0, count-1);
	int motherIndex = disMother(Math::Statistics::random_generator);
	out_mother = selection[motherIndex];   
	selection[motherIndex] = selection[--count]; 
	//________________________________________ select father
	std::tr1::uniform_int<int> disFather(0, count-1);
	int fatherIndex = disFather(Math::Statistics::random_generator);
	out_father = selection[fatherIndex];
	selection[fatherIndex] = selection[--count];
}

void GeneticAlgorithm::ListIndividuals(HWND hWnd)
{
	wchar_t texto[256];
	wstring info;
	const int numIndividuals = (int)poolA.size();

	int i;
	//__________________________________________________ pool A
	for(i=0; i<numIndividuals; i++)
	{
		_snwprintf_s(texto, 256, _TRUNCATE, L"ind[%d]\t\terror = %.10f\r\n", i, poolA[i].error);
		info += texto;
		::MessageBox(hWnd, info.c_str(), L"Pool A", MB_OK);
	}
	info = L"";
	//__________________________________________________ pool B
	for(i=0; i<numIndividuals; i++)
	{
		_snwprintf_s(texto, 256, _TRUNCATE, L"ind[%d]\t\terror = %.10f\r\n", i, poolB[i].error);
		info += texto;
		::MessageBox(hWnd, info.c_str(), L"Pool B", MB_OK);
	}
}

//_____________________________________________________________________FindMinimum
FindMinimum::FindMinimum(void)
{
}

FindMinimum::~FindMinimum(void)
{
}

void FindMinimum::Bracketing(Math::IFunction& func, Math::Point& a, Math::Point& b, Math::Point& c)
{
	const double golden_ration = (1.0 + sqrt(5.0))/2.0;
	a.y = func.EvaluateFunc(a.x);
	b.y = func.EvaluateFunc(b.x);

	if (b.y > a.y) //_______________________________ Swap to go to the righ direction
	{ 
		Math::Point tmp = a;
		a = b; 
		b = tmp;
	}

	//________________________________________ Guess c
	c.x = b.x + golden_ration * (b.x - a.x); 
	c.y = func.EvaluateFunc(c.x);

	double m1 = 0.0; 
	double m2 = 0.0; 
	double delta_m = 0.0;
	Math::Point u;
	double edge = 0.0;
	double frac = 0.0;
	while (b.y > c.y) 
	{ 
		m1 = (b.x - a.x) * (b.y - c.y); 
		m2 = (b.x - c.x) * (b.y - a.y);
		delta_m = m2 - m1;
		frac = (fabs(delta_m) > 1.0e-20) ? fabs(delta_m) : 1.0e-20;
		frac = 2.0 * Math::Oper::Sign(frac, delta_m);
		u.x = b.x - ((b.x - c.x) * m2 - (b.x - a.x)* m1) / frac;
		edge = b.x + 100.0 * (c.x - b.x);

		if ((b.x - u.x)*(u.x - c.x) > 0.0) //_____________________________________ Case 1
		{ 
			u.y = func.EvaluateFunc(u.x);
			if (u.y < c.y) //Minimum between b and c
			{ 				
				a = b;
				b = u;
				return;
			} 
			else if (u.y > b.y) //Minimum between a and u
			{ 
				c = u;
				return;
			}
			else
			{
				u.x = c.x + golden_ration * (c.x - b.x); //Default
				u.y=func.EvaluateFunc(u.x);
			}
		} 
		else if ((c.x - u.x)*(u.x - edge) > 0.0)  //_________________________________ Case 2
		{ 
			u.y = func.EvaluateFunc(u.x);
			if (u.y < c.y) 
			{
				b = c;
				c = u;
				u.x += ( golden_ration * (u.x - c.x) );
				u.y = func.EvaluateFunc(u.x);
			}
		} 
		else if ((u.x - edge)*(edge - c.x) >= 0.0)  //______________________________ Case 3
		{ 
			u.x = edge;
			u.y = func.EvaluateFunc(u.x);
		} 
		else  //______________________________________________________ Case 4
		{ 
			u.x = c.x + golden_ration * (c.x - b.x);
			u.y = func.EvaluateFunc(u.x);
		}
		a = b;
		b = c;
		c = u;
	}
}

double FindMinimum::BrentWithDerivative(Math::IFunctionD& func, const double a, const double b, const double c, const double tol, double &out_min_x)
{
	double x1 = (a < c) ? a : c;
	double x2 = (a > c ) ? a : c;
	Math::DPoint p;
	p.x = b;
	//
	//p.y = func.EvaluateFunc(p.x);
	//p.dy = func.EvaluateDeri(p.x);
	func.EvaluateFuncAndDeriv(p.x, p.y, p.dy);
	//
	Math::DPoint w = p;
	Math::DPoint v = p;
	Math::DPoint u;
	double xm = 0.0;
	double tol1 = 0.0;
	double tol2 = 0.0;
	double d = 0.0;
	double d1 = 0.0;
	double d2 = 0.0;
	double u1 = 0.0;
	double u2 = 0.0;
	bool ok1 = false;
	bool ok2 = false;
	double olderror = 0.0;
	double error = 0.0;
	const double epsilon = numeric_limits<double>::epsilon()*1.0e-3;

	for (int i = 0; i < 110; i++) 
	{
		xm = 0.5 * (x1 + x2);
		tol1 = tol * fabs(p.x) + epsilon;
		tol2 = 2.0*tol1;
		if (fabs(p.x - xm) <= (tol2-0.5*(x2 - x1))) 
		{
			out_min_x = p.x;
			return p.y;
		}

		if (fabs(error) > tol1) 
		{
			d1 = 2.0 * (x2 - x1); 
			d2 = d1; 
			if (w.dy != p.dy)
			{
				d1 = (w.x - p.x)*p.dy/(p.dy - w.dy); 
			}
			if (v.dy != p.dy) 
			{
				d2 = (v.x - p.x) * p.dy / (p.dy - v.dy); 
			}
			//
			u1 = p.x + d1;
			u2 = p.x + d2;
			ok1 = (x1 - u1)*(u1 - x2) > 0.0 && p.dy*d1 <= 0.0;
			ok2 = (x1 - u2)*(u2 - x2) > 0.0 && p.dy*d2 <= 0.0;
			olderror = error; 
			error = d;
			if (ok1 == true || ok2 == true) 
			{ 
				if (ok1 == true && ok2 == true)
				{
					d = (fabs(d1) < fabs(d2)) ? d1 : d2;
				}
				else if (ok1 == true)
				{
					d = d1;
				}
				else
				{
					d = d2;
				}

				if (fabs(d) <= fabs(0.5*olderror)) 
				{
					u.x = p.x + d;
					if (u.x - x1 < tol2 || x2 - u.x < tol2)
					{
						d = Math::Oper::Sign(tol1, xm - p.x);
					}
				} 
				else 
				{ 
					error = (p.dy >= 0.0) ? (x1 - p.x) : (x2 - p.x);
					d = 0.5 * error;
				}
			} 
			else 
			{
				error = (p.dy >= 0.0) ? (x1 - p.x) : (x2 - p.x);
				d = 0.5 * error;
			}
		} 
		else 
		{
			error = (p.dy >= 0.0) ? (x1 - p.x) : (x2 - p.x);
			d = 0.5 * error;
		}
		if (fabs(d) >= tol1) 
		{
			u.x = p.x + d;
			func.EvaluateFuncAndDeriv(u.x, u.y, u.dy); //u.y = func.EvaluateFunc(u.x);
		} 
		else 
		{
			u.x = p.x + Math::Oper::Sign(tol1, d);
			func.EvaluateFuncAndDeriv(u.x, u.y, u.dy); //u.y = func.EvaluateFunc(u.x);
			if (u.y > p.y) 
			{ 
				out_min_x = p.x;
				return p.y;
			}
		}

		//u.dy = func.EvaluateDeri(u.x); 
		if (u.y <= p.y) 
		{
			if (u.x >= p.x)
			{
				x1 = p.x; 
			}
			else 
			{
				x2 = p.x;
			}
			v = w;
			w = p;
			p = u;
		} 
		else 
		{
			if (u.x< p.x)
			{
				x1 = u.x; 
			}
			else
			{
				x2 = u.x;
			}
			if (u.y <= w.y || w.x == p.x) 
			{
				v = w;
				w = u;
			} 
			else if (u.y < v.y || v.x == p.x || v.x == w.x) 
			{
				v = u;
			}
		}
	}
	return 9.99e300;
}

// It computes the value of x that minimizes y = f(x)
// given the values of a, b and c returned by the funcion Bracketing()
// The function returns the y = f(x) and out_minX where out_minX is value of x that produces the minimum value of y 
double FindMinimum::Brent(Math::IFunction& func, const double a, const double b, const double c, const double tol, double &out_minX)
{
	const double golden_section = (3.0 - sqrt(5.0))/2.0;
	const double zepsilon = numeric_limits<double>::epsilon()*1.0e-3;
	double d=0.0, etemp, fu;
	double p, q, r, tol1, tol2, u, xm;
	double distance = 0.0; 
	double ax = (a < c ? a : c);
	double bx = (a > c ? a : c);
	double x = b;
	double w = b;
	double v = b;
	double fx = func.EvaluateFunc(x);
	double fw = fx;
	double fv = fx;
	for (int iter = 0; iter < 200; iter++) 
	{ 
		xm=0.5*(ax + bx);
		tol2=2.0*(tol1=tol*fabs(x) + zepsilon);
		//_______________________________________________ Are we done?
		if (fabs(x-xm) <= (tol2-0.5*(bx - ax))) 
		{ 
			out_minX=x;
			return fx;
		}
		if (fabs(distance) > tol1) 
		{ 
			r = (x - w)*(fx - fv);
			q = (x - v)*(fx - fw);
			p = (x - v)*q-(x - w)*r;
			q = 2.0*(q - r);
			if (q > 0.0) p = -p;
			q = fabs(q);
			etemp = distance;
			distance = d;
			if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(ax - x) || p >= q*(bx - x))
			{
				distance = (x >= xm) ? (ax - x) : (bx - x);
				d = golden_section*distance;
			}
			else 
			{
				d = p / q;
				u = x + d;
				if (u - ax < tol2 || bx - u < tol2)
				{
					if (xm-x >= 0)
					{
						d = (tol1 >= 0) ? tol1 : -tol1;
					}
					else
					{
						d = (tol1 >= 0) ? -tol1 : tol1;
					}
				}
			}
		} 
		else 
		{
			distance = (x >= xm) ? ax - x : bx - x;
			d = golden_section*distance;
		}
		if (fabs(d) >= tol1)
		{
			u = x + d;
		}
		else
		{
			if (d >= 0)
			{
				u = (tol1 >= 0) ? x+tol1 : x-tol1;
			}
			else
			{
				u = (tol1 >= 0) ? x-tol1 : x+tol1;
			}
		}
		fu=func.EvaluateFunc(u);
		if (fu <= fx) 
		{ 
			if (u >= x)
			{
				ax = x; 
			}
			else
			{
				bx = x;
			}
			//_________________ Shift x
			v = w;
			w = x;
			x = u;
			//_________________ Shift f(x)
			fv = fw;
			fw = fx;
			fx = fu;
		} 
		else 
		{
			if (u < x)
			{
				ax = u;
			}
			else 
			{
				bx = u;
			}
			if (fu <= fw || w == x) 
			{
				v = w;
				w = u;
				fv = fw;
				fw = fu;
			} 
			else if (fu <= fv || v == x || v == w) 
			{
				v = u;
				fv = fu;
			}
		}
	}
	out_minX = x; //Never get here.
	return fx;
}

//_____________________________________________________________________ FindMinimumMV
FindMinimumMV::FindMinimumMV()
{
	ifunc = NULL;
	stopWhenDone = true;
	error = NULL;
	numIterations = 220;
	goal = 1.0e-8;
	method = WT_MATH_CONJGRAD;
}

FindMinimumMV::~FindMinimumMV()
{
}

bool FindMinimumMV::Setup(Mt::DoubleTs& error, Math::IMultiVarFuncD& ifunc, const valarray<double>& startingPoint, int numIterations, double goal, int method)
{
	if (method != WT_MATH_CONJGRAD && method != WT_MATH_VARMETRIC) return false;
	this->method = method;
	this->error = &error;
	this->ifunc = &ifunc;
	const int size = (int)startingPoint.size();
	if (size == 0) return false;

	try
	{
		solution = startingPoint;
		derivative.resize(size);
		derg.resize(size);
		derh.resize(size);
		//
		xtmp.resize(size);
		dertmp.resize(size);
		//
		if (method == WT_MATH_VARMETRIC)
		{
			g.resize(size);
			hessian.resize(size);
			for(int i = 0; i<size; i++) hessian[i].resize(size);
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	this->numIterations = numIterations;
	this->goal = goal;
	return true;
}

DWORD FindMinimumMV::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	if (ifunc == NULL) return 0;
	if (error == NULL) return 0;
	progress.SetTry(0.0);
	double derror = 9.99e300;

	if (method == WT_MATH_CONJGRAD)
	{
		derror = ConjugateGradient(running, progress);
	}
	else if (method == WT_MATH_VARMETRIC)
	{
		derror = VariableMetric(running, progress);
	}
	error->Set(derror);
	if (stopWhenDone) running.Set(false);
	return 0;
}

double FindMinimumMV::ConjugateGradient(Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	const int len = (int)solution.size();
	if (len == 0) return 9.99e300;
	bool brunning = false;
	double derror = 9.99e300;
	double gradient, gam, dgg;
	const double ftol = 1.0e-7;

	//________________________________ Compute the function and its derivative at the starting solution
	//double fx = ifunc->EvaluateFunc(solution); 
	//ifunc->EvaluateGrad(solution, derivative); 
	double fx = 0.0;
	ifunc->EvaluateFuncAndGrad(solution, fx, derivative);
	
	derivative = -derivative;
	derh = derivative;
	derg = derivative;
	int i = 0, j = 0;
	double dummy;

	for(i = 1; i<= numIterations; i++) 
	{ 
		progress.SetTry(100.0*i/(double)numIterations);
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		derror = MoveAlongDirection(); 
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		error->SetTry(derror);
		//____________________________________ Stop when goal has been reached
		if (derror <= goal) return derror;
		//____________________________________ Stop when there is no improvement
		if (2.0*fabs(derror-fx) <= ftol*(fabs(derror)+fabs(fx)+1.0e-8)) 
		{
			return derror; // done
		}
		fx = derror;
		//
		//ifunc->EvaluateGrad(solution, derivative); 
		ifunc->EvaluateFuncAndGrad(solution, dummy, derivative);
		//
		dgg = gradient = 0.0;
		for (j=0; j<len; j++) 
		{
			gradient += derg[j]*derg[j];
			dgg += (derivative[j]+derg[j])*derivative[j]; 
		}
		if (gradient == 0.0) //____________________ Stop when gradient is zero
		{
			return derror;
		}
		gam=dgg/gradient;
		for (j=0; j<len; j++) 
		{
			derg[j] = -derivative[j];
			derivative[j] = derh[j]= derg[j] + gam * derh[j];
		}
	}
	return derror;
}

double FindMinimumMV::VariableMetric(Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	const int len = (int)solution.size();
	if (len == 0) return 9.99e300;
	bool brunning = false;
	double derror = 9.99e300;
	const double ftol = 1.0e-7;

	//________________________________ Compute the function and its derivative at the starting solution
	//double fx = ifunc->EvaluateFunc(solution);
	//ifunc->EvaluateGrad(solution, g);
	double fx = 0.0;
	ifunc->EvaluateFuncAndGrad(solution, fx, g);

	int i = 0, j = 0;
	double sum = 0.0;

	for (i=0; i<len; i++) 
	{
		for (j=0; j<len; j++)
		{
			hessian[i][j]=0.0;
		}
		hessian[i][i]=1.0;
		sum += solution[i]*solution[i];
	}
	derivative = -g;
	double c = 0.0;
	double d = 0.0;
	double e = 0.0;

	for (int iteration = 0; iteration < numIterations; iteration++) 
	{
		progress.SetTry(100.0*i/(double)numIterations);
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		derror = this->MoveAlongDirection();
		if (running.GetTry(brunning))
		{
			if (brunning == false) return derror;
		}
		error->SetTry(derror);
		//____________________________________ Stop when goal has been reached
		if (derror <= goal) return derror;
		//_____________________________________________  Stop when there is no improvement
		if (2.0*fabs(derror - fx) <= ftol*(fabs(derror)+fabs(fx)+1.0e-10)) 
		{
			return derror;
		}
		fx = derror;
		derg = g; 
		//
		//derror = ifunc->EvaluateFunc(solution);
		//ifunc->EvaluateGrad(solution, g);
		ifunc->EvaluateFuncAndGrad(solution, derror, g);
		//
		 derg = g - derg; 
		 derh = 0.0;
		for (i=0; i<len; i++) 
		{
			for (j=0; j<len; j++)
			{
				derh[i] += hessian[i][j]*derg[j];
			}
		}
		c = 0.0;
		e = 0.0;
		for (i=0; i<len; i++) 
		{
			c += derg[i]*derivative[i];
			e += derg[i]*derh[i];
		}

		c=1.0/c;
		d=1.0/e;
		derg = c* derivative - d * derh;
		for (i = 0; i < len; i++) 
		{
			for (j = i; j < len; j++) 
			{
				hessian[i][j] += c * derivative[i] * derivative[j] - d * derh[i] * derh[j] + e * derg[i] * derg[j];
				hessian[j][i]=hessian[i][j];
			}
		}
		derivative = 0.0;
		for (i=0; i<len; i++) 
		{
			for (j=0; j<len; j++) derivative[i] -= hessian[i][j] * g[j];
		}
	}
	return derror;
}

double FindMinimumMV::MoveAlongDirection()
{
	Math::Point a, x, b;
	a.x = 0.0;
	x.x = 1.0;
	b.x = 1.0e20;
	double min_x = 0.0;
	Math::FindMinimum::Bracketing(*this, a, x, b);
	const double error = Math::FindMinimum::BrentWithDerivative(*this, a.x, x.x, b.x, 3.0e-08, min_x);
	derivative *= min_x;
	solution += derivative;
	return error;
}

double FindMinimumMV::EvaluateFunc(const double x)
{
	xtmp = solution + x * derivative;
	return ifunc->EvaluateFunc(xtmp);
}

void FindMinimumMV::EvaluateFuncAndDeriv(const double x, double& Fx, double& dFx)
{
	xtmp = solution + x * derivative;
	ifunc->EvaluateFuncAndGrad(xtmp, Fx, dertmp); //ifunc->EvaluateGrad(xtmp, dertmp);
	const int len = (int)solution.size();
	dFx = 0.0; //double sum = 0.0;
	for(int j = 0; j<len; j++) dFx += dertmp[j]*derivative[j]; //sum += dertmp[j]*derivative[j];
	//return sum;
}

//double FindMinimumMV::EvaluateDeri(const double x)
//{
//	xtmp = solution + x * derivative;
//	ifunc->EvaluateGrad(xtmp, dertmp);
//	const int len = solution.size();
//	double sum = 0.0;
//	for(int j = 0; j<len; j++) sum += dertmp[j]*derivative[j];
//	return sum;
//}

//_____________________________________________________________________ PowellFindMinMV
PowellFindMinMV::PowellFindMinMV()
{
	ifunc = NULL;
	error = NULL;
	numIterations = 200;
	stopWhenDone = true;
}

PowellFindMinMV::~PowellFindMinMV()
{
}
	
bool PowellFindMinMV::Setup(Mt::DoubleTs& error, Math::IMultiVarFunc& ifunc, const valarray<double>& startingPoint, int numIterations)
{
	this->error = &error;
	this->ifunc = &ifunc;
	const size_t size = startingPoint.size();
	if (size == 0) return false;
	//_________________________________________________________ Memory allocation
	try
	{
		solution = startingPoint;
		//___________________________________________ xi
		xi.resize(size);
		for(size_t i = 0; i < size; i++)
		{
			xi[i].resize(size);
			xi[i][i] = 1.0;
		}
		ptt.resize(size);
		xit.resize(size);
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	this->numIterations = numIterations;
	return true;
}

void PowellFindMinMV::Delete()
{
	xi.clear();
	ptt.resize(0);
	xit.resize(0);
}

DWORD PowellFindMinMV::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	const double ftol = 1.0e-7;
	const int n = (int)solution.size();
	const int totalEval =  numIterations*(n+2);
	progress.Set(0.0);
	double fret = ifunc->EvaluateFunc(solution);
	error->Set(fret);
	valarray<double> pt = solution;

	int i = 0, j = 0;
	int ibig;
	double del, fp, fptt, t;
	double stmp;
	double ftmp;
	
	for (int iter = 0; iter < numIterations; iter++) 
	{
		fp = fret;
		ibig = 0;
		del = 0.0;
		for (i = 0; i < n; i++) 
		{
			for (j = 0; j < n; j++) xit[j] = xi[j][i];
			fptt = fret;
			fret = MoveAlongDirection();
			if (fptt - fret > del) 
			{
				del=fptt-fret;
				ibig=i+1;
			}
			//_____________________________ Control and reporting
			progress.Set(100.0*(iter*n+i)/totalEval);
			if (running.Get()==false) return 0;
		}
		error->Set(fret);
		if (running.Get()==false) break;
		if (2.0*(fp-fret) <= ftol*(fabs(fp)+fabs(fret)) + 1.0e-25) 
		{
			progress.Set(100.0);
			if (stopWhenDone == true) running.Set(false);
			return 0;
		}
		for (j=0; j<n; j++) 
		{
			ptt[j] = 2.0*solution[j] - pt[j];
			xit[j] = solution[j] - pt[j];
			pt[j] = solution[j];
		}
		fptt = ifunc->EvaluateFunc(ptt);
		if (fptt < fp) 
		{
			stmp = fp - fret - del;
			ftmp = fp - fptt;
			t=2.0*(fp - 2.0*fret + fptt)*stmp*stmp - del*ftmp*ftmp;
			if (t < 0.0) 
			{
				fret = MoveAlongDirection();
				for (j=0;j<n;j++) 
				{
					xi[j][ibig-1]=xi[j][n-1];
					xi[j][n-1]=xit[j];
				}
			}
		}
	}
	if (stopWhenDone == true) running.Set(false);
	return 0;
}

double PowellFindMinMV::MoveAlongDirection()  
{
	Math::Point a, x, b;
	a.x = 0.0;
	x.x = 1.0;
	b.x = 1.0e20;
	double min_x = 0.0;
	Math::FindMinimum::Bracketing(*this, a, x, b);
	const double error = Math::FindMinimum::Brent(*this, a.x, x.x, b.x, 3.0e-08, min_x);
	xit *= min_x;
	solution += xit;
	return error;
}

double PowellFindMinMV::EvaluateFunc(const double x)
{
	const size_t size = solution.size();
	valarray<double> xt;
	xt.resize(size);
	for (size_t j=0; j<size; j++) xt[j] = solution[j] + x*xit[j];
	return ifunc->EvaluateFunc(xt);
}

//_____________________________________________________________________ SingularValueDecomposition
SingValDecompos::SingValDecompos(void)
{
}

SingValDecompos::~SingValDecompos(void)
{
}

wchar_t* SingValDecompos::Decompose(const MATRIX& in_a, MATRIX& out_u, valarray<double>& out_s, MATRIX& out_v)
{
	try
	{
		out_u = in_a;
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return Decompose(out_u, out_s, out_v);
}

// A = (U)(S)(VT)
//MATRIX a;
//Math::Oper::CreateMatrix(a, 3, 3);
//a[0][0]=1;
//a[0][1]=2;
//a[0][2]=3;
//a[1][0]=4;
//a[1][1]=5;
//a[1][2]=6;
//a[2][0]=7;
//a[2][1]=8;
//a[2][2]=9;
//MATRIX v;
//valarray<double> s;
//Math::SingValDecompos::Decompose(a, s, v);
//
//MATRIX S;
//Math::Oper::CreateMatrix(S, 3, 3);
//S[0][0] = s[0];
//S[1][1] = s[1];
//S[2][2] = s[2];
//MATRIX result;
//Math::Oper::Product(a, S, result);
//MATRIX vt;
//MATRIX A;
//Math::Oper::Transpose(v, vt);
//Math::Oper::Product(result, vt, A);
//______________________________________
// Matrix U is returned in A
// Matrix S is returned in vector s
// Matrix V is not transposed
wchar_t* SingValDecompos::Decompose(MATRIX& a, valarray<double>& s, MATRIX& v)
{
	const int rows = (int)a.size();
	const int cols = (rows == 0) ? 0 : (int)a[0].size();

	if (rows<cols) return L"The number or rows must be greater than or equal to the number of columns";

	int i = 0;
	valarray<double> in;
	try 
	{
		//__________________ v
		v.resize(cols);
		for(i = 0; i < cols; i++)
		{
			v[i].resize(cols);
		}
		//__________________ s
		s.resize(cols);
		//__________________ in
		in.resize(cols);
	}
	catch (std::bad_alloc const&) 
	{
		return L"No enough memory to perform Singular Value Decomposition";
	}

	int j, q, k, t;
	double c, f, h, sep, x, y;
	bool isSplitting = false;
	int iterationCount = 0;
	double max1, max2; 
	int index = 0;
	double p;

	double w = 0.0;
	double scale = 0.0;
	double anorm = 0.0;
	for (i = 0; i < cols; i++) 
	{
		index = i+1;
		in[i] = scale*w;
		w = 0.0;
		sep = 0.0;
		scale = 0.0;
		if (i < rows) 
		{
			for (k = i; k<rows; k++)
			{
				scale += fabs(a[k][i]);
			}
			if (scale>0.0) 
			{
				for (k = i; k < rows; k++) 
				{
					a[k][i] /= scale; 
					sep += a[k][i]*a[k][i];
				}
				f = a[i][i];
				w = -Sign(sqrt(sep), f);
				h = f*w-sep;
				a[i][i] = f-w; 
				for (j = index; j<cols; j++) 
				{
					for (sep = 0.0, k=i; k < rows; k++)
					{
						sep += a[k][i]*a[k][j];
					}
					f=sep/h;
					for (k=i; k<rows; k++)
					{
						a[k][j] += f*a[k][i];
					}
				}
				for (k = i; k<rows; k++) 
				{
					a[k][i] *= scale;
				}
			}
		}
		s[i] = scale *w;
		w = 0.0;
		sep = 0.0;
		scale =0.0;
		if (i < rows && i != cols-1)
		{
			for (k = index; k<cols; k++)
			{
				scale += fabs(a[i][k]);
			}
			if (scale > 0.0)
			{
				for (k = index; k < cols; k++) 
				{
					a[i][k] /= scale;
					sep += a[i][k]*a[i][k];
				}
				f = a[i][index];
				w = -Sign(sqrt(sep),f);
				h = f*w - sep;
				a[i][index] = f - w;
				for (k = index; k < cols; k++)
				{
					in[k]=a[i][k]/h;
				}
				for (j = index; j < rows; j++) 
				{
					for (sep=0.0, k = index; k<cols; k++)
					{
						sep += a[j][k]*a[i][k];
					}
					for (k = index; k<cols; k++)
					{
						a[j][k] += sep*in[k];
					}
				}
				for (k = index; k < cols; k++)
				{
					a[i][k] *= scale;
				}
			}
		}

		max1 = anorm; 
		max2 = fabs(s[i]) + fabs(in[i]);
		anorm = (max1 > max2) ? max1 : max2;
	}
	for (i = cols-1; i >= 0; i--)
	{ 
		if (i < cols-1) 
		{
			if (w != 0.0) 
			{
				for (j = index; j < cols; j++)
				{
					v[j][i]=(a[i][j]/a[i][index])/w;
				}
				for (j = index; j<cols; j++) 
				{
					for (sep=0.0, k=index; k<cols; k++)
					{
						sep += a[i][k]*v[k][j];
					}
					for (k = index; k<cols; k++) 
					{
						v[k][j] += sep*v[k][i];
					}
				}
			}
			for (j = index; j < cols; j++)
			{
				v[i][j] = 0.0;
				v[j][i] = 0.0;
			}
		}
		v[i][i] = 1.0;
		w = in[i];
		index = i;
	}

	const int init = ( (rows-1) < (cols-1)) ? (rows-1) : (cols-1);
	for (i= init; i>=0; i--)
	{ 
		index = i+1;
		w = s[i];
		for (j = index; j<cols; j++)
		{
			a[i][j]=0.0;
		}
		if (w != 0.0) 
		{
			w = 1.0/w;
			for (j = index; j<cols; j++) 
			{
				for (sep = 0.0, k = index; k<rows; k++)
				{
					sep += a[k][i]*a[k][j];
				}
				f = (sep/a[i][i])*w;
				for (k = i; k < rows; k++)
				{
					a[k][j] += f*a[k][i];
				}
			}
			for (j = i; j < rows; j++)
			{
				a[j][i] *= w;
			}
		} 
		else 
		{
			for (j = i;  j< rows; j++) 
			{
				a[j][i]=0.0;
			}
		}
		++a[i][i];
	}

	for (k = cols-1; k >= 0; k--) 
	{ 
		for (iterationCount = 0; iterationCount < 100; iterationCount++) 
		{
			isSplitting =  true;
			for (index = k; index >= 0; index--) 
			{ 
				t = index-1; 
				if ((double)(fabs(in[index])+anorm) == anorm) 
				{
					isSplitting = false;
					break;
				}
				if ((double)(fabs(s[t])+anorm) == anorm) break;
			}
			if (isSplitting == true) 
			{
				c = 0.0;
				sep=1.0;
				for (i = index; i<=k; i++) 
				{
					f = sep*in[i];
					in[i] = c*in[i];
					if ((double)(fabs(f)+anorm) == anorm) break;
					w= s[i];
					h = Module(f, w);
					s[i] = h;
					h = 1.0/h;
					c = w*h;
					sep = -f*h;
					for (j = 0; j < rows; j++) 
					{
						y = a[j][t];
						p = a[j][i];
						a[j][t] = y*c + p*sep;
						a[j][i] = p*c - y*sep;
					}
				}
			}
			p = s[k];

			if (index == k)
			{ 
				if (p < 0.0)
				{ 
					s[k] = -p;
					for (j=0; j<cols; j++) 
					{
						v[j][k] = -v[j][k];
					}
				}
				break; // Done
			}

			if (iterationCount == 100) return L"Singular Value Decomposition no convergence in 100 iterations";
			x = s[index]; 
			t = k-1;
			y = s[t];
			w = in[t];
			h = in[k];
			f = ((y-p)*(y+p)+(w-h)*(w+h))/(2.0*h*y);
			w = Module(f, 1.0);
			f = ((x-p)*(x+p)+h*((y/(f+Sign(w, f)))-h))/x;
			c = 1.0;
			sep = 1.0;
			for (j = index; j <= t; j++) 
			{
				i = j+1;
				w = in[i];
				y = s[i];
				h = sep*w;
				w = c*w;
				p = Module(f, h);
				in[j] = p;
				c = f/p;
				sep = h/p;
				f = x*c + w*sep;
				w = w*c - x*sep;
				h = y*sep;
				y *= c;
				for (q = 0; q < cols; q++) 
				{
					x = v[q][j];
					p = v[q][i];
					v[q][j] = x*c + p*sep;
					v[q][i] = p*c - x*sep;
				}
				p = Module(f, h);
				s[j] = p;
				if (p > 0) 
				{
					p = 1.0/p;
					c = f*p;
					sep = h*p;
				}
				f = c*w + sep*y;
				x = c*y - sep*w;
				for (q = 0; q < rows; q++) 
				{
					y = a[q][j];
					p = a[q][i];
					a[q][j] = y*c + p*sep;
					a[q][i] = p*c - y*sep;
				}
			}
			in[index] = 0.0;
			in[k] = f;
			s[k] = x;
		}
	}
	return NULL;
}

double SingValDecompos::Sign(double a, double b)
{
	if (b > 0.0) return fabs(a);
	return - fabs(a);
}

//pow(a*a + b*b, 0.5) 
double SingValDecompos::Module(double a, double b)
{
	a = fabs(a);
	b = fabs(b);

	if (a == 0.0 && b == 0.0) return 0.0;
	if (a == 0.0) return b;
	if (b == 0.0) return a;
	double tmp;

	if (a > b) 
	{
		tmp = b/a;
		return a*sqrt(1.0+ tmp * tmp);
	}
	tmp = a/b;
	return b*sqrt(1.0+ tmp * tmp);
}

//Solves A·x = b for a vector X
//where A is specified by U S V from a singular value descomposition U[m n], s[n], V[n n]
// b[m], x[n]
//1.  Call Decompose to produce S, U, V.  Matrix U is return in variable a 
//2.  Call BackSubstitution providing S, U, V as returned by Decompose
//Returns false if not enough memory
bool SingValDecompos::BackSubstitution(const MATRIX& u, const valarray<double>& s, const MATRIX& v, const valarray<double>& b, valarray<double>& x)
{
	int rows = (int)u.size();
	int cols = (rows == 0) ? 0 : (int)u[0].size();
	int jj,j,i;
	double sep;
	
	valarray<double> tmp;

	try
	{
		tmp.resize(cols);
		x.resize(cols);
	}
	catch(std::bad_alloc const&)
	{
		return false;
	}

	for (j=0; j<cols; j++)
	{ 
		sep = 0.0;
		if (s[j] != 0.0)
		{ 
			for (i=0; i<rows; i++)
			{
				sep += u[i][j]*b[i];
			}
			sep /= s[j]; 
		}
		tmp[j] = sep;
	}
	 //________________________________ Multiply by V
	for (j=0; j<cols; j++)
	{ 
		sep = 0.0;
		for (jj=0; jj< cols; jj++)
		{
			sep += v[j][jj]*tmp[jj];
		}
		x[j] = sep;
	}
	return true;
}

//_____________________________________________________________________ Remez
Remez::~Remez()
{
}

Remez::Remez()
{
}

bool Remez::IsExtrema(double w, int index, int numPoints)
{
	if (w == 0.0) return false;
	if (w == M_PI) return false;
	if (index == 0) return true;
	if (index == numPoints-1) return true;
	return false;
}

double Remez::ComputeImpulseResponse(const vector<Math::Remez::Band>& in_band, int length, valarray<double>& out_impulseResponse)
{
	return ImpulseResponse(in_band, length, REMEZ_BANDPASS, out_impulseResponse);
	//return 0.0;
}

double Remez::ComputeHilbertImpulseResponse(int length, valarray<double>& out_impulseResponse)
{
	if (length%2 == 1) length++;
	//b = remez(21,[0.05 1],[1 1],'h');     % Highpass Hilbert
	//bb = remez(20,[0.05 0.95],[1 1],'h'); % Bandpass Hilbert
	vector<Math::Remez::Band> band(1);
	band[0].gain = 1.0;
	band[0].priory = 1.0;
	band[0].w1 = 0.1*M_PI;
	band[0].w2 = M_PI;
	return ImpulseResponse(band, length, REMEZ_HILBERT, out_impulseResponse);
	//return 0.0;
}

double Remez::ComputeDifferentiatorImpulseResponse(int length, valarray<double>& out_impulseResponse)
{
	vector<Math::Remez::Band> band(1);
	band[0].gain = 1.0;
	band[0].priory = 1.0;
	band[0].w1 = 0.0;
	band[0].w2 = M_PI;
	return ImpulseResponse(band, length, REMEZ_DIFFERENTIATOR, out_impulseResponse);
	//return 0.0;
}

int Remez::ComputeFirType(int M, int remezType)
{
	if (M % 2 == 0) //_________________ M is even
	{
		if (remezType == REMEZ_BANDPASS) return REMEZ_TYPE_I_FIR; // h[n] = h[m-n] and M is even
		 return REMEZ_TYPE_III_FIR; // h[n] = - h[m-n] and M is even
	}
	//___________________________ M is odd
	if (remezType == REMEZ_BANDPASS) return REMEZ_TYPE_II_FIR; // h[n] = h[m-n] and M is odd
	return REMEZ_TYPE_IV_FIR; // h[n] = - h[m-n] and M is odd
}

//Oppenheim & Schafer: problem 7.35
int Remez::ComputeL(int M, int firType)
{                                                                                                                                                                                                                                                                                                                                                                                                                                            
	switch(firType)
	{
	case REMEZ_TYPE_I_FIR: return M/2; //Oppenheim & Schafer: between equation 7.105 and 7.106. h[n] = h[M-n] and M is even
	case REMEZ_TYPE_II_FIR: return (M-1)/2; //Oppenheim & Schafer: problem 7.35 (b). h[n] = h[M-n] and M is odd
	case REMEZ_TYPE_III_FIR: return (M-2)/2; //Oppenheim & Schafer: problem 7.35 (d). h[n] = - h[M-n] and M is even
	case REMEZ_TYPE_IV_FIR: return (M-1)/2; //Oppenheim & Schafer: problem 7.35 (d). h[n] = - h[M-n] and M is odd
	}
	return 0;
}

void Remez::CreatePerformanceData(const vector<Math::Remez::Band> in_band, int firType, int numExtrema, vector<BandPoint>& out_perfomanceData)
{
	const double deltaFreq = M_PI / (numExtrema * REMEZ_DENSITY);
	const int numBands = (int)in_band.size();
	Math::Remez::BandPoint bandPoint;
	vector<BandPoint>::iterator p;
	int i= 0, j = 0;
	int numPoints = 0;
	for(i = 0; i < numBands; i++)
	{
		bandPoint.w = in_band[i].w1;
		bandPoint.gain = in_band[i].gain;
		bandPoint.priority = in_band[i].priory;
		bandPoint.error = 1.0e100;
		//___________________________________ Adjust first point for Differentiator and Hilbert
		if (i == 0 && (firType == REMEZ_TYPE_III_FIR || firType == REMEZ_TYPE_IV_FIR)) // h[n] =  -h[M-n]
		{
			if (bandPoint.w < deltaFreq) bandPoint.w = deltaFreq;
		}
		//
		numPoints = (int)( ((in_band[i].w2 - bandPoint.w)/deltaFreq) + 0.5);//numPoints = (int)( ((in_band[i].w2 - bandPoint.w)/deltaFreq) + 1.5);
		for(j = 0; j < numPoints; j++)
		{
			bandPoint.isExtrema = IsExtrema(bandPoint.w, j, numPoints);
			bandPoint.x = cos(bandPoint.w);
			out_perfomanceData.push_back(bandPoint);
			//
			bandPoint.w += deltaFreq;
		}
		//____________________________ adjust last point in each band to w2
		p = out_perfomanceData.end()-1;
		p->w = in_band[i].w2;
		p->x = cos(p->w);
		if (p->w == M_PI) p->isExtrema = false;
	}

	//_________________________________ Adjust last point for Differentiator and Hilbert
	if (firType == REMEZ_TYPE_III_FIR) // h[n] =  -h[M-n]  and M is even
	{
		p = out_perfomanceData.end()-1;
		if (p->w > (M_PI - deltaFreq))
		{
			p->w = M_PI - deltaFreq;
		}
	}
}

void Remez::CreateInitialExtremaIndex(vector<BandPoint>& in_performanceData, int numExtrema, set<int>& out_extremaIndex)
{
	const int len = (int)in_performanceData.size();
	int i = 0;
	//________________________First, we insert all cut frequencies and all stop frequencies
	//for(i = 0; i<len ; i++)
	//{
	//	if (in_performanceData[i].isExtrema == false) continue;
	//	if (in_performanceData[i].w == 0.0) continue;
	//	if (in_performanceData[i].w == M_PI) continue;
	//	out_extremaIndex.insert(i);
	//}
	//______________________ Second, we insert uniform distributed frequencies
	for(i = 0; i<=numExtrema; i++)
	{
		out_extremaIndex.insert(i*(len-1)/numExtrema);
	}
	//if ((int)out_extremaIndex.size() < L+2)
	//{
	//	// we add extra values, to reach a length of L+2
	//	set<int>::iterator q;
	//	std::tr1::minstd_rand gen;// linear congruential generator
	//	std::tr1::uniform_int<int> dist(0, len-1);// uniform integer distribution
	//	gen.seed((unsigned int)::GetTickCount());// initialize the generator
	//	int index = 0;
	//	while((int)out_extremaIndex.size() < L+2)
	//	{
	//		index = dist(gen);
	//		q = out_extremaIndex.find(index);
	//		if (q != out_extremaIndex.end()) continue;
	//		out_extremaIndex.insert(index);
	//	}
	//}
	//else if ((int)out_extremaIndex.size() > L+2)
	//{
	//	// we remove extra values, to reach a length of L+2
	//	set<int>::iterator q;
	//	std::tr1::minstd_rand gen;// linear congruential generator
	//	std::tr1::uniform_int<int> dist(0, len-1);// uniform integer distribution
	//	gen.seed((unsigned int)::GetTickCount());// initialize the generator
	//	int index = 0;
	//	while((int)out_extremaIndex.size() > L+2)
	//	{
	//		index = dist(gen);
	//		q = out_extremaIndex.find(index);
	//		if (q == out_extremaIndex.end()) continue;
	//		if (in_performanceData[*q].isExtrema == false)
	//		{
	//			out_extremaIndex.erase(q);
	//		}
	//	}
	//}
}

double Remez::ImpulseResponse(const vector<Math::Remez::Band>& in_band, int length, int remezType, 
	valarray<double>& out_impulseResponse)//, valarray<double>& error, valarray<double>& freq)
{
	const int M = length -1;
	const int firType = ComputeFirType(M, remezType);
	const int numExtrema = (firType == REMEZ_TYPE_I_FIR) ? (length/2)+1 : (length/2);
	int i = 0;

	//____________________________________ Create Performance Data
	vector<BandPoint> performanceData;
	CreatePerformanceData(in_band, firType, numExtrema, performanceData);
	//____________________________________ Create extrema index
	set<int> extremaIndex;
	set<int> newExtremaIndex;
	CreateInitialExtremaIndex(performanceData, numExtrema, extremaIndex);
	//
	const int perfDataLen = (int)performanceData.size();
	if (remezType == REMEZ_DIFFERENTIATOR)
	{
		for(i = 0; i < perfDataLen; i++)
		{
			if (performanceData[i].gain > 0.0001) 
			{
				performanceData[i].priority = 2.0*M_PI *performanceData[i].priority / performanceData[i].w;
			}
		}
	}
	AdjustPerformanceData(performanceData, firType);

	//___________________________________ Variable declaration
	valarray<double> b(numExtrema+1);//Oppenheim & Schafer: equation (7.132)
	valarray<double> C(numExtrema+1);//Oppenheim & Schafer: equation (7.133b)
	valarray<double> d(numExtrema+1);//Oppenheim & Schafer: equation (7.133c)
	double delta = 0.0;//Oppenheim & Schafer: equation (7.131)

	//___________________________________ Iterate
	for(i = 0; i<200; i++)
	{
		ComputeB(performanceData, extremaIndex, b);
		delta = ComputeDelta(performanceData, extremaIndex, b);
		ComputeD(performanceData, extremaIndex, b, d);
		ComputeC(performanceData, extremaIndex, delta, C);
		ComputeErrors(performanceData, extremaIndex, C, d);
		UpdateExtremaIndex(performanceData, numExtrema, newExtremaIndex);	
		if (extremaIndex == newExtremaIndex) break;
		extremaIndex = newExtremaIndex;
	}

	//_______________________________________ Compute A
	// Interpolate to uniformily distributed frequencies
	double factor = 0.0;
	valarray<double> A(length/2+1);
	double w = 0.0;
	for(i = 0; i <= length/2; i++)
	{
		w = 2.0*M_PI*(double)i/length;
		switch(firType)
		{
		case REMEZ_TYPE_I_FIR:
			factor = 1.0;
			break;
		case REMEZ_TYPE_II_FIR:
			factor = cos(w/2.0);
			break;
		case REMEZ_TYPE_III_FIR:
			factor = sin(w);
			break;
		case REMEZ_TYPE_IV_FIR:
			factor = sin(w/2.0);
			break;
		}
		A[i] = factor*ComputeA(performanceData, extremaIndex, w, C, d);
	}
	//out_impulseResponse = A;
	FreqToTime(length, A, out_impulseResponse, firType);

	//______________________________________________________ Copy data for debuging purposes
	//error.resize(perfDataLen);
	//freq.resize(perfDataLen);
	//for(i = 0 ; i < perfDataLen; i++)
	//{
	//	freq[i] = performanceData[i].w;
	//	error[i] = performanceData[i].error;
	//}
	return ComputeMaxError(performanceData);
}

void Remez::FreqToTime(const int length, const valarray<double>& in_A, valarray<double>& out_h, int firType)
{
	int n, k;
	const double M = (length-1.0)/2.0;
	double value, x;
	out_h.resize(length);

	//const unsigned int N = input.size();
	//output.resize(N);
	//const double f = (2*M_PI)/(double)N;
	//unsigned int i, j;
	//complex<double> tmp;
	//double sum; 
	//complex<double> real;

	//for(i=0; i<N; i++) //Direct calculation
	//{
	//	sum= 0.0;
	//	for (j=0; j<N; j++)
	//	{
	//		tmp._Val[_RE] = cos(f*i*j);
	//		tmp._Val[_IM] = sin(f*i*j);
	//		real = input[j]*tmp;
	//		sum+= real.real();
	//	}
	//	output[i] = sum;
	//}
	//output /= N;

	switch(firType)
	{
	case REMEZ_TYPE_I_FIR:
		for(n = 0; n < length; n++)
		{
			value = in_A[0];
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= M; k++)
			{
				value += 2.0*in_A[k]*cos(x*k);
			}
			out_h[n] = value/length;
		}
		break;
	case REMEZ_TYPE_II_FIR:
		for(n = 0; n < length; n++)
		{
			value = in_A[0];
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= (length/2-1); k++)
			{
				value += 2.0*in_A[k]*cos(x*k);
			}
			out_h[n] = value/length;
		}
		break;
	case REMEZ_TYPE_III_FIR:
		for(n = 0; n < length; n++)
		{
			value = 0;
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= M; k++)
			{
				value += 2.0*in_A[k]*sin(x*k);
			}
			out_h[n] = value/length;
		}
		break;
	case REMEZ_TYPE_IV_FIR:
		for(n = 0; n < length; n++)
		{
			value = in_A[length/2] * sin(M_PI*(n-M));
			x = 2.0*M_PI*(n-M)/length;
			for(k = 1; k <= (length/2-1); k++)
			{
				value += 2.0*in_A[k]*sin(x*k);
			}
			out_h[n] = value/length;
		}
		break;
	}
}

void Remez::ComputeErrors(vector<BandPoint>& in_performanceData,  set<int>& in_extremaIndex, valarray<double>& in_C, valarray<double>& in_d)
{
	const int len = (int)in_performanceData.size();
	double A = 0.0;
	for(int i = 0; i < len; i++)
	{
		A= ComputeA(in_performanceData, in_extremaIndex, in_performanceData[i].w, in_C, in_d);
		in_performanceData[i].error = in_performanceData[i].priority*(in_performanceData[i].gain - A);
	}
}

double Remez::ComputeMaxError(vector<BandPoint>& in_performanceData)
{
	const int len = (int)in_performanceData.size();
	if (len == 0) return 1.0e+100;
	double maxval = fabs(in_performanceData[0].error);
	const vector<BandPoint>::iterator bandPointEnd = in_performanceData.end();
	vector<BandPoint>::iterator p;
	for(p = in_performanceData.begin(); p != bandPointEnd; p++)
	{
		if (fabs(p->error) > maxval) maxval =  fabs(p->error);
	}
	return maxval;
}

void Remez::AdjustPerformanceData(vector<BandPoint>& in_performanceData, int firType)
{
	const int len = (int)in_performanceData.size();
	int k = 0;
	double tmp = 0.0;
	switch(firType)
	{
	case REMEZ_TYPE_I_FIR: 
		// Nothing to do
		break; 
	case REMEZ_TYPE_II_FIR: 
		for(k = 0; k< len; k++)
		{
			tmp = cos(in_performanceData[k].w/2);
			//Oppenheim & Schafer: equation (7.127)
			in_performanceData[k].gain /= tmp; //Hd
			//Oppenheim & Schafer: equation (7.128)
			in_performanceData[k].priority *= tmp;//W
		}
		break;
	case REMEZ_TYPE_III_FIR:
		//Oppenheim & Schafer: problem 7.35 (d)
		for(k = 0; k< len; k++)
		{
			tmp = sin(in_performanceData[k].w);
			in_performanceData[k].gain /= tmp; //Hd
			in_performanceData[k].priority *= tmp; //W
		}
		break;
	case REMEZ_TYPE_IV_FIR:
		//Oppenheim & Schafer: problem 7.35 (d)
		for(k = 0; k< len; k++)
		{
			tmp = sin(in_performanceData[k].w/2);
			in_performanceData[k].gain /= tmp; //Hd
			in_performanceData[k].priority *= tmp;//W
		}
		break;
	}
}

//Oppenheim & Schafer: equation (7.131)
double Remez::ComputeDelta(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& in_b)
{
	double numerator = 0.0;
	double denominator = 0.0;
	double sign = 1.0;
	int k = 0;
	const set<int>::iterator extremaIndexEnd = in_extremaIndex.end();
	set<int>::iterator pk;
	for(pk = in_extremaIndex.begin(); pk != extremaIndexEnd; pk++, k++)
	{
		numerator += (in_b[k] *in_performanceData[*pk].gain);
		denominator += (sign * in_b[k] /in_performanceData[*pk].priority);
		sign = -sign;
	}
	if (denominator == 0.0) denominator = 1.0e-200;
	//if (fabs(denominator) < 1.0e-10) denominator = 1.0e-10;
	return numerator/denominator;
}

//Oppenheim & Schafer: equation (7.132)
void Remez::ComputeB(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& out_b)
{
	const int len = (int)in_extremaIndex.size();
	valarray<double> x(len);
	const set<int>::iterator extremaIndexEnd = in_extremaIndex.end();
	set<int>::iterator pk;
	int k = 0;
	for(pk = in_extremaIndex.begin(); pk != extremaIndexEnd; pk++, k++)
	{
		x[k] = in_performanceData[*pk].x;
	}

	const int numExtrema = (int)out_b.size() - 1;
	const int skip = 1+ (numExtrema-1)/15;
	double denominator = 1.0;
	int j;
	double xi;
	for(int i = 0; i <= numExtrema; i++)
	{
		denominator = 1.0;
		xi = x[i];
		for(j = 0; j < skip; j++)
		{
			for(k = j; k <= numExtrema; k+= skip)
			{
				if (k != i) denominator *= (xi - x[k]);
			}
		}
		if (denominator == 0.0) denominator = 1.0e-200;
		out_b[i] = 1.0 / denominator;
	}

	//if (out_b.size() != in_extremaIndex.size())
	//{
	//	out_b.resize(in_extremaIndex.size()); // never get here
	//}
	//int i = 0, k = 0, index = 0;
	//double denominator[10]; // we will compute the denominator in array, at the end we will compute the product of the elements in the array
	//
	//double xk;
	//
	//set<int>::iterator pk, pi;
	//const set<int>::iterator extremaIndexEnd = in_extremaIndex.end();
	//double total_denominator;

	//for(pk = in_extremaIndex.begin(); pk != extremaIndexEnd; pk++, k++)
	//{
	//	xk = in_performanceData[*pk].x;
	//	//________________________________ reset denominator
	//	for(i=0; i<10; i++) denominator[i] = 1.0;
	//	index = 0;
	//	//
	//	for(pi = in_extremaIndex.begin(); pi != extremaIndexEnd; pi++)
	//	{
	//		if (pi == pk) continue;
	//		denominator[index++] *= (xk - in_performanceData[*pi].x);
	//		if (index >= 10) index = 0;
	//	}
	//	total_denominator = 1.0;
	//	for(i=0; i<10; i++) total_denominator *= denominator[i];
	//	if (total_denominator == 0.0) total_denominator = 1.0e-200;
	//	out_b[k] = 1.0 / total_denominator;
	//}
}

//Oppenheim & Schafer: equation (7.133a)
double Remez::ComputeA(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, double w, valarray<double>& in_C, valarray<double>& in_d)
{
	double numerator = 0.0;
	double denominator = 0.0;
	const double x = cos(w);
	const int len = (int)in_C.size();
	double tmp = 0.0;
	double dx = 0.0;
	set<int>::iterator pk = in_extremaIndex.begin();

	for(int k = 0; k<len; k++, pk++)
	{
		if (pk == in_extremaIndex.end()) break;
		dx = x - in_performanceData[*pk].x;
		if (fabs(dx) <1.0e-10) return in_C[k];
		tmp = in_d[k]/dx;
		numerator += tmp*in_C[k];
		denominator += tmp;
	}
	return numerator/denominator;
}

void Remez::ComputeA(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& in_C, valarray<double>& in_d, valarray<double>& out_A)
{
	const int len = (int)out_A.size();
	for(int i = 0; i<len; i++)
	{
		out_A[i] = ComputeA(in_performanceData, in_extremaIndex, in_performanceData[i].w, in_C, in_d);
	}
}

//Oppenheim & Schafer: equation (7.133b)
void Remez::ComputeC(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, double delta, valarray<double>& out_C)
{
	const int len = (int)out_C.size();
	double sign = 1.0;
	set<int>::iterator pk = in_extremaIndex.begin();
	for(int k = 0; k < len; k++, pk++)
	{
		if (pk == in_extremaIndex.end())
		{
			out_C[k] = 0.0;
			break;
		}
		out_C[k] = in_performanceData[*pk].gain - sign * delta / in_performanceData[*pk].priority; // C = Hd - (-1) Delta / W
		sign = -sign;
	}
}

//Oppenheim & Schafer: equation (7.133c)
void Remez::ComputeD(vector<BandPoint>& in_performanceData, set<int>& in_extremaIndex, valarray<double>& in_b, valarray<double>& out_d)
{
	const int len = (int)out_d.size();
	const int pflen = (int)in_performanceData.size(); // This is the last element of the vector
	const double xLplusTwo = in_performanceData[pflen-1].x;
	set<int>::iterator pk = in_extremaIndex.begin();
	for(int k = 0; k < len; k++, pk++)
	{
		if (pk == in_extremaIndex.end())
		{
			out_d[k] = 0.0;
			break;
		}
		out_d[k] = in_b[k]*(in_performanceData[*pk].x - xLplusTwo);
	}
}

void Remez::UpdateExtremaIndex(vector<BandPoint>& in_performanceData, int numExtrema, set<int>& out_newExtremaIndex)
{
	out_newExtremaIndex.clear();
	const int len = (int)in_performanceData.size();
	if (len == 0) return;
	if (len == 1) return;
	int i = 0;
	//_____________________________ Add all cut frequencies and all stop band frequencies
	for(i = 0; i < len; i++)
	{
		if (in_performanceData[i].isExtrema == true)
		{
			out_newExtremaIndex.insert(i);
		}
	}

	//____________________________ Find all extrema
	Math::Remez::Extrema extrema;
	list<Math::Remez::Extrema> extremaList;
	double current = 0.0;
	double next = 0.0;
	double previous = 0.0;

	//____________________________ Check if w = 0 is extrema
	current = in_performanceData[0].error;
	next = in_performanceData[1].error;
	extrema.index = 0;
	extrema.error = current;
	if (current > 0)
	{
		if (current > next) extremaList.push_back(extrema);
	}
	else
	{
		if (current < next) extremaList.push_back(extrema);
	}

	//____________________________ Check if w = pi is extrema
	current = in_performanceData[len-1].error;
	previous = in_performanceData[len-2].error;
	extrema.index = len-1;
	extrema.error = current;
	if (current > 0)
	{
		if (current > previous) extremaList.push_back(extrema);
	}
	else
	{
		if (current < previous) extremaList.push_back(extrema);
	}

	//____________________________________ Look for extrema in between
	for(i = 1; i < len-1; i++)
	{
		if (in_performanceData[i].isExtrema == true) continue;
		previous = in_performanceData[i-1].error;
		current = in_performanceData[i].error;
		next = in_performanceData[i+1].error;
		if (current >= 0)
		{
			if (previous < current && current > next)
			{
				extrema.index = i;
				extrema.error = in_performanceData[i].error;
				extremaList.push_back(extrema);
			}
		}
		else
		{
			if (previous > current && current < next)
			{
				extrema.index = i;
				extrema.error = in_performanceData[i].error;
				extremaList.push_back(extrema);
			}
		}
	}
	extremaList.sort(); // Sort extrema so that we can use the biggest
	list<Math::Remez::Extrema>::reverse_iterator p = extremaList.rbegin();
	const list<Math::Remez::Extrema>::reverse_iterator pend = extremaList.rend();
	while((int)out_newExtremaIndex.size() < numExtrema+2)
	{
		if (p == pend) break;
		out_newExtremaIndex.insert(p->index);
		p++;
	}
}

//_____________________________________________________________________ Dsp
Dsp::~Dsp()
{
}

Dsp::Dsp()
{
}

void Dsp::Autocorrelation(const valarray<double>& input, valarray<double>& output)
{
	const size_t len = input.size();
	if (output.size() != len) output.resize(len);
	size_t i, j;
	double sum = 0.0;
	for (i = 0; i < len; i++) 
	{
		sum = 0.0;
		for (j = 0; j < len-i; j++) 
		{
			sum += (input[j]*input[(j+i)%len]);
		}
		output[i] = sum;
	}
}

void Dsp::Autocorrelation(const valarray<complex<double> >& input, valarray<complex<double> >& output)
{
	const size_t len = input.size();
	if (output.size() != len) output.resize(len);
	size_t i, j;
	complex<double> sum = 0.0;
	size_t k;
	for (i = 0; i < len; i++)
	{
		sum = 0.0;
		for (j = 0; j < len-i; j++)
		{
			k = (j+i)%len;
			sum._Val[_RE] += (input[j].real()*input[k].real() + input[j].imag()*input[k].imag());
			sum._Val[_IM] += (input[j].imag()*input[k].real() - input[j].real()*input[k].imag());
			//sum += (input[j]*std::conj(input[(j+i)%len]));
		}
		output[i] = sum;
	}
}

bool Dsp::Convolution(const valarray<double>& input_x, const valarray<double>& input_y, valarray<double>& result)
{
	return _convolution(input_x, input_y, result, false);
}

bool Dsp::Convolution(const valarray<complex<double> >& input_x, const valarray<complex<double> >& input_y, valarray<complex<double> >& result)
{
	return _convolution(input_x, input_y, result, false);
}

bool Dsp::ShortConvolution(const valarray<double>& input_x, const valarray<double>& input_y, valarray<double>& result)
{
	return _convolution(input_x, input_y, result, true);
}

bool Dsp::ShortConvolution(const valarray<complex<double> >& input_x, const valarray<complex<double> >& input_y, valarray<complex<double> >& result)
{
	return _convolution(input_x, input_y, result, true);
}

bool Dsp::_convolution(const valarray<double>& input_x, const valarray<double>& input_y, valarray<double>& result, bool shortEvaluation)
{
	const int lenX = (int)input_x.size();
	const int lenY = (int)input_y.size();
	//
	const int lenMin = MINIMUM(lenX, lenY);
	const int lenMax = MAXIMUM(lenX, lenY);
	const int minN = (shortEvaluation == true) ? (lenMin-1)/2 : 0;
	const int lenResult = (shortEvaluation == true) ? lenMax : lenX + lenY - 1;
	const int maxN = (shortEvaluation == true) ? minN+lenMax : lenResult;
	if (lenResult <= 0)
	{
		result.resize(0);
		return true;
	}
	//_________________________ Memory allocation
	try
	{
		if (result.size() != lenResult) result.resize(lenResult);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	int n, k;
	double sum;
	int start;
	int end;

	// The following equations keep k and n-k as valid indexes for input_x and input_y
	// EQ1:  0 <= k < lenX          =>              0 <= k < lenX 
	// EQ2:  -1 < n-k <= lenY-1  => n+1-lenY <= k < n+1
	for(n = minN; n < maxN; n++)
	{
		sum = 0.0;
		start = MAXIMUM(0, n+1-lenY); // 0 <=k && n+1-lenY <= k 
		end = MINIMUM(lenX, n+1); // k<lenX && k < n+1
		for(k = start; k < end; k++)
		{
			sum += (input_x[k]*input_y[n-k]);
		}
		result[n-minN] = sum;
	}
	return true;
}

bool Dsp::_convolution(const valarray<complex<double> >& input_x, const valarray<complex<double> >& input_y, valarray<complex<double> >& result, bool shortEvaluation)
{
	const int lenX = (int)input_x.size();
	const int lenY = (int)input_y.size();
	//
	const int lenMin = MINIMUM(lenX, lenY);
	const int lenMax = MAXIMUM(lenX, lenY);
	const int minN = (shortEvaluation == true) ? (lenMin-1)/2 : 0;
	const int lenResult = (shortEvaluation == true) ? lenMax : lenX + lenY - 1;
	const int maxN = (shortEvaluation == true) ? minN+lenMax : lenResult;

	if (lenResult <= 0)
	{
		result.resize(0);
		return true;
	}
	//_________________________ Memory allocation
	try
	{
		if (result.size() != lenResult) result.resize(lenResult);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	int n, k;
	double rsum;
	double isum;
	int start;
	int end;

	// The following equations keep k and n-k as valid indexes for input_x and input_y
	// EQ1:  0 <= k < lenX          =>              0 <= k < lenX 
	// EQ2:  -1 < n-k <= lenY-1  => n+1-lenY <= k < n+1
	for(n = minN; n < maxN; n++)
	{
		isum = 0.0;
		rsum = 0.0;
		start = MAXIMUM(0, n+1-lenY); // 0 <=k && n+1-lenY <= k 
		end = MINIMUM(lenX, n+1); // k<lenX && k < n+1
		for(k = start; k < end; k++)
		{
			rsum += (input_x[k].real()*input_y[n-k].real()-input_x[k].imag()*input_y[n-k].imag());
			isum += (input_x[k].real()*input_y[n-k].imag()+input_x[k].imag()*input_y[n-k].real());
		}
		result[n-minN].real(rsum);
		result[n-minN].imag(isum);
	}
	return true;
}
	
bool Dsp::IsPowerOfTwo(int input)
{
	double d = log10((double)input)/log10(2.0);
	return (d-(int)(d)==0);
}

// The length of symmetricInput must be less than the length of input_y
// For the input:  ..., 4, 3, -2, 10, -2, 3, 4, ...  the variable symmetricInput must be: 10, -2, 3, 4, ...  
// that is, it assumes that the negative part is symmetric.  The function returns the short convolution.
bool Dsp::SymmetricConvolution(const valarray<double>& symmetricInput, const valarray<double>& input_y, valarray<double>& result)
{
	const int lenX = 2 * (int)symmetricInput.size() - 1;
	const int lenY = (int)input_y.size();
	const int M = lenX -1;
	const int halfM = M/2;
	if (lenX >= lenY) return false;
	//
	if (lenY <= 0)
	{
		result.resize(0);
		return true;
	}
	//_________________________ Memory allocation
	try
	{
		if (result.size() != lenY) result.resize(lenY);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	
	int n, m;
	double sum;
	int index;
	double tmp; // This variable is used to reduce the number of multiplications
	//___________________________ Case 1: Before full overlap
	for(n = 0; n <= halfM-1; n++)
	{
		sum = symmetricInput[0]*input_y[n];
		for(m = 1; m <=halfM; m++)
		{
			tmp = input_y[n+m];
			index = n-m;
			if (0 <= index)
			{
				tmp += input_y[index];
			}
			sum += symmetricInput[m]*tmp;
		}
		result[n] = sum;
	}
	//___________________________ Case 2: Full overlap
	for(n = halfM; n <= lenY - halfM-1; n++)
	{
		sum = symmetricInput[0]*input_y[n];
		for(m = 1; m <=halfM; m++)
		{
			sum += symmetricInput[m]*(input_y[n+m]+input_y[n-m]);
		}
		result[n] = sum;
	}
	//___________________________ Case 3: After full overlap
	for(n = lenY - halfM ; n < lenY; n++)
	{
		sum = symmetricInput[0]*input_y[n];
		for(m = 1; m <=halfM; m++)
		{	
			index = n+m;
			tmp = 0;
			if (index < lenY)
			{
				tmp += input_y[n+m];
			}
			tmp += input_y[n-m];
			sum += symmetricInput[m]*tmp;
		}
		result[n] = sum;
	}
	return true;
}

// The length of symmetricInput must be less than the length of input_y
// For the input:  ..., 4+3i, 3-i, -2+3i, 0, -2-3i, 3+i, 4-3i, ...  the variable symmetricInput must be: 0, -2-3i, 3+i, 4-3i, ...  
// that is, it assumes that the negative part is conjugate symmetric.  The function returns the short convolution.
bool Dsp::SymmetricConvolution(const valarray<complex<double> >& symmetricInput, const valarray<complex<double> >& input_y, valarray<complex<double> >& result)
{
	const int lenX = 2 * (int)symmetricInput.size() - 1;
	const int lenY = (int)input_y.size();
	const int M = lenX -1;
	const int halfM = M/2;
	if (lenX >= lenY) return false;
	//
	if (lenY <= 0)
	{
		result.resize(0);
		return true;
	}
	//_________________________ Memory allocation
	try
	{
		if (result.size() != lenY) result.resize(lenY);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	
	int n, m;
	double rsum;
	double isum;
	int index;
	double radd; // This variable is used to reduce the number of multiplications
	double iadd; // This variable is used to reduce the number of multiplications
	double rdiff; // This variable is used to reduce the number of multiplications
	double idiff; // This variable is used to reduce the number of multiplications
	//___________________________ Case 1: Before full overlap
	for(n = 0; n <= halfM-1; n++)
	{
		rsum = symmetricInput[0].real()*input_y[n].real() - symmetricInput[0].imag()*input_y[n].imag();
		isum = symmetricInput[0].real()*input_y[n].imag() + symmetricInput[0].imag()*input_y[n].real();
		//
		for(m = 1; m <=halfM; m++)
		{
			radd = input_y[n+m].real();
			iadd = input_y[n+m].imag();
			//
			rdiff = -input_y[n+m].real();
			idiff = -input_y[n+m].imag();
			//
			index = n-m;
			if (0 <= index)
			{
				//________________________________ Compute the summation
				radd += input_y[index].real();
				iadd += input_y[index].imag();
				//________________________________ Compute the difference
				rdiff += input_y[index].real();
				idiff += input_y[index].imag();
			}
			rsum += symmetricInput[m].real()*radd  - symmetricInput[m].imag()*idiff;
			isum += symmetricInput[m].real()*iadd + symmetricInput[m].imag()*rdiff;
		}
		result[n].real(rsum);
		result[n].imag(isum);
	}
	//___________________________ Case 2: Full overlap
	for(n = halfM; n <= lenY - halfM-1; n++)
	{
		rsum = symmetricInput[0].real()*input_y[n].real() - symmetricInput[0].imag()*input_y[n].imag();
		isum = symmetricInput[0].real()*input_y[n].imag() + symmetricInput[0].imag()*input_y[n].real();
		for(m = 1; m <=halfM; m++)
		{
			index = n-m;
			//
			radd = input_y[n+m].real() + input_y[index].real();
			iadd = input_y[n+m].imag() + input_y[index].imag();
			//
			rdiff = -input_y[n+m].real() + input_y[index].real();
			idiff = -input_y[n+m].imag() + input_y[index].imag();
			//
			rsum += symmetricInput[m].real()*radd  - symmetricInput[m].imag()*idiff;
			isum += symmetricInput[m].real()*iadd + symmetricInput[m].imag()*rdiff;
		}
		result[n].real(rsum);
		result[n].imag(isum);
	}
	//___________________________ Case 3: After full overlap
	for(n = lenY - halfM ; n < lenY; n++)
	{
		rsum = symmetricInput[0].real()*input_y[n].real() - symmetricInput[0].imag()*input_y[n].imag();
		isum = symmetricInput[0].real()*input_y[n].imag() + symmetricInput[0].imag()*input_y[n].real();
		for(m = 1; m <=halfM; m++)
		{	
			radd = 0.0;
			iadd = 0.0;
			//
			rdiff = 0.0;
			idiff = 0.0;
			//
			index = n+m;
			if (index < lenY)
			{
				radd += input_y[index].real();
				iadd += input_y[n+m].imag();
				//
				rdiff -= input_y[index].real();
				idiff -= input_y[index].imag();
			}
			radd += input_y[n-m].real();
			idiff += input_y[n-m].imag();
			//
			rdiff += input_y[n-m].real();
			idiff += input_y[n-m].imag();
			//
			rsum += symmetricInput[m].real()*radd  - symmetricInput[m].imag()*idiff;
			isum += symmetricInput[m].real()*iadd + symmetricInput[m].imag()*rdiff;
		}
		result[n].real(rsum);
		result[n].imag(isum);
	}
	return true;
}

// The length of symmetricInput must be less than the length of input_y
// For the input:  ..., 4+3i, 3-i, -2+3i, 0, -2-3i, 3+i, 4-3i, ...  the variable symmetricInput must be: 0, -2-3i, 3+i, 4-3i, ...  
// that is, it assumes that the negative part is conjugate symmetric.  The function returns the short convolution.
bool Dsp::SymmetricConvolution(const valarray<complex<double> >& symmetricInput, const valarray<double>& input_y, valarray<complex<double> >& result)
{
	const int lenX = 2 * (int)symmetricInput.size() - 1;
	const int lenY = (int)input_y.size();
	const int M = lenX -1;
	const int halfM = M/2;
	if (lenX >= lenY) return false;
	//
	if (lenY <= 0)
	{
		result.resize(0);
		return true;
	}
	//_________________________ Memory allocation
	try
	{
		if (result.size() != lenY) result.resize(lenY);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	
	int n, m;
	double rsum;
	double isum;
	int index;
	double add; // This variable is used to reduce the number of multiplications
	double diff; // This variable is used to reduce the number of multiplications
	//___________________________ Case 1: Before full overlap
	for(n = 0; n <= halfM-1; n++)
	{
		rsum = symmetricInput[0].real()*input_y[n];
		isum = symmetricInput[0].imag()*input_y[n];
		//
		for(m = 1; m <=halfM; m++)
		{
			add = input_y[n+m];
			diff = -input_y[n+m];
			//
			index = n-m;
			if (0 <= index)
			{
				add += input_y[index];
				diff += input_y[index];
			}
			rsum += symmetricInput[m].real()*add;
			isum += symmetricInput[m].imag()*diff;
		}
		result[n].real(rsum);
		result[n].imag(isum);
	}
	//___________________________ Case 2: Full overlap
	for(n = halfM; n <= lenY - halfM-1; n++)
	{
		rsum = symmetricInput[0].real()*input_y[n];
		isum = symmetricInput[0].imag()*input_y[n];
		for(m = 1; m <=halfM; m++)
		{
			add = input_y[n+m] + input_y[n-m];
			diff = -input_y[n+m] + input_y[n-m];
			//
			rsum += symmetricInput[m].real()*add;
			isum += symmetricInput[m].imag()*diff;
		}
		result[n].real(rsum);
		result[n].imag(isum);
	}
	//___________________________ Case 3: After full overlap
	for(n = lenY - halfM ; n < lenY; n++)
	{
		rsum = symmetricInput[0].real()*input_y[n];
		isum = symmetricInput[0].imag()*input_y[n];
		for(m = 1; m <=halfM; m++)
		{	
			index = n+m;
			add = 0.0;
			diff = 0.0;
			//
			if (index < lenY)
			{
				add += input_y[index];
				diff -= input_y[index];
			}
			add += input_y[n-m];
			diff += input_y[n-m];
			//
			rsum += symmetricInput[m].real()*add;
			isum += symmetricInput[m].imag()*diff;
		}
		result[n].real(rsum);
		result[n].imag(isum);
	}
	return true;
}


int Dsp::FindNextPowerOfTwo(int input)
{
	int new_n = (int)(log10((double)input)/log10(2.0))+1;
	return (int)pow(2.0, new_n);
	//int new_n = (int)(log10((double)n)/log10(2.0))-1;
	//int result = 0;
	//for(int i = new_n; i< 4294967290; i++)
	//{
	//	if (pow(2, i)<n && n<=pow(2, i+1))
	//	{
	//		result = (int)pow(2, i+1);
	//		break;
	//	}
	//}
	//return result;
}

int Dsp::FindPreviousPowerOfTwo(int input)
{
	int new_n = (int)(log10((double)input)/log10(2.0));
	return (int)pow(2.0, new_n);
}

bool Dsp::FourierTransform(const valarray<complex<double> >& input, valarray<complex<double> >& output, bool inverse)
{
	const unsigned int N = (int)input.size();
	//____________________________________ Memory allocation
	if (output.size() != N)
	{
		try
		{
			output.resize(N);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	const double f = inverse ? (2*M_PI)/(double)N : (-2*M_PI)/(double)N;

	unsigned int i, j;
	complex<double> tmp;
	complex<double> sum; 

	for(i=0; i<N; i++) //Direct calculation
	{
		sum= 0.0;
		for (j=0; j<N; j++)
		{
			tmp._Val[_RE] = cos(f*i*j);
			tmp._Val[_IM] = sin(f*i*j);
			sum += input[j]*tmp;
		}
		output[i] =sum;
	}
	if (inverse == true) output /= N;
	return true;
}

bool Dsp::FourierTransform(const MATRIXC& input, MATRIXC& output, bool inverse)
{
	const int rows = (int)input.size();
	//____________________________________ Memory allocation	
	if (output.size() != rows)
	{
		try
		{
			output.resize(rows);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	for(int i = 0; i < rows; i++)
	{
		if (FourierTransform(input[i], output[i], inverse) == false) return false;
	}
	return true;
}

bool Dsp::FourierTransformRe(const valarray<double>& input, valarray<complex<double> >& output)
{
	const unsigned int N = (int)input.size();
	const double f = (-2*M_PI)/(double)N;
	unsigned int i, j;
	complex<double> tmp;
	complex<double> sum; 

	//_______________________ Memory allocation
	if (output.size() != N)
	{
		try
		{
			output.resize(N);
		}
		catch(std::bad_alloc&)
		{
			return false;
		}
	}

	for(i=0; i<N; i++) // Direct calculation
	{
		sum= 0.0;
		for (j=0; j<N; j++)
		{
			tmp._Val[_RE] = input[j]*cos(f*i*j);
			tmp._Val[_IM] = input[j]*sin(f*i*j);
			sum += tmp;
		}
		output[i] =sum;
	}
	return true;
}

bool Dsp::FourierTransformRe(const MATRIX& input, MATRIXC& output)
{
	const int rows = (int)input.size();
	//____________________________________ Memory allocation	
	if (output.size() != rows)
	{
		try
		{
			output.resize(rows);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	for(int i = 0; i < rows; i++)
	{
		if (FourierTransformRe(input[i], output[i]) == false) return false;
	}
	return true;
}

bool Dsp::InverseFourierTransformRe(const valarray<complex<double> >& input, valarray<double>& output)
{
	const unsigned int N = (int)input.size();
	const double f = (2*M_PI)/(double)N;
	unsigned int i, j;
	complex<double> tmp;
	double sum; 
	complex<double> real;

	//_______________________ Memory allocation
	if (output.size() != N)
	{
		try
		{
			output.resize(N);
		}
		catch(std::bad_alloc&)
		{
			return false;
		}
	}

	for(i=0; i<N; i++) //Direct calculation
	{
		sum= 0.0;
		for (j=0; j<N; j++)
		{
			tmp._Val[_RE] = cos(f*i*j);
			tmp._Val[_IM] = sin(f*i*j);
			real = input[j]*tmp;
			sum+= real.real();
		}
		output[i] = sum;
	}
	output /= N;
	return true;
}

bool Dsp::InverseFourierTransformRe(const MATRIXC& input, MATRIX& output)
{
	const int rows = (int)input.size();
	//____________________________________ Memory allocation	
	if (output.size() != rows)
	{
		try
		{
			output.resize(rows);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	for(int i = 0; i < rows; i++)
	{
		if (InverseFourierTransformRe(input[i], output[i]) == false) return false;
	}
	return true;
}

const wchar_t* Dsp::RealFft(const valarray<double>& input, valarray<complex<double> >& output)
{
	static valarray<complex<double> > factor;
	const unsigned int N = (int)input.size();
	if (Math::Dsp::IsPowerOfTwo(N) == false) return L"Math::Dsp::RealFft The input lenght must be a power of two";
	const int half = N/2;
	const int half_minus_one = half - 1;
	int k;
	//__________________________________________________ Memory allocation
	valarray<complex<double> > tmp;
	try
	{
		tmp.resize(half);
		output.resize(N);
		if ((int)factor.size() != half_minus_one)
		{
			factor.resize(half_minus_one);
			//________________________________________________ Static factors  exp(j k 2 pi /N)
			const double piN = 2.0*M_PI/N;
			double angle;
			for (k = 0; k < half_minus_one; k++)
			{
				angle = piN*(k+1);
				factor[k].real(cos(angle));
				factor[k].imag(sin(angle));
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"Math::Dsp::RealFft No enough memory";
	}
	//________________________________________________ FFT
	for (k = 0; k < half; k++)
	{
		tmp[k].real(input[2*k]);
		tmp[k].imag(input[2*k+1]);
	}
	Math::Dsp::Fft(tmp, false);
	//_______________________________________________ Compute Output
	output[half].real(tmp[0].real() - tmp[0].imag());
	output[half].imag(0.0);
	//
	double reSum;
	double imSum;
	double reDiff;
	double imDiff;
	int index_factor = 0;
	int first = 1;
	int last = half_minus_one;
	int k_last = N-1;
	for (k = 1; k < half; k++, index_factor++, first++, last--, k_last--)
	{
		//________________________________summation
		reSum = 0.5*(tmp[first].real() + tmp[last].real());
		imSum = 0.5*(tmp[first].imag() + tmp[last].imag());
		//________________________________ difference
		reDiff = 0.5*(tmp[first].real() - tmp[last].real());
		imDiff = 0.5*(tmp[first].imag() - tmp[last].imag());
		//________________________________ output
		output[k].real(reSum + factor[index_factor].real()*imSum - factor[index_factor].imag()*reDiff);
		output[k].imag(imDiff - factor[index_factor].imag()*imSum - factor[index_factor].real()*reDiff);
		//________________________________ symmetric
		output[k_last] = std::conj(output[k]);
	}
	//__________________________________ Offset
	output[0] = input.sum();
	return NULL;
}

// Oppenheim Figure 9.25
const wchar_t* Dsp::Fft(valarray<complex<double> >& in_out, bool inverse)
{
	const unsigned int N = (int)in_out.size();
	if (Math::Dsp::IsPowerOfTwo(N) == false) return L"The input lenght must be a power of two";
	unsigned int i, j = 0, k;
	unsigned int LE1;
	complex <double> tx, U, W;
	const unsigned int m = (int)(log((double)N)/log((double)2));
	const unsigned int NV2 = N >> 1; // line 4
	const unsigned int NM1 = N - 1; // line 5
	complex<double> T;
	for (i = 0; i < NM1 ; i++)
	{
		if (i < j)
		{
			T = in_out[j]; // line 10
			in_out[j] = in_out[i]; // line 11
			in_out[i] = T; // line 12
		}
		k = NV2; // line 13
		while (k <= j) 
		{
			j -= k; // line 15
			k >>= 1;  // line 16
		}
		j += k; // line 18
	}
	W.real(-1.0);
	W.imag(0.0);
	int LE = 1, IP;
	for (unsigned int mx = 0; mx < m; mx++) // line 19 
	{
		LE1 = LE; //line 20 and 21
		LE <<= 1; // line 20 and 21
		U.real(1.0); // line 22
		U.imag(0.0); // line 22
		W.real(cos(M_PI/LE1));  // line 23
		if (inverse==true)
		{
			W.imag(sin(M_PI/LE1));  // line 23
		}
		else
		{
			W.imag(-sin(M_PI/LE1));  // line 23
		}
		for (j = 0; j < LE1; j++) // line 24
		{
			for (i = j; i < N; i += LE)  // line 25 
			{
				IP = i + LE1; // line 26
				T = in_out[IP] * U; // line 27
				in_out[IP] = in_out[i] - T; // line 28 
				in_out[i] += T; // line 29
			}
			U *= W; //U = U * W; // line 30
		}
		//W.imag(sqrt((1.0 - W.real()) / 2.0));
		//if (inverse==false) W.imag(-W.imag());
		//W.real(sqrt((1.0 + W.real()) / 2.0));
	}

	if (inverse == true) in_out /= N;      
	return NULL;
}

const wchar_t* Dsp::Fft(const valarray<double>& input, valarray<complex<double> >& output, bool inverse)
{
	const int in_size = (int)input.size();
	const int out_size = (int)output.size();
	try
	{
		if (in_size != out_size) output.resize(in_size);
		for(int i = 0; i<in_size; i++) output[i] = input[i];
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return Math::Dsp::Fft(output, inverse);
}

const wchar_t* Dsp::RealFft(valarray<double>& in_out, bool inverse)
{
	const int size = (int)in_out.size();
	if (size == 0) return NULL;
	valarray<complex<double> > tmp;
	int i = 0;
	try
	{
		tmp.resize(size);
		for(i = 0; i<size; i++)
		{
			tmp[i] = in_out[i];
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	const wchar_t * error = Fft(tmp, inverse);
	if (error != NULL) return error;
	for(i = 0; i<size; i++)
	{
		if (i%2 == 0)
		{
			in_out[i] = tmp[i].real();
		}
		else
		{
			in_out[i] = tmp[i].imag();
		}
	}
	return NULL;
}

const wchar_t* Dsp::RealFft(const valarray<double>& input, valarray<double>& output, bool inverse)
{
	const int size = (int)input.size();
	if (size == 0) return NULL;
	if (size <=1) return NULL;
	valarray<complex<double> > tmp;
	int i = 0;
	try
	{
		tmp.resize(size);
		output.resize(size);
		if (inverse == true)
		{	
			//________________________ Complete symmetric conjugate spectrum
			const int mid = size/2;
			//____________ offset
			tmp[0] = input[0];
			//____________ first part
			for(i = 1; i<mid; i++)
			{
				tmp[i]._Val[0] = input[2*i-1];
				tmp[i]._Val[1] = input[2*i];
			}
			//____________ middle
			tmp[mid] = input[size-1];
			//____________ symm conj
			for(i = 1; i<mid; i++)
			{
				tmp[mid+i]._Val[0] = input[2*mid-2*i-1];
				tmp[mid+i]._Val[1] = -input[2*mid-2*i];
			}
		}
		else
		{
			//________________________ Just copy real part
			for(i = 0; i<size; i++)
			{
				tmp[i] = input[i];
			}
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	const wchar_t * error = Fft(tmp, inverse);
	if (error != NULL) return error;
	if (inverse == true)
	{
		//________________________ Just copy real part
		for(i = 0; i<size; i++)
		{
			output[i] = tmp[i].real();
		}
	}
	else
	{
		//________________________ Remove symmetric conjugate spectrum
		for(i = 0; i<size; i++)
		{
			if (i == 0)
			{
				output[0] = tmp[0].real();
			}
			else if (i > 0)
			{
				output[2*i-1] = tmp[i].real();
				if (2*i == size) break;
				output[2*i] = tmp[i].imag();
			}
		}
	}
	return NULL;
}

const wchar_t* Dsp::RealFft(MATRIX& in_out, bool inverse)
{
	const int rows = (int)in_out.size();
	if (rows == 0) return NULL;
	const wchar_t* error = NULL;
	for(int i = 0; i<rows; i++)
	{
		error = RealFft(in_out[i], inverse);
		if (error) return error;
	}
	return NULL;
}

const wchar_t* Dsp::RealFft(const MATRIX& input, MATRIX& output, bool inverse)
{
	const int rows = (int)input.size();
	if (rows == 0) return NULL;
	try
	{
		output.resize(rows);
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	const wchar_t* error = NULL;
	for(int i = 0; i<rows; i++)
	{
		error = RealFft(input[i], output[i], inverse);
		if (error) return error;
	}
	return NULL;
}

bool Dsp::DiscreteCosineTransform_II(const valarray<double>& input, valarray<double>& output)
{
	// See Wikipedia DCT-II
	const int N = (int)input.size();
	if ((int)output.size() != N)
	{
		try
		{
			output.resize(N);
		}
		catch(const std::bad_alloc&)
		{
			return false;
		}
	}
	int n, k;
	double sum;
	const double piN = M_PI/N;
	const double factor = sqrt(2.0/N);
	for (k = 0; k < N; k++)
	{
		sum = 0.0;
		for (n = 0; n < N; n++)
		{
			sum += (   input[n]*cos(piN*(n+0.5)*k)  );
		}
		if (k == 0)
		{
			output[k] = sum/sqrt((double)N);
		}
		else
		{
			output[k] = factor*sum;
		}
	}
	return true;
}

bool Dsp::DiscreteCosineTransform(const valarray<double>& input, valarray<double>& output)
{
	// Numerical Recipes Second Edition (12.3.22)
	const int N = (int)input.size();
	if ((int)output.size() != N)
	{
		try
		{
			output.resize(N);
		}
		catch(const std::bad_alloc&)
		{
			return false;
		}
	}
	int k, j;
	double sum;
	const double piN = M_PI/N;
	for (k = 0; k < N; k++)
	{
		sum = 0.0;
		for (j = 0; j < N; j++)
		{
			sum += (   input[j]*cos(piN*k*(j+0.5))  );
		}
		output[k] = sum;
	}
	return true;
}

bool Dsp::InvDiscreteCosineTransform_II(const valarray<double>& input, valarray<double>& output)
{
	// See Wikipedia DCT-III
	const int N = (int)input.size();
	if ((int)output.size() != N)
	{
		try
		{
			output.resize(N);
		}
		catch(const std::bad_alloc&)
		{
			return false;
		}
	}
	int n, k;
	double sum;
	const double piN = M_PI/N;
	const double factor = sqrt(2.0/N);
	const double initial_sum = input[0]/sqrt(2.0);
	for (k = 0; k < N; k++)
	{
		sum = initial_sum;
		for (n = 1; n < N; n++)
		{
			sum += (   input[n]*cos(piN*n*(k+0.5))  );
		}
		output[k] = factor*sum;
	}
	return true;
}

bool Dsp::InvDiscreteCosineTransform(const valarray<double>& input, valarray<double>& output)
{
	// Numerical Recipes Second Edition (12.3.23)
	const int N = (int)input.size();
	if ((int)output.size() != N)
	{
		try
		{
			output.resize(N);
		}
		catch(const std::bad_alloc&)
		{
			return false;
		}
	}
	int j, k;
	double sum;
	const double piN = M_PI/N;
	for (j = 0; j < N; j++)
	{
		sum = 0.0;
		for (k = 0; k < N; k++)
		{
			sum += (   input[k]*cos(piN*k*(j+0.5))  );
			if (k == 0) sum /= 2.0;
		}
		output[j] = 2.0*sum/N;
	}
	return true;
}


const wchar_t* Dsp::Periodogram(const valarray<complex<double> >& input, valarray<double>& output)
{
	valarray<complex<double> > tmp(input);
	const wchar_t* error = Math::Dsp::Fft(tmp, false);
	if (error!= NULL) return error;
	Math::Dsp::GetModulus(tmp, output);
	//if (bScale) output[i] = output[i] / (2*M_PI*n);
	return NULL;
}

void Dsp::GetModulus(const valarray<complex<double> >& input, valarray<double>& output)
{
	const unsigned int len = (int)input.size();
	output.resize(len);
	for(unsigned int i=0; i<len; i++)
	{
		output[i] = input[i].real()*input[i].real() + input[i].imag()*input[i].imag();
	}
}

//in_out: offset, real1, imag1, real2, imag2, real3, imag3
void Dsp::PhaseNormalization(valarray<double>& in_out)
{
	double magnitude = 0.0;
	int mainArmonic = 1;
	double maxMagnitude = 0.0;
	double phase = 0.0;
	const int size = (int)in_out.size();
	int i;

	////______________________________ offset
	//magnitude = fabs(in_out[0]);
	//if (magnitude>maxMagnitude)
	//{
	//	mainArmonic = 0;
	//	maxMagnitude = magnitude;
	//}

	for(i = 1; ; i += 2) 
	{
		if (i+1 == size) break;
		magnitude = sqrt(in_out[i]*in_out[i]+in_out[i+1]*in_out[i+1]);
		if (magnitude>maxMagnitude)
		{
			mainArmonic = i/2+1;
			maxMagnitude = magnitude;
		}
	}
	// Normalization
	const double mainReal = in_out[2*mainArmonic-1];
	const double mainImag = in_out[2*mainArmonic];
	if (maxMagnitude>0.0) phase = atan2(mainImag, mainReal);
	if (phase==0) return;
	const double theta = phase/mainArmonic;
	int ireal;
	int iimag;
	for(i = mainArmonic; i < size/2; i += mainArmonic)
	{
		ireal = 2*i-1;
		iimag = 2*i;
		magnitude = sqrt(in_out[ireal]*in_out[ireal]+in_out[iimag]*in_out[iimag]);
		phase = (magnitude > 0.0) ? atan2(in_out[iimag], in_out[ireal]) : 0.0;
		phase -= theta*i;
		in_out[ireal] = magnitude*cos(phase);
		in_out[iimag] = magnitude*sin(phase);
	}
}

void Dsp::PhaseNormalization(MATRIX& in_out)
{
	const int len = (int)in_out.size();
	for(int i = 0; i < len; i++) Math::Dsp::PhaseNormalization(in_out[i]);
}

void Dsp::PhaseNormalization(valarray<complex<double> >& in_out)
{
	double magnitude = 0.0;
	double maxMagnitude = 0.0;
	double phase = 0.0;
	int mainArmonic = 1;
	const int size = (int)in_out.size();
	int i;

	for(i = 1; i < size; i++) 
	{
		magnitude = sqrt(in_out[i].real()*in_out[i].real() + in_out[i].imag()*in_out[i].imag());
		if (magnitude>maxMagnitude)
		{
			mainArmonic = i;
			maxMagnitude = magnitude;
		}
	}
	// Normalization
	if (maxMagnitude > 0.0)
	{
		phase = atan2(in_out[mainArmonic].imag(), in_out[mainArmonic].real());//atan2(matrixF[i][2*mainArmonic+1], matrixF[i][2*mainArmonic]);
	}
	if (phase == 0.0) return; // Nothing to do
	const double theta = phase/mainArmonic;
	for(i = mainArmonic; i < size/2; i += mainArmonic)
	{
		magnitude = sqrt(in_out[i].real()*in_out[i].real() + in_out[i].imag()*in_out[i].imag()); //magnitude = sqrt(matrixF[i][2*j]*matrixF[i][2*j]+matrixF[i][2*j+1]*matrixF[i][2*j+1]);
		phase = (magnitude > 0.0) ? atan2(in_out[i].imag(), in_out[i].real()) : 0.0;
		phase -= theta*i;
		in_out[i].real(magnitude*cos(phase));
		in_out[i].imag(magnitude*sin(phase));
		//
		in_out[size - i - 1].real(magnitude*cos(phase));
		in_out[size - i - 1].imag(magnitude*sin(phase));
	}
}

void Dsp::PhaseNormalization(MATRIXC& in_out)
{
	const int len = (int)in_out.size();
	for(int i = 0; i < len; i++) Math::Dsp::PhaseNormalization(in_out[i]);
}

const wchar_t* Dsp::Fft(MATRIXC& in_out, bool inverse)
{
	const int rows = (int)in_out.size();
	if (rows == 0) return NULL;
	const int cols = (int)in_out[0].size();
	if (cols == 0) return NULL;
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	for(int i = 0; i<rows; i++)
	{
		Math::Dsp::Fft(in_out[i], inverse);
	}
	return NULL;
}

const wchar_t* Dsp::Fft(const valarray<complex<double> >& input, valarray<complex<double> >& output, bool inverse)
{
	output = input;
	return Math::Dsp::Fft(output, inverse);
}

const wchar_t* Dsp::Fft(const MATRIX& input, MATRIXC& output, bool inverse)
{
	const int rows = (int)input.size();
	if (rows == 0) return NULL;
	const int cols = (int)input[0].size();
	if (cols == 0) return NULL;
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			if (output[i].size() != cols) output[i].resize(cols);
			Math::Dsp::Fft(input[i], output[i], inverse);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

const wchar_t* Dsp::Fft(const MATRIXC& input, MATRIXC& output, bool inverse)
{
	const int rows = (int)input.size();
	if (rows == 0) return NULL;
	const int cols = (int)input[0].size();
	if (cols == 0) return NULL;
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"Fft:: the number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			if (output[i].size() != cols) output[i].resize(cols);
			Math::Dsp::Fft(input[i], output[i], inverse);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"Fft: no enough memory";
	}
	return NULL;
}

const wchar_t* Dsp::TwoFft(const valarray<double>& input1, const valarray<double>& input2, valarray<complex <double> >& out_fft1, valarray<complex <double> >& out_fft2)
{
	const int n = (int)input1.size();
	if (input2.size() != n) return L"TwoFft: both inputs must be the same length";
	if (n < 2 || n&(n-1)) return L"TwoFft: the input length must be a power of two";
	try
	{
		if (out_fft1.size() != n) out_fft1.resize(n);
		if (out_fft2.size() != n) out_fft2.resize(n);
	}
	catch(std::bad_alloc& )
	{
		return L"TwoFft:  no enough memory to perform the transformation";
	}
	int j;
	//______________________ Both inputs in fft1
	for (j = 0; j < n; j++) 
	{
		out_fft1[j].real(input1[j]);
		out_fft1[j].imag(input2[j]);
	}
	//______________________ Perform the FFT
	Math::Dsp::Fft(out_fft1, false);
	//______________________ Split the results
	out_fft2[0].real(out_fft1[0].imag());
	out_fft1[0].imag(0.0);
	out_fft2[0].imag(0.0);
	complex<double> a, b;
	const int quart = n/2+1;
	for(j = 1; j < quart; j++) 
	{
		a.real(out_fft1[j].real() + out_fft1[n-j].real());
		a.imag(out_fft1[j].imag() - out_fft1[n-j].imag());
		a *= 0.5;
		//
		b.real(out_fft1[j].imag() + out_fft1[n-j].imag());
		b.imag(out_fft1[j].real() - out_fft1[n-j].real());
		b *= 0.5;
		//
		out_fft1[j] = a;
		out_fft1[n-j] = std::conj(a);
		//
		out_fft2[n-j] = b;
		out_fft2[j] = std::conj(b);
	}
	return NULL;
}

const wchar_t* Dsp::TwoIfft(const valarray<complex<double> >& input_fft1, const valarray<complex<double> >& input_fft2, valarray<double>& output1, valarray<double>& output2)
{
	const int n = (int)input_fft1.size();
	if (input_fft2.size() != n) return L"TwoIfft: both inputs must be the same length";
	if (n<2 || n&(n-1)) return L"TwoIfft: the input length must be a power of two";
	valarray<complex<double> >input;
	try
	{
		input.resize(n);
		if (output1.size() != n) output1.resize(n);
		if (output2.size() != n) output2.resize(n);
	}
	catch(std::bad_alloc& )
	{
		return L"TwoIfft: no enough memory to perform the transformation";
	}
	int i;
	//______________________ input = input_fft1 + i * (input_fft2)
	for (i = 0; i < n; i++) 
	{
		input[i].real( input_fft1[i].real() - input_fft2[i].imag() );
		input[i].imag( input_fft1[i]._Val[_IM]+ input_fft2[i].real() );
	}
	//_____________________ Perform the IFFT
	const wchar_t* error = Math::Dsp::Fft(input, true);
	if (error != NULL) return error;
	//_____________________ Real part of input is output1, Imaginary part of input is output2
	for (i = 0; i < n; i++) 
	{
		output1[i] = input[i].real();
		output2[i] = input[i].imag();
	}
	return NULL;
}

const wchar_t* Dsp::Fft2D(const MATRIX& input, MATRIXC& output)
{
	//___________________________________ rows
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	//___________________________________ cols
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.clear();
		return NULL;
	}
	if (rows != cols) return L"Fft2D: the number of rows must be equal to the number of columns";
	if (rows < 2 || rows&(rows-1)) return L"Fft2D: the number of rows must be a power of two";
	//___________________________________ Allocate output and col1, col2
	int i, j, k;
	valarray<double> col1;
	valarray<double> col2;
	valarray<complex<double> > colfft1;
	valarray<complex<double> > colfft2;
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(i = 0; i < rows; i++)
		{
			if (output[i].size() != cols) output[i].resize(cols);
		}
		col1.resize(rows);
		col2.resize(rows);
		colfft1.resize(rows);
		colfft2.resize(rows);
	}
	catch(std::bad_alloc& )
	{
		return L"Fft2D: no enough memory to perform the transformation";
	}
	//________________________________ Copy two columns (at a time) from the input and transform the columns
	const int half = rows/2;
	int c1, c2;
	for(j = 0; j < half; j++)
	{
		c1 = 2*j;
		c2 = c1 + 1;
		for(i = 0; i < rows; i++) // Prepare the two columns
		{
			col1[i] = input[i][c1];
			col2[i] = input[i][c2];
		}
		Math::Dsp::TwoFft(col1, col2, colfft1, colfft2);
		//_____________ Copy the two columns to the output while unfolding the spectrum
		for(i = 0, k = half; i < half; i++, k++)
		{
			output[i][c1] = colfft1[k];
			output[i][c2] = colfft2[k];
		}
		for(i = half, k = 0; k < half; i++, k++)
		{
			output[i][c1] = colfft1[k];
			output[i][c2] = colfft2[k];
		}
		//for(i = 0; i < rows; i++) 
		//{
		//	output[i][c1] = colfft1[i];
		//	output[i][c2] = colfft2[i];
		//}
	}
	//_______________________________ Transform and unfold the rows in place
	for(i = 0; i < half+1; i++)
	{
		Math::Dsp::Fft(output[i], false);
		Math::Dsp::SpectrumUnfold(output[i]);
	}
	//_______________________________ Fill the symmetric part of the transformation
	int rowDest = 0;
	for(i = 1; i < half; i++)
	{
		rowDest = rows-i;
		//________________________________________ Conjugate First Element in the row
		output[rowDest][0]._Val[_RE] =  output[i][0]._Val[_RE];
		output[rowDest][0]._Val[_IM] =  -output[i][0]._Val[_IM];
		//________________________________________ Reverse and conjugate the rest of the elements (without touching the first one)
		for(j = 1; j < cols; j++)
		{
			output[rowDest][j]._Val[_RE] =  output[i][cols-j]._Val[_RE];
			output[rowDest][j]._Val[_IM] =  -output[i][cols-j]._Val[_IM];
		}
	}
	return NULL;
}

const wchar_t* Dsp::Fft2D(const MATRIXC& input, MATRIXC& output)
{
	//___________________________________ rows
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	//___________________________________ cols
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.clear();
		return NULL;
	}
	if (rows != cols) return L"Fft2D: the number of rows must be equal to the number of columns";
	if (rows < 2 || rows&(rows-1)) return L"Fft2D: the number of rows must be a power of two";
	//___________________________________ Allocate output and col1, col2
	int i, j, k;
	valarray<complex<double> > column;
	valarray<complex<double> > columnFft;
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(i = 0; i < rows; i++)
		{
			if (output[i].size() != cols) output[i].resize(cols);
		}
		column.resize(rows);
		columnFft.resize(rows);
	}
	catch(std::bad_alloc& )
	{
		return L"Fft2D: no enough memory to perform the transformation";
	}
	//________________________________ Copy one column (at a time) from the input and transform this column
	const int half = rows/2;
	for(j = 0; j < rows; j++)
	{
		for(i = 0; i < rows; i++) // Prepare the column
		{
			column[i] = input[i][j];
		}
		Math::Dsp::Fft(column, columnFft, false);
		//_____________ Copy the column to the output while unfolding the spectrum
		for(i = 0, k = half; i < half; i++, k++)
		{
			output[i][j] = columnFft[k];
		}
		for(i = half, k = 0; k < half; i++, k++)
		{
			output[i][j] = columnFft[k]; 
		}
	}
	//_______________________________ Transform and unfold the rows in place
	for(i = 0; i < rows; i++)
	{
		Math::Dsp::Fft(output[i], false);
		Math::Dsp::SpectrumUnfold(output[i]);
	}
	////_______________________________ Fill the symmetric part of the transformation
	//int rowDest = 0;
	//for(i = 1; i < half; i++)
	//{
	//	rowDest = rows-i;
	//	//________________________________________ Conjugate First Element in the row
	//	output[rowDest][0]._Val[_RE] =  output[i][0]._Val[_RE];
	//	output[rowDest][0]._Val[_IM] =  -output[i][0]._Val[_IM];
	//	//________________________________________ Reverse and conjugate the rest of the elements (without touching the first one)
	//	for(j = 1; j < cols; j++)
	//	{
	//		output[rowDest][j]._Val[_RE] =  output[i][cols-j]._Val[_RE];
	//		output[rowDest][j]._Val[_IM] =  -output[i][cols-j]._Val[_IM];
	//	}
	//}
	return NULL;
}

// When the input is symmetric the algorithm is faster and the returned value is real
const wchar_t* Dsp::IFft2D(bool isInputSymmetric, const MATRIXC& input, MATRIXC& output)
{
	const wchar_t* error = NULL;
	//___________________________________ rows
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	//___________________________________ cols
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.clear();
		return NULL;
	}
	if (rows != cols) return L"IFft2D: the number of rows must be equal to the number of columns";
	if (rows < 2 || rows&(rows-1)) return L"IFft2D: the number of rows must be a power of two";
	//___________________________________ Allocate output and col1, col2 (col1, col2 and fft2 are used only for a symmetric input)
	int i, j, k;
	valarray<double> col1;
	valarray<double> col2;
	valarray<complex<double> > fft1;
	valarray<complex<double> > fft2;
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(i = 0; i < rows; i++)
		{
			if (output[i].size() != cols) output[i].resize(cols);
		}
		fft1.resize(rows);
		if (isInputSymmetric == true)
		{
			col1.resize(rows);
			col2.resize(rows);
			fft2.resize(rows);
		}
	}
	catch(std::bad_alloc& )
	{
		return L"IFft2D: no enough memory to perform the transformation";
	}
	const int half = rows/2;
	//________________________________________________________ Transform the rows in place
	if (isInputSymmetric == true)
	{
		for(i = 0; i < half+1; i++)
		{
			Math::Dsp::SpectrumFold(input[i], output[i]);
			Math::Dsp::Fft(output[i], true);	
		}
		//___________ Fill symmetric part
		int rowDest = 0;
		for(i = 1; i < half; i++)
		{
			rowDest = rows-i;
			//__ Conjugate the elements
			for(j = 0; j < cols; j++)
			{
				output[rowDest][j]._Val[_RE] =  output[i][j]._Val[_RE];
				output[rowDest][j]._Val[_IM] =  -output[i][j]._Val[_IM];
			}
		}
	}
	else
	{
		for(i = 0; i < rows; i++)
		{
			Math::Dsp::SpectrumFold(input[i], output[i]);
			Math::Dsp::Fft(output[i], true);	
		}
	}
	//Sys::FileAssistant::CsvSave(L"output2.csv", output);

	if (isInputSymmetric == true)
	{
		//________________________________ Copy two columns (at a time) from the output and transform the columns
		int c1, c2;
		for(j = 0; j < half; j++)
		{
			c1 = 2*j;
			c2 = c1 + 1;
			//_____________ Copy two column from the output while unfolding the spectrum
			for(i = 0, k = half; i < half; i++, k++)
			{
				fft1[k] = output[i][c1];
				fft2[k] = output[i][c2];
			}
			for(i = half, k = 0; k < half; i++, k++)
			{
				fft1[k] = output[i][c1];
				fft2[k] = output[i][c2];
			}
			//_____________ Perform the transformation
			error = Math::Dsp::TwoIfft(fft1, fft2, col1, col2);
			if (error != NULL) return error;
			//_____________ Copy back to the output
			for(i = 0; i < rows; i++)
			{
				output[i][c1] = col1[i];
				output[i][c2] = col2[i];
			}
		}
	}
	else
	{
		//________________________________ Copy one column (at a time) from the output and transform the column
		for(j = 0; j < cols; j++)
		{
			//_____________ Copy one column from the output while unfolding the spectrum
			for(i = 0, k = half; i < half; i++, k++)
			{
				fft1[k] = output[i][j];
			}
			for(i = half, k = 0; k < half; i++, k++)
			{
				fft1[k] = output[i][j];
			}
			//_____________ Perform the transformation
			error = Math::Dsp::Fft(fft1, true);
			if (error != NULL) return error;
			//_____________ Copy back to the output
			for(i = 0; i < rows; i++)
			{
				output[i][j] = fft1[i];
			}
		}
	}
	return NULL;
}

void Dsp::SpectrumUnfold(valarray<complex<double> >& in_out)
{
	const int len = (int)in_out.size();
	if (len <= 1) return;
	complex <double> tmp;
	int i = 0;
	const int half = len/2;
	if (len%2 == 0)
	{	
		for(i = 0; i < half; i++)
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
	}
	else
	{
		complex <double> first = in_out[0]; // Store first
		for(i = 1; i <= half; i++) // swap left with right in the same order
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
		for(i = 0; i < half; i++) // shift first half to the left
		{
			in_out[i] = in_out[i+1];
		}
		in_out[half] = first;
	}
}

bool Dsp::SpectrumUnfold(const valarray<complex<double> >& input, valarray<complex<double> >& output)
{
	const int len = (int)input.size();
	if (len <= 1) return true;
	try
	{
		if (output.size() != len) output.resize(len);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	complex <double> tmp;
	int i = 0, k;
	const int half = len/2;
	if (len%2 == 0)
	{	
		for(i = 0, k = half; i < half; i++, k++)
		{
			output[i]= input[k];
		}
		for(i = half, k = 0; k < half; i++, k++)
		{
			output[i] =input[k];
		}
	}
	else
	{
		for(i = 0, k = half+1; i < half; i++, k++)
		{
			output[i]= input[k];
		}
		for(i = half, k = 0; i < len; i++, k++)
		{
			output[i] =input[k];
		}
	}
	return true;
}

bool Dsp::SpectrumUnfold(const valarray<double>& input, valarray<double>& output)
{
	const int len = (int)input.size();
	if (len <= 1) return true;
	try
	{
		if (output.size() != len) output.resize(len);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	complex <double> tmp;
	int i = 0, k;
	const int half = len/2;
	if (len%2 == 0)
	{	
		for(i = 0, k = half; i < half; i++, k++)
		{
			output[i]= input[k];
		}
		for(i = half, k = 0; k < half; i++, k++)
		{
			output[i] =input[k];
		}
	}
	else
	{
		for(i = 0, k = half+1; i < half; i++, k++)
		{
			output[i]= input[k];
		}
		for(i = half, k = 0; i < len; i++, k++)
		{
			output[i] =input[k];
		}
	}
	return true;
}

void Dsp::SpectrumUnfold(valarray<double>& in_out)
{
	const int len = (int)in_out.size();
	if (len <= 1) return;
	double tmp;
	int i = 0;
	const int half = len/2;
	if (len%2 == 0)
	{	
		for(i = 0; i < half; i++)
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
	}
	else
	{
		double first = in_out[0]; // Store first
		for(i = 1; i <= half; i++) // swap left with right in the same order
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
		for(i = 0; i < half; i++) // shift first half to the left
		{
			in_out[i] = in_out[i+1];
		}
		in_out[half] = first;
	}
}

void Dsp::SpectrumFold(valarray<complex<double> >& in_out)
{
	const int len = (int)in_out.size();
	if (len%2 == 0)
	{
		Math::Dsp::SpectrumUnfold(in_out);
	}
	else
	{
		const int half = len/2;
		complex<double> tmp;
		complex<double> first = in_out[half]; // Store half
		int i;
		for(i = half; i > 0; i--) // shift first half
		{
			in_out[i] = in_out[i-1];
		}
		for(i = 1; i <= half; i++) // invert
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
		in_out[0] = first;
	}
}

bool Dsp::SpectrumFold(const valarray<complex<double> >& input, valarray<complex<double> >& output)
{
	const int len = (int)input.size();
	const int half = len/2;
	if (len%2 == 0) return Math::Dsp::SpectrumUnfold(input, output);
	try
	{
		if (output.size() != len) output.resize(len);
	}
	catch(std::bad_alloc &)
	{
		return false;
	}
	int i, k;
	for(i = 0, k = half; k < len; i++, k++)
	{
		output[i]= input[k];
	}
	for(i = half+1, k = 0; i < len; i++, k++)
	{
		output[i] =input[k];
	}
	return true;
}

void Dsp::SpectrumFold(valarray<double>& in_out)
{
	const int len = (int)in_out.size();
	if (len%2 == 0)
	{
		Math::Dsp::SpectrumUnfold(in_out);
	}
	else
	{
		const int half = len/2;
		double tmp;
		double first = in_out[half]; // Store half
		int i;
		for(i = half; i > 0; i--) // shift first half
		{
			in_out[i] = in_out[i-1];
		}
		for(i = 1; i <= half; i++) // invert
		{
			tmp = in_out[i];
			in_out[i] = in_out[i+half];
			in_out[i+half] = tmp;
		}
		in_out[0] = first;
	}
}

bool Dsp::SpectrumFold(const valarray<double>& input, valarray<double>& output)
{
	const int len = (int)input.size();
	const int half = len/2;
	if (len%2 == 0) return Math::Dsp::SpectrumUnfold(input, output);
	try
	{
		if (output.size() != len) output.resize(len);
	}
	catch(std::bad_alloc &)
	{
		return false;
	}
	int i, k;
	for(i = 0, k = half; k < len; i++, k++)
	{
		output[i]= input[k];
	}
	for(i = half+1, k = 0; i < len; i++, k++)
	{
		output[i] =input[k];
	}
	return true;
}

const wchar_t* Dsp::Spectrum(const valarray<double>& input, valarray<double>& output)
{
	valarray<complex<double> > y;
	const wchar_t* error = Math::Dsp::Fft(input, y, false);
	if (error != NULL) return error;
	const int len = (int)input.size() / 2;
	try
	{
		if (output.size() != len) output.resize(len);
		for(int i = 0; i<len; i++)
		{
			output[i] = abs(y[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

// Returns the magnitude of the FFT of a signal
const wchar_t* Dsp::Spectrum(const valarray<complex<double>>& input, valarray<double>& output)
{
	valarray<complex<double> > y;
	const wchar_t* error = Math::Dsp::Fft(input, y, false);
	if (error != NULL) return error;
	const int len = (int)input.size() / 2;
	try
	{
		if (output.size() != len) output.resize(len);
		for(int i = 0; i<len; i++)
		{
			output[i] = abs(y[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

const wchar_t* Dsp::Spectrum(const MATRIX& input, MATRIX& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.clear();
		return NULL;
	}
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			Math::Dsp::Spectrum(input[i], output[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

const wchar_t* Dsp::Spectrum(const MATRIXC& input, MATRIX& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.clear();
		return NULL;
	}
	if (Math::Dsp::IsPowerOfTwo(cols) == false) return L"The number of columns must be a power of 2";
	try
	{
		if (output.size() != rows) output.resize(rows);
		for(int i = 0; i<rows; i++)
		{
			Math::Dsp::Spectrum(input[i], output[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	return NULL;
}

double Dsp::Impulse(int n, int delay) // n is the discrete time d[n-delay]
{
	return (n==delay) ? 1 : 0;
}

double Dsp::Step(int n, int delay) // n is the discrete time u[n-delay]
{
	return (n-delay)>=0 ? 1 : 0;
}

double Dsp::Sin(int n, double k, int delay) // n is the discrete time Sin(kn-delay)
{
	return sin(n*k-delay);
}

double Dsp::Sinc(int n, double k, int delay) // n is the discrete time Sin(kn-delay)
{
	double t = n*k-delay;
	if (t==0) return 1;
	return sin(M_PI*t)/(M_PI*t);
}

double Dsp::Sinc(double x)
{
	if (x==0) return 1.0;
	return sin(M_PI*x)/(M_PI*x);
}

double Dsp::Sgn(double x)
{
	if (x > 0.0) return 1.0;
	if (x < 0.0) return -1.0;
	return 0.0;
}

double Dsp::Step(double x)
{
	if (x > 0.0) return 1.0;
	if (x == 0.0) return 0.5;
	return 0.0;
}

// Keeps the angle in [-pi pi]
double Dsp::AngleRotate(double x)
{
	const double twopi = 2.0*M_PI;
	while (x > M_PI) x -= twopi;
	while (x < -M_PI) x += twopi;
	return x;
}

// Keeps the angle in [0 2*pi]
double Dsp::AngleRotate2(double x)
{
	const double twopi = 2.0*M_PI;
	while (x >= twopi) x -= twopi;
	while (x < 0) x += twopi;
	return x;
}

double Dsp::Sawtooth(double x, double period)
{
	const double half = period/2.0;
	if (x==0) return 0.0;
	if (x>0)
		while(x>half) x-=period;
	else
		while(x<-half) x+=period;
	return x/half;
}

double Dsp::Triangular(double x, double period)
{
	const double half = period/2.0;
	if (x==0) return 1.0;
	if (x>0)
		while(x>half) x-=period;
	else
		while(x<-half) x+=period;
	if (x>0)
		return -4.0*x/period+1.0;
	else
		return 4.0*x/period+1.0;
	return 0.0;
}

double Dsp::Rectangular(double x, double period)
{
	const double half = period/2.0;
	if (x==0) return 0.0;
	if (x>0)
		while(x>half) x-=period;
	else
		while(x<-half) x+=period;
	if (x>0)
		return 1.0;
	else
		return -1.0;
	return 0.0;
}

double Dsp::Pi(int n, int delay, int duration) // PI(n-delay)
{
	if (n-delay<-duration/2.0) return 0.0;
	if (duration/2.0<n-delay) return 0.0;
	return 1.0;
}

double Dsp::Rect(double x)
{
	if (x < -0.5) return 0.0;
	if (0.5 < x) return 0.0;
	if (x == 0.5) return 0.5;
	if (x == -0.5) return 0.5;
	return 1.0;
}

double Dsp::Delta(double x)
{
	if (x == 0) return 1.0;
	return 0.0;
}

double Dsp::Circ(double x)
{
	if (x > 1.0) return 0.0;
	if (x < -1.0) return 0.0;
	return 1.0;
}


void Dsp::KaiserWindow(double beta, int length, valarray<double>& out_window)
{
	const int M = length-1;
	out_window.resize(length);
	const double alpha = M/2.0;
	const double denominator = Math::Bessel::In(0, beta); 
	double z;
	//_j0, _j1, _jn
	for(int n=0; n<=M; n++)
	{
		z = (n-alpha)/(double)alpha;
		out_window[n] = Math::Bessel::In(0, beta*sqrt(1.0-z*z))/denominator; 
	}
}

double Dsp::Kaiser(double beta, double x)
{
	if (x > 1.0) return 0.0;
	if (x < -1.0) return 0.0;
	const double i0 = Math::Bessel::In(0, beta);
	return Math::Bessel::In(0, beta*sqrt(1.0-x*x))/i0;
}

void Dsp::WelchWindow(int length, valarray<double>& out_window)
{
	const double alpha = (length-1.0)/2.0;
	const double m = (length+1.0)*(length+1.0)/4.0;

	out_window.resize(length);
	double w;
	for(int n=0; n<length; n++)
	{
		w = (n-alpha);
		out_window[n] = 1.0 - w*w/m;
	}
}

void Dsp::ImpulRespLowPass(double beta, int length, double cutFreqRad, valarray<double>& out_h)
{
	// Oppenheim:  Example 7.11
	valarray<double> kaiser;
	Dsp::KaiserWindow(beta, length, kaiser);

	const int M = length-1;
	const double alpha = M/2.0;
	out_h.resize(length);

	for(int n=0; n<length; n++)
	{
		if (n-alpha == 0.0)
		{
			out_h[n]=cutFreqRad/M_PI;
		}
		else
		{
			out_h[n]=sin(cutFreqRad*(n-alpha))/(M_PI*(n-alpha));
		}
		out_h[n] = kaiser[n]*out_h[n];
	}
}

void  Dsp::ImpulRespHighPass(double beta, int length, double cutFreqRad, valarray<double>& out_h)
{
	valarray<double> kaiser;
	Dsp::KaiserWindow(beta, length, kaiser);
	const int M = length-1;
	const double alpha = M/2.0;
	out_h.resize(length);

	for(int n=0; n<length; n++)
	{
		if (n-alpha == 0.0)
		{
			out_h[n]=Math::Dsp::Sinc(n-alpha) - cutFreqRad/M_PI;
		}
		else
		{
			out_h[n]=Math::Dsp::Sinc(n-alpha) - sin(cutFreqRad*(n-alpha))/(M_PI*(n-alpha));
		}
		out_h[n] = kaiser[n]*out_h[n];
	}
}

double Dsp::ComputeBeta(double stopBandGaindB)
{
	const double A = fabs(stopBandGaindB);

	if (A>50)
	{
		return 0.1102*(A-8.7);
	}
	else if (A<21)
	{
		return 0.0;
	}
	else
	{
		return 0.5842*pow((A-21), 0.4) + 0.07886*(A-21);
	}
	return 0.0;
}

int Dsp::ComputeM(double stopBandGaindB, double transitionWidthRad)
{
	const double A = fabs(stopBandGaindB);
	return (int)((A-8)/(2.285*transitionWidthRad)+0.5);
}

void Dsp::ImpulRespLowPass(double sampFreqHz, double cutFreqHz, double stopBandGaindB, double transitionWidthHz, valarray<double>& out_h)
{
	const double cutFreqRad = 2.0 * M_PI * cutFreqHz / sampFreqHz;
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(stopBandGaindB);
	const int length = ComputeM(stopBandGaindB, transitionWidthRad)+1;
	ImpulRespLowPass(beta, length, cutFreqRad, out_h);
}

void Dsp::ImpulRespHighPass(double sampFreqHz, double cutFreqHz, double stopBandGaindB, double transitionWidthHz, valarray<double>& out_h)
{
	const double cutFreqRad = 2.0 * M_PI * cutFreqHz / sampFreqHz;
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(stopBandGaindB);
	const int length = ComputeM(stopBandGaindB, transitionWidthRad)+1;
	ImpulRespHighPass(beta, length, cutFreqRad, out_h);
}

void Dsp::FreqRespLowPass(double beta, int length, double cutFreqRad, valarray<double>& out_H)
{
	Math::Dsp::ImpulRespLowPass(beta, length, cutFreqRad, out_H);
	int i;
	valarray<complex<double> > freq(length);
	Math::Dsp::FourierTransformRe(out_H, freq);

	for(i=0; i<length; i++) //Compute Modulus
	{
		out_H[i] = abs(freq[i]);
	}
}

void Dsp::FreqRespHighPass(double beta, int length, double cutFreqRad, valarray<double>& out_H)
{
	Math::Dsp::ImpulRespHighPass(beta, length, cutFreqRad, out_H);
	int i;
	valarray<complex<double> > freq(length);
	Math::Dsp::FourierTransformRe(out_H, freq);

	for(i=0; i<length; i++) //Compute Modulus
	{
		out_H[i] = abs(freq[i]);
	}
	out_H[0] = 0.0; //Eliminate DC
}

bool Dsp::LowPass(const valarray<double>& input, valarray<double>& output, double cutFreqRad)
{
	const double beta = 6.0;
	const int M = 128;
	const int alpha = M/2;
	const int length = (int)input.size();
	valarray<double> h, result;
	Math::Dsp::ImpulRespLowPass(beta, M+1, cutFreqRad, h);
	try
	{
		output.resize(length);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	if (Math::Dsp::Convolution(input, h, result)==false) return false;
	for(int n=0; n<length; n++) output[n] = result[n+alpha];
	return true;
}

bool Dsp::HighPass(const valarray<double>& input, valarray<double>& output, double cutFreqRad)
{
	const double beta = 6.0;
	const int M = 128;
	const int alpha = M/2;
	const int length = (int)input.size();
	valarray<double> h, result;
	Math::Dsp::ImpulRespHighPass(beta, M+1, cutFreqRad, h);
	try
	{
		output.resize(length);
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	if (Math::Dsp::Convolution(input, h, result)==false) return false;
	for(int n=0; n<length; n++) output[n] = result[n+alpha];
	return true;
}

//Even coefficients in the impulse response are zero when the length is odd
void Dsp::ImpulRespHilbertTransform(double beta, int length, valarray<double>& out_h)
{
	const int M = length -1;
	out_h.resize(length);
	const double alpha = M/2.0;
	double z;
	double kaiser;
	double sinz;
	double delay;
	for(int n=0; n<length; n++)
	{
		if (n == alpha) 
		{
			out_h[n] = 0.0;
			continue;
		}
		delay = n-alpha;
		z = delay/(double)alpha;
		kaiser = Math::Bessel::In(0, beta*sqrt(1.0-z*z))/Math::Bessel::In(0, beta); 
		//
		sinz = sin(M_PI*delay/2.0);
		out_h[n] = kaiser*2.0*sinz*sinz/(M_PI*delay);
	}
}

//Even coefficients in the impulse response are zero when the length is odd
void Dsp::FreqRespHilbertTransform(double beta, int length, valarray<double>& out_H)
{
	Math::Dsp::ImpulRespHilbertTransform(beta, length, out_H);
	const unsigned int size = (int)out_H.size();
	unsigned int i;
	valarray<complex<double> > freq(size);
	Math::Dsp::FourierTransformRe(out_H, freq);

	const unsigned int freq_length = (int)freq.size();
	out_H.resize(freq_length);
	for(i=0; i<freq_length; i++) //Compute Modulus
	{
		out_H[i] = abs(freq[i]);
	}
}

// rippleErrordB = -40.0 dB
void Dsp::ImpulRespHilbertTransform(double sampFreqHz, double rippleErrordB, double transitionWidthHz, valarray<double>& out_h)
{
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(rippleErrordB);
	const int length = ComputeM(rippleErrordB, transitionWidthRad)+1;
	ImpulRespHilbertTransform(beta, length, out_h);
}

// rippleErrordB = -40.0 dB
void Dsp::FreqRespHilbertTransform(double sampFreqHz, double rippleErrordB, double transitionWidthHz, valarray<double>& out_H)
{
	const double transitionWidthRad = 2.0 * M_PI * transitionWidthHz / sampFreqHz;
	const double beta = ComputeBeta(rippleErrordB);
	const int length = ComputeM(rippleErrordB, transitionWidthRad)+1;
	FreqRespHilbertTransform(beta, length, out_H);
}

//_____________________________________________________________________ Interpolation
Interpolation::Interpolation()
{
}

Interpolation::~Interpolation()
{
}

double Interpolation::Lagrange(const MATRIX& x_fx, const double x)
{
	const int N = (int)x_fx.size();
	if (N == 0) return 1.0e300;
	const int col_count = (int)x_fx[0].size();
	if (col_count != 2) return 1.0e300;
	double numerator = 1.0;
	double denominator = 1.0;
	double sum = 0.0;
	int i, j;
	for (i = 0; i < N; i++)
	{
		numerator = 1.0;
		denominator = 1.0;
		for (j = 0; j < N; j++)
		{
			if (i == j) continue;
			numerator *= (x - x_fx[j][0]);
			denominator *= (x_fx[i][0] - x_fx[j][0]);
		}
		sum += (numerator*x_fx[i][1])/denominator;
	}
	return sum;
}

double Interpolation::Neville(const MATRIX& x_fx, const double x, double&out_error)
{
	const int count = (int)x_fx.size();
	valarray<double> c;
	valarray<double> d;
	c.resize(count);
	d.resize(count);

	double delta1 = fabs(x - x_fx[0][0]);
	double delta2 = 0.0;
	int i = 0;
	int k = 0;
	for (i = 0; i < count; i++) 
	{
		delta2 = fabs(x - x_fx[i][0]);
		if (delta2 < delta1) 
		{
			k = i;
			delta1 = delta2;
		}
		c[i] = x_fx[i][1];
		d[i] = x_fx[i][1];
	}
	double y = x_fx[k][1];
	double w = 0.0;
	double delta;
	k--;
	for (int j = 1; j < count; j++) 
	{
		for (i = 0; i < count-j; i++) 
		{
			delta1 = x_fx[i][0] - x;
			delta2 = x_fx[i+j][0] - x;
			w = c[i+1] - d[i];
			if (delta1 == delta2) throw("Precision error in Math::Interpolation::Neville");
			delta = delta1 - delta2;
			delta = w/delta;
			d[i] = delta2*delta;
			c[i] = delta1*delta;
		}
		if (2*(k+1) < (count - j))
		{
			out_error = c[k+1];
		}
		else
		{
			out_error = d[k];
			k--;
		}
		y += out_error;
	}
	return y;
}

double Interpolation::Neville(const MATRIX& x_fx, const double x)
{
	const int N = (int)x_fx.size();
	if (N == 0) return 1.0e300;
	const int col_count = (int)x_fx[0].size();
	if (col_count != 2) return 1.0e300;
	MATRIX P;
	Math::Oper::CreateMatrix(P, N, N);
	int i, j, m;
	//_________________________________ 1. Fill diagonal (Prepare recursion: P[0][0], P[1][1], P[2][2],  ...)
	for (i = 0; i < N; i++)
	{
		P[i][i] = x_fx[i][1];
	}
	//________________________________ 2. Compute Ps
	for (m = 1; m < N; m++)
	{
		for (i = 0; i < N-m; i++)
		{
			j = i+m;
			P[i][j] = (  (x_fx[j][0] - x) * P[i][j-1] + (x - x_fx[i][0]) * P[i+1][j]  ) / (x_fx[j][0] - x_fx[i][0]);
		}
	}
	return P[0][N-1];
}

double Interpolation::Linear(const MATRIX& x_fx, double& out_m, double& out_b)
{
	out_m = 0.0;
	out_b = 0.0;
	//__________________________________
	const int len = (int)x_fx.size();
	double sumx = 0.0;
	double sumy = 0.0;
	int i;
	for (i = 0; i < len; i++) 
	{
		sumx += x_fx[i][0];
		sumy += x_fx[i][1];
	}
	const double sxlen = sumx/len;
	double tmp;
	double sigma = 0.0;

	for (i = 0; i < len; i++) 
	{
		tmp= x_fx[i][0] - sxlen;
		sigma += (tmp*tmp);
		out_m += (tmp*x_fx[i][1]);
	}
	out_m /= sigma;
	out_b = (sumy - sumx*out_m)/len;
	double chi_squared = 0.0;
	double y;
	for (i = 0; i < len; i++)
	{
		y = out_m*x_fx[i][0] + out_b; // y = mx + b
		tmp = x_fx[i][1] - y;
		chi_squared += (tmp*tmp);
	}
	return chi_squared;
}

double Interpolation::Lagrange2D(const valarray<double>& vx, const valarray<double>& vy, const MATRIX& fxy, const double x, const double y)
{
	int i, j;
	//______________________________________________________ Check size
	const int N = (int)fxy.size();
	if (N == 0) return 1.0e300;
	const int M = (int)fxy[0].size();
	if (M == 0) return 1.0e300;
	if (N != (int)vx.size()) return 1.0e300;
	if (M != (int)vy.size()) return 1.0e300;
	//__________________________________________________________________ Validate vx
	for(i = 0; i < N-1; i++)
	{
		if(vx[i] == vx[i+1]) return 1.0e300;
	}
	//__________________________________________________________________ Validate vy
	for(i = 0; i < M-1; i++)
	{
		if(vy[i] == vy[i+1]) return 1.0e300;
	}
	//_____________________________________________________ Fill first column of x_fx
	MATRIX x_fx;
	Math::Oper::CreateMatrix(x_fx, N, 2);
	for (i = 0; i < N; i++) x_fx[i][0] = vx[i];
	//______________________________________________________ Interpolate in x
	valarray<double> Y;
	Y.resize(M);
	for (j = 0; j < M; j++)
	{
		//_____________________ Fill second column of x_fx
		for (i = 0; i < N; i++)
		{
			x_fx[i][1] = fxy[i][j];
		}
		Y[j] = Math::Interpolation::Lagrange(x_fx, x);
	}
	//_____________________________________________________ Interpolate in y
	Math::Oper::CreateMatrix(x_fx, M, 2);
	for (i = 0; i < M; i++)
	{
		x_fx[i][0] = vy[i];
		x_fx[i][1] = Y[i];
	}
	return Math::Interpolation::Lagrange(x_fx, y);
}

double Interpolation::Neville2D(const valarray<double>& vx, const valarray<double>& vy, const MATRIX& fxy, const double x, const double y)
{
	int i, j;
	//______________________________________________________ Check size
	const int N = (int)fxy.size();
	if (N == 0) return 1.0e300;
	const int M = (int)fxy[0].size();
	if (M == 0) return 1.0e300;
	if (N != (int)vx.size()) return 1.0e300;
	if (M != (int)vy.size()) return 1.0e300;
	//__________________________________________________________________ Validate vx
	for(i = 0; i < N-1; i++)
	{
		if(vx[i] == vx[i+1]) return 1.0e300;
	}
	//__________________________________________________________________ Validate vy
	for(i = 0; i < M-1; i++)
	{
		if(vy[i] == vy[i+1]) return 1.0e300;
	}
	//_____________________________________________________ Fill first column of x_fx
	MATRIX x_fx;
	Math::Oper::CreateMatrix(x_fx, N, 2);
	for (i = 0; i < N; i++) x_fx[i][0] = vx[i];
	//______________________________________________________ Interpolate in x
	valarray<double> Y;
	Y.resize(M);
	for (j = 0; j < M; j++)
	{
		//_____________________ Fill second column of x_fx
		for (i = 0; i < N; i++)
		{
			x_fx[i][1] = fxy[i][j];
		}
		Y[j] = Math::Interpolation::Neville(x_fx, x);
	}
	//_____________________________________________________ Interpolate in y
	Math::Oper::CreateMatrix(x_fx, M, 2);
	for (i = 0; i < M; i++)
	{
		x_fx[i][0] = vy[i];
		x_fx[i][1] = Y[i];
	}
	return Math::Interpolation::Neville(x_fx, y);
}

double Interpolation::Bilinear(const valarray<double>& vx, const valarray<double>& vy, const MATRIX& fxy, const double x, const double y)
{
	int i;
	//_____________________________________________________________________ Data Validation
	const int numX = (int)vx.size();
	if (numX == 0) return 1.0e300;
	const int numY = (int)vy.size();
	if (numY == 0) return 1.0e300;
	const int numRowFxy = (int)fxy.size();
	if (numRowFxy == 0) return 1.0e300;
	if (numRowFxy != numX) return 1.0e300;
	const int numColFxy = (int)fxy[0].size();
	if (numColFxy != numY) return 1.0e300;
	//_____________________________________________________________________  Find xindex;
	int xindex = -1;
	for (i = 0; i < numX-1; i ++)
	{
		if (vx[i] < x && x <= vx[i+1])
		{
			xindex = i;
			break;
		}
	}
	if (xindex == -1)
	{
		if (vx[0] == x)
		{
			xindex = 0;
		}
		else
		{
			return 1.0e300;
		}
	}
	//_____________________________________________________________________  Find yindex;
	int yindex = -1;
	for (i = 0; i < numY-1; i ++)
	{
		if (vy[i] < y && y <= vy[i+1])
		{
			yindex = i;
			break;
		}
	}
	if (yindex == -1)
	{
		if (vy[0] == y)
		{
			yindex = 0;
		}
		else
		{
			return 1.0e300;
		}
	}
	//____________________________________________________________________ Normalize: [0 1]
	const double dx = (x - vx[xindex])/(vx[xindex+1] - vx[xindex]);
	const double dy = (y - vy[yindex])/(vy[yindex+1] - vy[yindex]);
	//____________________________________________________________________ Interpolate
	return (1.0 - dx)*(1.0 - dy)*fxy[xindex][yindex] + dx*(1.0 - dy)*fxy[xindex+1][yindex] 
		+ dx*dy*fxy[xindex+1][yindex+1] + (1.0 - dx)*dy*fxy[xindex][yindex+1];
}

//_____________________________________________________________________ SplineInterpolation
SplineInterpolation::SplineInterpolation()
{
}

SplineInterpolation::~SplineInterpolation()
{
}

bool SplineInterpolation::Create(const valarray<double>& x, const valarray<double>& fx)
{
	int i;
	//__________________________________________________________________ Input Validation
	const int lenX = (int)x.size();
	if (lenX == 0) return false;
	const int lenFx = (int)fx.size();
	if (lenX != lenFx) return false;
	const int N = lenX - 1;
	//__________________________________________________________________ Validate x
	for (i = 0; i < N; i++)
	{
		if (x[i] == x[i+1]) return false;
	}
	//__________________________________________________________________ Memory Allocation
	valarray<double> tmp;
	try
	{
		secondDerivative.resize(lenX);
		tmp.resize(N);
		table_x = x;
		table_fx = fx;
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	tmp[0] = 0.0;
	secondDerivative[0] = 0.0;
	secondDerivative[N] = 0.0;
	double dx;
	double dx_;
	double dxdx;
	double df;
	//__________________________________________________________________ Compute Second Derivative
	
	for (i = 1; i < N; i++) 
	{
		dx = x[i]-x[i-1];
		dx_ = x[i+1]-x[i-1];
		dxdx = dx / dx_;
		df = dxdx*secondDerivative[i-1]+2.0;
		secondDerivative[i] = (dxdx -1.0)/df;
		tmp[i] = (6.0*((fx[i+1] - fx[i])/(x[i+1] - x[i]) - (fx[i]-fx[i-1])/dx)/dx_ - dxdx*tmp[i-1])/df;
	}
	for (i = N-1; i >= 0; i--)
	{
		secondDerivative[i] = secondDerivative[i]*secondDerivative[i+1] + tmp[i];
	}
	return true;
}

double SplineInterpolation::Interpolate(const double x)
{
	const int len = (int)secondDerivative.size();
	//_________________________________________________________________ table_x[first] < x < table_x[last]
	int current = 0;
	int first = 0;
	int last = len - 1;
	while (last - first > 1) 
	{
		current = (last + first) >> 1; // (last + first)/2
		if (table_x[current] > x) 
		{
			last = current;
		}
		else
		{
			first = current;
		}
	}
	const double delta = table_x[last] - table_x[first];
	const double a = (table_x[last] - x)/delta;
	const double b = (x - table_x[first])/delta;
	return a*table_fx[first] + b*table_fx[last] + ((a*a*a - a)*secondDerivative[first] + (b*b*b-b)*secondDerivative[last])*(delta*delta)/6.0;
}

//_____________________________________________________________________ SplineInterpolation2D
SplineInterpolation2D::SplineInterpolation2D()
{
}

SplineInterpolation2D::~SplineInterpolation2D()
{
}

bool SplineInterpolation2D::Create(const valarray<double>& x, const valarray<double>& y, const MATRIX& fxy)
{
	int i;
	//__________________________________________________________________ Validate input
	const int rowCount = (int)x.size();
	if (rowCount == 0) return false;
	const int colCount = (int)y.size();
	if (colCount == 0) return false;
	if (rowCount != (int)fxy.size()) return false;
	if (colCount != (int)fxy[0].size()) return false;
	//__________________________________________________________________ Validate x
	for(i = 0; i < rowCount-1; i++)
	{
		if(x[i] == x[i+1]) return false;
	}
	//__________________________________________________________________ Validate y
	for(i = 0; i < colCount-1; i++)
	{
		if(y[i] == y[i+1]) return false;
	}
	si.resize(rowCount);
	for (i = 0; i < rowCount; i++)
	{
		if (si[i].Create(y, fxy[i]) == false) return false;
	}
	table_x = x;
	return true;
}

double SplineInterpolation2D::Interpolate(const double x, const double y)
{
	const int rowCount = (int)table_x.size();
	int i;
	//___________________________________________________________________ Interpolate y
	valarray<double> estimate_x;
	estimate_x.resize(rowCount);
	for (i = 0; i < rowCount; i++)
	{
		estimate_x[i] = si[i].Interpolate(y);
	}
	//___________________________________________________________________ Interpolate x
	Math::SplineInterpolation tsi;
	tsi.Create(table_x, estimate_x);
	return tsi.Interpolate(x);
}

//_____________________________________________________________________ GaborTransform
GaborTransform::GaborTransform()
{
	_deltaT = 0.0;
	_deltaF = 0.0;
	_sigma = 0.0;
	_delta_n = 1;
}

GaborTransform::~GaborTransform()
{
}

 // phi0 < 0.25
bool GaborTransform::Create(int numFreq)
{
	return Create(1, numFreq); 
}

bool GaborTransform::Create(int delta_n, int numFreq)
{
	const int N = numFreq;
	const double phi0 = 0.5/(N-1);
	if (delta_n*phi0 > 0.25) return false;
	//_____________________________________ Compute Transformation Parameters
	_delta_n = delta_n;
	_sigma = sqrt(delta_n/(2.0*M_PI*phi0)); // EQ 5.22
	_deltaT = _sigma/sqrt(2.0);   // EQ 5.20
	_deltaF = 1.0/(2.0*sqrt(2.0)*M_PI*_sigma);
	//____________________________________ Memory allocation
	const int halfLength = (int)(1.0 + 7.4*_sigma);
	try
	{
		filterBank.resize(N);
		for(int i = 0; i < numFreq; i++) filterBank[i].resize(halfLength);
	}
	catch(std::bad_alloc&)
	{
		return false;
	}
	//
	const double g = 1.0/(pow(M_PI, 0.25)*sqrt(_sigma)); //  EQ 5.18
	//
	const double fact = -0.5/(_sigma*_sigma);
	int n;
	double frequency;
	double w;

	//___________________________________________ Compute h_0
	for (n = 1; n <= halfLength; n++)
	{
		w = g*exp(fact*n*n); // EQ 5.18
		filterBank[0][n-1].real(w);
		filterBank[0][n-1].imag(0.0);
	}

	//__________________________________________ Compute h_1, h_2, ... h_N-1
	for(int k = 1; k < N; k++)
	{
		frequency = (2.0*M_PI*k/N); // From 0 to pi
		for (n = 1; n <= halfLength; n++)
		{
			filterBank[k][n-1].real(cos(n*frequency)*filterBank[0][n-1].real());
			filterBank[k][n-1].imag(sin(n*frequency)*filterBank[0][n-1].real());
		}
	}
	return true;
}

bool GaborTransform::Transform(const valarray<double>& input, MATRIXC& output)
{
	const int numFreq = (int)filterBank.size();
	if (numFreq == 0) return false;
	const int halfLength = (int)filterBank[0].size();
	const int input_size = (int)input.size();
	const int numTimePoints = 1 + (input_size- 2*halfLength -1)/_delta_n;
	//______________________________ memory allocation
	try
	{
		if (output.size() != numFreq)
		{
			output.resize(numFreq);
			for(int i = 0; i < numFreq; i++) output[i].resize(numTimePoints);
		}
	}
	catch (std::bad_alloc& )
	{
		return false;
	}
	//___________________________________ apply the filter
	const double g = 1.0/(pow(M_PI, 0.25)*sqrt(_sigma)); //  EQ 5.18
	int indexFreq;
	int m ,n;
	double rsum = 0.0;
	double isum = 0.0;
	int index;
	for(m = 0; m < numTimePoints; m++)
	{
		index = halfLength+m*_delta_n;
		for(indexFreq = 0; indexFreq < numFreq; indexFreq++)
		{
			rsum = g*input[index];
			isum = 0.0;

			for(n = 1; n <= halfLength; n++)
			{
				rsum += (filterBank[indexFreq][n-1].real()    *   (input[index+n]+input[index-n])   );
				isum += (filterBank[indexFreq][n-1].imag()   *   (input[index+n]-input[index-n])   );
			}
			output[indexFreq][m].real(rsum);
			output[indexFreq][m].imag(isum);
		}
	}

	return true;
}

double GaborTransform::GetDeltaT()
{
	return _deltaT;
}

double GaborTransform::GetDeltaF()
{
	return _deltaF;
}

double GaborTransform::GetSigma()
{
	return _sigma;
}

//_____________________________________________________________________ TimeDependentFT
TimeDependentFT::TimeDependentFT()
{
}

TimeDependentFT::~TimeDependentFT()
{
}

bool TimeDependentFT::Create(int windowWidth, int numFrequencies, double beta)
{
	const int N = numFrequencies;
	//
	//windowWidth = N/2;
	//
	if (windowWidth%2 == 0) windowWidth++; // Force an window length that is odd
	//
	const int M = windowWidth-1;
	if (M >= N)
	{
		filterBank.clear();
		return false;
	}
	//
	const double kaiserDenominator = Math::Bessel::In(0, beta);
	const int half = 1+M/2;
	//____________________________________ Memory allocation
	int n;
	try
	{
		filterBank.resize(N);
		for(n = 0; n < N; n++)
		{
			if (filterBank[n].size() != half)
			{
				filterBank[n].resize(half);
			}
		}
	}
	catch(std::bad_alloc& )
	{
		return false;
	}

	//______________________________________ Compute h_0 (which is just the window)
	double z;
	for(n = 0; n < half; n++)
	{
		z = (2.0*n)/M;
		filterBank[0][n].real(Math::Bessel::In(0, beta*sqrt(1.0-z*z))/kaiserDenominator); 
		filterBank[0][n].imag(0.0);
	}
	//_____________________________________ Compute the Energy of the Window
	double energy = 0;
	for(n = 0; n < half; n++)
	{
		if (n == 0)
		{
			energy += filterBank[0][n].real()*filterBank[0][n].real(); 
		}
		else
		{
			energy += 2.0*(filterBank[0][n].real()*filterBank[0][n].real()); 
		}
	}
	//____________________________________ Normalized the window
	for(n = 0; n < half; n++)
	{
		filterBank[0][n].real(filterBank[0][n].real()/energy); 
	}
	
	//_____________________________________ Compute h_1, h_2, ... h_N-1
	// To avoid computing the Kaiser window for each k frequency, we will use h_0 
	const double fact = 2.0*M_PI/N;
	double angle;
	for(int k = 1; k < N; k++)
	{
		for(int n=0; n< half; n++)
		{
			angle = fact*k*n;
			//
			filterBank[k][n].real(cos(angle)*filterBank[0][n].real()); 
			filterBank[k][n].imag(sin(angle)*filterBank[0][n].real()); 
		}
	}

	return true;
}

bool TimeDependentFT::Transform(const valarray<double>& input, MATRIXC& output)
{
	//const int lenInput = input.size();
	//const int N = filterBank.size();
	//if (N == 0)
	//{
	//	output.clear();
	//	return false;
	//}
	//const int half = filterBank[0].size();
	////__________________________________ Memory Allocation
	//int k;
	//try
	//{
	//	if (output.size() != N)
	//	{
	//		output.resize(N);
	//		for(k = 0; k < N; k ++) 
	//		{
	//			if (output[k].size() != lenInput)
	//			{
	//				output[k].resize(lenInput);
	//			}
	//		}
	//	}
	//}
	//catch(std::bad_alloc& )
	//{
	//	return false;
	//}
	////________________________________ Convolution:  X[n, k] = x[n]*h_k[n]
	//for(k = 0; k < N; k++)
	//{
	//	Math::Dsp::SymmetricConvolution(filterBank[k], input, output[k]);
	//}
	//return true;

	const int numFreq = (int)filterBank.size();
	if (numFreq == 0)
	{
		output.clear();
		return false;
	}
	const int halfLength = (int)filterBank[0].size() - 1;
	const int M = 2*halfLength;
	const int input_size = (int)input.size();
	const int numTimePoints = input_size - M;
	//______________________________ memory allocation
	try
	{
		if (output.size() != numFreq) output.resize(numFreq);
		for(int i = 0; i < numFreq; i++)
		{
			if (output[i].size() != numTimePoints)
			{
				output[i].resize(numTimePoints);
			}
		}
	}
	catch (std::bad_alloc& )
	{
		return false;
	}
	//___________________________________ apply the filter

	int indexFreq;
	int m ,n;
	double rsum = 0.0;
	double isum = 0.0;
	int index;
	for(m = 0; m < numTimePoints; m++)
	{
		index = halfLength+m;
		for(indexFreq = 0; indexFreq < numFreq; indexFreq++)
		{
			rsum = filterBank[indexFreq][0].real()*input[index];
			isum = filterBank[indexFreq][0].imag()*input[index];

			for(n = 1; n <= halfLength; n++)
			{
				rsum += (filterBank[indexFreq][n].real()    *   (input[index+n]+input[index-n])   );
				isum += (filterBank[indexFreq][n].imag()   *   (input[index+n]-input[index-n])   );
			}
			if (m < 0 || m >= numTimePoints)
			{
				index++;
			}
			if (indexFreq<0 || indexFreq>=numFreq)
			{
				index++;
			}
			output[indexFreq][m].real(rsum);
			output[indexFreq][m].imag(isum);
			//output[indexFreq][m].real(0.0);
			//output[indexFreq][m].imag(0.0);
		}
		
	}

	return true;
}

//_____________________________________________________________________ PidController
PidController::PidController(void)
{
	kp= 0.0;
	ki= 0.0;
	kd= 0.0;
	error= 0.0;
	integral = 0.0;
	prev_error= 0.0;
	targetValue= 0.0;
	minControlValue= 0.0;
	maxControlValue= 0.0;
	controlValue= 0.0;
}

PidController::~PidController(void)
{
}

//returns the initial controlValue
double PidController::Create(double kp, double ki, double kd, double target, double minControlValue, double maxControlValue)
{
	this->kp= kp;
	this->ki=ki;
	this->kd=kd;
	this->targetValue=targetValue;
	this->minControlValue=minControlValue;
	this->maxControlValue=maxControlValue;
	this->controlValue = (maxControlValue+minControlValue)/2.0;
	return this->controlValue;
}

double PidController::GetControlValue(double measuredValue)
{
	prev_error = error;
	error = targetValue-measuredValue;
	double derivative = error - prev_error;
	integral += prev_error; //double integral = (error+prev_error)/2.0;
	controlValue += (kp*error +ki*integral+kd*derivative);
	if (controlValue>maxControlValue) return maxControlValue;
	if (controlValue<minControlValue) return minControlValue;
	return controlValue;
}

double PidController::GetControlValue(double currentOutput, double amortiguamiento)
{
	prev_error = error;
	error = targetValue-currentOutput;
	double derivative = error - prev_error;
	integral += prev_error; //double integral = (error+prev_error)/2.0;
	if (error>0)
	{
		controlValue += (kp*error +ki*integral+kd*derivative)/amortiguamiento;
	}
	else
	{
		controlValue += (kp*error +ki*integral+kd*derivative);
	}
	if (controlValue>maxControlValue) return maxControlValue;
	if (controlValue<minControlValue) return minControlValue;
	return controlValue;
}

//_____________________________________________________________________ FourierTransform
//FourierTransform::FourierTransform()
//{
//	w = NULL;
//	size = 0;
//}
//
//FourierTransform::~FourierTransform()
//{
//}
//
//bool FourierTransform::Create(const int size)
//{
//	Delete();
//	w = new complex<double>*[size];
//	if (w == NULL) return false;
//	int k, n;
//	const double a = -2.0*M_PI/size;
//	double theta;
//	for(k = 0; k < size; k++)
//	{
//		w[k] = new complex<double>[k+1];
//		if (w[k] == NULL)
//		{
//			Delete();
//			return false;
//		}
//		for(n = 0; n <= k; n++)
//		{
//			theta = a*(k*n);
//			w[k][n].real(cos(theta));
//			w[k][n].imag(sin(theta));
//		}
//	}
//	this->size = size;
//	return true;
//}
//
//void FourierTransform::Delete()
//{
//	for(int i = 0; i < size; i++)
//	{
//		if (w[i] != NULL) delete [] w;
//	}
//	if (w != NULL) delete [] w;
//	w = NULL;
//	size = 0;
//}
//
//bool FourierTransform::Fft(const valarray<complex<double>>& input, valarray<complex<double>>& output)
//{
//	const int N = input.size();
//	if (N != size) return false;
//	int k , n;
//	//___________________________ Memory Allocation
//	try
//	{
//		if (output.size() != N) output.resize(N);
//	}
//	catch(std::bad_alloc& )
//	{
//		return false;
//	}
//	complex<double> sum;
//
//	for(k = 0; k < N; k++)
//	{
//		sum = 0.0;
//		for(n = 0; n <= k; n++)
//		{
//			//sum += (input[n]*w[k][n]);
//			sum.real(sum.real() + input[n].real()*w[k][n].real() -input[n].imag()*w[k][n].imag());
//			sum.imag(sum.imag() + input[n].real()*w[k][n].imag() -input[n].imag()*w[k][n].real());
//		}
//		for(n = k+1; n < N; n++)
//		{
//			//sum += (input[n]*w[n][k]);
//			sum.real(sum.real() + input[n].real()*w[n][k].real() -input[n].imag()*w[n][k].imag());
//			sum.imag(sum.imag() + input[n].real()*w[n][k].imag() -input[n].imag()*w[n][k].real());
//		}
//		output[k].real(sum.real());
//		output[k].imag(sum.imag());
//	}
//	return true;
//}

//_____________________________________________________________________ IIR
IIR::IIR(void)
{
	k0 = 1.0;
}

IIR::~IIR(void)
{
}

bool IIR::SetOrder(int order)
{
	const size_t len = polarCoeff.size();
	if (len == order/2) return true;
	try
	{
		polarCoeff.resize(order/2);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	return true;
}

bool IIR::GetZeros(vector<complex<double> >& out_zeros)
{
	//_____________________________________________ Check for empty filter designer
	const size_t len = polarCoeff.size();
	if (len == 0)
	{
		out_zeros.clear();
		return true;
	}
	//_____________________________________________ Memory allocation
	if (out_zeros.size() != 2*len)
	{
		try
		{
			out_zeros.resize(2*len);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	for(size_t i = 0; i < len; i++)
	{
		out_zeros[i].real(polarCoeff[i].zeroR * cos(polarCoeff[i].zeroAngle));
		out_zeros[i].imag(polarCoeff[i].zeroR * sin(polarCoeff[i].zeroAngle));
		//_____________________________________________ Complex Conjugate
		out_zeros[i+len].real(out_zeros[i].real());
		out_zeros[i+len].imag(-out_zeros[i].imag());
	}
	return true;
}

bool IIR::GetPoles(vector<complex<double> >& out_poles)
{
	//_____________________________________________ Check for empty filter designer
	const size_t len = polarCoeff.size();
	if (len == 0)
	{
		out_poles.clear();
		return true;
	}
	//_____________________________________________ Memory allocation
	if (out_poles.size() != 2*len)
	{
		try
		{
			out_poles.resize(2*len);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	for(size_t i = 0; i < len; i++)
	{
		out_poles[i].real(polarCoeff[i].poleR * cos(polarCoeff[i].poleAngle));
		out_poles[i].imag(polarCoeff[i].poleR * sin(polarCoeff[i].poleAngle));
		//_____________________________________________ Complex Conjugate
		out_poles[i+len].real(out_poles[i].real());
		out_poles[i+len].imag(-out_poles[i].imag());
	}
	return true;
}

bool IIR::GetCoeff(vector<Sys::IirCoeff>& out_coeff)
{
	//_____________________________________________ Check for empty filter designer
	const size_t len = polarCoeff.size();
	if (len == 0)
	{
		out_coeff.clear();
		return true;
	}
	//_____________________________________________ Memory allocation
	if (out_coeff.size() != len)
	{
		try
		{
			out_coeff.resize(len);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	for(size_t i = 0; i < len; i++)
	{
		out_coeff[i] = polarCoeff[i];
	}
	return true;
}

bool IIR::SetCoeff(const vector<Sys::IirCoeff>& coeff)
{
	//_____________________________________________ Check for empty input coeff
	const size_t len = coeff.size();
	if (len == 0)
	{
		polarCoeff.clear();
		return true;
	}
	//_____________________________________________ Memory allocation
	if (polarCoeff.size() != len)
	{
		try
		{
			polarCoeff.resize(len);
		}
		catch(std::bad_alloc& )
		{
			return false;
		}
	}
	for(size_t i = 0; i < len; i++)
	{
		polarCoeff[i] = coeff[i];
	}
	return true;
}

//void IIR::SetCoeff(const vector<Sys::IirPolarCoeff>& polarCoeff)
//{
//	this->polarCoeff = polarCoeff;
//}

double IIR::PrivateGetMagnitude(double radFrequency)
{
	const int N = (int)polarCoeff.size();
	double alpha = 1.0;
	double tmp;
	double fap, fan;
	double fbp, fbn;
	for(int i = 0; i < N; i ++)
	{
		tmp = 1.0 + polarCoeff[i].zeroR * polarCoeff[i].zeroR;
		fap = tmp - 2.0*polarCoeff[i].zeroR*cos(radFrequency + polarCoeff[i].zeroAngle);
		fan = tmp - 2.0*polarCoeff[i].zeroR*cos(radFrequency - polarCoeff[i].zeroAngle);
		//
		tmp = 1.0 + polarCoeff[i].poleR * polarCoeff[i].poleR;
		fbp = tmp - 2.0*polarCoeff[i].poleR*cos(radFrequency + polarCoeff[i].poleAngle);
		fbn = tmp - 2.0*polarCoeff[i].poleR*cos(radFrequency - polarCoeff[i].poleAngle);
		//
		alpha *= ((fap*fan) / (fbp*fbn));
	}
	return sqrt(alpha);
}

// Andrew G. Deczky 1972 Eq. 11
double IIR::GetMagnitude(double radFrequency)
{
	return fabs(k0)*PrivateGetMagnitude(radFrequency);
}

double IIR::Estimatek0(const int pointCount)
{
	//const int pointCount = 1024;
	const double delta = M_PI/(pointCount - 1);
	double frequency;
	double maximum = 0.0;
	double magnitude;
	int i;
	for(i = 0; i < pointCount; i++)
	{
		frequency = i*delta;
		magnitude = fabs(PrivateGetMagnitude(frequency));
		if (magnitude > maximum) maximum = magnitude;
	}
	if (maximum == 0.0) return 1.0;
	return 1.0/maximum;
}

// Andrew G. Deczky 1972 Eq. 12
double IIR::GetGroupDelay(double radFrequency)
{
	if (radFrequency == M_PI) radFrequency = 0.9999*M_PI;
	if (radFrequency == -M_PI) radFrequency = -0.9999*M_PI;
	const int N = (int)polarCoeff.size();
	double tao = 0.0;
	for(int i = 0; i < N; i ++)
	{
		tao += ( (1.0 - polarCoeff[i].poleR*cos(radFrequency - polarCoeff[i].poleAngle) ) / (1.0 - 2*polarCoeff[i].poleR*cos(radFrequency - polarCoeff[i].poleAngle) + polarCoeff[i].poleR*polarCoeff[i].poleR) );
		tao += ( (1.0 - polarCoeff[i].poleR*cos(radFrequency + polarCoeff[i].poleAngle) ) / (1.0 - 2*polarCoeff[i].poleR*cos(radFrequency + polarCoeff[i].poleAngle) + polarCoeff[i].poleR*polarCoeff[i].poleR) );
		tao -= ( (1.0 - polarCoeff[i].zeroR*cos(radFrequency - polarCoeff[i].zeroAngle) ) / (1.0 - 2*polarCoeff[i].zeroR*cos(radFrequency - polarCoeff[i].zeroAngle) + polarCoeff[i].zeroR*polarCoeff[i].zeroR) );
		tao -= ( (1.0 - polarCoeff[i].zeroR*cos(radFrequency + polarCoeff[i].zeroAngle) ) / (1.0 - 2*polarCoeff[i].zeroR*cos(radFrequency + polarCoeff[i].zeroAngle) + polarCoeff[i].zeroR*polarCoeff[i].zeroR) );
	}
	return tao;
}

void IIR::BilinearTransformation_LowPass(double A, double B, double C, double& out_a, double& out_b, double& out_c)
{
	// (4*A + 2*B + C) + (-8*A+2*C) z^-1 + (4*A - 2*B + C) z^-2
	out_a = 4.0*A + 2.0*B + C;
	out_b = -8.0*A + 2.0*C;
	out_c = 4.0*A - 2.0*B + C;
}

void IIR::BilinearTransformation_HighPass(double A, double B, double C, double& out_a, double& out_b, double& out_c)
{
	// (4*A + 2*B + C) + (8*A-2*C) z^-1 + (4*A - 2*B + C) z^-2
	out_a = 4.0*A + 2.0*B + C;
	out_b = 8.0*A - 2.0*C;
	out_c = 4.0*A - 2.0*B + C;
}

//void IIR::BilinearTransformation_LowPass(double B, double C, double& out_a, double& out_b)
//{
//	// (2*B + C) + (-2*B + C) z^-1 + (0) z^-2 
//	out_a = 2.0*B + C;
//	out_b = -2.0*B + C;
//}

//_____________________________________________________________________ IIRButterworth
IIRButterworth::IIRButterworth()
{
	type = 0; //Low pass
}

IIRButterworth::~IIRButterworth()
{
}

bool IIRButterworth::CreateLowPass(double cutFrequency_radians, double passBand_dB, double stopFrequency_radians, double stopBand_dB)
{
	type = 0;
	if (cutFrequency_radians >= stopFrequency_radians) return false;
	return Create(cutFrequency_radians, passBand_dB, stopFrequency_radians, stopBand_dB);
}

bool IIRButterworth::CreateHighPass(double cutFrequency_radians, double passBand_dB, double stopFrequency_radians, double stopBand_dB)
{
	type = 1;
	if (cutFrequency_radians <= stopFrequency_radians) return false;
	cutFrequency_radians = M_PI - cutFrequency_radians;
	stopFrequency_radians = M_PI - stopFrequency_radians;
	return Create(cutFrequency_radians, passBand_dB, stopFrequency_radians, stopBand_dB);
}

// Oppenheim Example 7.4 (page 420)
bool IIRButterworth::Create(double cutFrequency_radians, double passBand_dB, double stopFrequency_radians, double stopBand_dB)
{
	const double gainPassBand = pow(10.0, passBand_dB/20.0);
	const double gainStopBand = pow(10.0, stopBand_dB/20.0);
	const double wCut = 2.0*tan(cutFrequency_radians/2.0);
	const double wStop = 2.0*tan(stopFrequency_radians/2.0);
	const double pass = 1.0/(gainPassBand*gainPassBand) - 1.0;
	const double stop = 1.0/(gainStopBand*gainStopBand) - 1.0;
	const double n = log10(stop/pass)/ (2.0*log10(wStop/wCut));
	if (n <= 0) return false;
	const int in = (int)ceil(n);
	const int N = (in %2 == 0) ? in : in +1; // Force even
	//const int N = in;
	const double omegaCut = wStop / pow(stop, 1.0/(2.0*N));
	const double sq_omegaCut = omegaCut*omegaCut;
	const int half = N/2;
	//const bool isOdd = (N%2 != 0);
	vector<Sys::IirCoeff> coeff;
	coeff.resize(half);
	//if (isOdd == true)
	//{
	//	coeff.resize(half+1);
	//}
	//else
	//{
	//	coeff.resize(half);
	//}
	double A, B, C, a, b, c;
	int i;
	const double delta = M_PI/N;
	double poleAngle;
	k0 = 1;
	for(i = 0; i < half; i++)
	{
		//______________ Compute pole
		poleAngle = M_PI/2.0 + i*delta + delta/2.0;
		//______________ Numerator: A*s*s + B*s + C which is  only a constant value
		A = 0.0;
		B = 0.0;
		C = sq_omegaCut;
		if (type == 0)
		{
			BilinearTransformation_LowPass(A, B, C, a, b, c);
		}
		else
		{
			BilinearTransformation_HighPass(A, B, C, a, b, c);
		}
		coeff[i].a = b/a;
		coeff[i].b = c/a;
		k0 *= a;
		//______________ Denominator: A*s*s + B*s + C wich is s*s - 2*s*omegaCut*cos(poleAngle)+omegaCut*omegaCut
		A = 1.0;
		B = -2.0*omegaCut*cos(poleAngle);
		C = sq_omegaCut;
		if (type == 0)
		{
			BilinearTransformation_LowPass(A, B, C, a, b, c);
		}
		else
		{
			BilinearTransformation_HighPass(A, B, C, a, b, c);
		}
		coeff[i].c = b/a;
		coeff[i].d = c/a;
		k0 /= a;
	}
	//if (isOdd == true)
	//{
	//	i = half;
	//	//______________ Compute single pole
	//	poleAngle = M_PI;
	//	//______________ Numerator: B*s + C which is  only a constant value
	//	B = 0.0;
	//	C = omegaCut;
	//	BilinearTransformation_LowPass(B, C, a, b);
	//	coeff[i].a1 = b/a;
	//	coeff[i].a2 = 0.0;
	//	k0 *= a;
	//	//______________ Denominator: B*s + C wich is s + omegaCut
	//	B = 1.0;
	//	C = omegaCut;
	//	BilinearTransformation_LowPass(B, C, a, b);
	//	coeff[i].b1 = b/a;
	//	coeff[i].b2 = 0.0;
	//	k0 /= a;
	//}
	return SetCoeff(coeff);
}

//_____________________________________________________________________ IIRChebyshev
IIRChebyshev::IIRChebyshev()
{
	type = 0; //Low pass
}

IIRChebyshev::~IIRChebyshev()
{
}

bool IIRChebyshev::CreateLowPass(double cutFrequency_radians, double passBandRipples_dB, double stopFrequency_radians, double stopBand_dB)
{
	type = 0;
	if (cutFrequency_radians >= stopFrequency_radians) return false;
	return Create(cutFrequency_radians, passBandRipples_dB, stopFrequency_radians, stopBand_dB);
}

bool IIRChebyshev::CreateHighPass(double cutFrequency_radians, double passBandRipples_dB, double stopFrequency_radians, double stopBand_dB)
{
	type = 1;
	if (cutFrequency_radians <= stopFrequency_radians) return false;
	cutFrequency_radians = M_PI - cutFrequency_radians;
	stopFrequency_radians = M_PI - stopFrequency_radians;
	return Create(cutFrequency_radians, passBandRipples_dB, stopFrequency_radians, stopBand_dB);
}

// Oppenheim  B2 Chebyshev Filters, page 847
bool IIRChebyshev::Create(double cutFrequency_radians, double passBandRipples_dB, double stopFrequency_radians, double stopBand_dB)
{
	if (fabs(passBandRipples_dB) > 3.0) passBandRipples_dB = 3.0;
	const double epsilon = sqrt(pow(10.0, fabs(passBandRipples_dB)/10.0) - 1.0);
	const double gainStopBand = pow(10.0, stopBand_dB/20.0);
	const double wCut = 2.0*tan(cutFrequency_radians/2.0);
	const double wStop = 2.0*tan(stopFrequency_radians/2.0);
	//const double pass = 1.0/(gainPassBand*gainPassBand) - 1.0;
	const double stop = 1.0/(gainStopBand*gainStopBand) - 1.0;
	const double n = acosh(sqrt(stop/(epsilon*epsilon)))/acosh(wStop/wCut);
	if (n <= 0) return false;
	const int in = (int)ceil(n);
	const int N = (in %2 == 0) ? in : in +1; // Force even
	const double omegaCut = wCut*cosh(acosh(1.0/epsilon)/N);
	const double alpha = 1.0/epsilon + sqrt(1.0+1.0/(epsilon*epsilon));
	const double beta = (pow(alpha, 1.0/N) - pow(alpha, -1.0/N))/2.0;
	const double gamma = (pow(alpha, 1.0/N) + pow(alpha, -1.0/N))/2.0;
	const double zero = 0.0;
	const int half = N/2;
	vector<Sys::IirCoeff> coeff;
	coeff.resize(half);
	double A, B, C, a, b, c;
	int i;
	const double delta = M_PI/N;
	double angle;
	double re, im;
	k0 = 1;
	for(i = 0; i < half; i++)
	{
		//______________ Compute pole
		angle = M_PI/2.0 + i*delta + delta/2.0;
		re = beta*omegaCut*cos(angle);
		im = gamma*omegaCut*sin(angle);
		//______________ Numerator: A*s*s + B*s + C which is  only a constant value
		A = 0.0;
		B = 0.0;
		C = re*re + im*im;
		if (type == 0)
		{
			BilinearTransformation_LowPass(A, B, C, a, b, c);
		}
		else
		{
			BilinearTransformation_HighPass(A, B, C, a, b, c);
		}
		coeff[i].a = b/a;
		coeff[i].b = c/a;
		k0 *= a;
		//______________ Denominator: A*s*s + B*s + C
		A = 1.0;
		B = -2.0*re;
		C = re*re + im*im;
		if (type == 0)
		{
			BilinearTransformation_LowPass(A, B, C, a, b, c);
		}
		else
		{
			BilinearTransformation_HighPass(A, B, C, a, b, c);
		}
		coeff[i].c = b/a;
		coeff[i].d = c/a;
		k0 /= a;
	}
	return SetCoeff(coeff);
}

//_____________________________________________________________________ IIRElliptic
IIRElliptic::IIRElliptic()
{
	type = 0; //Low pass
}

IIRElliptic::~IIRElliptic()
{
}

bool IIRElliptic::CreateLowPass(double cutFrequency_radians, double passBandRipples_dB, double stopFrequency_radians, double stopBand_dB)
{
	type = 0;
	if (cutFrequency_radians >= stopFrequency_radians) return false;
	return Create(cutFrequency_radians, passBandRipples_dB, stopFrequency_radians, stopBand_dB);
}

bool IIRElliptic::CreateHighPass(double cutFrequency_radians, double passBandRipples_dB, double stopFrequency_radians, double stopBand_dB)
{
	type = 1;
	if (cutFrequency_radians <= stopFrequency_radians) return false;
	cutFrequency_radians = M_PI - cutFrequency_radians;
	stopFrequency_radians = M_PI - stopFrequency_radians;
	return Create(cutFrequency_radians, passBandRipples_dB, stopFrequency_radians, stopBand_dB);
}

//Digital Filter Designer'S Handbook: Featuring C Routines C. Britton Rorabaugh
bool IIRElliptic::Create(double cutFrequency_radians, double passBandRipples_dB, double stopFrequency_radians, double stopBand_dB)
{
	const double Ap = fabs(passBandRipples_dB); //pow(10.0, fabs(passBandRipples_dB)/20.0);
	const double As = fabs(stopBand_dB); //pow(10.0, stopBand_dB/-20.0);
	const double wp = 2.0*tan(cutFrequency_radians/2.0);
	const double ws = 2.0*tan(stopFrequency_radians/2.0);
	const double k = wp/ws;
	const double kk = sqrt(sqrt(1.0-k*k));
	const double u = (1.0 - kk)/(2.0*(1.0 + kk));  // EQ. (5.2)
	const double u4 = u*u*u*u;
	const double u5 = u4*u;
	const double u9 = u4*u5;
	const double u13 = u4*u9;
	const double q = u + 2.0*u5 + 15.0*u9 + 150.0*u13; // EQ. (5.1)
	const double D = (pow(10.0, As/10.0) -1.0)/(pow(10.0, Ap/10.0) -1.0); // EQ. (5.3)
	const double dn = (log10(16.0*D))/(log10(1.0/q));
	const int in = (int)ceil(dn); // EQ. (5.4)
	const int n = (in %2 == 0) ? in : in +1; // Force even
	const double actual_As = 10.0*log10(1.0 + (pow(10.0, Ap/10.0)-1.0)/(16.0*pow(q, (double)n))); // EQ. (5.5)
	const double alpha = sqrt(wp*ws); // EQ. (5.8)
	const double vv = pow(10.0, Ap/20.0);
	const double V = (1.0/(2.0*n))*log( (vv + 1.0)/(vv - 1.0)  ); // EQ. (5.12)
	//______________________________________________________________ EQ. (5.13)
	double pp;
	int m;
	//____________________ Numerator
	double sum_numerator = 0.0;
	for(m = 0; m < 100; m++)
	{
		pp = pow(q, m*(m+1))*sinh((2*m+1)*V);
		if (m%2 != 0) pp = -pp;
		sum_numerator += pp;
		if ( fabs(pp)/fabs(sum_numerator) < 1.0e-10*fabs(sum_numerator)) break; // done
	}
	//____________________ Denominator
	double sum_denominator = 0.5;
	for(m = 1; m < 100; m++)
	{
		pp = pow(q, m*m)*cosh(2*m*V);
		if (m%2 != 0) pp = -pp;
		sum_denominator += pp;
		if ( fabs(pp)/fabs(sum_denominator) < 1.0e-10*fabs(sum_denominator)) break; // done
	}
	const double p0 = fabs( sqrt(sqrt(q))*sum_numerator/sum_denominator);
	const double W = sqrt( (1.0 + (p0*p0)/k)  *  (1.0 + k*p0*p0)  ); //EQ. (5.14)
	const bool is_n_even = (n%2 == 0);
	const int r = is_n_even ? n/2: (n-1)/2;
	//______________________________________________________________ EQ. (5.15)
	vector<double> X;
	X.resize(r);
	int i;
	double mu;
	for(i = 1; i <= r; i++)
	{
		mu = is_n_even ? (i-0.5) : (double)i;
		//____________________ Numerator
		sum_numerator = 0.0;
		for(m = 0; m < 100; m++)
		{
			pp = pow(q, m*(m+1))*sin((2*m+1)*mu*M_PI/n);
			if (m%2 != 0) pp = -pp;
			sum_numerator += pp;
			if ( fabs(pp)/fabs(sum_numerator) < 1.0e-10*fabs(sum_numerator)) break; // done
		}
		//____________________ Denominator
		sum_denominator = 0.0;
		for(m = 1; m < 100; m++)
		{
			pp = pow(q, m*m)*cos(2.0*m*mu*M_PI/n);
			if (m%2 != 0) pp = -pp;
			sum_denominator += pp;
			if ( fabs(pp)/fabs(sum_denominator) < 1.0e-10*fabs(sum_denominator)) break; // done
		}
		X[i-1] = (2.0*sqrt(sqrt(q))*sum_numerator) / (1.0 + 2.0*sum_denominator);
	}
	//______________________________________________________________ EQ. (5.16)
	vector<double> Y;
	Y.resize(r);
	for(i = 1; i <= r; i++)
	{
		Y[i-1] = sqrt(  (1.0 - (X[i-1]*X[i-1]/k)  )  *  (1.0 - k*X[i-1]*X[i-1]) );
	}
	//______________________________________________________________ EQ. (5.17)
	vector<double> a_;
	a_.resize(r);
	for(i = 1; i <= r; i++)
	{
		a_[i-1] = 1.0/(X[i-1]*X[i-1]);
	}
	//______________________________________________________________ EQ. (5.18)
	vector<double> b_;
	b_.resize(r);
	for(i = 1; i <= r; i++)
	{
		b_[i-1] = 2.0*p0*Y[i-1]/(1.0 + p0*p0*X[i-1]*X[i-1]);
	}
	//______________________________________________________________ EQ. (5.19)
	vector<double> c_;
	c_.resize(r);
	double tmp;
	for(i = 1; i <= r; i++)
	{
		pp = p0*Y[i-1];
		tmp = X[i-1]*W;
		c_[i-1] = pp*pp + tmp*tmp;
		//
		tmp = 1.0 + p0*p0*X[i-1]*X[i-1];
		c_[i-1] /= (tmp*tmp);
	}
	//______________________________________________________________ EQ. (5.20)
	tmp = 1.0;
	for(i = 1; i <= r; i++) tmp *= (c_[i-1]/a_[i-1]);
	const double H0 = (is_n_even == true) ? (pow(10.0, -Ap/20.0)*tmp) : (p0*tmp);
	//______________________________________________________________ EQ. (5.22)
	k0 = H0; //(is_n_even == true) ? H0 : ( (H0*alpha)/(s + alpha*p0));
	for(i = 0; i < r; i++)
	{
		a_[i] = alpha*alpha*a_[i];
		b_[i] = alpha*b_[i];
		c_[i] = alpha*alpha*c_[i];
	}
	//______________________________________________________________ Bilinear
	const int N = n;
	const int half = N/2;
	vector<Sys::IirCoeff> coeff;
	coeff.resize(half);
	double A, B, C, a, b, c;
	const double delta = M_PI/N;
	for(i = 0; i < half; i++)
	{
		//______________ Numerator: A*s*s + B*s + C which is  only a constant value
		A = 1.0;
		B = 0.0;
		C = a_[i];
		if (type == 0)
		{
			BilinearTransformation_LowPass(A, B, C, a, b, c);
		}
		else
		{
			BilinearTransformation_HighPass(A, B, C, a, b, c);
		}
		coeff[i].a = b/a;
		coeff[i].b = c/a;
		k0 *= a;
		//______________ Denominator: A*s*s + B*s + C
		A = 1.0;
		B = b_[i];
		C = c_[i];
		if (type == 0)
		{
			BilinearTransformation_LowPass(A, B, C, a, b, c);
		}
		else
		{
			BilinearTransformation_HighPass(A, B, C, a, b, c);
		}
		coeff[i].c = b/a;
		coeff[i].d = c/a;
		k0 /= a;
	}
	return SetCoeff(coeff);
}

//_____________________________________________________________________ IIRFilterDesigner
IIRFilterDesigner::IIRFilterDesigner()
{
}

IIRFilterDesigner::~IIRFilterDesigner()
{
}

//____________________________________________________________ IGenetic
void IIRFilterDesigner::GeneticInitialize(Sys::BoolArray& bits)
{
	const int bitCount = bits.GetCount();
	if (bitCount <= 0) return;
	const int count = bitCount / IIR_BITS_PER_VARIABLE; 
	std::tr1::uniform_int<__int16> dis(-IIR_VARIABLE_RES, IIR_VARIABLE_RES);
	int i;
	__int16 value;
	//
	for(i = 0; i < count; i++)
	{
		value = dis(Math::Statistics::random_generator);
		bits.SetInt16(i, value);
	}
}

double IIRFilterDesigner::GeneticGetError()
{
	return ComputeError();
}

void IIRFilterDesigner::GeneticSetFromBits(const Sys::BoolArray& bits)
{
	const int bitCount = bits.GetCount();
	if (bitCount <= 0) return;
	const double twopi = 2.0*M_PI;
	const int count = ((bitCount / IIR_BITS_PER_VARIABLE) -1)/4; // We do not count k0, and each coeff has four variables
	if (polarCoeff.size() != count) polarCoeff.resize(count);
	int i = 0;
	int j = 0;
	for (i = 0; i < count; i++)
	{
		polarCoeff[i].zeroR = (bits.GetInt16(j++) + IIR_VARIABLE_RES)/(2.0*IIR_VARIABLE_RES);
		polarCoeff[i].zeroAngle = (M_PI*bits.GetInt16(j++))/IIR_VARIABLE_RES;
		polarCoeff[i].poleR = IIR_MAX_R *(bits.GetInt16(j++) + IIR_VARIABLE_RES)/(2.0*IIR_VARIABLE_RES);
		polarCoeff[i].poleAngle = (M_PI *bits.GetInt16(j++))/IIR_VARIABLE_RES;
		//___________________________________________________ Clip values
		if (polarCoeff[i].zeroR < 0.0) polarCoeff[i].zeroR = 0.0;
		if (polarCoeff[i].zeroR > 1.0) polarCoeff[i].zeroR = 1.0;
		//
		if (polarCoeff[i].zeroAngle < -M_PI) polarCoeff[i].zeroAngle += twopi;
		if (polarCoeff[i].zeroAngle > M_PI) polarCoeff[i].zeroAngle -= twopi;
		//
		if (polarCoeff[i].poleR < 0.0) polarCoeff[i].poleR = 0.0;
		if (polarCoeff[i].poleR > IIR_MAX_R) polarCoeff[i].poleR = IIR_MAX_R;
		//
		if (polarCoeff[i].poleAngle < -M_PI) polarCoeff[i].poleAngle += twopi;
		if (polarCoeff[i].poleAngle > M_PI) polarCoeff[i].poleAngle -= twopi;
	}
	k0 = IIR_MAX_K0 *(bits.GetInt16(j++) + IIR_VARIABLE_RES)/(2.0*IIR_VARIABLE_RES);
}

void IIRFilterDesigner::SimAnnealInitialize()
{
	const size_t count = polarCoeff.size();
	if (count <= 0) return;
	std::tr1::uniform_real<double> disR(0.1, IIR_MAX_R);
	//std::tr1::uniform_real<double> distK(0.0, IIR_MAX_K0);
	std::tr1::uniform_real<double> disAngle(0, M_PI);

	size_t i;
	for(i = 0; i < count; i++)
	{
		polarCoeff[i].zeroR = disR(Math::Statistics::random_generator);
		polarCoeff[i].zeroAngle = disAngle(Math::Statistics::random_generator);
		//
		polarCoeff[i].poleR = disR(Math::Statistics::random_generator);
		polarCoeff[i].poleAngle= disAngle(Math::Statistics::random_generator);
	}
	k0 = this->Estimatek0(32);
	//k0  = distK(Math::Statistics::random_generator);
}

void IIRFilterDesigner::SimAnnealPerturb(Math::ISimAnneal& original, double temperature, double initialTemperature)
{
	const size_t count = polarCoeff.size();
	if (count <= 0) return;
	const double perturbRatio = temperature/initialTemperature;
	const double originalRatio = 1.0 - perturbRatio;
	Math::IIRFilterDesigner& source = (Math::IIRFilterDesigner&)original;
	std::tr1::uniform_real<double> dist_simm(-1.0, 1.0);
	std::tr1::uniform_real<double> dist_pos(-1.0, 1.0);
	
	size_t i;
	//___________________________________________________________________________ k0
	//k0 = originalRatio * source.k0 + perturbRatio * dist_simm(Math::Statistics::random_generator);
	//if (k0 < 0) k0 = 1.0e-10;
	//if (k0 > IIR_MAX_K0) k0  = IIR_MAX_K0;
	double x, y;
	//
	for(i = 0; i < count; i++)
	{
		//________________________________________________________________________ zero
		x =  source.polarCoeff[i].zeroR*cos(source.polarCoeff[i].zeroAngle)+ perturbRatio *dist_simm(Math::Statistics::random_generator);
		y =  source.polarCoeff[i].zeroR*sin(source.polarCoeff[i].zeroAngle)+ perturbRatio *dist_pos(Math::Statistics::random_generator);
		if (y < 0) y = 0;
		//
		polarCoeff[i].zeroR = sqrt(x*x+y*y);
		if (polarCoeff[i].zeroR > 1.0) polarCoeff[i].zeroR = 1.0;
		polarCoeff[i].zeroAngle = atan2(y, x);
		//________________________________________________________________________ pole
		x =  source.polarCoeff[i].poleR*cos(source.polarCoeff[i].poleAngle)+ perturbRatio *dist_simm(Math::Statistics::random_generator);
		y =  source.polarCoeff[i].poleR*sin(source.polarCoeff[i].poleAngle)+ perturbRatio *dist_pos(Math::Statistics::random_generator);
		if (y < 0) y = 0;
		//
		polarCoeff[i].poleR = sqrt(x*x+y*y);
		if (polarCoeff[i].poleR > 0.999) polarCoeff[i].poleR = 0.999;
		polarCoeff[i].poleAngle = atan2(y, x);
	}
	k0 = this->Estimatek0(32);
	//const size_t count = _coeff.size();
	//if (count <= 0) return;
	//const double twopi = 2.0*M_PI;
	//const double perturbRatio = temperature/initialTemperature;
	//const double originalRatio = 1.0 - perturbRatio;
	//Math::IIRFilterDesigner& source = (Math::IIRFilterDesigner&)original;
	//std::tr1::uniform_real<double> dist(0.0, 1.0);
	//std::tr1::uniform_real<double> simm(-1.0, 1.0);
	//
	//size_t i;
	////___________________________________________________________________________ k0
	//k0 = originalRatio * source.k0 + perturbRatio * dist(Math::Statistics::random_generator);
	//if (k0 < 0) k0 = 1.0e-10;
	//if (k0 > IIR_MAX_K0) k0  = IIR_MAX_K0;
	////
	//for(i = 0; i < count; i++)
	//{
	//	//________________________________________________________________________ zeroR
	//	_coeff[i].zeroR = originalRatio * source._coeff[i].zeroR + perturbRatio *dist(Math::Statistics::random_generator);
	//	if (_coeff[i].zeroR < 0) _coeff[i].zeroR = 1.0e-10;
	//	if (_coeff[i].zeroR > 1.0) _coeff[i].zeroR = 1.0;
	//	//________________________________________________________________________ zeroAngle
	//	_coeff[i].zeroAngle = originalRatio * source._coeff[i].zeroAngle + perturbRatio * M_PI*simm(Math::Statistics::random_generator);
	//	if (_coeff[i].zeroAngle < -M_PI) _coeff[i].zeroAngle = - M_PI;
	//	if (_coeff[i].zeroAngle >= M_PI) _coeff[i].zeroAngle = M_PI - 1.0e-10;
	//	//________________________________________________________________________ poleR
	//	_coeff[i].poleR = originalRatio * source._coeff[i].poleR + perturbRatio * IIR_MAX_R*dist(Math::Statistics::random_generator);
	//	if (_coeff[i].poleR < 0) _coeff[i].poleR = 1.0e-10;
	//	if (_coeff[i].poleR > IIR_MAX_R) _coeff[i].poleR = IIR_MAX_R;
	//	//________________________________________________________________________ poleAngle
	//	_coeff[i].poleAngle = originalRatio * source._coeff[i].poleAngle + perturbRatio * M_PI*simm(Math::Statistics::random_generator);
	//	if (_coeff[i].poleAngle < -M_PI) _coeff[i].poleAngle = -M_PI;
	//	if (_coeff[i].poleAngle  >= M_PI) _coeff[i].poleAngle = M_PI - 1.0e-10;
	//}	
}

double IIRFilterDesigner::SimAnnealGetError()
{
	return ComputeError();
}

void IIRFilterDesigner::SimAnnealCopy(const Math::ISimAnneal& source)
{
	Math::IIRFilterDesigner& init = (Math::IIRFilterDesigner&)source;
	k0 = init.k0;
	const size_t count = init.polarCoeff.size();
	//_______________________________________ Memory allocation
	if (polarCoeff.size() != count)
	{
		try
		{
			polarCoeff.resize(count);
		}
		catch(bad_alloc& )
		{
			return;
		}
	}
	//______________________________________ Copy
	for (size_t i = 0; i < count; i ++)
	{
		polarCoeff[i] = init.polarCoeff[i];
	}
}

void IIRFilterDesigner::CopyThisToPoint(valarray<double>& point) const
{
	const int pointCount = (int)point.size();
	const int coeffCount = (int)polarCoeff.size();
	//________________________________________________________ Check for memory allocation
	if (4*coeffCount+1 != pointCount) // k0 is at the end of point
	{
		try
		{
			point.resize(4*coeffCount+1);
		}
		catch(std::bad_alloc& )
		{
			return;
		}
	}
	//_______________________________________________________ Copy
	int i = 0;
	int j = 0;
	for(i = 0; i < coeffCount; i++)
	{
		point[j++] = polarCoeff[i].zeroR;
		point[j++] = polarCoeff[i].zeroAngle;
		point[j++] = polarCoeff[i].poleR;
		point[j++] = polarCoeff[i].poleAngle;
	}
	point[j] = k0; // k0 is at the end of point
}

void IIRFilterDesigner::CopyPointToThis(const valarray<double>& point)
{
	const size_t pointCount = point.size();
	const size_t coeffCount = polarCoeff.size();
	//________________________________________________________ Check for memory allocation
	if (4*coeffCount+1 != pointCount) // k0 is at the end of point
	{
		try
		{
			polarCoeff.resize((pointCount-1)/4);
		}
		catch(std::bad_alloc& )
		{
			return;
		}
	}
	//_______________________________________________________ Copy
	size_t i = 0;
	size_t j = 0;
	for(i = 0; i < coeffCount; i++)
	{
		polarCoeff[i].zeroR = point[j++];
		polarCoeff[i].zeroAngle = point[j++];
		polarCoeff[i].poleR = point[j++];
		polarCoeff[i].poleAngle = point[j++];
	}
	k0 = point[j]; // k0 is at the end of point
}

double IIRFilterDesigner::ComputeError()
{
	const int K = (int)desiredFrequencyResponse.size();
	const double p = 1.0;
	int i;
	
	double phi;
	//___________________________________________________ Compute alpha and tao
	for(i = 0; i < K; i++) //Deczky Eq. 17 and 18
	{
		phi = desiredFrequencyResponse[i].radFrequency;
		desiredFrequencyResponse[i].alpha = GetMagnitude(phi);
		//desiredFrequencyResponse[i].tao = GetGroupDelay(phi);
	}
	//___________________________________________________ Computer errors
	double sumMagSq = 0.0;
	double sumTaoSq = 0.0;
	double sumTao = 0.0;
	double tmp;
	//int countVar = 0;
	for(i = 0; i < K; i++)
	{
		if (desiredFrequencyResponse[i].w == 0.0) continue;
		tmp = desiredFrequencyResponse[i].alpha - desiredFrequencyResponse[i].magnitude;
		if (desiredFrequencyResponse[i].magnitude == 1.0)
		{
			if (fabs(tmp) < 0.1) continue;
		}
		//else if (desiredFrequencyResponse[i].magnitude == 0.0)
		//{
		//	if (fabs(tmp) < 0.0001) continue;
		//}
		sumMagSq += (desiredFrequencyResponse[i].w * tmp * tmp);
		//
		//tmp = desiredFrequencyResponse[i].w * desiredFrequencyResponse[i].magnitude * desiredFrequencyResponse[i].tao;
		////if (tmp != 0.0)
		////{
		////	countVar++;
		////}
		//sumTaoSq += (tmp * tmp);
		//sumTao += tmp;
	}
	//if (countVar <= 1) countVar = 2;
	//return (p*sumMagSq)/K + (1.0 - p)*( sumTaoSq/(countVar-1) - sumTao/ (countVar*(countVar-1)) ) ;
	//return (p*sumMagSq/K) + (1.0 - p)*( sumTaoSq/(K-1) - sumTao/ (K*(K-1)) ) ;
	return sumMagSq/K;
}

double IIRFilterDesigner::EvaluateFunc(const valarray<double>& x)
{
	CopyPointToThis(x);
	return ComputeError();
}

void IIRFilterDesigner::EvaluateFuncAndGrad(const valarray<double>& x, double& Fx, valarray<double>& gradient)
{
	const int gradient_size = (int)gradient.size();
	//_____________________________________________________ Compute Fx
	CopyPointToThis(x);
	Fx = ComputeError(); // It computes alpha and tao
	//_____________________________________________________ Compute gradient
	double partialAlpha_ZeroR, partialAlpha_ZeroAngle;
	double partialAlpha_PoleR, partialAlpha_PoleAngle;
	double partialTao_ZeroR, partialTao_ZeroAngle;
	double partialTao_PoleR, partialTao_PoleAngle;
	const int N = (int)polarCoeff.size();
	const int K = (int)desiredFrequencyResponse.size();
	double alpha, phi, tao;
	int i, k;
	//_____________________ These variables are used to reduced the number of operations and improve performance
	double cosplusp;
	double cosminusp;
	double cosplusz;
	double cosminusz;
	double rrp;
	double rrz;
	double denplusp;
	double denminusp;
	double denplusz;
	double denminusz;


	for(i = 0; i < N; i++)
	{	
		for(k = 0; k < K; k++) //Deczky Eq. 17 and 18
		{
			phi = desiredFrequencyResponse[k].radFrequency;
			alpha = desiredFrequencyResponse[k].alpha;
			tao = desiredFrequencyResponse[k].tao;
			//______________________________________________________ Compute performance variables
			cosplusp = cos(phi + polarCoeff[i].poleAngle);
			cosminusp = cos(phi - polarCoeff[i].poleAngle);
			cosplusz = cos(phi + polarCoeff[i].zeroAngle);
			cosminusz = cos(phi - polarCoeff[i].zeroAngle);
			rrp = (polarCoeff[i].poleR) * (polarCoeff[i].poleR);
			rrz = (polarCoeff[i].zeroR) * (polarCoeff[i].zeroR);
			denplusp = 1.0 - 2.0*polarCoeff[i].poleR*cosplusp+rrp;
			denminusp = 1.0 - 2.0*polarCoeff[i].poleR*cosminusp+rrp;
			denplusz = 1.0 - 2.0*polarCoeff[i].zeroR*cosplusz+rrz;
			denminusz = 1.0 - 2.0*polarCoeff[i].zeroR*cosminusz+rrz;
			//______________________________________________________ partialAlpha_ZeroR: Dekzik 1972 Eq. 13
			partialAlpha_ZeroR = alpha*( (polarCoeff[i].zeroR - cosminusz)/denminusz + (polarCoeff[i].zeroR - cosplusz)/denplusz  );
			//______________________________________________________ partialAlpha_PoleR: Replacing the zero with the pole.  Replacing alpha with -alpha
			partialAlpha_PoleR = -alpha*( (polarCoeff[i].poleR - cosminusp)/denminusp + (polarCoeff[i].poleR - cosplusp)/denplusp  );
			//______________________________________________________ partialAlpha_ZeroAngle: //Dekzik 1972 Eq. 14
			partialAlpha_ZeroAngle = alpha*( (polarCoeff[i].zeroR * sin(phi -polarCoeff[i].zeroAngle))/denminusz - (polarCoeff[i].zeroR * sin(phi +polarCoeff[i].zeroAngle))/denplusz  );
			//______________________________________________________ partialAlpha_PoleAngle: replacing the zero with the pole.  Replacing alpha with -alpha
			partialAlpha_PoleAngle = -alpha*( (polarCoeff[i].poleR * sin(phi -polarCoeff[i].poleAngle))/denminusp - (polarCoeff[i].poleR * sin(phi +polarCoeff[i].poleAngle))/denplusp  );
			//______________________________________________________  partialTao_PoleR: Dekzik 1972 Eq. 15
			partialTao_PoleR = (1.0 + rrp)*(  (cosminusp - 2.0*polarCoeff[i].poleR)/(denminusp*denminusp) + (cosplusp - 2.0*polarCoeff[i].poleR)/(denplusp*denplusp) );
			//______________________________________________________  partialTao_ZeroR: replacing the pole with the zero.  With a minus sign at the begining of the equation
			partialTao_ZeroR = -(1.0 + rrz)*(  (cosminusz - 2.0*polarCoeff[i].zeroR)/(denminusz*denminusz) + (cosplusz - 2.0*polarCoeff[i].zeroR)/(denplusz*denplusz) );
			//______________________________________________________  partialTao_PoleAngle: Dekzik 1972 Eq. 16
			partialTao_PoleAngle = polarCoeff[i].poleR * (1.0 - rrp)*(   (sin(phi - polarCoeff[i].poleAngle))/(denminusp*denminusp) - (sin(phi + polarCoeff[i].poleAngle))/(denplusp*denplusp) );
			//______________________________________________________  partialTao_ZeroAngle: replacing the pole with the zero.  With a minus sign at the begining of the equation
			partialTao_ZeroAngle = polarCoeff[i].zeroR * (1.0 - rrz)*(   (sin(phi - polarCoeff[i].zeroAngle))/(denminusz*denminusz) - (sin(phi + polarCoeff[i].zeroAngle))/(denplusz*denplusz) );
		}
	}
}

void IIRFilterDesigner::OptimizeGenetic(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::GeneticParam& param)
{
	Math::GeneticAlgorithm ga;
	ga.initPopulationSize = param.initPopulationSize;
	ga.numGenerations = param.numGenerations;
	ga.overPopulation = param.overPopulation;
	ga.mutationProbability = param.mutationProbability;
	ga.crossoverProbability = param.crossoverProbability;
	ga.goal = param.goal;
	//
	ga.stopWhenDone = true;
	//
	const int count = (int)polarCoeff.size();
	const int individualSize = (4*count +1 )*IIR_BITS_PER_VARIABLE;
	ga.Setup(mse, individualSize, *this);
	//_____________________________Copy Best individual
	//int i, k = 0;
	//for(i = 0; i<count; i++)
	//{
	//	ga.bestIndividual.bits.SetInt16(k++, IIR_VARIABLE_RES); //(int)(2.0*IIR_VARIABLE_RES*_coeff[i].zeroR/IIR_MAX_R));
	//	ga.bestIndividual.bits.SetInt16(k++, IIR_VARIABLE_RES);
	//	ga.bestIndividual.bits.SetInt16(k++, IIR_VARIABLE_RES);
	//	ga.bestIndividual.bits.SetInt16(k++, IIR_VARIABLE_RES);
	//}
	Mt::BoolTs resetTime;
	//____________________________ 
	ga.ThreadFunc(running, progress, resetTime);
	mse.Set(ComputeError());
}

void IIRFilterDesigner::OptimizeSimAnneal(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::SimAnnealParam& param)
{
	Mt::BoolTs resetTime;

	Math::SimulatedAnnealing sa;
	sa.numTemps = param.numTemps;
	sa.numIterations = param.numIterations;
	sa.initialTemp = param.initialTemp;
	sa.finalTemp = param.finalTemp;
	sa.isCoolingScheduleLinear = param.isCoolingScheduleLinear;
	sa.cycles = param.cycles;
	sa.goal = param.goal;

	Math::IIRFilterDesigner work1, work2;
	work1 = *this;
	work2 = *this;
	//
	sa.stopWhenDone = false;
	sa.Setup(mse, *this, work1, work2);
	sa.ThreadFunc(running, progress, resetTime);
}

void IIRFilterDesigner::OptimizeConjugateGradient(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return OptimizeCGVM(running, progress, mse, epochs, goal, WT_MATH_CONJGRAD);
}

void IIRFilterDesigner::OptimizeVariableMetric(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return OptimizeCGVM(running, progress, mse, epochs, goal, WT_MATH_VARMETRIC);
}

void IIRFilterDesigner::OptimizeCGVM(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal, int method)
{
	Mt::BoolTs resetTime;
	const int variableCount = (int)polarCoeff.size() + 1; // k0 is at the end
	valarray<double> x(variableCount);
	this->CopyThisToPoint(x);

	Math::FindMinimumMV fmmv;
	fmmv.Setup(mse, *this, x, epochs, goal, method);
	fmmv.stopWhenDone = true;
	fmmv.ThreadFunc(running, progress, resetTime);
	mse.Set(ComputeError());
}

void IIRFilterDesigner::OptimizePowell(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs)
{
	Mt::BoolTs resetTime;
	const int variableCount = (int)(4*polarCoeff.size() + 1); // k0 is at the end
	valarray<double> x(variableCount);
	this->CopyThisToPoint(x);

	Math::PowellFindMinMV fmmv;
	fmmv.Setup(mse, *this, x, epochs);
	fmmv.stopWhenDone = true;
	fmmv.ThreadFunc(running, progress, resetTime);
	mse.Set(ComputeError());
}

//_____________________________________________________________________ BiquadraticIIR
IIRBiquadratic::IIRBiquadratic(void)
{
	a1 = 1.0;
	a2 = 1.0;
	b0 = 1.0;
	b1 = 1.0;
	b2 = 1.0;
	Reset();
}

IIRBiquadratic::~IIRBiquadratic(void)
{
}

void IIRBiquadratic::Reset()
{
	w0 = 0.0;
	w1 = 0.0;
	w2 = 0.0;
	n = 0;
}

double IIRBiquadratic::GenerateOutput(double input)
{
	if (n == 0)
	{
		w2 = a2*w0 + a1*w1 + input;
		n = 1;
		return b2*w0 + b1*w1+ b0*w2;
	}
	else if (n == 1)
	{
		w0 = a2*w1 + a1*w2 + input;
		n = 2;
		return b2*w1 + b1*w2+ b0*w0;
	}
	//____________________________  (n == 2)
	w1 = a2*w2 + a1*w0 + input;
	n = 0;
	return b2*w2 + b1*w0 + b0*w1;
}

double IIRBiquadratic::GenerateOutputB(double input)
{
	if (n == 0)
	{
		w2 = a2*w0 + a1*w1 + input;
		n = 1;
		return b2*w0 + b1*w1 + w2;
	}
	else if (n == 1)
	{
		w0 = a2*w1 + a1*w2 + input;
		n = 2;
		return b2*w1 + b1*w2 + w0;
	}
	//____________________________  (n == 2)
	w1 = a2*w2 + a1*w0 + input;
	n = 0;
	return b2*w2 + b1*w0 + w1;
}


//_____________________________________________________________________ IIRFilter
IIRFilter::IIRFilter(void)
{
	currentIndex = 0;
	order = 0;
}

IIRFilter::~IIRFilter(void)
{
}

// Both vectors must be same size
bool IIRFilter::Create(valarray<double>& numerator, valarray<double>& denominator)
{
	const int nNumerator = (int)numerator.size();
	const int nDenominator = (int)denominator.size();
	if (nNumerator!=nDenominator) return false;
	if (nNumerator<=1) return false;
	this->numerator = numerator;
	this->denominator = denominator;
	this->order = nNumerator-1;
	this->currentIndex = 0;
	this->vectDelay.resize(nNumerator);
	if (this->denominator[0]!=1)
	{
		double a= this->denominator[0];
		for(int i=0; i<nNumerator; i++)
		{
			this->numerator[i]=this->numerator[i]/a;
			this->denominator[i]=this->denominator[i]/a;
		}
	}
	return true;
}

double IIRFilter::GenerateOutput(double input)
{
	int index = 0, i;
	double y = input;

	// Apply denominator
	index = GoNext(currentIndex);
	for(i=0; i<order; i++)
	{
		if (denominator[i+1] != 0.0) y-=(vectDelay[index]*denominator[i+1]);
		index=GoNext(index);
	}
	vectDelay[currentIndex]=y;
	//m_vectDelay.Display_(NULL);

	// Apply numerator
	y=0;
	index = currentIndex;
	for(i=0; i<=order; i++)
	{
		if (numerator[i] != 0.0) y+=(numerator[i]*vectDelay[index]);
		index = GoNext(index);
	}
	currentIndex = GoPrevious(currentIndex);

	return y;
}

int IIRFilter::GoNext(int n)
{
	n++;
	return (n>order) ? 0 : n;
}

int IIRFilter::GoPrevious(int n)
{
	n--;
	return (n<0) ? order: n;
}

////
//// Example C code for 2nd order IIR filter
////
//// RGH 2012  richard.hayes@dit.ie
// 
//#include <p18f4620.h>
// 
//void main(void)
//{
//int yint;    // temp variable for 16 bit multiply result
//char b0=127, b1=0, b2=-128, a1=-111, a2=82;
//char x=50, x1=0, x2=0, y=0, y1=0, y2=0;
// 
//int bit_shift = 7;
//int dc_shift = 128;
// 
//int voltage;
//char datain[13]={128+50,128,128,128,128,128,128,128,128,128,128,128,128};
//char dataout[13];
// 
//int i=0;
// 
//// Operating Loop
////x=50;
////i=0;
//while (i<12)
//{
//x=datain[i]-dc_shift;    // Remove DC level from a/d i/p
////Implement the filter and crudely update the 'past' input and output x and y values
//yint = (int)b0*x+(int)b1*x1+(int)b2*x2-(int)a1*y1-(int)a2*y2;
//y=(char)(yint>>bit_shift);  //  8- bit result from filter. Note type casting
//y2 = y1;
//y1 = y;
//x2 = x1;
//x1 = x;
//dataout[i]=y;    // Save output; this will be output to D/A
//x=0;
//i=i+1;
// 
//}
//}

//_____________________________________________________________________ FIRFilter
FIRFilter::FIRFilter(void)
{
	currentIndex = 0;
	order = 0;
}

FIRFilter::~FIRFilter(void)
{
}

bool FIRFilter::Create(valarray<double>& impulseResponse)
{
	const int nNumerator = (int)impulseResponse.size();
	if (nNumerator<=1) return false;
	this->impulseResponse = impulseResponse;
	this->order = nNumerator-1;
	this->currentIndex = 0;
	this->taps.resize(nNumerator);
	for(int i = 0; i<nNumerator; i++) taps[i] = 0.0;
	return true;
}

void FIRFilter::ClearTaps()
{
	this->currentIndex = 0;
	const int len = (int)taps.size();
	for(int i = 0; i<len; i++) taps[i] = 0.0;
}

double FIRFilter::GenerateOutput(double input)
{
	taps[currentIndex] = input;
	double y = 0.0;
	int index = currentIndex;
	for(int i=0; i<=order; i++)
	{
		if (impulseResponse[i] != 0.0) y += (impulseResponse[i]*taps[index]);
		//____________________________GoNext
		index++;
		if (index > order) index = 0;
	}
	//______________________________GoPrevious
	currentIndex--;
	if (currentIndex < 0) currentIndex = order;
	return y;
}

//_____________________________________________________________________ FIRFilter16
FIRFilter16::FIRFilter16(void)
{
	currentIndex = 0;
	order = 0;
}

FIRFilter16::~FIRFilter16(void)
{
}

bool FIRFilter16::Create(valarray<double>& impulseResponse)
{
	const double scale = pow(2.0, 15);
	const int nNumerator = (int)impulseResponse.size();
	if (nNumerator<=1) return false;
	this->impulseResponse.resize(nNumerator);
	for(int i = 0; i<nNumerator; i++)
	{
		this->impulseResponse[i] = (int)(impulseResponse[i]*scale);//+0.5) Do not round up
	}
	this->order = nNumerator-1;
	this->currentIndex = 0;
	this->taps.resize(nNumerator);
	for(int i = 0; i<nNumerator; i++) taps[i] = 0;
	return true;
}

void FIRFilter16::ClearTaps()
{
	this->currentIndex = 0;
	const int len = (int)taps.size();
	for(int i = 0; i<len; i++) taps[i] = 0;
}

__int16 FIRFilter16::GenerateOutput(__int16 input)
{
	taps[currentIndex] = input;
	int sum = 1 << 14;
	int product;
	int index = currentIndex;
	for(int i=0; i<=order; i++)
	{
		if (impulseResponse[i] != 0)
		{
			product = impulseResponse[i]*taps[index];
			//_____________________ saturate the result
			if (product > 0x3fffffff) 
			{
				product = 0x3fffffff;
			} 
			else if (product < -0x40000000) 
			{
				product = -0x40000000;
			}
			sum += product;
		}
		//____________________________GoNext
		index++;
		if (index > order) index = 0;
	}
	//______________________________GoPrevious
	currentIndex--;
	if (currentIndex < 0) currentIndex = order;
	sum = sum>>15;
	return (__int16)sum;
}


// This function is for: Type I FIR and Type II FIR.  It will reduce the number of multiplications
__int16 FIRFilter16::GenerateOutputSymmetric(__int16 input)
{
	taps[currentIndex] = input;
	int sum = 1 << 14;
	int product;
	int index1 = currentIndex;
	//
	int index2 = index1-1;
	if (index2 < 0) index2 = order;
	//
	int tmp;
	//
	const int half = order/2;
	for(int i=0; i<half; i++)
	{
		if (impulseResponse[i] != 0)
		{
			tmp = taps[index1]+taps[index2];
			product = impulseResponse[i]*tmp;
			//_____________________ saturate the result
			if (product > 0x3fffffff) 
			{
				product = 0x3fffffff;
			} 
			else if (product < -0x40000000) 
			{
				product = -0x40000000;
			}
			sum += product;
		}
		//____________________________GoNext
		index1++;
		if (index1 > order) index1 = 0;
		//
		index2--;
		if (index2 < 0) index2 = order;
	}
	//______________________________________________ Process Middle Point
	if (impulseResponse[half] != 0)
	{
		if (order%2 == 0) //_____________________Type I
		{
			product = impulseResponse[half]*taps[index1];
		}
		else//_________________________________Type II
		{
			tmp = taps[index1]+taps[index2];
			product = impulseResponse[half]*tmp;
		}
		//_____________________ saturate the result
		if (product > 0x3fffffff) 
		{
			product = 0x3fffffff;
		} 
		else if (product < -0x40000000) 
		{
			product = -0x40000000;
		}
		sum += product;
	}
	//______________________________GoPrevious
	currentIndex--;
	if (currentIndex < 0) currentIndex = order;
	sum = sum>>15;
	return (__int16)sum;
}

// This function is for: Type III FIR and Type IV FIR.  It will reduce the number of multiplications
__int16 FIRFilter16::GenerateOutputAntisymmetric(__int16 input)
{
	taps[currentIndex] = input;
	int sum = 1 << 14;
	int product;
	int index1 = currentIndex;
	//
	int index2 = index1-1;
	if (index2 < 0) index2 = order;
	//
	int tmp;
	//
	const int half = order/2;
	for(int i=0; i<half; i++)
	{
		if (impulseResponse[i] != 0)
		{
			tmp = taps[index2] - taps[index1];
			product = impulseResponse[i]*tmp;
			//_____________________ saturate the result
			if (product > 0x3fffffff) 
			{
				product = 0x3fffffff;
			} 
			else if (product < -0x40000000) 
			{
				product = -0x40000000;
			}
			sum += product;
		}
		//____________________________GoNext
		index1++;
		if (index1 > order) index1 = 0;
		//
		index2--;
		if (index2 < 0) index2 = order;
	}
	//______________________________________________ Process Middle Point
	if (impulseResponse[half] != 0)
	{
		if (order%2 == 0) //_____________________Type III
		{
			product = impulseResponse[half]*taps[index1];
		}
		else//_________________________________Type IV
		{
			tmp = taps[index2]-taps[index1];
			product = impulseResponse[half]*tmp;
		}
		//_____________________ saturate the result
		if (product > 0x3fffffff) 
		{
			product = 0x3fffffff;
		} 
		else if (product < -0x40000000) 
		{
			product = -0x40000000;
		}
		sum += product;
	}
	//______________________________GoPrevious
	currentIndex--;
	if (currentIndex < 0) currentIndex = order;
	sum = sum>>15;
	return (__int16)sum;
}

//_____________________________________________________________________Function

//_____________________________________________________________________ NumericDerivative
NumericDerivative::NumericDerivative(void)
{
}

 NumericDerivative::~NumericDerivative(void)
 {
 }

void  NumericDerivative::FirstDerivative(double deltaX, const valarray<double>& in_y, valarray<double>& out_dy)
{
	const int len = (int)in_y.size();
	if (len == 0)//____________________________________ 0
	{
		out_dy.resize(0);
		return;
	}
	out_dy.resize(len);
	if (len == 1) //____________________________________ 1
	{
		out_dy[0] = 0.0;
		return;
	}
	if (len == 2)//____________________________________ 2
	{
		out_dy[0] = (-in_y[0] +in_y[1])/deltaX;
		out_dy[1] = out_dy[0];
		return;
	}
	if (len == 3)//____________________________________ 3
	{
		const double denominator = 2.0*deltaX;
		out_dy[0] = (-3.0*in_y[0] + 4.0*in_y[1] - in_y[2])/denominator;
		out_dy[1] = (-1.0*in_y[0] + in_y[2])/denominator;
		out_dy[2] = (in_y[0] - 4.0*in_y[1]+3.0*in_y[2])/denominator;
		return;
	}
	//______________________________________________ 4 or longer
	const double denominator = 6.0*deltaX;
	for(int i = 0; i < len; i++)
	{
		if (i == 0)
		{
			out_dy[i] = -11.0*in_y[0] +18.0*in_y[1]-9.0*in_y[2]+2.0*in_y[3];
		}
		else if (i == len-2)
		{
			out_dy[i] = in_y[len-4] -6.0*in_y[len-3]+3.0*in_y[len-2]+2.0*in_y[len-1];
		}
		else if (i == len-1)
		{
			out_dy[i] = -2.0*in_y[len-4] +9.0*in_y[len-3]-18.0*in_y[len-2]+11.0*in_y[len-1];
		}
		else
		{
			out_dy[i] = -2.0*in_y[i-1] -3.0*in_y[i]+6.0*in_y[i+1]-1.0*in_y[i+2];
		}
		out_dy[i] /= denominator;
	}
}

void NumericDerivative::SecondDerivative(double deltaX, const valarray<double>& in_y, valarray<double>& out_dy)
{
	const int len = (int)in_y.size();
	const double denominator = deltaX*deltaX;
	if (len == 0)
	{
		out_dy.resize(0);
		return;
	}
	out_dy.resize(len);
	if (len == 1)//______________________________________________ 1
	{
		out_dy[0] = 0.0;
		return;
	}
	if (len == 2)//______________________________________________ 2
	{
		out_dy[0] = 0.0;
		out_dy[1] = 0.0;
		return;
	}
	if (len == 3)//______________________________________________ 3
	{
		out_dy[0] = 0.0;
		out_dy[1] = (in_y[0] -2.0*in_y[1]+in_y[2])/denominator;
		out_dy[2] = 0.0;
		return;
	}
	//______________________________________________ 4 or longer
	for(int i = 0; i < len; i++)
	{
		if (i == 0)
		{
			out_dy[i] = 2.0*in_y[0] -5.0*in_y[1]+4.0*in_y[2]-1.0*in_y[3];
		}
		else if (i == len-2)
		{
			out_dy[i] = /*0* in_y[len-4] + */in_y[len-3]-2.0*in_y[len-2]+in_y[len-1];
		}
		else if (i == len-1)
		{
			out_dy[i] = -1.0*in_y[len-4] +4.0*in_y[len-3]-5.0*in_y[len-2]+2.0*in_y[len-1];
		}
		else
		{
			out_dy[i] = in_y[i-1] -2.0*in_y[i]+in_y[i+1];//-1.0*in_y[i+2];
		}
		out_dy[i] /= denominator;
	}
}

void NumericDerivative::ThirdDerivative(double deltaX, const valarray<double>& in_y, valarray<double>& out_dy)
{
	const int len = (int)in_y.size() - 2;
	const double denominator = deltaX*deltaX*deltaX;
	if (len <= 0)
	{
		out_dy.resize(0);
		return;
	}
	out_dy.resize(len);
	for(int i = 0; i < len; i++)
	{
		if (i == len-1)
		{
			out_dy[i] = -1.0*in_y[len-2] +3.0*in_y[len-1]-3.0*in_y[len]+in_y[len+1];
		}
		else
		{
			out_dy[i] = -1.0* in_y[i] + 3.0*in_y[i+1]-3.0*in_y[i+2]+in_y[i+3];
		}
		out_dy[i] /= denominator;
	}
}

//_____________________________________________________________________ NumericIntegration
NumericIntegration::NumericIntegration(void)
{
}

NumericIntegration::~NumericIntegration(void)
{
}

// steps will be approximated to next multiple of 4
double NumericIntegration::Simpson(Math::IFunction& function, double a, double b, int steps, double& resultingError)
{
	int i =0, j = 0;
	double delta = 0;
	double sum_half = 0.0;
	resultingError = 1.0e100;

	if (b<a || steps<=0) return 0.0; 

	//______________ be sure steps is a multiple of 4
	if (steps<4) steps = 4;

	if (steps%4==1)
	{
		steps+=3;
	}
	else if (steps%4==2)
	{
		steps+=2;
	}
	else if (steps%4==3)
	{
		steps++;
	}
	delta=(b-a)/steps;
	//______________________________________ Initial Point
	double x = a;
	double sum = function.EvaluateFunc(x);
	x+=delta;
	//______________________________________ Last Point
	sum += function.EvaluateFunc(b);
	double y = 0;
	for(i = 1; i < steps; i++, x+=delta)
	{
		y=function.EvaluateFunc(x);
		j = i/2;
		if (i%2==0)
		{
			sum += (2.0*y);
			//_______________ Compute the integral using half the steps 
			if (j%2 == 0)
			{
				sum_half += (2.0*y);
			}
			else
			{
				sum_half += (4.0*y);
			}
		}
		else
		{
			sum += (4.0*y);
		}
	}
	sum_half = sum_half*(2.0*delta)/3.0;
	sum = sum*delta/3.0;

	resultingError = fabs(sum_half-sum)/16.0; // 2^4
	return sum;
}

complex<double> NumericIntegration::Simpson(Math::IFunctionC& function, double a, double b, int steps, double& resultingError)
{
	int i =0, j = 0;
	double delta = 0;
	complex<double> sum_half = 0.0;
	complex<double> sum = 0.0;
	double x = 0;
	complex<double> y = 0;
	resultingError = 1.0e100;

	if (b<a || steps<=0) return 0.0; 

	//______________ be sure steps is a multiple of 4
	if (steps<4) steps = 4;

	if (steps%4==1)
	{
		steps+=3;
	}
	else if (steps%4==2)
	{
		steps+=2;
	}
	else if (steps%4==3)
	{
		steps++;
	}
	delta=(b-a)/steps;

	for(i=0, x=a; i<=steps; i++, x+=delta)
	{
		y=function.EvaluateFunc(x);
		j = i/2;
		if (i==0 || i==steps)
		{
			sum+=y;
			sum_half+=y;
		}
		else if (i%2==0)
		{
			sum+=(2.0*y);
			//_______________ Compute the integral using half the steps 
			if (j%2==0)
			{
				sum_half+=(2.0*y);
			}
			else
			{
				sum_half+=(4.0*y);
			}
		}
		else
		{
			sum+=(4.0*y);
		}
	}
	sum_half = sum_half*(2.0*delta)/3.0;
	sum = sum*delta/3.0;
	resultingError = abs(sum_half-sum)/16.0; // 2^4
	return sum;
}

double NumericIntegration::helper(Math::IFunction& function, double a, double b, int nx)
{
	static double value;
	if (nx == 0) 
	{
		value=0.5*(b-a)*(function.EvaluateFunc(a)+function.EvaluateFunc(b));
		return value;
	}

	double sum = 0.0;
	int ivalue = 1;
	int j;

	for (j = 0; j < nx-1; j++) 
	{
		ivalue <<= 1;
	}

	const double delta = (b-a)/(double)ivalue;
	double x = a + 0.5*delta;
	for (j = 0; j < ivalue; j++) 
	{
		sum += function.EvaluateFunc(x);
		x += delta;
	}
	value = 0.5*(value+(b-a)*sum/(double)ivalue);
	return value;
}

complex<double> NumericIntegration::helper(Math::IFunctionC& function, double a, double b, int nx)
{
	static complex<double> value;
	if (nx == 0) 
	{
		value=0.5*(b-a)*(function.EvaluateFunc(a)+function.EvaluateFunc(b));
		return value;
	}
	
	complex<double> sum = 0.0;
	int ivalue = 1;
	int j;

	for (j=0; j<nx-1; j++) 
	{
		ivalue <<= 1;
	}

	const double delta=(b-a)/(double)ivalue;
	double x = a + 0.5*delta;
	for (j = 0; j < ivalue; j++) 
	{
		sum += function.EvaluateFunc(x);
		x += delta;
	}
	value=0.5*(value+(b-a)*sum/(double)ivalue);
	return value;
}

double NumericIntegration::Simpson(Math::IFunction& func, double a, double b, double& resultingError)
{
	resultingError = 1.0e100;
	double result = 0.0;
	double sresult = 0.0, xresult=0.0, presult = 0.0;
	for (int ix = 0; ix <= 11; ix++) 
	{
		sresult = helper(func, a, b, ix);
		result = (4.0*sresult - xresult)/3.0;
		resultingError = fabs(result-presult);
		if (ix > 4)
		{
			if (resultingError < (1.0e-6)*fabs(presult))
			{
				resultingError/=15.5;
				return result;
			}
			if (result == 0.0 && presult == 0.0) 
			{
				resultingError/=15.5;
				return 0.0;
			}
		}
		presult = result;
		xresult = sresult;
	}
	resultingError /= 15.5;
	return result;
}

complex<double> NumericIntegration::Simpson(Math::IFunctionC& func, double a, double b, double& resultingError)
{
	resultingError = 1.0e100;
	complex<double> result = 0.0;
	complex<double> sresult = 0.0,  xresult = 0.0, presult = 0.0;
	for (int ix=0; ix<=11; ix++) 
	{
		sresult = helper(func, a, b, ix);
		result=(4.0*sresult-xresult)/3.0; 
		resultingError = abs(result-presult);
		if (ix>4)
		{
			if (resultingError < (1.0e-4)*abs(presult)) 
			{
				resultingError/=15.5;
				return result;
			}
			if (result == 0.0 && presult == 0.0) 
			{
				resultingError/=15.5;
				return 0.0;
			}
		}
		presult = result;
		xresult = sresult;
	}
	resultingError/=15.5;
	return result;
}

double NumericIntegration::Simpson3_8(Math::IFunction& function, double a, double b, int steps)
{
	int i =0;
	double delta = 0;
	double sum = 0.0;
	double x = 0, y = 0;
	const double remainder = steps%3;
	if (b < a || steps <= 0) return 0.0; 

	//______________ be sure steps is a multiple of 3
	if (steps < 3) steps = 3;

	if (remainder == 1)
	{
		steps += 2;
	}
	else if (remainder ==2)
	{
		steps += 1;
	}
	delta=(b-a)/steps;

	for(i=0, x=a; i<=steps; i++, x += delta)
	{
		y=function.EvaluateFunc(x);
		if (i==0 || i==steps)
		{
			sum += y;
		}
		else if (i%3 == 0)
		{
			sum += (2.0*y);
		}
		else
		{
			sum += (3.0*y);
		}
	}
	return 3.0*delta*sum/8.0;
}


double NumericIntegration::ClenshawCurtis(Math::IFunction& function, double a, double b)
{
	int N = 2;
	double integral = Math::NumericIntegration::ClenshawCurtis(function, a, b, N);
	double prev = integral;
	//double tol = 1.0e100;
	double delta = 1.0e100;
	while(delta*fabs(integral) > 1.0e-6)
	{
		N *= 2;
		integral = Math::NumericIntegration::ClenshawCurtis(function, a, b, N);
		//
		delta = fabs(integral - prev);
		//tol = abs((integral - prev)/integral);
		prev = integral;
		if (N > 256) break;
	}
	return integral;
}

double NumericIntegration::ClenshawCurtis(Math::IFunction& function, double a, double b, int N)
{
	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960, eq.  (7) and (9)
	// Numerical Recipes Second Edition eq. (5.9.3)
	valarray<double> F;
	try
	{
		F.resize(N);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	//_______________________________________________ Scale input from [a, b]  to  [-1, 1] and compute F[s]
	const double mapSum = (b + a)/2.0;
	const double mapDiff = (b - a)/2.0;
	const double piN = M_PI/N;
	int n, s;
	double t;  // [-1 1]
	double x;  // [a b]

	for (s = 0; s < N; s++)
	{
		t = cos(piN*(s+0.5)); // eq. (11) second part argument
		 x = t * mapDiff + mapSum; // eq. (5)
		F[s] = function.EvaluateFunc(x); // eq. (11) second part
	}
	//____________________________________________ Summation of eq. (11)
	const double factor = 2.0/N;
	double sum;
	double c;
	double integral = 0.0;
	for (n = 0; n < N; n += 2) // Compute: c[0], c[2], c[4], c[6], ... only
	{
		sum = 0.0;
		for (s = 0; s < N; s++)
		{
			sum += F[s]*cos(piN*n*(s+0.5));
		}
		c = factor*sum;
		//__________________________________________ Compute the Integral
		if (n == 0)
		{
			integral = c/2.0;
		}
		else
		{
			//integral -= (c/( (n+1)*(n-1)));
			integral += (c/(1- n*n));
		}
	}
	return (b-a)*integral;
}

//_____________________________________________________________________ TimePredictor
TimePredictor::TimePredictor(void)
{
	whenLast = ::GetTickCount();
	valueLast = 0.0;
	for(int i = 0; i<TIME_PREDICTOR_LENGTH; i++) data[i]=0.0;
	index = 0;
}

TimePredictor::~TimePredictor(void)
{
}

void TimePredictor::AddValue(double value)
{
	const DWORD now = ::GetTickCount();
	const DWORD deltaTime = now - whenLast;
	whenLast = now;
	//
	if (value==valueLast)
	{
		data[index++] = 0.0;
	}
	else
	{
		data[index++] = deltaTime/(value-valueLast);
	}
	valueLast = value;
	if (index==TIME_PREDICTOR_LENGTH) index=0;
}

int TimePredictor::GetPredictionInSeconds(double targetValue)
{
	double average = 0.0;
	for(int i=0; i<TIME_PREDICTOR_LENGTH; i++) average+=data[i];
	return (int)((targetValue-valueLast)*average/(TIME_PREDICTOR_LENGTH*1000.0)+0.5);
}

void TimePredictor::Reset(void)
{
	whenLast = ::GetTickCount();
	valueLast = 0.0;
	for(int i = 0; i<TIME_PREDICTOR_LENGTH; i++) data[i]=0.0;
	index = 0;
}

//_____________________________________________________________________ BinaryConverter
BinaryConverter::BinaryConverter(void)
{
	this->bitCount = 0;
	data = NULL;
}

int BinaryConverter::Convert(int value)
{
	if (data) delete [] data;
	data = NULL;
	bitCount = 0;
	//
	if (value <= 0)
	{
		return 0;
	}

	bitCount = (int)(log((double)value)/log(2.0)+1.0);
	if (bitCount==0) return 0;
	data = new bool[bitCount];
	if (data==NULL)
	{
		bitCount = 0;
		return 0;
	}
	for(int i = 0; i<bitCount; i++)
	{
		if (value%2==0)
			data[i]=false;
		else
			data[i]=true;
		value /= 2;
	}
	return bitCount;
}

// Call this function after calling BinaryConverter::Convert
bool BinaryConverter::GetBit(int bitIndex)
{
	if (bitIndex<0 || bitIndex>=bitCount) return false;
	return data[bitIndex];
}

int BinaryConverter::Convert(const int value, const int bitCount, valarray<int>& output)
{
	if (value <= 0)
	{
		try
		{
			output.resize(bitCount);
		}
		catch(const std::bad_alloc& )
		{
			return 0;
		}
		for(int i = 0; i<bitCount; i++) output[i] = 0;
		return bitCount;
	}
	BinaryConverter bc;
	const int _bitCount = bc.Convert(value);
	if (_bitCount <= 0)
	{
		output.resize(0);
		return 0;
	}
	try
	{
		output.resize(bitCount);
	}
	catch(const std::bad_alloc& )
	{
		return 0;
	}
	for(int i = 0; i<bitCount; i++)
	{
		if (bc.GetBit(i) == true)
		{
			output[bitCount-i-1] = 1;
		}
		else
		{
			output[bitCount-i-1] = 0;
		}
	}
	return _bitCount;
}

int BinaryConverter::Convert(const int value, const int bitCount, valarray<double>& output)
{
	if (value <= 0)
	{
		try
		{
			output.resize(bitCount);
		}
		catch(const std::bad_alloc& )
		{
			return 0;
		}
		for(int i = 0; i<bitCount; i++) output[i] = 0.0;
		return bitCount;
	}
	BinaryConverter bc;
	const int _bitCount = bc.Convert(value);
	if (_bitCount <= 0)
	{
		output.resize(0);
		return 0;
	}
	try
	{
		output.resize(bitCount);
	}
	catch(const std::bad_alloc& )
	{
		return 0;
	}
	for(int i = 0; i<bitCount; i++)
	{
		if (bc.GetBit(i) == true)
		{
			output[bitCount-i-1] = 1.0;
		}
		else
		{
			output[bitCount-i-1] = 0.0;
		}
	}
	return _bitCount;
}

BinaryConverter::~BinaryConverter(void)
{
	if (data) delete [] data;
}

//_____________________________________________________________________Statistics
std::tr1::mt19937 Statistics::random_generator;

Statistics::Statistics(void)
{
}

Statistics::~Statistics(void)
{
}

//Theil's U inequality index (Theil 1961) is a measure of the degree to which one time series () 
//differs from another ().  The score returned by the THEIL this test is  for consistency;  
//varies from 0 to 1 with 1 meaning maximum disagreement. Like DBK, it performs a 
//point-by-point matching of the two time series; if the lengths of reference and actual data 
//do not match, a warning is issued, and only the number of pairs corresponding to the length of the shortest one is used.
double Statistics::TheilUInequalityIndex(valarray<double>& input_x, valarray<double>& input_y)
{
	int size = (int)input_x.size();
	if ((int)input_y.size()<size) size = (int)input_y.size();
	double sumx=0, sumy=0, sumxy=0, tmp;
	int i;
	for(i=0; i<size; i++) 
	{
		tmp = input_x[i];
		sumx += tmp*tmp;
	}
	for(i=0; i<size; i++) 
	{
		tmp = input_y[i];
		sumy += tmp*tmp;
	}
	for(i=0; i<size; i++) 
	{
		tmp = input_x[i]-input_y[i];
		sumxy += tmp*tmp;
	}
	return (sqrt(sumxy/size))/(  sqrt(sumx)/size + sqrt(sumy)/size   );
}

double Statistics::TheilIndex(valarray<double>& input)
{
	double mean = 0.0;
	int size = (int)input.size();
	int i;
	for(i=0; i<size; i++) mean+=input[i];
	//
	double theil = 0.0, tmp;
	for(i=0; i<size; i++)
	{
		tmp = input[i]/mean;
		theil += (tmp*log(tmp));
	}
	return theil/size;
}

// It returns the value and position of the element with the minimum magnitude
complex<double> Statistics::GetMagnitudeMin(valarray<complex<double> >& input, int& position)
{
	position = -1;
	const int size = (int)input.size();
	if (size<=0) return 0.0;
	complex<double> minimum = input[0];
	position = 0;
	for(int i=0; i<size; i++)
	{
		if (abs(input[i])<abs(minimum))
		{
			minimum=input[i];
			position = i;
		}
	}
	return minimum;
}

// It returns the value and position of the element with the minimum magnitude
complex<double> Statistics::GetMagnitudeMin(MATRIXC& input, int& row, int& col)
{
	row = -1;
	col = -1;
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	if (rows*cols == 0) return 0.0;
	int i, j;
	row = 0;
	col = 0;
	complex<double> minimum = input[0][0];

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (abs(input[i][j])<abs(minimum))
			{
				minimum=input[i][j];
				row = i;
				col = j;
			}
		}
	}
	return minimum;
}

complex<double> Statistics::GetMagnitudeMax(valarray<complex<double> >& input, int& position)
{
	position = -1;
	const  int size = (int)input.size();
	if (size<=0) return 0.0;
	complex<double> maximum = input[0];
	position = 0;
	for(int i=0; i<size; i++)
	{
		if (abs(input[i])>abs(maximum))
		{
			maximum=input[i];
			position = i;
		}
	}
	return maximum;
}

complex<double> Statistics::GetMagnitudeMax(MATRIXC& input, int& row, int& col)
{
	row = -1;
	col = -1;
	const int rows = (int)input.size();
	if (rows == 0) return 0.0;
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	if (rows*cols == 0) return 0.0;
	int i, j;
	complex<double> maximum = input[0][0];
	row = 0;
	col = 0;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (abs(input[i][j])>abs(maximum))
			{
				maximum=input[i][j];
				row = i;
				col = j;
			}
		}
	}
	return maximum;
}

// It also returns the position of the minimum
double Statistics::GetMinimum(const MATRIX& input, int& row, int& col)
{
	row = -1;
	col = -1;
	const unsigned int rows = (int)input.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = (int)input[0].size();
	if (cols==0) return -1.0e100;
	unsigned int i, j;
	double minimum = input[0][0];
	row = 0;
	col = 0;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (input[i][j] < minimum)
			{
				minimum = input[i][j];
				row = i;
				col = j;
			}
		}
	}
	return minimum;
}

// It also returns the position of the minimum
double Statistics::GetMinimum(const MATRIXC& input, int& row, int& col)
{
	row = -1;
	col = -1;
	const unsigned int rows = (int)input.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = (int)input[0].size();
	if (cols==0) return -1.0e100;
	unsigned int i, j;
	double minimum = input[0][0].real();
	row = 0;
	col = 0;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (input[i][j].real() < minimum)
			{
				minimum = input[i][j].real();
				row = i;
				col = j;
			}
			if (input[i][j].imag() < minimum)
			{
				minimum = input[i][j].imag();
				row = i;
				col = j;
			}
		}
	}
	return minimum;
}

// It also returns the position of the maximum
double Statistics::GetMaximum(const MATRIX& input, int& row, int& col)
{
	row = -1;
	col = -1;
	const unsigned int rows = (int)input.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = (int)input[0].size();
	if (cols==0) return -1.0e100;
	unsigned int i, j;
	double maximum = input[0][0];
	row = 0;
	col = 0;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (maximum<input[i][j])
			{
				maximum = input[i][j];
				row = i;
				col = j;
			}
		}
	}
	return maximum;
}

// It also returns the position of the maximum
double Statistics::GetMaximum(const MATRIXC& input, int& row, int& col)
{
	row = -1;
	col = -1;
	const unsigned int rows = (int)input.size();
	if (rows==0) return -1.0e100;
	//
	const unsigned int cols = (int)input[0].size();
	if (cols==0) return -1.0e100;
	unsigned int i, j;
	double maximum = input[0][0].real();
	row = 0;
	col = 0;
	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			if (maximum<input[i][j].real())
			{
				maximum = input[i][j].real();
				row = i;
				col = j;
			}
			if (maximum<input[i][j].imag())
			{
				maximum = input[i][j].imag();
				row = i;
				col = j;
			}
		}
	}
	return maximum;
}

double Statistics::GetMinimum(const valarray<double>& input, int& position) // It also returns the position of the minimum
{
	position = -1;
	const unsigned int size = (int)input.size();
	if (size == 0) return -1.0e100;
	//
	unsigned int i;
	double minimum = input[0];
	position = 0;
	for(i=0; i<size; i++)
	{
		if (input[i] < minimum)
		{
			minimum = input[i];
			position = i;
		}
	}
	return minimum;
}

double Statistics::GetMinimum(const valarray<complex<double> >& input, int& position)// It also returns the position of the minimum
{
	position = -1;
	const unsigned int size = (int)input.size();
	if (size == 0) return -1.0e100;
	//
	unsigned int i;
	double minimum = input[0].real();
	position = 0;
	for(i=0; i<size; i++)
	{
		if (input[i].real() < minimum)
		{
			minimum = input[i].real();
			position = i;
		}
		if (input[i].imag() < minimum)
		{
			minimum = input[i].imag();
			position = i;
		}
	}
	return minimum;
}

double Statistics::GetMaximum(const valarray<double>& input, int& position)// It also returns the position of the maximum
{
	position = -1;
	const unsigned int size = (int)input.size();
	if (size == 0) return -1.0e100;
	//
	unsigned int i;
	double maximum = input[0];
	position = 0;
	for(i=0; i<size; i++)
	{
		if (maximum < input[i])
		{
			maximum = input[i];
			position = i;
		}
	}
	return maximum;
}

double Statistics::GetMaximum(const valarray<complex<double> >& input, int& position)// It also returns the position of the maximum
{
	position = -1;
	const unsigned int size = (int)input.size();
	if (size == 0) return -1.0e100;
	//
	unsigned int i;
	double maximum = input[0].real();
	position = 0;
	for(i=0; i<size; i++)
	{
		if (maximum  < input[i].real())
		{
			maximum = input[i].real();
			position = i;
		}
		if (maximum < input[i].imag())
		{
			maximum = input[i].imag();
			position = i;
		}
	}
	return maximum;
}

double Statistics::GetSum(valarray<double>& input)
{
	const int size = (int)input.size();
	double sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += input[i];
	}
	return sum;
}

complex<double> Statistics::GetSum(valarray<complex<double> >& input)
{
	const int size = (int)input.size();
	complex<double> sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += input[i];
	}
	return sum;
}

double Statistics::GetSum(MATRIX& input)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	double sum = 0.0;
	int i, j;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j];
		}
	}
	return sum;
}

complex<double> Statistics::GetSum(MATRIXC& input)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	int i, j;
	complex<double> sum = 0.0;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j];
		}
	}
	return sum;
}

double Statistics::GetDiagonalSum(MATRIX& input)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	double sum = 0.0;
	const int len = rows<cols ? rows : cols;

	for(int i=0; i<len; i++)
	{
		sum += input[i][i];
	}
	return sum;
}

complex<double> Statistics::GetDiagonalSum(MATRIXC& input)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	complex<double> sum = 0.0;
	const int len = rows<cols ? rows : cols;

	for(int i=0; i<len; i++)
	{
		sum += input[i][i];
	}
	return sum;
}

double Statistics::GetSumOfSquares(valarray<double>& input)
{
	const int size = (int)input.size();
	double sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += (input[i]*input[i]);
	}
	return sum;
}

double Statistics::GetSumOfSquares(valarray<complex<double> >& input)
{
	const int size = (int)input.size();
	double sum = 0.0;
	for(int i=0; i<size; i++)
	{
		sum += abs(input[i]);
	}
	return sum;
}

double Statistics::GetSumOfSquares(MATRIX& input)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	double sum = 0.0;
	int i, j;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += (input[i][j]*input[i][j]);
		}
	}
	return sum;
}

double Statistics::GetSumOfSquares(MATRIXC& input)
{
	const int rows = (int)input.size();
	const int cols = (rows == 0) ? 0 : (int)input[0].size();
	int i, j;
	double sum = 0.0;

	for(i=0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += abs(input[i][j]);
		}
	}
	return sum;
}

double Statistics::AbsoluteRelativeError(const valarray<double>& exact, const valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::AbsoluteRelativeError input vectors need to be of the same size";
	double error = 0;
	const int length = (int)exact.size();

	for(int i=0; i< length; i++)
	{
		error += fabs(approx[i] - exact[i]);
	}
	return error/length;
}

void Statistics::AbsoluteRelativeError(const valarray<double>& exact, const valarray<double>& approx,
											valarray<double>& outRelativeError)
{
	if (exact.size() != approx.size())
		throw L"Statistics::AbsoluteRelativeError input vectors need to be of the same size";
	const int length = (int)exact.size();
	outRelativeError.resize(length);

	for(int i=0; i< length; i++)
	{
		outRelativeError[i] = ( approx[i] - exact[i]) / exact[i];
	}
}

double Statistics::MeanAbsoluteError(const valarray<double>& exact, const valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::MeanAbsoluteError input vectors need to be of the same size";
	double error = 0.0;
	const int length = (int)exact.size();

	for(int i=0; i< length; i++)
	{
		error += fabs(approx[i] - exact[i]);
	}
	return error/length;
}

double Statistics::MeanSquaredError(const valarray<double>& exact, const valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::MeanSquaredError input vectors need to be of the same size";
	double error = 0.0;
	double tmp = 0.0;
	const int length = (int)exact.size();

	for(int i=0; i< length; i++)
	{
		tmp = approx[i] - exact[i];
		error += (tmp*tmp);
	}
	return error/length;
}

double Statistics::RootMeanSquaredError(const valarray<double>& exact, const valarray<double>& approx)
{
	return sqrt(Math::Statistics::MeanSquaredError(exact, approx));
}

double Statistics::RelativeRootMeanSquareError(const valarray<double>& exact, const valarray<double>& approx)
{
	if (exact.size() != approx.size())
		throw L"Statistics::RelativeRootMeanSquareError input vectors need to be of the same size";
	double error = 0;
	double tmp = 0;
	const int length = (int)exact.size();

	for(int i=0; i< length; i++)
	{
		tmp = (approx[i] - exact[i]) / exact[i];
		error += (tmp*tmp);
	}
	return sqrt(error/length);
}

double Statistics::MeanValue(valarray<double>& input)
{
	double sum = 0.0;
	const int length = (int)input.size();
	if (length==0) return 0.0;
	for(int i = 0; i<length; i++)
	{
		sum += input[i]; 
	}
	return sum/length;
}

complex<double> Statistics::MeanValue(valarray<complex<double> >& input)
{
	complex<double> sum = 0.0;
	const int length = (int)input.size();
	if (length==0) return 0.0;
	for(int i = 0; i<length; i++)
	{
		sum += input[i]; 
	}
	return sum/(double)length;
}

double Statistics::MeanValue(MATRIX& input)
{
	double sum = 0.0;
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	const int length = rows*cols;
	if (length==0) return 0.0;
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j]; 
		}
	}
	return sum/length;
}

complex<double> Statistics::MeanValue(MATRIXC& input)
{
	complex<double> sum = 0.0;
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	const int length = rows*cols;
	if (length==0) return 0.0;
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			sum += input[i][j]; 
		}
	}
	return sum/(double)length;
}

double Statistics::Bias(valarray<double>& exact, valarray<double>& approx)
{
	double bias = 0.0;
	const unsigned int length = (int)exact.size();
	if (length==0) return 0.0;
	if (length!=approx.size()) return -999999.999;
	for(unsigned int i = 0; i<length; i++)
	{
		bias += (exact[i]-approx[i]); 
	}
	return bias/length;
}

double Statistics::Bias(valarray<double>& approx, double exact)
{
	double bias = 0.0;
	const int length = (int)approx.size();
	if (length==0) return 0.0;

	for(int i = 0; i<length; i++)
	{
		bias += (exact-approx[i]); 
	}
	return bias/length;
}

double Statistics::StandardDeviation(const valarray<double>& input)
{
	return sqrt(Variance(input));
}

bool Statistics::MovingAverage(const valarray<double>& input, const int windowLength, valarray<double>& output)
{
	const int input_len = (int)input.size();
	if (input_len == 0)
	{
		output.resize(0);
		return true;
	}
	try
	{
		output.resize((size_t)input_len);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	int i, j;
	int begin, end;
	double sum = 0.0;
	for (i = 0; i < input_len; i++)
	{
		begin = i - windowLength/2;
		end = begin + windowLength;
		//
		sum = 0.0;
		for (j = begin; j <end; j++)
		{
			if (j < 0) continue;
			if (j >= input_len) continue;
			sum += input[j];
		}
		output[i] = sum/windowLength;
	}
	return true;
}

bool Statistics::MovingVariance(const valarray<double>& input, const int windowLength, valarray<double>& output)
{
	const int input_len = (int)input.size();
	if (input_len == 0)
	{
		output.resize(0);
		return true;
	}
	try
	{
		output.resize((size_t)input_len);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	const int window_minus_one = windowLength - 1;
	int i, j;
	int begin, end;
	double sum = 0.0;
	double sums = 0.0;
	for (i = 0; i < input_len; i++)
	{
		begin = i - windowLength/2;
		end = begin + windowLength;
		//
		sum = 0.0;
		sums = 0.0;
		for (j = begin; j <end; j++)
		{
			if (j < 0) continue;
			if (j >= input_len) continue;
			sum += input[j];
			sums += (input[j]*input[j]);
		}
		output[i] = sums/(window_minus_one) - (sum*sum)/(windowLength*(window_minus_one));
	}
	return true;
}

bool Statistics::MovingAverageAndVariance(const valarray<double>& input, const int windowLength, valarray<double>& out_average, valarray<double>& out_variance)
{
	const int input_len = (int)input.size();
	if (input_len == 0)
	{
		out_average.resize(0);
		out_variance.resize(0);
		return true;
	}
	try
	{
		out_average.resize((size_t)input_len);
		out_variance.resize((size_t)input_len);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}
	const int window_minus_one = windowLength - 1;
	int i, j;
	int begin, end;
	double sum = 0.0;
	double sums = 0.0;
	for (i = 0; i < input_len; i++)
	{
		begin = i - windowLength/2;
		end = begin + windowLength;
		//
		sum = 0.0;
		sums = 0.0;
		for (j = begin; j <end; j++)
		{
			if (j < 0) continue;
			if (j >= input_len) continue;
			sum += input[j];
			sums += (input[j]*input[j]);
		}
		out_average[i] = sum/windowLength;
		out_variance[i] = sums/(window_minus_one) - (sum*sum)/(windowLength*(window_minus_one));
	}
	return true;
}

double Statistics::Variance(const valarray<double>& input)
{
	const int size = (int)input.size();
	double sum = 0.0;
	double sums = 0.0;

	if (size==0) return 0.0;
	for(int i = 0; i<size; i++)
	{
		sum+=input[i];
		sums+=(input[i]*input[i]);
	}
	return sums/(size-1) - (sum*sum)/(size*(size-1));
}

complex<double> Statistics::Variance(const valarray<complex<double> >& input)
{
	const int size = (int)input.size();
	complex<double> sum = 0.0;
	complex<double> sums = 0.0;

	if (size==0) return 0.0;
	for(int i = 0; i<size; i++)
	{
		sum+=input[i];
		sums+=(input[i]*input[i]);
	}
	return sums/(size-1.0) - (sum*sum)/(size*(size-1.0));
}

double Statistics::Variance(const MATRIX& input)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	const int size = rows*cols;
	if (size==0) return 0.0;
	double sum = 0.0;
	double sums = 0.0;
	double value;

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
	}
	return sums/(size-1.0) - (sum*sum)/(size*(size-1.0));
}

complex<double> Statistics::Variance(const MATRIXC& input)
{
	const int rows = (int)input.size();
	const int cols = rows == 0 ? 0 : (int)input[0].size();
	const int size = rows*cols;
	if (size==0) return 0.0;
	complex<double> sum = 0.0;
	complex<double> sums = 0.0;
	complex<double> value;

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
	}
	return sums/(size-1.0) - (sum*sum)/(size*(size-1.0));
}

// It returns the variance of each column in the matrix
void Statistics::ColumnVariance(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(cols);

	double sum = 0.0;
	double sums = 0.0;
	double value;

	int i, j;
	for(j = 0; j<cols; j++)
	{
		sum = 0.0;
		sums = 0.0;
		for(i = 0; i<rows; i++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
		output[j] = sums/(rows-1.0) - (sum*sum)/(rows*(rows-1.0));
	}
}

// It returns the variance of each row in the matrix
void Statistics::RowVariance(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(rows);

	double sum = 0.0;
	double sums = 0.0;
	double value;

	int i, j;
	for(i = 0; i<rows; i++)
	{
		sum = 0.0;
		sums = 0.0;
		for(j = 0; j<cols; j++)
		{
			value = input[i][j];
			sum+=value;
			sums+=(value*value);
		}
		output[i] = sums/(cols-1.0) - (sum*sum)/(cols*(cols-1.0));
	}
}

// It returns the mean of each column in the matrix
void Statistics::ColumnMean(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(cols);

	double sum = 0.0;

	int i, j;
	for(j = 0; j<cols; j++)
	{
		sum = 0.0;
		for(i = 0; i<rows; i++) sum += input[i][j];
		output[j] = sum/rows;
	}
}

// It returns the mean of each row in the matrix
void Statistics::RowMean(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(rows);

	double sum = 0.0;

	int i, j;
	for(i = 0; i<rows; i++)
	{
		sum = 0.0;
		for(j = 0; j<cols; j++) sum += input[i][j];
		output[i] = sum/cols;
	}
}

// It returns the minimum of each column in the matrix
void Statistics::ColumnMinimum(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(cols);

	int i, j;
	//______________________ Make the first row the minimum
	for(j = 0; j<cols; j++) output[j] = input[0][j];
	//______________________ Find the minimum
	for(i = 1; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			if (input[i][j] < output[j]) output[j] = input[i][j];
		}
	}
}

// It returns the maximum of each column in the matrix
void Statistics::ColumnMaximum(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(cols);

	int i, j;
	//______________________ Make the first row the maximum
	for(j = 0; j<cols; j++) output[j] = input[0][j];
	//______________________ Find the maximum
	for(i = 1; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			if (input[i][j] > output[j]) output[j] = input[i][j];
		}
	}
}

// It returns the minimum of each row in the matrix
void Statistics::RowMinimum(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(rows);

	int i, j;
	//______________________ Make the first column the minimum
	for(i = 0; i<rows; i++) output[i] = input[i][0];
	//______________________ Find the minimum
	for(j = 1; j<cols; j++)
	{
		for(i = 0; i<rows; i++)
		{
			if (input[i][j] < output[i]) output[i] = input[i][j];
		}
	}
}

// It returns the maximum of each row in the matrix
void Statistics::RowMaximum(const MATRIX& input, valarray<double>& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.resize(0);
		return;
	}
	const int cols = (int)input[0].size();
	if (cols == 0)
	{
		output.resize(0);
		return;
	}
	output.resize(rows);

	int i, j;
	//______________________ Make the first column the minimum
	for(i = 0; i<rows; i++) output[i] = input[i][0];
	//______________________ Find the minimum
	for(j = 1; j<cols; j++)
	{
		for(i = 0; i<rows; i++)
		{
			if (input[i][j] > output[i]) output[i] = input[i][j];
		}
	}
}

double Statistics::Covariance(const valarray<double>& input_x, const valarray<double>& input_y, bool bNormalDistr)
{
	unsigned int size = (int)input_x.size();
	if (size != input_y.size() || size == 0) throw L"Statistics::Covariance input vectors need to be of the same size";
	double meanX = 0.0;
	double meanY = 0.0;
	double cov = 0.0;
	unsigned int i;

	for(i=0; i<size; i++)
	{
		meanX += input_x[i];
		meanY += input_y[i];
	}
	meanX /= size;
	meanY /= size;

	for(i=0; i< size; i++) cov += (input_x[i]*input_y[i]);
	if (bNormalDistr) size--;
	return cov /size - meanX * meanY;
}

double Statistics::Correlation(const valarray<double>& input_x, const valarray<double>& input_y)
{
	unsigned int size = (int)input_x.size();
	if (size != input_y.size() || size == 0) throw L"Statistics::Correlation input vectors need to be of the same size";
	double corr = 0.0;

	for(unsigned int i=0; i< size; i++) corr += (input_x[i]*input_y[i]);
	return corr /size;
}

const wchar_t* Statistics::CovarianceMatrix(const MATRIX& input, MATRIX& output)
{
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	int i, j, k;
	valarray<double> mean;
	//________________________________ Memory allocation
	try
	{
		if (output.size() != cols)
		{
			output.resize(cols);
			for(i = 0; i < cols; i++) output[i].resize(cols);
			for(i = 0; i < cols; i++) for(j = 0; j < cols; j++)output[i][j] = 0.0;
		}
		mean.resize(cols);
	}
	catch(std::bad_alloc& )
	{
		return L"Statistics::CovarianceMatrix: No enough memory";
	}
	//________________________________ Compute Column Mean
	double tmp;
	for(j = 0; j < cols; j++)
	{
		tmp = 0.0;
		for(i = 0; i < rows; i++)
		{
			tmp += input[i][j];
		}
		mean[j] = tmp / rows;
	}
	//________________________________ Compute Covariance Matrix
	double delta1, delta2;
	for(i = 0; i < rows; i++)
	{
		for(j = 0; j < cols; j++)
		{
			delta1 = input[i][j]- mean[j];
			for(k = j; k < cols; k++)
			{
				delta2 = input[i][k]- mean[k];
				output[j][k] += (delta1*delta2);
			}
		}
	}
	// Fill symmetric part
	const double n = rows - 1.0;
	for(j = 0; j < cols; j++)
	{
		for(k = j; k < cols; k++)
		{
			output[j][k] /= n;
			if (j != k) output[k][j] = output[j][k];
		}
	}
	return NULL;
}

const wchar_t* Statistics::CorrelationMatrix(const MATRIX& input, MATRIX& output)
{
	const wchar_t* error = Math::Statistics::CovarianceMatrix(input, output);
	if (error != NULL) return error;
	const int rows = (int)output.size(); // Matrix is squared, therefore the number of rows is equal to the number of columns
	if (rows == 0) return NULL;
	int j, k;
	valarray<double> std;
	//__________________________ Memory allocation
	try
	{
		std.resize(rows);
	}
	catch(std::bad_alloc& )
	{
		return L"Statistics::CorrelationMatrix: No enough memory";
	}
	//__________________________ Compute Standard Deviation
	for(j = 0; j < rows; j++)
	{
		std[j] = sqrt(output[j][j]);
		output[j][j] = 1.0; // Main diagonal has ones only
	}
	for(j = 0; j < rows-1; j++)
	{
		for(k = j+1; k < rows; k++)
		{
			output[j][k] /= (std[j]*std[k]);
			output[k][j] = output[j][k];
		}
	}
	return NULL;
}

double Statistics::CorrelationCoeff(const valarray<double>& input_x, const valarray<double>& input_y)
{
	double stdX = sqrt(Statistics::Variance(input_x));
	double stdY = sqrt(Statistics::Variance(input_y));
	return Statistics::Correlation(input_x, input_y)/(stdX*stdY);
}

unsigned int Statistics::Combinations(unsigned int n, unsigned int k)
{
	if (k > n) return 0;
	unsigned int r = 1;
	if (n-k < k) k = n - k;  // Combinations(n, k) is equal to Combinations(n, n-k);

	for (unsigned int d = 1; d <= k; ++d)
	{
		r *= n--;
		r /= d;
	}
     return r;
}

//_____________________________________________________________________ Bessel
Bessel::Bessel(void)
{
}

Bessel::~Bessel(void)
{
}

/*
This subroutine calculates the first kind modified Bessel function
of integer order N, for any REAL X. We use here the classical
recursion formula, when X > N. For X < N, the Miller's algorithm
is used to avoid overflows. 
REFERENCE:
C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS,
MATHEMATICAL TABLES, VOL.5, 1962.
*/
double Bessel::In(int n, double x) 
{
	int IACC = 40; 
	double BIGNO = 1e10, BIGNI = 1e-10;
	double TOX, BIM, BI, BIP, BSI;
	int J, M;

	if (n == 0)  return (Math::Bessel::I0(x));
	if (n == 1)  return (Math::Bessel::I1(x));
	if (x == 0.0) return 0.0;

	TOX = 2.0/x;
	BIP = 0.0;
	BI  = 1.0;
	BSI = 0.0;
	M = (int) (2*((n+floor(sqrt((double)IACC*n)))));
	for (J = M; J>0; J--) 
	{
		BIM = BIP+J*TOX*BI;
		BIP = BI;
		BI  = BIM;
		if (fabs(BI) > BIGNO) 
		{
			BI  = BI*BIGNI;
			BIP = BIP*BIGNI;
			BSI = BSI*BIGNI;
		}
		if (J==n)  BSI = BIP;
	}
	return (BSI*Math::Bessel::I0(x)/BI);
}

double Bessel::I0(double x) 
{
	double Y;
	
	if (fabs(x) < 3.75) 
	{
		const double P1=1.0; 
		const double P2=3.5156229; 
		const double P3=3.0899424; 
		const double P4=1.2067429;
		const double P5=0.2659732; 
		const double P6=0.360768e-1; 
		const double P7=0.45813e-2;
		Y=(x/3.75)*(x/3.75);
		return (P1+Y*(P2+Y*(P3+Y*(P4+Y*(P5+Y*(P6+Y*P7))))));
	}
	const double Q1=0.39894228; 
	const double Q2=0.1328592e-1; 
	const double Q3=0.225319e-2;
	const double Q4=-0.157565e-2; 
	const double Q5=0.916281e-2; 
	const double Q6=-0.2057706e-1;
	const double Q7=0.2635537e-1; 
	const double Q8=-0.1647633e-1; 
	const double Q9=0.392377e-2;
	double AX=fabs(x);
	Y=3.75/AX;
	const double BX=exp(AX)/sqrt(AX);
	AX=Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*(Q5+Y*(Q6+Y*(Q7+Y*(Q8+Y*Q9)))))));
	return (AX*BX);
}

double Bessel::I1(double x) 
{
	double Y;

	if (fabs(x) < 3.75) 
	{
		const double P1=0.5; 
		const double P2=0.87890594; 
		const double P3=0.51498869; 
		const double P4=0.15084934;
		const double P5=0.2658733e-1; 
		const double P6=0.301532e-2; 
		const double P7=0.32411e-3;
		Y=(x/3.75)*(x/3.75);
		return(x*(P1+Y*(P2+Y*(P3+Y*(P4+Y*(P5+Y*(P6+Y*P7)))))));
	}

	const double Q1=0.39894228; 
	const double Q2=-0.3988024e-1; 
	const double Q3=-0.362018e-2;
	const double Q4=0.163801e-2; 
	const double Q5=-0.1031555e-1; 
	const double Q6=0.2282967e-1;
	const double Q7=-0.2895312e-1; 
	const double Q8=0.1787654e-1; 
	const double Q9=-0.420059e-2;
	double AX=fabs(x);
	Y=3.75/AX;
	const double BX=exp(AX)/sqrt(AX);
	AX=Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*(Q5+Y*(Q6+Y*(Q7+Y*(Q8+Y*Q9)))))));
	return (AX*BX);
}

double Bessel::J0(double x)
{
	const double absx = abs(x);
	if (absx < 8.0) 
	{ 
		const double y=x*x;
		const double a = 57568490574.0 + y*(-13362590354.0+y*(651619640.7+y*(-11214424.18+y*(77392.33017+y*(-184.9052456)))));
		const double b = 57568490411.0+y*(1029532985.0+y*(9494680.718+y*(59272.64853+y*(267.8532712+y*1.0))));
		return a/b;
	} 

	const double z = 8.0/absx;
	const double y = z*z;
	const double xx = absx - 0.785398164;
	const double a = 1.0+y*(-0.1098628627e-2+y*(0.2734510407e-4+y*(-0.2073370639e-5+y*0.2093887211e-6)));
	const double b = -0.1562499995e-1+y*(0.1430488765e-3+y*(-0.6911147651e-5+y*(0.7621095161e-6-y*0.934945152e-7)));
	return sqrt(0.636619772/absx)*(cos(xx)*a-z*sin(xx)*b);
}

double Bessel::J1(double x)
{
	const double absx = abs(x);

	if (absx < 8.0) 
	{ 
		const double y = x*x;
		const double a = x*(72362614232.0+y*(-7895059235.0+y*(242396853.1+y*(-2972611.439+y*(15704.48260+y*(-30.16036606))))));
		const double b = 144725228442.0+y*(2300535178.0+y*(18583304.74+y*(99447.43394+y*(376.9991397+y*1.0))));
		return a/b;
	} 

	const double z = 8.0/absx;
	const double y = z*z;
	const double xx = absx -2.356194491;
	const double a = 1.0+y*(0.183105e-2+y*(-0.3516396496e-4+y*(0.2457520174e-5+y*(-0.240337019e-6))));
	const double b = 0.04687499995+y*(-0.2002690873e-3+y*(0.8449199096e-5+y*(-0.88228987e-6+y*0.105787412e-6)));
	if (x < 0.0) return -1.0*sqrt(0.636619772/absx)*(cos(xx)*a-z*sin(xx)*b);
	return sqrt(0.636619772/absx)*(cos(xx)*a-z*sin(xx)*b);
}

double Bessel::Jn(int n, double x)
{
	if (n == 0) return Math::Bessel::J0(x);
	if (n == 1) return Math::Bessel::J1(x);
	bool isEven = (n%2 == 0);
	const double MATH_BESSEL_ACCURACY = 40.0;
	const double MATH_BESSEL_BIGNO = 1.0e10;
	const double MATH_BESSEL_BIGNI = 1.0e-10;

	const double absx = fabs(x);
	if (absx == 0.0) return 0.0;
	const double tox = 2.0/absx;
	double bjm = 0.0, bj = 1.0, bjp = 0.0;
	
	if (absx > (double) n) 
	{ 
		bjm = Math::Bessel::J0(absx);
		bj = Math::Bessel::J1(absx);
		for (int j = 1; j < n; j++) 
		{
			bjp = j*tox*bj-bjm;
			bjm = bj;
			bj = bjp;
		}
		return (x < 0.0 && isEven == false) ? -bj : bj;
	} 

	const int m = 2*((n+(int) sqrt(MATH_BESSEL_ACCURACY*n))/2);
	bool jsum =false;
	double sum = 0.0;
	int j;
	double result = 0.0;

	for (j = m; j > 0; j--) 
	{ 
		bjm = j*tox*bj-bjp;
		bjp = bj;
		bj = bjm;
		if (fabs(bj) > MATH_BESSEL_BIGNO) 
		{ 
			bj *= MATH_BESSEL_BIGNI;
			bjp *= MATH_BESSEL_BIGNI;
			result *= MATH_BESSEL_BIGNI;
			sum *= MATH_BESSEL_BIGNI;
		}
		if (jsum == true)
		{
			sum += bj;
			jsum = false;
		}
		else
		{
			jsum = true;
		}
		if (j == n) result = bjp;
	}
	sum = 2.0*sum - bj;
	result /= sum;
	return (x < 0.0 && isEven == false) ? -result : result;
}

//_____________________________________________________________________ Chebyshev
Chebyshev::Chebyshev(void)
{
}

Chebyshev::~Chebyshev(void)
{
}

double Chebyshev::Tn(const unsigned int n, double x)
{
	if (n == 0)
	{
		return 1.0;
	}
	else if (n == 1)
	{
		return x;
	}
	else if (n == 2)
	{
		return 2.0*x*x - 1.0;
	}
	else if (n == 3)
	{
		return 4.0*x*x*x - 3.0*x;
	}
	else if (n == 4)
	{
		const double x2 = x*x;
		return 8.0*x2 *(x2 - 1.0) + 1.0;
	}
	else if (n == 5)
	{
		const double x2 = x*x;
		const double x3 = x*x2;
		const double x5 = x3*x2;
		return 16.0*x5 - 20.0*x3 + 5.0*x;
	}
	else if (n == 6)
	{
		const double x2 = x*x;
		const double x4 = x2*x2;
		const double x6 = x4*x2;
		return 32.0*x6 - 48.0*x4 +18.0*x2 -1.0;
	}
	else if (n == 7)
	{
		const double x2 = x*x;
		const double x3 = x*x2;
		const double x5 = x3*x2;
		const double x7 = x5*x2;
		return 64.0*x7 - 112.0*x5 + 56.0*x3 - 7.0*x;
	}
	else if (n == 8)
	{
		const double x2 = x*x;
		const double x4 = x2*x2;
		const double x6 = x4*x2;
		const double x8 = x6*x2;
		return 128.0*x8 - 256.0*x6 + 160.0*x4 -32.0*x2 + 1;
	}
	else if (n == 9)
	{
		const double x2 = x*x;
		const double x3 = x*x2;
		const double x5 = x3*x2;
		const double x7 = x5*x2;
		const double x9 = x7*x2;
		return 256.0*x9 - 576.0*x7 + 432.0*x5 - 120.0*x3 + 9.0*x;
	}
	else if (n == 10)
	{
		const double x2 = x*x;
		const double x4 = x2*x2;
		const double x6 = x4*x2;
		const double x8 = x6*x2;
		const double x10 = x8*x2;
		return 512.0*x10 - 1280.0*x8 + 1120.0*x6 - 400.0*x4 + 50.0*x2 - 1;
	}
	else if (n == 11)
	{
		const double x2 = x*x;
		const double x3 = x*x2;
		const double x5 = x3*x2;
		const double x7 = x5*x2;
		const double x9 = x7*x2;
		const double x11 = x9*x2;
		return 1024.0*x11  - 2816.0*x9 + 2816.0*x7 - 1232.0*x5 + 220.0*x3 - 11.0*x;
	}

	//return (2.0 * x * Tn(n - 1, x)) - Tn(n - 2, x) ;
	double tnm1 = 2.0*x*x - 1.0;
	double tnm2 = x;
	double tn = tnm1;

	register unsigned int i;
	for (i = 3 ; i <= n ; i++)
	{ 
		tn = (2.0 * x * tnm1) - tnm2 ;
		tnm2 = tnm1;
		tnm1 = tn;
	}
	return tn;
}

double Chebyshev::Un(const unsigned int n, double x)
{
	if (n == 0)
	{
		return 1.0;
	}
	else if (n == 1)
	{
		return 2.0*x;
	}
	else if (n == 2)
	{
		return 4.0*x*x - 1.0;
	}
	else if (n == 3)
	{
		return 8.0*x*x*x - 4.0*x;
	}
	else if (n == 4)
	{
		const double x2 = x*x;
		const double x4 = x2*x2;
		return 16.0*x4 - 12.0*x2 + 1.0;
	}
	else if (n == 5)
	{
		const double x2 = x*x;
		const double x3 = x*x2;
		const double x5 = x3*x2;
		return 32.0*x5 - 32.0*x3 + 6.0*x;
	}
	else if (n == 6)
	{
		const double x2 = x*x;
		const double x4 = x2*x2;
		const double x6 = x4*x2;
		return 64.0*x6 - 80.0*x4 + 24.0*x2 - 1.0;
	}
	else if (n == 7)
	{
		const double x2 = x*x;
		const double x3 = x*x2;
		const double x5 = x3*x2;
		const double x7 = x5*x2;
		return 128.0*x7 - 192.0*x5 + 80.0*x3 - 8.0*x;
	}
	else if (n == 8)
	{
		const double x2 = x*x;
		const double x4 = x2*x2;
		const double x6 = x4*x2;
		const double x8 = x6*x2;
		return 256.0*x8 - 448.0*x6 + 240.0*x4 - 40.0*x2 + 1;
	}
	else if (n == 9)
	{
		const double x2 = x*x;
		const double x3 = x*x2;
		const double x5 = x3*x2;
		const double x7 = x5*x2;
		const double x9 = x7*x2;
		return 512.0*x9 - 1024.0*x7 + 672.0*x5 - 160.0*x3 + 10.0*x;
	}

	//return (2.0 * x * Un(n - 1, x)) - Un(n - 2, x) ;
	double unm1 = 4.0*x*x - 1.0;
	double unm2 = 2.0*x;
	double un = unm1;

	register unsigned int i;
	for (i = 3 ; i <= n ; i++)
	{ 
		un = (2.0 * x * unm1) - unm2 ;
		unm2 = unm1;
		unm1 = un;
	}
	return un;
}

bool Chebyshev::ComputeCoefficients_FirstKind(Math::IFunction& function, double a, double b, int N, valarray<double>& out_c)
{
	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960
	//_______________________________________________ Memory allocation
	valarray<double> F;
	try
	{
		F.resize(N);
		out_c.resize(N);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	//_______________________________________________ Scale input from [a, b]  to  [-1, 1] and compute F[s]
	const double mapSum = (b+ a)/2.0;
	const double mapDiff = (b - a)/2.0;
	const double piN = M_PI/N;
	int n, s;
	double t;  // [-1 1]
	double x;  // [a b]

	for (s = 0; s < N; s++)
	{
		t = cos(piN*(s+0.5)); // eq. (11) second part argument
		 x = t * mapDiff + mapSum; // eq. (5)
		F[s] = function.EvaluateFunc(x); // eq. (11) second part
	}
	//____________________________________________ Summation of eq. (11)
	const double factor = 2.0/N;
	double sum;
	for (n = 0; n < N; n++)
	{
		sum = 0.0;
		for (s = 0; s < N; s++)
		{
			sum += F[s]*cos(piN*n*(s+0.5));
		}
		out_c[n] = factor*sum;
	}
	return true;
}

//bool Chebyshev::ComputeCoefficients_Method2(Math::IFunction& function, double a, double b, int N, valarray<double>& out_c)
//{
//	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960
//	const int _N = N - 1;
//	//_______________________________________________ Memory allocation
//	valarray<double> F;
//	try
//	{
//		F.resize(N);
//		out_c.resize(N);
//	}
//	catch(const std::bad_alloc&)
//	{
//		return false;
//	}
//	//_______________________________________________ Scale input from [a, b]  to  [-1, 1] and compute F[s]
//	const double mapSum = (b+ a)/2.0;
//	const double mapDiff = (b - a)/2.0;
//	const double piN = M_PI/_N;
//	int n, s;
//	double t;  // [-1 1]
//	double x;  // [a b]
//
//	for (s = 0; s <= _N; s++)
//	{
//		t = cos(piN*s); // eq. (11) second part argument
//		 x = t * mapDiff + mapSum; // eq. (5)
//		F[s] = function.EvaluateFunc(x); // eq. (11) second part
//	}
//	//____________________________________________ Summation of eq. (11)
//	const double factor = 2.0/_N;
//	double sum;
//	for (n = 0; n <= _N; n++)
//	{
//		sum = 0.0;
//		for (s = 1; s < _N; s++)
//		{
//			sum += F[s]*cos(piN*n*s);
//		}
//		if (n%2 == 0)
//		{
//			out_c[n] = factor*( (F[0] + F[_N])/2.0 + sum);
//		}
//		else
//		{
//			out_c[n] = factor*( (F[0] - F[_N])/2.0 + sum);
//		}
//	}
//	return true;
//}

bool Chebyshev::ComputeCoefficients_SecondKind(Math::IFunction& function, double a, double b, int N, valarray<double>& out_c)
{
	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960
	//_______________________________________________ Memory allocation
	valarray<double> F;
	try
	{
		F.resize(N+1);
		out_c.resize(N+1);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	//_______________________________________________ Scale input from [a, b]  to  [-1, 1] and compute F[s]
	const double mapSum = (b+ a)/2.0;
	const double mapDiff = (b - a)/2.0;
	const double piN = M_PI/N;
	int n, s;
	double t;  // [-1 1]
	double x;  // [a b]

	for (s = 0; s <= N; s++)
	{
		t = cos(piN*s); // eq. (11) second part argument
		 x = t * mapDiff + mapSum; // eq. (5)
		F[s] = function.EvaluateFunc(x); // eq. (11) second part
	}
	//____________________________________________ Summation of eq. (11)
	const double factor = 2.0/N;
	double sum;
	for (n = 0; n <= N; n++)
	{
		sum = 0.0;
		for (s = 1; s < N; s++)
		{
			sum += F[s]*cos(piN*n*s);
		}
		if (n%2 == 0)
		{
			out_c[n] = factor*( (F[0] + F[N])/2.0 + sum);
		}
		else
		{
			out_c[n] = factor*( (F[0] - F[N])/2.0 + sum);
		}
	}
	return true;
}


//bool Chebyshev::ComputeCoefficients_Method1X(Math::IFunction& function, double a, double b, int N, valarray<double>& out_c)
//{
//	// Numerical Methods for Special Functions by Amparo Gill, Javier Segura, and Nico Temme
//	// Chapter 3. Chebyshev Expansion
//	//_______________________________________________ Memory allocation
//	valarray<double> F;
//	try
//	{
//		F.resize(N+1);
//		out_c.resize(N+1);
//	}
//	catch(const std::bad_alloc&)
//	{
//		return false;
//	}
//	//_______________________________________________ Scale input from [a, b]  to  [-1, 1] and compute F[s]
//	const double mapSum = (b+ a)/2.0;
//	const double mapDiff = (b - a)/2.0;
//	const double piN = M_PI/(N+1);
//	int n, j;
//	double t;  // [-1 1]
//	double x;  // [a b]
//
//	for (j = 0; j <= N; j++)
//	{
//		t = cos(piN*(j+0.5)); // eq. (3.55), eq. (3.56)
//		 x = t * mapDiff + mapSum; 
//		F[j] = function.EvaluateFunc(x); 
//	}
//	//____________________________________________ Summation of eq. (3.55), eq. (3.56)
//	const double factor = 2.0/(N+1.0);
//	double sum;
//	for (n = 0; n <= N; n++)
//	{
//		sum = 0.0;
//		for (j = 0; j <= N; j++)
//		{
//			sum += F[j]*cos(piN*n*(j+0.5));
//		}
//		out_c[n] = factor*sum;
//	}
//	return true;
//}

//bool Chebyshev::ComputeCoefficients_Method2X(Math::IFunction& function, double a, double b, int N, valarray<double>& out_c)
//{
//	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960
//	//
//	// Numerical Methods for Special Functions by Amparo Gill, Javier Segura, and Nico Temme
//	// Chapter 3. Chebyshev Expansion
//	//_______________________________________________ Memory allocation
//	valarray<double> F;
//	try
//	{
//		F.resize(N+1);
//		out_c.resize(N+1);
//	}
//	catch(const std::bad_alloc&)
//	{
//		return false;
//	}
//	//_______________________________________________ Scale input from [a, b]  to  [-1, 1] and compute F[s]
//	const double mapSum = (b+ a)/2.0;
//	const double mapDiff = (b - a)/2.0;
//	const double piN = M_PI/N;
//	int n, j;
//	double t;  // [-1 1]
//	double x;  // [a b]
//
//	for (j = 0; j <= N; j++)
//	{
//		t = cos(piN*j); // eq. (11) second part argument
//		 x = t * mapDiff + mapSum; // eq. (5)
//		F[j] = function.EvaluateFunc(x); // eq. (11) second part
//	}
//	//____________________________________________ Summation of eq. (11)
//	const double factor = 2.0/N;
//	double sum;
//	for (n = 0; n <= N; n++)
//	{
//		sum = 0.0;
//		for (j = 1; j < N; j++)
//		{
//			sum += F[j]*cos(piN*n*j);
//		}
//		if (n%2 == 0)
//		{
//			out_c[n] = factor*( (F[0] + F[N])/2.0 + sum);
//		}
//		else
//		{
//			out_c[n] = factor*( (F[0] - F[N])/2.0 + sum);
//		}
//	}
//	return true;
//}


double Chebyshev::ComputeApproximation_FirstKind(double a, double b, const valarray<double>& in_c, int m, double x)
{
	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960
	// Numerical Methods for Special Functions by Amparo Gill, Javier Segura, and Nico Temme
	// Chapter 3. Chebyshev Expansion eq. (3.53)
	const int N = (int)in_c.size();
	if (N == 0) return 0.0;
	if (m > N) m = N;
	//_______________________________________________________ Scale from [a, b] to [-1, 1]
	if (x< a) x = a;
	if (x > b) x = b;
	const double t = (2.0*x - b - a) / (b - a) ; // C.W. Clenshaw  eq. (5)
	double Tprev = 1.0;
	double Tcurrent = t;
	double tmp;
	double sum = in_c[0]/2.0;
	int n; 
	for (n = 1; n < m; n++)
	{
		sum += (in_c[n]*Tcurrent);
		//_________________________ Compute Tn using recursion: Numerical Recipes 2nd Edition eq (5.8.2)
		tmp = Tcurrent;
		Tcurrent = 2.0*t*Tcurrent - Tprev;
		Tprev = tmp;
	}
	return sum;
}

double Chebyshev::ComputeApproximation_SecondKind(double a, double b, const valarray<double>& in_c, int m, double x)
{
	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960
	const int N = (int)in_c.size();
	const int N_1 = N - 1;
	if (N == 0) return 0.0;
	if (m > N) m = N;
	//_______________________________________________________ Scale from [a, b] to [-1, 1]
	if (x< a) x = a;
	if (x > b) x = b;
	const double t = (2.0*x - b - a) / (b - a) ; // C.W. Clenshaw eq. (5)
	double Tprev = 1.0;
	double Tcurrent = t;
	double tmp;
	double sum = in_c[0]/2.0;
	int n;
	for (n = 1; n < m; n++)
	{
		if (n == N_1)
		{
			sum += 0.5*(in_c[n]*Tcurrent);
		}
		else
		{
			sum += (in_c[n]*Tcurrent);
		}
		//_________________________ Compute Tn using recursion: Numerical Recipes 2nd Edition eq (5.8.2)
		tmp = Tcurrent;
		Tcurrent = 2.0*t*Tcurrent - Tprev;
		Tprev = tmp;
	}
	return sum;
}

double Chebyshev::ComputeApproximation_FirstKind(double a, double b, const double* in_c, const int size_of_c, double x)
{
	// A method for numerical integration on an automatic computer.  C.W. Clenshaw and A. R. Curtis, Numerische Mathematik 1960
	// Numerical Methods for Special Functions by Amparo Gill, Javier Segura, and Nico Temme
	// Chapter 3. Chebyshev Expansion eq. (3.53)
	if (size_of_c == 0) return 0.0;
	const double *c = in_c;
	//_______________________________________________________ Scale from [a, b] to [-1, 1]
	if (x< a) x = a;
	if (x > b) x = b;
	const double t = (2.0*x - b - a) / (b - a) ; // C.W. Clenshaw  eq. (5)
	double Tprev = 1.0;
	double Tcurrent = t;
	double tmp;
	double sum = *c/2.0;
	c++;
	int n;
	for (n = 1; n < size_of_c; n++, c++)
	{
		sum += ( (*c) *Tcurrent);  //sum += (in_c[n]*Tcurrent);
		//_________________________ Compute Tn using recursion: Numerical Recipes 2nd Edition eq (5.8.2)
		tmp = Tcurrent;
		Tcurrent = 2.0*t*Tcurrent - Tprev;
		Tprev = tmp;
	}
	return sum;
}

//_____________________________________________________________________ Agc
Agc::Agc(void)
{
	buffer = new Agc::Data[ACG_LENGTH];
	SetForwardGainSpeed(-10.0);
	SetBackwardGainSpeed(-2.0);
	SetMaxGaindB(40.0);
	Reset();
}

void Agc::Reset()
{
	position = 0;
	maximum = 0.0;
	
	for (int i = 0; i < ACG_LENGTH; i++)
	{
		buffer[i].value = 0;
		buffer[i].maximum = 32000;
	}
}

Agc::~Agc(void)
{
	if (buffer != NULL) delete [] buffer;
}

double Agc::GetForwardGainSpeed()
{
	return 20.0*44100.0*log10(forwardGain);
}

void Agc::SetForwardGainSpeed(double db_per_second)
{
	forwardGain = pow(10.0, -fabs(db_per_second)/(20.0*44100.0));
}

double Agc::GetBackwardGainSpeed()
{
	return 20.0*44100.0*log10(backwardGain);
}

void Agc::SetBackwardGainSpeed(double db_per_second)
{
	backwardGain = pow(10.0, -fabs(db_per_second)/(20.0*44100.0));
}

double Agc::GetMaxGaindB()
{
	return 20.0*log10(ACG_MAX_VAL / maxGain);
}

void Agc::SetMaxGaindB(double gain_dB)
{
	maxGain = ACG_MAX_VAL / pow(10.0, fabs(gain_dB) / 20.0);
	if (maxGain < 1) maxGain = 1;
	if (maxGain > ACG_MAX_VAL) maxGain = ACG_MAX_VAL;
}

int Agc::ComputeOutput(int input)
{
	Agc::Data data = buffer[position];
	//
	const int abs_input = abs(input);
	const bool maximum_found = (abs_input > maximum);
	if (maximum_found == true) maximum = abs_input;
	buffer[position].maximum = (int)maximum;
	buffer[position].value = input;
	//_________________________________ Propagate maximum to the future
	if (maximum_found == true)
	{
		const int len = ACG_LENGTH - 1;
		int prev = position -1;
		if (prev < 0) prev = ACG_LENGTH - 1;
		double back_maximum = maximum;
		for(int i = 0; i < len; i++)
		{
			if (buffer[prev].maximum > back_maximum) break; // Stop propagation
			//
			buffer[prev].maximum = (int)back_maximum; // Update maximum in the future
			//______________ Go Back
			prev--;
			if (prev < 0) prev = ACG_LENGTH - 1;
			//
			back_maximum *= forwardGain;
		}
	}
	//_________________________________ Go Next
	position++;
	if (position == ACG_LENGTH) position = 0;
	//
	maximum *= backwardGain;
	if (data.maximum == 0) return data.value;
	if (data.maximum < (int)maxGain) data.maximum = (int)maxGain;
	return (int)(data.value*ACG_MAX_VAL / data.maximum);
}

//_____________________________________________________________________ Delay
Delay::Delay(void)
{
	buffer = NULL;
	delay = 0;
	Reset();
}

void Delay::Reset()
{
	position = 0;
	for(int i = 0; i < delay; i++) buffer[i] = 0;
}

Delay::~Delay(void)
{
	if (buffer != NULL) delete [] buffer;
}

int Delay::ComputeOutput(int input)
{
	const int data = buffer[position];
	//
	buffer[position] = input;
	//_________________________________ Go Next
	position++;
	if (position == delay) position = 0;
	return data;
}

bool Delay::SetDelay(int delay)
{
	if (buffer != NULL) delete [] buffer;
	buffer = new int[delay];
	if (buffer == NULL)
	{
		this->delay = 0;
		return false;
	}
	this->delay = delay;
	for(int i = 0; i < delay; i++) buffer[i] = 0;
	position = 0;
	return true;
}

//_____________________________________________________________________ Assessment

//_____________________________________________________________________Normalization
Normalization::Normalization()
{
	mean = 0.0;
	std = 0.0;
}

Normalization::~Normalization()
{
}

void Normalization::prestd(valarray<double>& values)
{
	const unsigned int size = (int)values.size();
	if (size<=0) return;
	mean = Math::Statistics::MeanValue(values);
	std = Math::Statistics::StandardDeviation(values);
	for(unsigned int i = 0; i<size; i++)
	{
		values[i]=(values[i]-mean)/std;
	}
}

void Normalization::poststd(valarray<double>& values)
{
	const unsigned int size = (int)values.size();
	if (size<=0) return;
	for(unsigned int i = 0; i<size; i++)
	{
		values[i]=values[i]*std+mean;
	}
}


//_____________________________________________________________________ Trender
Trender::Trender()
{
	m = 0.0;
	b = 0.0;
}

Trender::~Trender()
{
}

void Trender::CalculateMB(bool leastSquares, valarray<double>& source)
{
	const unsigned int count = (int)source.size();
	if (count<2) return;
	unsigned int i;
	double x, y;
	m = 0.0;
	b = 0.0;
	if (leastSquares)
	{
		double xmean = (count-1.0)/2.0;
		//
		double ymean = 0.0;
		for(i=0; i<count; i++) ymean +=source[i];
		ymean /= (double)count;
		//
		double xvar =0.0, xy = 0.0;
		for(i=0; i<count; i++)
		{
			x = (double)i-xmean;
			y = source[i]-ymean;
			xvar+=x*x;
			xy+=x*y;
		}
		//*********************** Calculate m and b
		m = xy/xvar;
		b = ymean-m*xmean;
	}
	else
	{
		m = (source[count-1]-source[0])/(double)(count-1);
		b = source[0];
	}
}

void Trender::pretrending(bool leastSquares, valarray<double>& source, valarray<double>& destination)
{
	double y;
	this->CalculateMB(leastSquares, source);
	//_______________________________Pretrending
	const unsigned int count = (int)source.size();
	for(unsigned int i=0; i<count; i++)
	{ 
		y = m*(double)i+b;
		destination[i]=source[i]-y;
	}
}


void Trender::posttrending(valarray<double>& source, valarray<double>& destination)
{
	const unsigned int count = (int)source.size();
	destination.resize(count);
	for(unsigned int i=0; i<count; i++)
	{
		destination[i] = source[i]+m*(double)i+b;
	}
}

//_____________________________________________________________________SyntheticDiv
SyntheticDiv::SyntheticDiv(void)
{
}

SyntheticDiv::~SyntheticDiv(void)
{
}

// Returns F(inX)
double SyntheticDiv::Run(const valarray<double>& inputCoeff, valarray<double>& outputCoeff, double x)
{
	const unsigned int size = (int)inputCoeff.size();
	outputCoeff.resize(size);

	outputCoeff[0]=inputCoeff[0];

	for(unsigned int i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	return outputCoeff[size-1];
}

// Returns F(x)
// and F'(x) in out_dx
double SyntheticDiv::Run(const valarray<double>& inputCoeff, valarray<double>& outputCoeff, double x, double&out_dx)
{
	const unsigned int size = (int)inputCoeff.size();
	unsigned int i = 0;
	//_______________________________________ F(x)
	outputCoeff.resize(size);
	outputCoeff[0]=inputCoeff[0];

	for(i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	//______________________________________ F'(x)
	out_dx = outputCoeff[0];
	for(i=1; i<size-1; i++)
	{
		out_dx = outputCoeff[i]+out_dx*x;
	}
	return outputCoeff[size-1];
}


// Input: the equation coefficiente and a initial guess for x
// Output: the output coeff and the value of x
// Returns the error,
// Xn = Xn-1  -  F(X) / F'(X)
double SyntheticDiv::Newton(const valarray<double>& inputCoeff, valarray<double>& outputCoeff, double& int_out_x)
{
	double prevx = 1.0;
	double fx = 1.0;
	double dx = 0.0;
	double error = 1.0e100;
	for(int i = 0; i <1000; i++)
	{
		fx = Math::SyntheticDiv::Run(inputCoeff, outputCoeff, int_out_x, dx);
		prevx =int_out_x;
		int_out_x -= (fx/dx);
		error = fabs((int_out_x-prevx)/prevx);
		if (error < 1.0e-9) break;
	}
	return error;
}

// Returns F(inX)
complex<double> SyntheticDiv::Run(const valarray<complex<double> >& inputCoeff, valarray<complex<double> >& outputCoeff, complex<double> x)
{
	const unsigned int size = (int)inputCoeff.size();
	outputCoeff.resize(size);

	outputCoeff[0]=inputCoeff[0];

	for(unsigned int i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	return outputCoeff[size-1];
}

// Returns F(x)
// and F'(x) in out_dx
complex<double> SyntheticDiv::Run(const valarray<complex<double> >& inputCoeff, valarray<complex<double> >& outputCoeff, complex<double> x, complex<double>&out_dx)
{
	const unsigned int size = (int)inputCoeff.size();
	unsigned int i = 0;
	//_______________________________________ F(x)
	outputCoeff.resize(size);
	outputCoeff[0]=inputCoeff[0];

	for(i=1; i<size; i++)
	{
		outputCoeff[i]=inputCoeff[i]+outputCoeff[i-1]*x;
	}
	//______________________________________ F'(x)
	out_dx = outputCoeff[0];
	for(i=1; i<size-1; i++)
	{
		out_dx = outputCoeff[i]+out_dx*x;
	}
	return outputCoeff[size-1];
}


// Input: the equation coefficiente and a initial guess for x
// Output: the output coeff and the value of x
// Returns the error,
// Xn = Xn-1  -  F(X) / F'(X)
double SyntheticDiv::Newton(const valarray<complex<double> >& inputCoeff, valarray<complex<double> >& outputCoeff, complex<double>& int_out_x)
{
	complex<double> prevx = 1.0;
	complex<double> fx = 1.0;
	complex<double> dx = 0.0;
	double error = 1.0e100;
	for(int i = 0; i <1000; i++)
	{
		fx = Math::SyntheticDiv::Run(inputCoeff, outputCoeff, int_out_x, dx);
		prevx =int_out_x;
		int_out_x -= (fx/dx);
		error = abs(int_out_x-prevx)/abs(prevx);
		if (error < 1.0e-9) break;
	}
	return error;
}

//_____________________________________________________________________  EigenSystem
EigenSystem::EigenSystem()
{
}

EigenSystem::~EigenSystem()
{
}

void EigenSystem::Sort(valarray<double> &eigen_value, MATRIX& eigen_vector)
{
	const int n = (int)eigen_value.size();
	int i, j, k;
	double tmp = 0.0;
	for (i=0; i < n-1; i++) 
	{
		k = i;
		//_____________________ Sort eigen values
		tmp = eigen_value[k];
		for (j = i; j < n; j++)
		{
			if (eigen_value[j] >= tmp) tmp = eigen_value[k=j];
		}
		if (k != i) 
		{
			eigen_value[k] = eigen_value[i];
			eigen_value[i] = tmp;
			//___________________ Sort eigen vectors
			for (j = 0; j < n; j++) 
			{
				tmp = eigen_vector[j][i];
				eigen_vector[j][i] = eigen_vector[j][k];
				eigen_vector[j][k] = tmp;
			}
		}
	}
}

void EigenSystem::Rotate(MATRIX &a, const double s, const double u, const int i, const int j, const int k, const int m)
{
	const double x = a[i][j];
	const double y = a[k][m];
	a[i][j] = x - s*(y + x*u);
	a[k][m] = y + s*(x - y*u);
}

// Input is a symmetric matrix (it is destroyed after calling the function)
const wchar_t* EigenSystem::Jacobi(MATRIX& input, valarray<double>& eigen_value, MATRIX& eigen_vector)
{
	const int n = (int)input.size();
	if (n == 0)
	{
		eigen_value.resize(0);
		eigen_vector.clear();
		return NULL;
	}

	//______________________________ Check that the input is squared
	if (input[0].size() != n) return L"EigenSystem: the number of rows must be equal to the number of columns";

	//______________________________ Check for simmetry
	int p, q;
	for(p = 0; p < n; p++)
	{
		for(q = p; q < n; q++)
		{
			if (input[p][q] != input[q][p]) return L"EigenSystem: the matrix must be symmetric";
		}
	}

	
	
	//______________________________ Memory allocation
	valarray<double> b, z;
	try
	{
		b.resize(n);
		z.resize(n);
		if (eigen_value.size() != n) eigen_value.resize(n);
		if (eigen_vector.size() != n)
		{
			eigen_vector.resize(n);
			for(p = 0; p < n; p++) eigen_vector[p].resize(n);
		}
	}
	catch(std::bad_alloc& )
	{
		return L"EigenSystem::Jacobi: No enough memory";
	}
	
	for(p = 0; p < n; p++) 
	{
		for (q = 0; q < n; q++) eigen_vector[p][q] = 0.0;
		eigen_vector[p][p]=1.0;
	}

	for (p = 0; p < n; p++) 
	{
		eigen_value[p] = input[p][p];
		b[p] = input[p][p];
		z[p] = 0.0;
	}
	
	int i;
	double sum = 0.0;
	double threshold = 0.0;
	double tolerance = 0.0;
	int numRotations = 0;
	double diff = 0.0;
	double tmp = 0.0;
	double theta = 0.0;
	double k = 0.0;
	double s = 0.0;
	double u = 0.0;
	int y = 0;
	for (i = 1; i <= 50; i++) 
	{
		sum = 0.0;
		for (p = 0; p < n-1; p++) 
		{
			for (q = p+1; q < n; q++)
			{
				sum += abs(input[p][q]);
			}
		}
		if (sum == 0.0) 
		{
			Sort(eigen_value, eigen_vector);
			return NULL;
		}
		if (i < 4)
		{
			threshold = 0.2*sum/(n*n);
		}
		else
		{
			threshold = 0.0;
		}
		for (p = 0; p < n-1; p++) 
		{
			for (q = p+1; q < n; q++) 
			{
				tolerance = 100.0*abs(input[p][q]);
				if (i > 4 && (fabs(eigen_value[p])+tolerance) == fabs(eigen_value[p]) && (fabs(eigen_value[q])+tolerance)  == fabs(eigen_value[q]))
				{
					input[p][q]=0.0;
				}
				else if (abs(input[p][q]) > threshold) 
				{
					diff = eigen_value[q] - eigen_value[p];
					if ((fabs(diff)+tolerance) == fabs(diff))
					{
						tmp = (input[p][q])/diff;
					}
					else 
					{
						theta = 0.5*diff/(input[p][q]);
						tmp = 1.0/(abs(theta)+sqrt(1.0+theta*theta));
						if (theta < 0.0) tmp *= -1.0;
					}
					k = 1.0/sqrt(1+tmp*tmp);
					s = tmp*k;
					u = s /(1.0+k);
					diff = tmp*input[p][q];
					z[p] -= diff;
					z[q] += diff;
					eigen_value[p] -= diff;
					eigen_value[q] += diff;
					input[p][q] = 0.0;
					for (y = 0; y < p; y++) Rotate(input, s, u, y, p, y, q);
					for (y = p+1; y < q; y++) Rotate(input, s, u, p, y, y, q);
					for (y = q+1; y < n; y++) Rotate(input, s, u, p, y, q, y);
					for (y = 0; y < n; y++) Rotate(eigen_vector, s, u, y, p, y, q);
					++numRotations;
				}
			}
		}
		for (p = 0; p < n; p++) 
		{
			b[p] += z[p];
			eigen_value[p] = b[p];
			z[p] = 0.0;
		}
	}
	return L"EigenSystem::Jacobi: Too many iterations";
}


} //____________________________________________________ namespace Math::End

namespace Nn //________________________________________ namespace Nn::Ini
{

//_____________________________________________________________________ Scaler
Scaler::Scaler()
{
	Constructor();
}

Scaler::~Scaler()
{
}

Scaler::Scaler(const Scaler& init)
{
	Constructor();
	Copy(init);
}

Scaler& Scaler::operator=(const Scaler& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Scaler::Copy(const Scaler &init)
{
	if (init.size<=0) return;
	if (init.data)
	{
		this->data = new Nn::ScalingInfo[init.size];
		if (this->data==NULL) return;
		::memcpy(data, init.data, init.size*sizeof(Nn::ScalingInfo));
		this->size = init.size;
	}
}

void Scaler::Constructor()
{
	//errorDescr[0] = '\0';
	size = 0;
	data = NULL;
}

void Scaler::Delete()
{
	size = 0;
	if (data) delete [] data;
	data = NULL;
}

void Scaler::GetDescription(wchar_t* description, int length)
{
	_snwprintf_s(description, length, _TRUNCATE, L"%d", size);
}

bool Scaler::Create(int count)
{
	Delete();
	this->data = new Nn::ScalingInfo[count];
	if (this->data==NULL) return false;
	size = count;
	for(int i = 0; i<count; i++)
	{
		data[i].minimum = 0.0;
		data[i].maximum = 0.0;
		//data[i].processingIndex = 1.0;
	}
	return true;
}

bool Scaler::AutoSet(MATRIX& input)
{
	const int rows = (int)input.size();
	const int cols = input.size() == 0 ? 0 : (int)input[0].size();
	if (rows<=0) return false;
	if (cols<=0) return false;
	if (Create(cols)==false) return false;

	double minimum = 0.0, maximum = 0.0;
	int i, j;
	for(j=0; j<cols; j++)
	{
		minimum = input[0][j];
		maximum = minimum;
		for(i=1; i<rows; i++)
		{
			if (input[i][j]>maximum) maximum = input[i][j];
			if (input[i][j]<minimum) minimum = input[i][j];
		}
		data[j].minimum = minimum;
		data[j].maximum = maximum;
	}
	return true;
}

bool Scaler::AutoSet(MATRIXC& input)
{
	const int rows = (int)input.size();
	const int cols = input.size() == 0 ? 0 : (int)input[0].size();
	if (rows<=0) return false;
	if (cols<=0) return false;
	if (Create(cols)==false) return false;

	double minimum = 0.0, maximum = 0.0;
	int i, j;
	double value;
	for(j=0; j<cols; j++)
	{
		minimum = input[0][j].real();
		maximum = minimum;
		for(i=0; i<rows; i++)
		{
			value = input[i][j].real();
			if (value>maximum) maximum = value;
			if (value<minimum) minimum = value;
			//
			value = input[i][j].imag();
			if (value>maximum) maximum = value;
			if (value<minimum) minimum = value;
		}
		data[j].minimum = minimum;
		data[j].maximum = maximum;
	}
	return true;
}

bool Scaler::Save(const wchar_t* filename)
{
	Sys::File file;
	if (file.CreateForWritting(filename)==false) return false;
	return this->Save(file);
}

bool Scaler::Save(Sys::File& file)
{
	if (file.Write(&size, sizeof(int)) != sizeof(int)) return false;
	const int bytes = size*sizeof(Nn::ScalingInfo);
	return (file.Write(data, bytes) == bytes);
}

bool Scaler::Load(const wchar_t* filename)
{
	Sys::File file;
	if (file.CreateForReading(filename)==false) return false;
	return Load(file);
}

bool Scaler::Load(Sys::File& file)
{
	Delete();
	int new_size = 0;
	//_____________________________________________ read size
	if (file.Read(&new_size, sizeof(int)) != sizeof(int)) return false;
	if (new_size==0) return true;
	//
	if (this->Create(new_size)==false) return false;
	const int bytes = new_size*sizeof(Nn::ScalingInfo);
	return (file.Read(data, bytes) == bytes);
}

bool Scaler::Set(int index, double minimum, double maximum)
{
	ScalingInfo si;
	si.minimum = minimum;
	si.maximum = maximum;
	//si.processingIndex = processingIndex;
	return Set(index, si);
}

bool Scaler::Set(int index, ScalingInfo& si)
{
	if (index<0 || index>=size) return false;
	//if (si.processingIndex != 1.0) // Be sure minimum and maximum are simmetric
	//{
	//	const double max_tmp = MAXIMUM(fabs(si.minimum), fabs(si.maximum));
	//	si.minimum = -max_tmp;
	//	si.maximum = max_tmp;
	//}
	data[index] = si;
	return true;
}

bool Scaler::GetScalingInfo(int index, ScalingInfo& si)
{
	if (index<0 || index>=size) return false;
	si = data[index];
	return true;
}

bool Scaler::Get(int index, double& minimum, double& maximum)
{
	if (index<0 || index>=size) return false;
	minimum = data[index].minimum;
	maximum = data[index].maximum;
	//processingIndex = data[index].processingIndex;
	return true;
}

bool Scaler::operator==(const Scaler& init) const
{
	if (size != init.size) return false;
	for(int i = 0; i<size; i++)
	{
		if (this->data[i].minimum != init.data[i].minimum) return false;
		if (this->data[i].maximum != init.data[i].maximum) return false;
		//if (this->data[i].processingIndex != init.data[i].processingIndex) return false;
	}
	return true;
}

bool Scaler::operator!=(const Scaler& init) const
{
	if (size != init.size) return true;
	for(int i = 0; i<size; i++)
	{
		if (this->data[i].minimum != init.data[i].minimum) return true;
		if (this->data[i].maximum != init.data[i].maximum) return true;
		//if (this->data[i].processingIndex != init.data[i].processingIndex) return true;
	}
	return false;
}

//To: -0.9 to 0.9
wchar_t* Scaler::ScaleToStandardRange(const valarray<double>& input, valarray<double>& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int cols = (int)input.size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	int j;
	double range = 1.0;
	double minOut = 0.0;

	if (output.size() != cols)
	{
		output.resize(cols);
	}
	for(j=0; j<cols; j++)
	{
		if (data[j].maximum == 0.0 && data[j].minimum == 0.0) //__________________No scaling
		{
			output[j] = input[j];
		}
		else //___________________________________________________________ Scaling
		{
			range = data[j].maximum-data[j].minimum;
			if (range == 0.0) range = 1.0;
			output[j] = (1.8*(input[j]-data[j].minimum)/range)-0.9;  // -0.9 to 0.9
		}
	}
	return NULL;
}

//To: -0.9/sqrt(2) to 0.9/sqrt(2)
wchar_t* Scaler::ScaleToStandardRange(const valarray<complex<double> >& input, valarray<complex<double> >& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int cols = (int)input.size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	int j;
	double range = 1.0;
	double minOut = 0.0;
	const double delta = 1.8/sqrt(2.0);
	const double minLevel = 0.9/sqrt(2.0);

	if (output.size() != cols)
	{
		output.resize(cols);
	}
	for(j=0; j<cols; j++)
	{
		if (data[j].maximum == 0.0 && data[j].minimum == 0.0) //__________________No scaling
		{
			output[j] = input[j];
		}
		else //___________________________________________________________ Scaling
		{
			range = data[j].maximum-data[j].minimum;
			if (range == 0.0) range = 1.0;
			output[j].real((delta*(input[j].real()-data[j].minimum)/range)-minLevel);  // -0.64 to 0.64
			output[j].imag((delta*(input[j].imag()-data[j].minimum)/range)-minLevel);  // -0.64 to 0.64
		}
	}
	return NULL;
}

//To: -0.9 to 0.9
wchar_t*  Scaler::ScaleToStandardRange(const MATRIX& input, MATRIX& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	if (Math::Oper::CreateMatrix(output, rows, cols) == false) return L"No enough memory to scale the data set";
	wchar_t * error = NULL;
	for(int i=0; i<rows; i++)
	{
		error = ScaleToStandardRange(input[i], output[i]);
		if (error) return error;
	}
	return NULL;
}

//To: -0.64 to 0.64
wchar_t*  Scaler::ScaleToStandardRange(const MATRIXC& input, MATRIXC& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	if (Math::Oper::CreateMatrix(output, rows, cols) == false) return L"No enough memory to scale the data set";
	wchar_t * error = NULL;
	for(int i=0; i<rows; i++)
	{
		error = ScaleToStandardRange(input[i], output[i]);
		if (error) return error;
	}
	return NULL;
}

// This is for Kohonen networks
// It scales to the range [-1 1]
// The ouput matrix has an extra column for the synthetic input (initially set to zero)
wchar_t* Scaler::ScaleTo11(const MATRIX& input, MATRIX& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	if (Math::Oper::CreateMatrix(output, rows, cols+1) == false) return L"No enough memory to scale the data set";
	wchar_t * error = NULL;
	for(int i=0; i<rows; i++)
	{
		error = ScaleTo11(input[i], output[i]);
		if (error) return error;
	}
	return NULL;
}

// This is for Kohonen networks
//It scales to the range [-1.0 1.0]
//The output has an extra column for the synthetic input (initially set to zero)
wchar_t* Scaler::ScaleTo11(const valarray<double>& input, valarray<double>& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int cols = (int)input.size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	int j;
	double range = 1.0;
	double minOut = 0.0;

	if (output.size() != cols+1)
	{
		output.resize(cols+1);
	}
	for(j=0; j<cols; j++)
	{
		if (data[j].maximum == 0.0 && data[j].minimum == 0.0) //__________________No scaling
		{
			output[j] = input[j];
		}
		else //___________________________________________________________ Scaling
		{
			range = data[j].maximum-data[j].minimum;
			if (range == 0.0) range = 1.0;
			output[j] = (2.0*(input[j]-data[j].minimum)/range)-1.0;  // -1.0 to 1.0
		}
	}
	output[cols] = 0.0; // Synthetic input, initially set to zero
	return NULL;
}

wchar_t* Scaler::ScaleFromStandardRange(const valarray<double>& input, valarray<double>& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int cols = (int)input.size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	int j;
	double range = 1.0;
	double minOut = 0.0;

	if (output.size() != cols)
	{
		output.resize(cols);
	}
	for(j=0; j<cols; j++)
	{
		if (data[j].maximum == 0.0 && data[j].minimum == 0.0)//______ No Processing + No scaling
		{
			output[j] = input[j];
		}
		else//______________________________________________No Processing + Scaling
		{
			range = data[j].maximum-data[j].minimum;
			output[j] = (range*(input[j]+0.9)/1.8)+data[j].minimum;
		}
	}
	return NULL;
}

wchar_t* Scaler::ScaleFromStandardRange(const valarray<complex<double> >& input, valarray<complex<double> >& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int cols = (int)input.size();
	if (cols != size) return L"The number of columns in the data set does not match the size of the scaler";
	int j;
	double range = 1.0;
	double minOut = 0.0;
	const double delta = 1.8/sqrt(2.0);
	const double minLevel = 0.9/sqrt(2.0);

	if (output.size() != cols)
	{
		output.resize(cols);
	}
	for(j=0; j<cols; j++)
	{
		if (data[j].maximum == 0.0 && data[j].minimum == 0.0)//______ No scaling
		{
			output[j] = input[j];
		}
		else//______________________________________________ Scaling
		{
			range = data[j].maximum-data[j].minimum;
			output[j].real((range*(input[j].real()+minLevel)/delta)+data[j].minimum);
			output[j].imag((range*(input[j].imag()+minLevel)/delta)+data[j].minimum);
		}
	}
	return NULL;
}

wchar_t*  Scaler::ScaleFromStandardRange(const MATRIX& input, MATRIX& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	if (cols!=size) return L"The number of columns in the data set does not match the size of the scaler";
	if (Math::Oper::CreateMatrix(output, rows, cols) == false) return L"No enough memory to scale the data set";
	wchar_t * error = NULL;
	for(int i=0; i<rows; i++)
	{
		error = ScaleFromStandardRange(input[i], output[i]);
		if (error) return error;
	}
	return NULL;
}

wchar_t*  Scaler::ScaleFromStandardRange(const MATRIXC& input, MATRIXC& output)
{
	if (data == NULL || size == 0) return L"The scaler has not been created";
	const int rows = (int)input.size();
	if (rows == 0)
	{
		output.clear();
		return NULL;
	}
	const int cols = (int)input[0].size();
	if (cols!=size) return L"The number of columns in the data set does not match the size of the scaler";
	if (Math::Oper::CreateMatrix(output, rows, cols) == false) return L"No enough memory to scale the data set";
	wchar_t * error = NULL;
	for(int i=0; i<rows; i++)
	{
		error = ScaleFromStandardRange(input[i], output[i]);
		if (error) return error;
	}
	return NULL;
}

void Scaler::GetText(int index, wchar_t* buffer, int buffer_length)
{
	if (index<0 || index>=size) 	
	{
		_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"Invalid scaler index");
		return;
	}
	if (data == NULL)
	{
		_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"The scaler has not been created");
		return;
	}

	//_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"[%g   %g] pi=%.1f",
	//	data[index].minimum, data[index].maximum, data[index].processingIndex);
	_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"[%g   %g]", data[index].minimum, data[index].maximum);
}

int Scaler::GetSize()
{
	return size;
}

//__________________________________________________________________ Tanh
double Nn::Tanh::scale = 0.0;
double Nn::Tanh::funcTable[NN_AF_TABLE_LENGTH];
double Nn::Tanh::deriTable[NN_AF_TABLE_LENGTH];

Tanh::Tanh(void)
{
	if (scale == 0.0)
	{
		scale = (double)(NN_AF_TABLE_LENGTH-1)/(double)NN_AF_TANHLIM;
		for(int i=0; i<NN_AF_TABLE_LENGTH; i++)
		{
			funcTable[i]=tanh(1.5*(double)i/scale);
			if (i != 0) 
			{
				deriTable[i-1]= funcTable[i]-funcTable[i-1];
			}
		}
	}
}

Tanh::~Tanh(void)
{
}

double Tanh::Func(double x)
{
	if (x>NN_AF_TANHLIM) return 1.0;
	if (x<-NN_AF_TANHLIM) return -1.0;
	double xd = fabs(x*scale);
	int i = (int)xd;
	double y = funcTable[i]+deriTable[i]*(xd-i); 
	return (x>=0.0) ? y : -y;
}

double Tanh::Derivative(double y)
{
	return 1.5 * (1.0 - y * y) ;
}

double Tanh::InverseFunc(double y)
{
	//if (y<0) return -20.0;
	//if (y>0) return 20.0;
	if (y < -NN_AF_LIM) y = -NN_AF_LIM;
	if (y > NN_AF_LIM) y = NN_AF_LIM;
	return 0.333333333333333 * log ( (1.0 + y) / (1.0 - y) ) ;
}

double Tanh::GetNeuronOn(void)
{
	return 0.9;
}

double Tanh::GetNeuronOff(void)
{
	return -0.9;
}

double Tanh::GetClassificationThreshold(void)
{
	return 0.0;
}

void Tanh::ShowError(HWND hWnd)
{
	const double x1 = -20.0;
	const double x2 = 20.0;
	const int length = 32000;
	const double delta = (x2-x1)/length;
	double x = 0.0;
	double y = 0.0;
	double mse = 0.0;
	//Win::Clipboard cb;

	// Reading or writing file
	//DWORD dwWritten, dwWrite = 0;
	wchar_t texto[256];

	//HANDLE hFile = CreateFile(_T("C:\\hola.csv"), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

	//if (hFile == INVALID_HANDLE_VALUE) return;

	for(int i=0; i<length; i++)
	{
		x = x1+i*delta;
		y = GetExactValue(x) - Func(x);
		mse += (y*y);
		//dwWrite = _sntprintf(texto, 256, _T("%.14f, %.14f, %.14f\r\n"), x, getExactValue(x), func(x));
		//::WriteFile(hFile, texto, dwWrite, &dwWritten, NULL);
	}
	_snwprintf_s(texto, 256, _TRUNCATE, L"%d\t%g", NN_AF_TANHLIM, mse/length);
	::MessageBox(hWnd, texto, L"mse", MB_OK);
	//Win::Clipboard::CopyTextToClipboard(hWnd, texto);

	//if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
}

double Tanh::GetExactValue(double x)
{
	return tanh(1.5*x);
}

//__________________________________________________________ Layer
Layer::Layer(void)
{

}

Layer::~Layer(void)
{
}

Layer::Layer(const Layer& init)
{
	//Constructor();
	Copy(init);
}

Layer& Layer::operator=(const Layer& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Layer::Copy(const Layer &init)
{
	weight = init.weight;
	output = init.output;
}

double Layer::OutputDerivative(const int index)
{
	const double value  = output[0][index];
	return 1.5 * (1.0 - value * value) ;
}

// Computes the output for the input in the row rowInputIndex
// output has only one row
void Layer::ComputeOutput(const MATRIX& input, int rowInputIndex)
{
	//const int numOut = (output.size() == 0) ? 0 : output[0].size();
	//if (numOut == 0) return;
	//const int numWeights = (weight.size() == 0) ? 0: weight[0].size();
	//double* out = &(output[0])[0];
	//double sum;
	//double *in;
	//double *we;
	//int i, j;
	//for(i=0; i<numOut; i++, out++)
	//{
	//	sum = 0.0;
	//	in = &input[rowInputIndex][0];
	//	we = &weight[i][0];
	//	for(j=0; j<numWeights-1; j++, in++, we++)
	//	{
	//		sum += ( (*in)*(*we) );
	//	}
	//	sum +=weight[i][numWeights-1]; //bias
	//	*out = activation.Func(sum);
	//}


	const int numOut = (output.size() == 0) ? 0 : (int)output[0].size();
	const int numWeights = (weight.size() == 0) ? 0 : (int)weight[0].size();
	if (numWeights == 0) return;
	double sum = 0.0;
	int i, j;
	for(i=0; i<numOut; i++)
	{
		sum = 0.0;
		for(j=0; j<numWeights-1; j++)
		{
			sum+= (input[rowInputIndex][j]*weight[i][j]);
		}
		sum +=weight[i][numWeights-1]; //bias
		output[0][i] = activation.Func(sum);
	}
}

void Layer::Delete()
{
	this->weight.clear();
	this->output.clear();
}

void Layer::Agitate(double perturbRatio, Nn::Layer& source)
{
	const int rows = (int)weight.size();
	if (rows <= 0) return;
	const int cols = (rows == 0) ? 0 : (int)weight[0].size();
	if (cols <= 0) return;
	//
#ifdef _DEBUG
	const int rowsSource = (int)source.weight.size();
	const int colsSource = (rowsSource == 0) ? 0 : (int)source.weight[0].size();
	if (rows != rowsSource) throw L"Nn::Layer::Agitate size error in the number of rows";
	if (cols != colsSource) throw L"Nn::Layer::Agitate size error in the number of columns";
#endif
	std::tr1::uniform_real<double> dist(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);
	const double originalRatio = 1.0 - perturbRatio;
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			weight[i][j] = originalRatio * source.weight[i][j] + perturbRatio * dist(Math::Statistics::random_generator);
		}
	}
}

void Layer::Initialize()
{
	const int rows = (int)weight.size();
	if (rows<=0) return;
	const int cols = (weight.size() == 0) ? 0 : (int)weight[0].size();
	if (cols<=0) return;
	std::tr1::uniform_real<double> dist(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			weight[i][j] = dist(Math::Statistics::random_generator);
		}
	}
}

//__________________________________________________________ LayerC
LayerC::LayerC(void)
{

}

LayerC::~LayerC(void)
{
}

LayerC::LayerC(const LayerC& init)
{
	//Constructor();
	Copy(init);
}

LayerC& LayerC::operator=(const LayerC& init)
{
	Delete();
	Copy(init);
	return *this;
}

void LayerC::Copy(const LayerC &init)
{
	weight = init.weight;
	output = init.output;
}

void LayerC::InverseActivationFunction(const complex<double>& output, complex<double>& input)
{
	double output_magnitude = sqrt(output.real()*output.real() + output.imag()*output.imag());
	if (output_magnitude < 1.0e-100) output_magnitude = 1.0e-100;
	const double input_magnitude = activation.InverseFunc(output_magnitude);
	const double level = input_magnitude/output_magnitude;
	input.real(level*output.real());
	input.imag(level*output.imag());
}

// This functions updates this->output and returns the derivatives: real_real, imag_imag and real_imag
void LayerC::ComputeOutputAndDerivative(const MATRIXC& input, int rowInputIndex, valarray<Nn::ComplexDerivative>& out_derivative)
{
	const int numOut = (output.size() == 0) ? 0 : (int)output[0].size();
	const int numWeights = (weight.size() == 0) ? 0 : (int)weight[0].size();
	if (numWeights == 0) return;
	double sum_real = 0.0;
	double sum_imag = 0.0;
	int i, j;
	double level;
	double magnitude;
	double simple_derivative;
	double squared_magnitude;
	double diff;
	for(i=0; i<numOut; i++)
	{
		sum_real = 0.0;
		sum_imag = 0.0;
		for(j=0; j<numWeights-1; j++)
		{
			sum_real += (input[rowInputIndex][j].real()*weight[i][j].real()-input[rowInputIndex][j].imag()*weight[i][j].imag());
			sum_imag += (input[rowInputIndex][j].real()*weight[i][j].imag()+input[rowInputIndex][j].imag()*weight[i][j].real());
		}
		sum_real += weight[i][numWeights-1].real(); //bias
		sum_imag += weight[i][numWeights-1].imag(); //bias
		//_______________________________________ Compute magnitude 
		squared_magnitude = sum_real*sum_real + sum_imag*sum_imag;
		if (squared_magnitude < 1.0e-100) squared_magnitude = 1.0e-100;
		magnitude = sqrt(squared_magnitude);
		//_______________________________________ Activation
		level = activation.Func(magnitude);
		simple_derivative = activation.Derivative(level);
		//
		level /= magnitude;
		output[0][i].real(level*sum_real);
		output[0][i].imag(level*sum_imag);
		//_______________________________________ Derivatives
		diff = (simple_derivative - level)/squared_magnitude;
		out_derivative[i].real_real = level + sum_real*sum_real*diff;
		out_derivative[i].imag_imag = level + sum_imag*sum_imag*diff;
		out_derivative[i].real_imag = sum_real*sum_imag*diff;
	}
}

// This functions updates this->output
void LayerC::ComputeOutput(const MATRIXC& input, int rowInputIndex)
{
	if (output.size() == 0) return;
	if (weight.size() == 0) return;
	const int numOut = (int)output[0].size();
	if (numOut == 0) return;
	const int numWeights = (int)weight[0].size();
	if (numWeights == 0) return;
	double sum_real = 0.0;
	double sum_imag = 0.0;
	int i, j;
	double level;
	double magnitude;
	for(i=0; i<numOut; i++)
	{
		sum_real = 0.0;
		sum_imag = 0.0;
		for(j=0; j<numWeights-1; j++)
		{
			sum_real += (input[rowInputIndex][j].real()*weight[i][j].real()-input[rowInputIndex][j].imag()*weight[i][j].imag());
			sum_imag += (input[rowInputIndex][j].real()*weight[i][j].imag()+input[rowInputIndex][j].imag()*weight[i][j].real());
		}
		sum_real += weight[i][numWeights-1].real(); //bias
		sum_imag += weight[i][numWeights-1].imag(); //bias
		//_______________________________________ Compute magnitude 
		magnitude = sqrt(sum_real*sum_real + sum_imag*sum_imag);
		if (magnitude <= 1.0e-100) magnitude = 1.0e-100;
		//_______________________________________ Activation
		level = activation.Func(magnitude);
		level /= magnitude;
		output[0][i].real(level*sum_real);
		output[0][i].imag(level*sum_imag);
	}
}

void LayerC::Delete()
{
	this->weight.clear();
	this->output.clear();
}

void LayerC::Agitate(double perturbRatio, Nn::LayerC& source)
{
	const int rows = (int)weight.size();
	if (rows <= 0) return;
	const int cols = (rows == 0) ? 0 : (int)weight[0].size();
	if (cols <= 0) return;
	//
#ifdef _DEBUG
	const int rowsSource = (int)source.weight.size();
	const int colsSource = (rowsSource == 0) ? 0 : (int)source.weight[0].size();
	if (rows != rowsSource) throw L"Nn::Layer::Agitate size error in the number of rows";
	if (cols != colsSource) throw L"Nn::Layer::Agitate size error in the number of columns";
#endif
	std::tr1::uniform_real<double> dist(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);
	const double originalRatio = 1.0 - perturbRatio;
	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			weight[i][j].real(originalRatio * source.weight[i][j].real() + perturbRatio * dist(Math::Statistics::random_generator));
			weight[i][j].imag(originalRatio * source.weight[i][j].imag() + perturbRatio * dist(Math::Statistics::random_generator));
		}
	}
}

void LayerC::Initialize()
{
	const int rows = (int)weight.size();
	if (rows<=0) return;
	const int cols = (weight.size() == 0) ? 0 : (int)weight[0].size();
	if (cols<=0) return;
	std::tr1::uniform_real<double> dist(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			weight[i][j].real(dist(Math::Statistics::random_generator));
			weight[i][j].imag(dist(Math::Statistics::random_generator));
		}
	}
}


//_____________________________________________________________________ LayerNet
MATRIX LayerNet::trainSetScaledIn;
MATRIX LayerNet::trainSetScaledTarget;
MATRIX LayerNet::svd_a;
MATRIX LayerNet::svd_u;
MATRIX LayerNet::svd_v;
MATRIX LayerNet::svd_y;
valarray<double> LayerNet::deltaOutput;
valarray<double> LayerNet::deltaHidden2;

LayerNet::LayerNet()
{
	Constructor();
}

LayerNet::~LayerNet()
{
}

LayerNet::LayerNet(const LayerNet& init)
{
	Constructor();
	Copy(init);
}

LayerNet& LayerNet::operator=(const LayerNet& init)
{
	Delete();
	Copy(init);
	return *this;
}

int LayerNet::GetMinNumTrainCases()
{
	const int layerCount = GetLayerCount();
	int rows = 0;
	int numWeights = 0;

	if (layerCount == 2)
	{       
		rows = (int)layerOut.weight.size();
		if (rows == 0) return 0;
		numWeights = (int)layerOut.weight[0].size() * rows;
	}
   else if (layerCount == 3)
   {          
	   rows = (int)layerHid1.weight.size();
		if (rows == 0) return 0;
		numWeights = (int)layerHid1.weight[0].size() * rows;
		//_________ ignore output layer
	}
	else if (layerCount == 4)
	{                    
		rows = (int)layerHid1.weight.size();
		if (rows > 0) numWeights += ((int)layerHid1.weight[0].size() * rows);
		//
		rows = (int)layerHid2.weight.size();
		if (rows > 0) numWeights += ((int)layerHid2.weight[0].size() * rows);
		//_________ ignore output layer
	}
	return (int)(2.2*numWeights+0.99999999);
}

void LayerNet::CopyThisToPoint(valarray<double>& point) const
{
	const int layerCount = GetLayerCount();
	int r, c, j=0;

	if (layerCount >= 2)
	{
		//_______________________________________ Copy Output Layer
		const int rows = (int)layerOut.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) point[j++] = layerOut.weight[r][c];
		}
	}
	if (layerCount >= 4)
	{
		//_______________________________________ Copy Hidden 2 Layer
		const int rows = (int)layerHid2.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerHid2.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) point[j++] = layerHid2.weight[r][c];
		}
	}
	if (layerCount >= 3)
	{
		//_______________________________________ Copy Hidden1 Layer
		const int rows = (int)layerHid1.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerHid1.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) point[j++] = layerHid1.weight[r][c];
		}
	}
}

void LayerNet::CopyPointToThis(const valarray<double>& point)
{
	const int layerCount = GetLayerCount();
	int r, c, j=0;

	if (layerCount >= 2)
	{
		//_______________________________________ Copy Output Layer
		const int rows = (int)layerOut.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) layerOut.weight[r][c] = point[j++];
		}
	}
	if (layerCount >= 4)
	{
		//_______________________________________ Copy Hidden 2 Layer
		const int rows = (int)layerHid2.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerHid2.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) layerHid2.weight[r][c] = point[j++];
		}
	}
	if (layerCount >= 3)
	{
		//_______________________________________ Copy Hidden 1 Layer
		const int rows = (int)layerHid1.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerHid1.weight[0].size();
		for(r=0; r<rows; r++) 
		{
			for(c=0; c<cols; c++) layerHid1.weight[r][c] = point[j++];
		}
	}
}

void LayerNet::Copy(const LayerNet &init)
{
	this->layerHid1 = init.layerHid1;
	this->layerHid2 = init.layerHid2;
	this->layerOut = init.layerOut;
	this->scalerInput = init.scalerInput;
	this->scalerOutput = init.scalerOutput;
	this->hasTrainSet = false;
	//wcscpy_s(this->text, NN_LAYERNET_TEXTMAX, init.text);
	this->trainSetScaledIn.clear();
	this->trainSetScaledTarget.clear();
}

double LayerNet::EvaluateFunc(const valarray<double>& x)
{
	this->CopyPointToThis(x);
	int i, j;
	const int rows = (int)trainSetScaledIn.size();
	double divergence;
	const int numOut = GetOutputCount();
	const int layerCount = GetLayerCount();
	double gradError = 0.0;

	if (layerCount == 2)
	{
		for(i=0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i);//it updates layerOut.output	
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				gradError += (divergence*divergence);
			}
		}
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		for(i=0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0);
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				gradError += (divergence*divergence);
			}
		}
	}
	else if (layerCount == 4)
	{
		const int numHid1 = GetHidden1NeuronCount();
		const int numHid2 = GetHidden2NeuronCount();
		for(i=0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0);
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				gradError += (divergence*divergence);
			}
		}
	}
	return gradError/(rows*numOut);
}

//void LayerNet::EvaluateGrad(const valarray<double>& x, valarray<double>& outGrad)
void LayerNet::EvaluateFuncAndGrad(const valarray<double>& x, double& Fx, valarray<double>& gradient)
{
	this->CopyPointToThis(x);
	const int gradSize = (int)gradient.size();
	int i, j, m, index=0;

	
	//________________________________________________ Set the gradient to zero
	for(i = 0; i < gradSize; i++) gradient[i] = 0.0;
	//
	const int rows = (int)trainSetScaledIn.size();
	double divergence;
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	double delta = 0.0;
	const int layerCount = GetLayerCount();
	Fx = 0.0;

	if (layerCount == 2)
	{
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerOut.ComputeOutput(trainSetScaledIn, i);//it updates layerOut.output	
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				Fx += (divergence*divergence);
				delta = 2.0*divergence * layerOut.OutputDerivative(j);
				for(m=0; m<numIn; m++) gradient[index++] += (delta * this->trainSetScaledIn[i][m]);
				gradient[index++] += delta;
			}
		}
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0);
			//____________________________________________________________ Output layer gradient
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
				Fx += (divergence*divergence);
				delta = 2.0*divergence * layerOut.OutputDerivative(j);
				deltaOutput[j]= delta;
				for(m=0; m<numHid1; m++)
				{
					gradient[index++] += (delta * layerHid1.output[0][m]);
				}
				gradient[index++] += delta;
			}
			//____________________________________________________________ Hid1 layer gradient
			for(m=0; m<numHid1; m++)
			{
				delta = 0.0;
				for(j=0; j<numOut; j++)
				{
					delta += deltaOutput[j]*layerOut.weight[j][m];
				}
				delta *= layerHid1.OutputDerivative(m);
				for(j=0; j<numIn; j++) 
				{
					gradient[index++] += (delta*trainSetScaledIn[i][j]);
				}
				gradient[index++] += delta;
			}
		}
	}
	else if (layerCount == 4)
	{
		const int numHid1 = GetHidden1NeuronCount();
		const int numHid2 = GetHidden2NeuronCount();
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0);
			//____________________________________________________________ Output layer gradient
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				Fx += (divergence*divergence);
				delta = 2.0*divergence * layerOut.OutputDerivative(j);
				deltaOutput[j]= delta;
				for(m=0; m<numHid2; m++)
				{
					gradient[index++] += (delta * layerHid2.output[0][m]);
				}
				gradient[index++] += delta;
			}
			//____________________________________________________________ Hid2 layer gradient
			for(m=0; m<numHid2; m++)
			{
				delta = 0.0;
				for(j=0; j<numOut; j++) delta += deltaOutput[j]*layerOut.weight[j][m];
				delta *= layerHid2.OutputDerivative(m);
				deltaHidden2[m]=delta;
				for(j=0; j<numHid1; j++)
				{
					gradient[index++] += (delta*layerHid1.output[0][j]);
				}
				gradient[index++] += delta;
			}
			//____________________________________________________________ Hid1 layer gradient
			for(m=0; m<numHid1; m++)
			{
				delta = 0.0;
				for(j=0; j<numHid2; j++)
				{
					delta += (deltaHidden2[j]*layerHid2.weight[j][m]);
				}
				delta *= layerHid1.OutputDerivative(m);
				for(j=0; j<numIn; j++)
				{
					gradient[index++] += (delta*trainSetScaledIn[i][j]);
				}
				gradient[index++] += delta;
			}
		}
	}
	gradient /= rows;
	Fx = Fx/(rows*numOut);
}

//double LayerNet::EvaluateFuncAndGrad(const valarray<double>& x, valarray<double>& outGrad)
//{
//	this->CopyPointToThis(x);
//	const int gradSize = outGrad.size();
//	int i, j, m, index=0;
//
//	//________________________________________________ Set the gradient to zero
//	for(i = 0 ; i < gradSize; i++) outGrad[i] = 0.0;
//	//
//	const int rows = trainSetScaledIn.size();
//	double divergence;
//	const int numIn = GetInputCount();
//	const int numOut = GetOutputCount();
//	double delta = 0.0;
//	const int layerCount = GetLayerCount();
//	double gradError = 0.0;
//
//	if (layerCount == 2)
//	{
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			layerOut.ComputeOutput(trainSetScaledIn, i);//it updates layerOut.output	
//			for(j=0; j<numOut; j++)
//			{
//				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
//				gradError += (divergence*divergence);
//				delta = 2.0*divergence * layerOut.OutputDerivative(j);
//				for(m=0; m<numIn; m++) outGrad[index++] += delta * trainSetScaledTarget[i][m];
//				outGrad[index++] += delta;
//			}
//		}
//	}
//	else if (layerCount == 3)
//	{
//		const int numHid1 = GetHidden1NeuronCount();
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			layerHid1.ComputeOutput(trainSetScaledIn, i);
//			layerOut.ComputeOutput(layerHid1.output, 0);
//			//____________________________________________________________ Output layer gradient
//			for(j=0; j<numOut; j++)
//			{
//				divergence = layerOut.output[0][j] -trainSetScaledTarget[i][j];
//				gradError += (divergence*divergence);
//				delta = 2.0*divergence * layerOut.OutputDerivative(j);
//				deltaOutput[j]= delta;
//				for(m=0; m<numHid1; m++)
//				{
//					outGrad[index++] += delta * layerHid1.output[0][m];
//				}
//				outGrad[index++] += delta;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numOut; j++)
//				{
//					delta += deltaOutput[j]*layerOut.weight[j][m];
//				}
//				delta *= layerHid1.OutputDerivative(m);
//				for(j=0; j<numIn; j++) 
//				{
//					outGrad[index++] += delta*trainSetScaledIn[i][j];
//				}
//				outGrad[index++] += delta;
//			}
//		}
//	}
//	else if (layerCount == 4)
//	{
//		const int numHid1 = GetHidden1NeuronCount();
//		const int numHid2 = GetHidden2NeuronCount();
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			layerHid1.ComputeOutput(trainSetScaledIn, i);
//			layerHid2.ComputeOutput(layerHid1.output, 0);
//			layerOut.ComputeOutput(layerHid2.output, 0);
//			//____________________________________________________________ Output layer gradient
//			for(j=0; j<numOut; j++)
//			{
//				divergence = layerOut.output[0][j] - trainSetScaledTarget[i][j];
//				gradError += (divergence*divergence);
//				delta = 2.0*divergence * layerOut.OutputDerivative(j);
//				deltaOutput[j]= delta;
//				for(m=0; m<numHid2; m++)
//				{
//					outGrad[index++] += delta * layerHid2.output[0][m];
//				}
//				outGrad[index++] += delta;
//			}
//			//____________________________________________________________ Hid2 layer gradient
//			for(m=0; m<numHid2; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numOut; j++) delta += deltaOutput[j]*layerOut.weight[j][m];
//				delta *= layerHid2.OutputDerivative(m);
//				deltaHidden2[m]=delta;
//				for(j=0; j<numHid1; j++)
//				{
//					outGrad[index++] += delta*layerHid1.output[0][j];
//				}
//				outGrad[index++] += delta;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numHid2; j++)
//				{
//					delta += deltaHidden2[j]*layerHid2.weight[j][m];
//				}
//				delta *= layerHid1.OutputDerivative(m);
//				for(j=0; j<numIn; j++)
//				{
//					outGrad[index++] += delta*trainSetScaledIn[i][j];
//				}
//				outGrad[index++] += delta;
//			}
//		}
//	}
//	outGrad /= rows;
//	return gradError/(rows*numOut);
//}

void LayerNet::Constructor()
{
	hasTrainSet = false;
}

void LayerNet::Delete()
{
	layerHid1.Delete();
	layerHid2.Delete();
	layerOut.Delete();
	scalerInput.Delete();
	scalerOutput.Delete();
	hasTrainSet = false;
	text[0] = '\0';
	//trainSetScaledIn.clear();
	//trainSetScaledTarget.clear();
	//SvdDelete();
}

bool LayerNet::SvdCreate()
{
	// This for regression in Simulated Annealing and Genetic Algorithm for (for one and two hidden layers)
	const int layerCount = GetLayerCount();
	if (layerCount != 3 && layerCount != 4) return false;
	const int numTrainCases = (int)trainSetScaledIn.size();
	const int numOutputs = GetOutputCount();
	const int numInputs = GetInputCount();

	int i, j;
	if (Math::Oper::CreateMatrix(svd_y, numOutputs, numTrainCases) == false) return false;
	//__________________________________________________________  Expected y'
	for(i = 0; i<numOutputs; i++)
	{
		for(j = 0; j<numTrainCases; j++)
		{
			svd_y[i][j] = Nn::Tanh::InverseFunc(trainSetScaledTarget[j][i]); // y = transposed(inv_tanh(trainSetScaledTarget))
		}
	}

	if (layerCount == 3)
	{	
		if (Math::Oper::CreateMatrix(svd_a, numTrainCases, GetHidden1NeuronCount()+1) == false) return false;
		if (Math::Oper::CreateMatrix(svd_u, numTrainCases, GetHidden1NeuronCount()+1) == false) return false;
	}
	else if (layerCount == 4)
	{
		if (Math::Oper::CreateMatrix(svd_a, numTrainCases, GetHidden2NeuronCount()+1) == false) return false;
		if (Math::Oper::CreateMatrix(svd_u, numTrainCases, GetHidden2NeuronCount()+1) == false) return false;
	}
	return true;
}

void LayerNet::SvdDelete()
{
	svd_a.clear();
	svd_u.clear();
	svd_v.clear();
	svd_y.clear();
	svd_s.resize(0);
}

bool LayerNet::DeltaCreate()
{
	const int layerCount = GetLayerCount();
	try
	{
		if (layerCount == 2)
		{
			//deltaOutput.resize(GetOutputCount());
			return true;
		}
		else if (layerCount == 3)
		{
			deltaOutput.resize(GetOutputCount());
			return true;
		}
		else if (layerCount == 4)
		{
			deltaOutput.resize(GetOutputCount());
			deltaHidden2.resize(GetHidden2NeuronCount());
			return true;
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return false;
}

void LayerNet::DeltaDelete()
{
	deltaOutput.resize(0);
	deltaHidden2.resize(0);
}

void LayerNet::GetDescription(wchar_t* description, int length)
{
	const int layerCount = GetLayerCount();
	int rows = 0;
	int inputCount = 0;
	switch(layerCount)
	{
	case 2:
		_snwprintf_s(description, length, _TRUNCATE, L"%d,%d", GetInputCount(), GetOutputCount());
		break;
	case 3:
		_snwprintf_s(description, length, _TRUNCATE, L"%d,%d,%d", GetInputCount(), GetHidden1NeuronCount(), GetOutputCount());
	case 4:
		_snwprintf_s(description, length, _TRUNCATE, L"%d,%d,%d,%d", GetInputCount(), GetHidden1NeuronCount(), GetHidden2NeuronCount(), GetOutputCount());
	}	
}

int LayerNet::GetLayerCount() const
{
	const int hidden1Count = GetHidden1NeuronCount();
	const int hidden2Count = GetHidden2NeuronCount();
	int layerCount = 0;
	if (hidden1Count ==0 && hidden2Count == 0)
	{
		layerCount = 2; // Input and Output Layer
	}
	else if (hidden1Count != 0 && hidden2Count == 0)
	{
		layerCount = 3; // Input, Hidden1 and Output Layer
	}
	else
	{
		layerCount = 4; // Input, Hidden1, Hidden2 and Output Layer
	}
	return layerCount;
}

bool LayerNet::Create(int inputCount, int hidden1Count, int hidden2Count, int outputCount)
{
	Delete();
	//___________________________________________ check and correct input values
	if (inputCount<=0) inputCount = 1;
	if (outputCount<=0) outputCount = 1;
	if (hidden1Count<0) hidden1Count = 0;
	if (hidden2Count<0) hidden2Count = 0;
	if (hidden1Count == 0) hidden2Count = 0;
	if (hidden2Count != 0 && hidden1Count == 0) hidden1Count = 1;
	//___________________________________________ computer layer count
	int layerCount = 0;
	if (hidden1Count ==0 && hidden2Count == 0)
	{
		layerCount = 2; // Input and Output Layer
	}
	else if (hidden1Count != 0 && hidden2Count == 0)
	{
		layerCount = 3; // Input, Hidden1 and Output Layer
	}
	else
	{
		layerCount = 4; // Input, Hidden1, Hidden2 and Output Layer
	}
	//__________________________________________ allocate layers
	bool ok = false;
	switch(layerCount)
	{
	case 2:
		ok = Math::Oper::CreateMatrix(layerOut.weight, outputCount, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	case 3:
		ok = Math::Oper::CreateMatrix(layerHid1.weight, hidden1Count, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerHid1.output, 1, hidden1Count);
		ok = ok && Math::Oper::CreateMatrix(layerOut.weight, outputCount, hidden1Count+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	case 4:
		ok = Math::Oper::CreateMatrix(layerHid1.weight, hidden1Count, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerHid1.output, 1, hidden1Count);
		ok = ok && Math::Oper::CreateMatrix(layerHid2.weight, hidden2Count, hidden1Count+1);
		ok = ok && Math::Oper::CreateMatrix(layerHid2.output, 1, hidden2Count);
		ok = ok && Math::Oper::CreateMatrix(layerOut.weight, outputCount, hidden2Count+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	}
	if (ok==false)
	{
		this->Delete();
		return false;
	}
	if (scalerInput.Create(inputCount) == false)
	{
		Delete();
		return false;
	}
	if (scalerOutput.Create(outputCount) == false)
	{
		Delete();
		return false;
	}
	return true;
}

const wchar_t* LayerNet::Load(const wchar_t* filename)
{
	this->Delete();
	Sys::File file;

	if (file.CreateForReading(filename)== false) return L"The file couldn't be read";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Read(&version, sizeof(int))==false) return L"Unable to read version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Read(&subversion, sizeof(int))==false) return L"Unable to read sub version";
	//
	if (version != NN_NEURAL_LAB_VERSION)// || subversion != NN_NEURAL_LAB_SUBVERSION)
	{
		_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Neural Lab %d.%d does not open files of version %d.%d",
			NN_NEURAL_LAB_VERSION, NN_NEURAL_LAB_SUBVERSION, version, subversion);
		return text;
	}
	//
	if (Sys::SerialAssistant::Load(file, layerHid1.weight) == false) {this->Delete(); return L"Unable to read hidden layer 1";}
	if (layerHid1.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerHid1.output, 1, (int)layerHid1.weight.size()) == false) { this->Delete(); return L"No enough memory for layer hidden 1"; }
	}
	//
	if (Sys::SerialAssistant::Load(file, layerHid2.weight) == false) {this->Delete(); return L"Unable to read hidden layer 2";}
	if (layerHid2.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerHid2.output, 1, (int)layerHid2.weight.size()) == false) { this->Delete(); return L"No enough memory for layer hidden 2"; }
	}
	//
	if (Sys::SerialAssistant::Load(file, layerOut.weight) == false) {this->Delete(); return L"Unable to read output layer";}
	if (layerOut.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerOut.output, 1, (int)layerOut.weight.size()) == false) { this->Delete(); return L"No enough memory for output layer"; }
	}
	//
	if (this->scalerInput.Load(file)==false) {this->Delete(); return L"Unable to read network input scaler";}
	if (this->scalerOutput.Load(file)==false) {this->Delete(); return L"Unable to read network output scaler";}
	return NULL;
}

const wchar_t* LayerNet::Save(const wchar_t* filename)
{
	Sys::File file;
	wchar_t * error = NULL;

	if (file.CreateForWritting(filename)==false) return L"Unable to write file";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Write(&version, sizeof(int))==false) return L"Unable to write version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Write(&subversion, sizeof(int))==false) return L"Unable to write sub version";
	//
	if (Sys::SerialAssistant::Save(file, layerHid1.weight) == false) return L"Unable to save weights from hidden layer 1";
	if (Sys::SerialAssistant::Save(file, layerHid2.weight) == false) return L"Unable to save weights from hidden layer 2";
	if (Sys::SerialAssistant::Save(file, layerOut.weight) == false) return L"Unable to save weights from output layer";
	//
	//
	if (this->scalerInput.Save(file)==false) return L"Unable to save network input scaler";
	if (this->scalerOutput.Save(file)==false) return L"Unable to save network output scaler";
	return NULL;
}

bool LayerNet::SetWeights(int layerIndex, const MATRIX& weights)
{
	const int layerCount = GetLayerCount();
	switch(layerCount)
	{
	case 2:
		if (layerIndex == 3) break; // Output
		return false;
	case 3:
		if (layerIndex == 1) break; // Hidden 1
		if (layerIndex == 3) break; // Output
		return false;
	case 4:
		if (layerIndex == 1) break; // Hidden 1
		if (layerIndex == 2) break; // Hidden 2
		if (layerIndex == 3) break;// Output
		return false;
	}
	if (layerIndex == 1) //______________ Hidden 1
	{
		if (AreMatrixSameSize(layerHid1.weight, weights) == false) return false;
		layerHid1.weight = weights;
		Math::Oper::CreateMatrix(layerHid1.output, 1, (int)weights.size());
		return true;
	}
	else if (layerIndex == 2) //______________ Hidden 2
	{
		if (AreMatrixSameSize(layerHid2.weight, weights) == false) return false;
		layerHid2.weight = weights;
		Math::Oper::CreateMatrix(layerHid2.output, 1, (int)weights.size());
		return true;
	}
	else if (layerIndex == 3) //______________ Output
	{
		if (AreMatrixSameSize(layerOut.weight, weights) == false) return false;
		layerOut.weight = weights;
		Math::Oper::CreateMatrix(layerOut.output, 1, (int)weights.size());
		return true;
	}
	return false;
}

bool LayerNet::AreMatrixSameSize(const MATRIX& a, const MATRIX& b)
{
	if (a.size() != b.size()) return false;
	if (a.size() == 0) return true;
	if (a[0].size() != b[0].size()) return false;
	return true;
}

bool LayerNet::GetActivation(int layerIndex, valarray<double>& activation)
{
	const int layerCount = GetLayerCount();
	if (layerIndex == 1)
	{
		if (layerCount == 2) return false;
		activation = layerHid1.output[0];
		return true;
	}
	else if (layerIndex == 2)
	{
		if (layerCount == 2 || layerCount == 3) return false;
		activation = layerHid2.output[0];
		return true;
	}
	else if (layerIndex == 3)
	{
		activation = layerOut.output[0];
		return true;
	}
	return false;
}

bool LayerNet::GetWeights(int layerIndex, MATRIX& weights)
{
	if (layerIndex == 1)
	{
		weights = layerHid1.weight;
		return true;
	}
	else if (layerIndex == 2)
	{
		weights = layerHid2.weight;
		return true;
	}
	else if (layerIndex == 3)
	{
		weights = layerOut.weight;
		return true;
	}
	return false;
}

int LayerNet::GetInputCount() const
{
	const int layerCount = GetLayerCount();
	int rows = 0;
	int inputCount = 0;
	switch(layerCount)
	{
	case 2:
		rows = (int)layerOut.weight.size();
		inputCount = (rows == 0) ? 0 : (int)layerOut.weight[0].size() - 1;
		break;
	case 3:
	case 4:
		rows = (int)layerHid1.weight.size();
		inputCount = (rows == 0) ? 0 : (int)layerHid1.weight[0].size() - 1;
		break;
	}
	return inputCount;
}

int LayerNet::GetOutputCount() const
{
	return (int)layerOut.weight.size();
}

int LayerNet::GetHidden1NeuronCount() const
{
	return (int)layerHid1.weight.size();
}

int LayerNet::GetHidden2NeuronCount() const
{
	return (int)layerHid2.weight.size();
}

void LayerNet::Unlearn()
{
	this->SimAnnealInitialize();
}

bool LayerNet::AutoSetInputScaler(MATRIX& input)
{
	return scalerInput.AutoSet(input);
}

bool LayerNet::AutoSetOutputScaler(MATRIX& output)
{
	return scalerOutput.AutoSet(output);
}

bool LayerNet::SetInputScaler(int index, double minimum, double maximum)
{
	return scalerInput.Set(index, minimum, maximum);
}

bool LayerNet::SetOutputScaler(int index, double minimum, double maximum)
{
	return scalerOutput.Set(index, minimum, maximum);
}

bool LayerNet::GetInputScaler(int index, double& minimum, double& maximum)
{
	Nn::ScalingInfo si;
	if (scalerInput.GetScalingInfo(index, si) == false) return false;
	minimum = si.minimum;
	maximum = si.maximum;
	return true;
}

bool LayerNet::GetOutputScaler(int index, double& minimum, double& maximum)
{
	Nn::ScalingInfo si;
	if (scalerOutput.GetScalingInfo(index, si) == false) return false;
	minimum = si.minimum;
	maximum = si.maximum;
	//processingIndex = si.processingIndex;
	return true;
}

const wchar_t * LayerNet::ScaleInputDataSet(const MATRIX& input, MATRIX& scaledInput, bool ignoreWarnings)
{
	const int rows = (int)input.size();
	if (rows == 0) return L"The input data set is empty";
	const int cols = (rows == 0) ? 0 : (int)input[0].size();
	if (cols == 0) return L"The input data set is empty";
	if (cols != GetInputCount()) return L"The numb of cols in the input set and the numb of inputs in the network must be equal";
	wchar_t * error  = scalerInput.ScaleToStandardRange(input, scaledInput);
	if (error) return error;

	int i, j;
	double value;
	//______________________________________ Check range
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = scaledInput[i][j];
			if (NN_LAYERNET_OFF-0.001 <= value && value <= NN_LAYERNET_ON+0.001) continue;
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The network scaling in input %d is invalid", j);
			return text;
		}
	}
	if (ignoreWarnings == false)
	{
		double sum, sums;
		double variance;
		//_____________________________________ Check the set
		for(j = 0; j<cols; j++)
		{
			sum = 0.0;
			sums = 0.0;
			for(i = 0; i<rows; i++)
			{
				value = input[i][j];
				sum += value;
				sums += (value*value);
			}
			variance = fabs(sums/(rows-1.0) - (sum*sum)/(rows*(rows-1.0)));
			if (variance < NN_MIN_VARIANCE)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The colum %i in the input data set has very little information", j);
				return text;
			}
		}
	}
	return NULL;
}

wchar_t* LayerNet::GetScaledOutput(MATRIX& scaledOutput)
{
	return scalerOutput.ScaleFromStandardRange(layerOut.output, scaledOutput);
}

const wchar_t * LayerNet::ScaleOutputDataSet(const MATRIX& output, MATRIX& scaledOutput, bool ignoreWarnings)
{
	const int rows = (int)output.size();
	if (rows == 0) return L"The output set is empty";
	const int cols = (rows == 0) ? 0 : (int)output[0].size();
	if (cols == 0) return L"The output set is empty";
	if (cols != GetOutputCount()) return L"The numb of cols in the output set must be equal to the numb of outputs in the network";
	wchar_t * error  = scalerOutput.ScaleToStandardRange(output, scaledOutput);
	if (error) return error;

	int i, j;
	double value;
	//______________________________________ Check range
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = scaledOutput[i][j];
			if (NN_LAYERNET_OFF-0.01 <= value && value <= NN_LAYERNET_ON+0.01) continue;
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Network scaling in output %i is invalid", j);
			return text;
		}
	}

	//_____________________________________ Check variance
	if (ignoreWarnings == false)
	{
		double sum, sums;
		double variance;
		//_____________________________________ Check the set
		for(j = 0; j<cols; j++)
		{
			sum = 0.0;
			sums = 0.0;
			for(i = 0; i<rows; i++)
			{
				value = scaledOutput[i][j];
				sum += value;
				sums += (value*value);
			}
			variance = fabs(sums/(rows-1.0) - (sum*sum)/(rows*(rows-1.0)));
			if (variance < NN_MIN_VARIANCE)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Column %i in the target set has little information", j);
				return text;
			}
		}
	}
	return NULL;
}

const wchar_t* LayerNet::SetTrainingSet(const MATRIX& trainSetIn, const MATRIX& trainSetTarget, bool ignoreWarnings)
{
	//trainSetScaledIn.clear();
	//trainSetScaledTarget.clear();

	hasTrainSet = false;
	wchar_t * error = NULL;

	if (trainSetIn.size() != trainSetTarget.size()) return L"The number of rows in the input set and the target set must be equal";

	error = (wchar_t*)ScaleInputDataSet(trainSetIn, trainSetScaledIn, ignoreWarnings);
	if (error) return error;

	error = (wchar_t*)ScaleOutputDataSet(trainSetTarget, trainSetScaledTarget, ignoreWarnings);
	if (error) return error;

	if (ignoreWarnings == false)
	{
		const int minNumTrainCases = GetMinNumTrainCases();
		if (trainSetIn.size() < (size_t)minNumTrainCases)
		{
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The minimum number of training cases is %d", minNumTrainCases);
			return text;
		}
	}

	hasTrainSet = true;

	return NULL;
}

const wchar_t* LayerNet::TrainGenetic(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::GeneticParam& param)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;
	int individualSize = 0;
	int i, j, k;

	Math::GeneticAlgorithm ga;
	ga.initPopulationSize = param.initPopulationSize;
	ga.numGenerations = param.numGenerations;
	ga.overPopulation = param.overPopulation;
	ga.mutationProbability = param.mutationProbability;
	ga.crossoverProbability = param.crossoverProbability;
	ga.goal = param.goal;
	//
	ga.stopWhenDone = false;
	//
	const int rows = (int)this->layerOut.weight.size();
	const int cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
	const int rowsHid1 = (int)layerHid1.weight.size();
	const int colsHid1 = (rowsHid1 == 0) ? 0 : (int)layerHid1.weight[0].size();
	const int rowsHid2 = (int)layerHid2.weight.size();
	const int colsHid2 = (rowsHid2 == 0) ? 0 : (int)layerHid2.weight[0].size();

	if (layerCount == 2)
	{
		
		individualSize = rows*cols*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rows; i++)
		{
			for(j = 0; j < cols; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerOut.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		this->SimAnnealGetError(); // Compute the output weights usign SVD
		mse.Set(ComputeCurrentTrueMse());
	}
	else if (layerCount == 3)
	{
		SvdCreate();
		individualSize = rowsHid1*colsHid1*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rowsHid1; i++)
		{
			for(j = 0; j < colsHid1; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid1.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		this->SimAnnealGetError(); // Compute the output weights usign SVD
		mse.Set(ComputeCurrentTrueMse());
		SvdDelete();
	}
	else if (layerCount == 4)
	{
		SvdCreate();
		individualSize = rowsHid1*colsHid1*NN_BITS_PER_WEIGHT + rowsHid2*colsHid2*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rowsHid1; i++)
		{
			for(j = 0; j < colsHid1; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid1.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		for(i = 0; i<rowsHid2; i++)
		{
			for(j = 0; j < colsHid2; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid2.weight[i][j]/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		this->SimAnnealGetError(); // Compute the output weights usign SVD
		mse.Set(ComputeCurrentTrueMse());
		SvdDelete();
	}
	return NULL;
}

const wchar_t* LayerNet::TrainSimAnneal(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::SimAnnealParam& param)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;

	Math::SimulatedAnnealing sa;
	sa.numTemps = param.numTemps;
	sa.numIterations = param.numIterations;
	sa.initialTemp = param.initialTemp;
	sa.finalTemp = param.finalTemp;
	sa.isCoolingScheduleLinear = param.isCoolingScheduleLinear;
	sa.cycles = param.cycles;
	sa.goal = param.goal;

	Nn::LayerNet work1, work2;
	if (work1.Create(this->GetInputCount(), this->GetHidden1NeuronCount(), this->GetHidden2NeuronCount(), this->GetOutputCount()) == false)
	{
		return L"No enough memory to train using Simulated Annealing";
	}
	if (work2.Create(this->GetInputCount(), this->GetHidden1NeuronCount(), this->GetHidden2NeuronCount(), this->GetOutputCount()) == false)
	{
		return L"No enough memory to train using Simulated Annealing";
	}
	sa.stopWhenDone = false;
	sa.Setup(mse, *this, work1, work2);

	if (layerCount == 2)
	{
		sa.ThreadFunc(running, progress, resetTime);
	}
	else if (layerCount == 3)
	{
		SvdCreate();
		sa.ThreadFunc(running, progress, resetTime);
		SvdDelete();
	}
	else if (layerCount == 4)
	{
		SvdCreate();
		sa.ThreadFunc(running, progress, resetTime);
		SvdDelete();
	}
	mse.Set(ComputeCurrentTrueMse());
	return NULL;
}

const wchar_t* LayerNet::TrainConjugateGradient(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return TrainCGVM(running, progress, mse, epochs, goal, WT_MATH_CONJGRAD);
}

const wchar_t* LayerNet::TrainVariableMetric(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return TrainCGVM(running, progress, mse, epochs, goal, WT_MATH_VARMETRIC);
}

const wchar_t * LayerNet::TrainCGVM(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal, int method)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call SetTrainingSet()";
	if (DeltaCreate() == false) return L"No enough memory";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;
	const int weightCount = GetWeightCount();
	valarray<double> x(weightCount);
	this->CopyThisToPoint(x);

	Math::FindMinimumMV fmmv;
	fmmv.Setup(mse, *this, x, epochs, goal, method);
	fmmv.stopWhenDone = false;
	fmmv.ThreadFunc(running, progress, resetTime);
	mse.Set(ComputeCurrentTrueMse());

	DeltaDelete();
	return NULL;
}

const wchar_t* LayerNet::TrainLevenbergMarquardt(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal, bool stopWhenDone)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int numWeights = this->GetWeightCount();

	int i = 0;

	//_____________________________________________________ Allocate singular value decompostion
	MATRIX a, v; // For Singular Value Decomposition
	valarray<double> s;  // For Singular Value Decomposition
	MATRIX hessian;
	valarray<double> b;
	valarray<double> gradient, grad, correction, delta;
	valarray<double> deltaHiddenLayer2;
	const int layerCount = GetLayerCount();
	try
	{
		a.resize(numWeights);
		hessian.resize(numWeights);
		v.resize(numWeights);
		for(i = 0; i < numWeights; i++)
		{
			a[i].resize(numWeights);
			hessian[i].resize(numWeights);
			v[i].resize(numWeights);
		}
		b.resize(numWeights);
		s.resize(numWeights);
		if (layerCount == 4) deltaHiddenLayer2.resize(GetHidden2NeuronCount());
		gradient.resize(numWeights);
		grad.resize(numWeights);
		correction.resize(numWeights);
		delta.resize(numWeights);
	}
	catch (const std::bad_alloc& )
	{
		return L"No enough memory";
	}
	progress.SetTry(0.0);
	double derror = LevenMarComputeHessianAndGradient(deltaHiddenLayer2, gradient, hessian, grad, running);
 
	//______________________________________________________ Initialize lambda
	double lambda = 0.0 ;
	for (i=0 ; i<numWeights; i++) 
	{
		if (hessian[i][i] > lambda) lambda = hessian[i][i];
	}
	lambda += 1.0e-20;
	bool brunning = false;
	if (running.GetTry(brunning))
	{
		if (brunning == false) return NULL;
	}

	const double ftol = 1.0e-7;
	const double reltol = 1.0e-10;
	double improvement = 0.0;
	double maxgrad = 0.0;
	double previousError = derror;
	bool resetAlphaAndBeta = true;
	int numBadIterations = 0;
	int numTrivialImprovements = 0;

	for (int iteration = 1; iteration <= epochs; iteration++)
	{  
		progress.SetTry(100.0*iteration/(double)epochs);
		if (running.GetTry(brunning))
		{
			if (brunning == false) break;
		}
		if (resetAlphaAndBeta)
		{      
			a = hessian;
			b = grad;
		}

		for (i=0; i<numWeights; i++)
		{
			a[i][i] += lambda; 
		}
		//________________________________________________ Solve the system of equations using Singular Value Decomposition
		Math::SingValDecompos::Decompose(a, s, v);
		Math::SingValDecompos::BackSubstitution(a, s, v, b, delta);
		LevenMarMove(1.0, delta);
		derror = LevenMarComputeHessianAndGradient(deltaHiddenLayer2, gradient, a, b, running);
		improvement = (previousError - derror) / previousError;

		if (improvement > 0.0) 
		{
			if (derror <= goal) break; 
			if (2.0*fabs(derror-previousError) <= ftol*(fabs(derror)+fabs(previousError)+1.0e-8)) break;
			previousError = derror;
			mse.SetTry(derror);
			if (improvement < reltol) 
			{
				maxgrad = 0.0 ;
				for (i=0 ; i<numWeights ; i++) 
				{
					if (fabs (b[i])  >  maxgrad) maxgrad = fabs (b[i]);
				}
				if (derror > 1.0) maxgrad /= derror;
				if (maxgrad <= reltol) break;
				numTrivialImprovements++;
				if (numTrivialImprovements == 4) 
				{
					for (i=0; i<numWeights; i++) 
					{
						if (hessian[i][i] > lambda) lambda = hessian[i][i];
					}
				}
				else if (numTrivialImprovements == 10)  //Done
				{
					break;
				}
			}
			else
			{
				numTrivialImprovements = 0 ; // Good improvement
			}
			hessian = a;
			grad = b;
			resetAlphaAndBeta = false;
			numBadIterations = 0;
			lambda *= 0.5;
		}
		else 
		{
			this->LevenMarMove(-1.0, delta);   // Move back
			resetAlphaAndBeta = true;
			lambda *= 2.0; 
			numBadIterations++;
			if (numBadIterations == 4) 
			{ 
				for (i=0 ; i<numWeights ; i++) 
				{	
					if (hessian[i][i] > lambda) lambda = hessian[i][i] ;
				}
			}
			if (numBadIterations == 10)  break;    //Almost impossible to get here     
		}
		if (running.GetTry(brunning))
		{
			if (brunning == false) break;
		}
	}
	if (stopWhenDone) running.Set(false);
	mse.Set(ComputeCurrentTrueMse());

	return NULL;
}

void LayerNet::LevenMarMove(double step, valarray<double>& direction)
{
	const int rows = (int)layerOut.weight.size();
	const int cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
	const int rowsHid1 = (int)layerHid1.weight.size();
	const int colsHid1 = (rowsHid1 == 0) ? 0 : (int)layerHid1.weight[0].size();
	const int rowsHid2 = (int)layerHid2.weight.size();
	const int colsHid2 = (rowsHid2 == 0) ? 0 : (int)layerHid2.weight[0].size();
	int r, c, index=0;

	//_________________________________________________ Output Layer
	for(r = 0; r<rows; r++)
	{
		for(c=0; c<cols; c++)
		{
			layerOut.weight[r][c] += direction[index++]*step;
		}
	}
	//_________________________________________________ Hidden 2 Layer
	for(r = 0; r<rowsHid2; r++)
	{
		for(c=0; c<colsHid2; c++)
		{
			layerHid2.weight[r][c] += direction[index++]*step;
		}
	}
	//_________________________________________________ Hidden 1 Layer
	for(r = 0; r<rowsHid1; r++)
	{
		for(c=0; c<colsHid1; c++)
		{
			layerHid1.weight[r][c] += direction[index++]*step;
		}
	}
}

double LayerNet::LevenMarComputeHessianAndGradient(valarray<double>& hid2delta, valarray<double>& grad, MATRIX& hessian, valarray<double>& beta, Mt::BoolTs& running)
{
	const int weightCount = GetWeightCount();
	int i = 0, j = 0;
	beta = 0.0;
	for (i=0 ; i<weightCount ; i++)
	{   
		for (j=0 ; j<=i ; j++)  hessian[i][j] = 0.0 ;// Set to zero only half
	}
	const int rows = (int)trainSetScaledIn.size();
	double error = 0.0, err;
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	const int layerCount = GetLayerCount();
	for (int tset=0; tset<rows; tset++) 
	{ 
		this->ComputeOutput(trainSetScaledIn, tset, layerCount);
		err = 0.0;
		for (i=0 ; i<numOut ; i++)
		{
				err += LevenMar(trainSetScaledIn, tset, i, trainSetScaledTarget[tset][i], hessian, beta, hid2delta, grad);
		}
		if (running.Get() == false) 
		{
			error=9.99e300; //Prevent from taking this solution
			break;
		}
		error += err;
	}

	for (i=1; i<weightCount; i++) //Fill in the uncomputed half of alpha via symmetry.
	{
		for (j=0; j<i; j++) hessian[j][i] = hessian[i][j];
	}
   return error / (double)(rows*numOut); 
}

double LayerNet::LevenMar(MATRIX & input, int inputRow, 
							  int idep, double target, 
							  MATRIX& alpha, valarray<double>& beta, 
							  valarray<double>& hid2delta, valarray<double>& grad)
{
	const int layerCount = GetLayerCount();
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	const int n = (int)alpha.size();

	if (layerCount == 2)
	{	
		const double outdelta = layerOut.OutputDerivative(idep);
		int i, j, index = 0;
		double difference;
	
		for (i=0 ; i<numOut; i++) 
		{
			if (i == idep) 
			{
				for (j=0 ; j<numIn; j++)
				{
					grad[index++] = outdelta * input[inputRow][j];
				}
				grad[index++] = outdelta; 
			}
			else 
			{
				for (j=0; j<numIn; j++)
				{
					grad[index++] = 0.0;
				}
				grad[index++] = 0.0;
			}
		}
		difference = target - layerOut.output[0][idep]; 

		const int weightCount = this->GetWeightCount();
		for (i=0; i<weightCount; i++) 
		{
			beta[i] += difference * grad[i];
			for (j=0; j<=i; j++)
			{
				alpha[i][j] += grad[i] * grad[j];
			}
		}
		return difference*difference;
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		int i, j, index = 0;
		double difference, delta;
		const double outdelta = layerOut.OutputDerivative(idep);

		for (i=0 ; i<numOut; i++) 
		{
			if (i == idep) 
			{
				for (j=0 ; j<numHid1; j++) 
				{
					grad[index++] = outdelta * layerHid1.output[0][j];
				}
				grad[index++] = outdelta;
			}
			else 
			{
				for (j=0; j<numHid1; j++)
				{
					grad[index++] = 0.0;
				}
				grad[index++] = 0.0;
			}
		}
	
		//________________________________________________ Hidden 1 Layer
		for (i=0; i<numHid1; i++) 
		{
			delta = outdelta * layerOut.weight[idep][i];
			delta *= layerHid1.OutputDerivative(i);
			for (j=0; j<numIn; j++)
			{
				grad[index++] = delta * input[inputRow][j];
			}
			grad[index++]= delta ;
		}
		difference = target - layerOut.output[0][idep]; 

		for (i=0; i<n; i++) 
		{
			beta[i] += difference * grad[i];
			for (j=0; j<=i; j++)
			{
				alpha[i][j] += grad[i] * grad[j];
			}
		}
		return difference*difference;
	}
	else if (layerCount == 4)
	{
		const int numHid1 = GetHidden1NeuronCount();
		const int numHid2 = GetHidden2NeuronCount();
		
		int i, j, index = 0;
		double difference, delta;
		const double outdelta = layerOut.OutputDerivative(idep);

		for (i=0 ; i<numOut; i++) 
		{
			if (i == idep) 
			{
				for (j=0 ; j<numHid2; j++)
				{
					grad[index++] = outdelta * layerHid2.output[0][j];
				}
				grad[index++] = outdelta; 
			}
			else 
			{
				for (j=0; j<numHid2; j++)
				{
					grad[index++] = 0.0;
				}
				grad[index++] = 0.0;
			}
		}

		//________________________________________________________ Hidden 2 Layer
		for (i=0 ; i<numHid2 ; i++) 
		{
			delta = outdelta * layerOut.weight[idep][i];
			delta *= layerHid2.OutputDerivative(i);
			hid2delta[i] = delta ;
			for (j=0 ; j<numHid1 ; j++)
			{
				grad[index++]  = delta * layerHid1.output[0][j];
			}
			grad[index++] = delta ; 
		}

		//________________________________________________________ Hidden 1 Layer
		for (i=0 ; i<numHid1; i++) 
		{
			delta = 0.0;
			for (j=0; j<numHid2; j++)
			{
				delta += hid2delta[j] * layerHid2.weight[j][i];
			}
			delta *= layerHid1.OutputDerivative(i);
			for (j=0; j<numIn; j++)
			{
				grad[index++] = delta * input[inputRow][j];
			}
			grad[index++] = delta ;
		}
		difference = target - layerOut.output[0][idep];

		for (i=0; i<n; i++) 
		{
			beta[i] += difference * grad[i];
			for (j=0; j<=i; j++) alpha[i][j] += grad[i] * grad[j];
		}
		return difference*difference;
	}
	return 9.99e300;
}

const wchar_t* LayerNet::TrainRegression(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call SetTrainingSet()";
	const int layerCount = GetLayerCount();
	if (layerCount != 2) return L"The number of hidden layers must be zero to use regression for training";
	const int numTrainCases = (int)trainSetScaledIn.size();
	const int numOutputs = GetOutputCount();
	const int numInputs = GetInputCount();
	bool isRunning = false;
	int i, j;
	MATRIX a, v, y;
	valarray<double> s;

	if (Math::Oper::CreateMatrix(y, numOutputs, numTrainCases) == false) return L"No enough memory";
	if (Math::Oper::CreateMatrix(a, numTrainCases, numInputs+1) == false) return L"No enough memory";

	//__________________________________________________________  Expected y'
	for(i = 0; i<numOutputs; i++)
	{
		for(j = 0; j<numTrainCases; j++)
		{
			y[i][j] = Nn::Tanh::InverseFunc(trainSetScaledTarget[j][i]); // y = transposed(inv_tanh(trainSetScaledTarget))
		}
	}

	//______________________________________________ Is still running?
	if (running.GetTry(isRunning))
	{
		if (isRunning == false) return L"Stopped by the user";
	}

	//_________________________________________________________  A = [X 1]
	for(i = 0; i<numTrainCases; i++)
	{
		for(j = 0; j<numInputs+1; j++)
		{
			if (j == numInputs) // Last column
			{
				a[i][j] = 1.0;
			}
			else
			{
				a[i][j] = trainSetScaledIn[i][j];
			}
		}
	}

	//______________________________________________ Is still running?
	if (running.GetTry(isRunning))
	{
		if (isRunning == false) return L"Stopped by the user";
	}

	wchar_t* error = NULL;
	error = Math::SingValDecompos::Decompose(a, s, v);
	if (error ) return error;

	//______________________________________________ Is still running?
	if (running.GetTry(isRunning))
	{
		if (isRunning == false) return L"Stopped by the user";
	}

	for(i=0; i<numOutputs; i++)
	{
		Math::SingValDecompos::BackSubstitution(a, s, v, y[i], layerOut.weight[i]);
	}
	mse.Set(ComputeCurrentTrueMse());
	return NULL;
}

int LayerNet::GetWeightCount() const
{
	const int layerCount = GetLayerCount();
	int count = 0;
	int rows, cols;
	if (layerCount >= 2)
	{
		rows = (int)layerOut.weight.size();
		cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
		count += (rows*cols);
	}
	if (layerCount >= 3)
	{
		rows = (int)layerHid1.weight.size();
		cols = (rows == 0) ? 0 : (int)layerHid1.weight[0].size();
		count += (rows*cols);
	}
	if (layerCount >= 4)
	{
		rows = (int)layerHid2.weight.size();
		cols = (rows == 0) ? 0 : (int)layerHid2.weight[0].size();
		count += (rows*cols);
	}

	return count;
}

bool LayerNet::Run(const MATRIX& input, MATRIX& output)
{
	const int rows = (int)input.size();
	const int cols = (rows == 0) ? 0 : (int)input[0].size();
	if (cols != GetInputCount()) return false;
	MATRIX scaledInput;
	scalerInput.ScaleToStandardRange(input, scaledInput);
	const int layerCount = GetLayerCount();
	const int outputCount = GetOutputCount();
	//______________________________ Create the output matrix
	try
	{
		output.resize(rows);
	
		for(int i = 0; i<rows; i++)
		{
			ComputeOutput(scaledInput, i, layerCount);  // it updates layerOut.output[0]
			output[i].resize(outputCount);
			scalerOutput.ScaleFromStandardRange(layerOut.output[0], output[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

void LayerNet::ComputeOutput(const MATRIX& input, int inputRowIndex, int layerCount)
{
	switch(layerCount)
	{
	case 2:
		layerOut.ComputeOutput(input, inputRowIndex); //it updates layerOut.output
		break;
	case 3:
		layerHid1.ComputeOutput(input, inputRowIndex);
		layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
		break;
	case 4:
		layerHid1.ComputeOutput(input, inputRowIndex);
		layerHid2.ComputeOutput(layerHid1.output, 0);
		layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
		break;
	}
}

void LayerNet::SimAnnealInitialize()
{
	layerHid1.Initialize();
	layerHid2.Initialize();
	layerOut.Initialize();
}

void LayerNet::SimAnnealPerturb(Math::ISimAnneal& original, double temperature, double initialTemperature)
{
	const double pertubRatio = temperature/initialTemperature;
	const int layerCount = GetLayerCount();
	if (layerCount == 2)
	{
		layerOut.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerOut);
	}
	else if (layerCount == 3)
	{
		layerHid1.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerHid1);
		//__________________ LayerOut is not perturbed as Regression is used at the output level
	}
	else if (layerCount == 4)
	{
		layerHid1.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerHid1);
		layerHid2.Agitate(pertubRatio, ((Nn::LayerNet&)original).layerHid2);
		//__________________ LayerOut is not perturbed as Regression is used at the output level
	}	
}

double LayerNet::SimAnnealGetError()
{
	const int layerCount = GetLayerCount();
	const int rows = (int)trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	const int numHid1 = GetHidden1NeuronCount();
	const int numHid2 = GetHidden2NeuronCount();
	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				mse += diff * diff;
			}
		}
		return mse/(rows*outputCount);
	}
	else if (layerCount == 3)
	{
		//______________________________________________________ A = [X 1]
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);	
			for(j = 0; j<numHid1+1; j++)
			{
				if (j == numHid1) // Last column
				{
					svd_a[i][j] = 1.0;
				}
				else
				{
					svd_a[i][j] = layerHid1.output[0][j];
				}
			}
		}
		//______________________________________________________ Compute Ouput Weights using SVD
		Math::SingValDecompos::Decompose(svd_a, svd_u, svd_s, svd_v);
		for(i=0; i<outputCount; i++)
		{
			Math::SingValDecompos::BackSubstitution(svd_u, svd_s, svd_v, svd_y[i], layerOut.weight[i]);
		}
		//_____________________________________________________ Compute mse
		for(i = 0; i<rows; i++)
		{
			//layerHid1.ComputeOutput(trainSetScaledIn, i);	
			//layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			layerOut.ComputeOutput(svd_a, i); // Instead of computing the activation again, we use svd_a
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				mse += diff * diff;
			}
		}
		return mse/(rows*outputCount);
	}
	else if (layerCount == 4)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			//_____________________________________________________ A = [X 1]
			for(j = 0; j<numHid2+1; j++)
			{
				if (j == numHid2) // Last column
				{
					svd_a[i][j] = 1.0;
				}
				else
				{
					svd_a[i][j] = layerHid2.output[0][j];
				}
			}
		}
		//______________________________________________________ Compute Ouput Weights using SVD
		Math::SingValDecompos::Decompose(svd_a, svd_u, svd_s, svd_v);
		for(i=0; i<outputCount; i++)
		{
			Math::SingValDecompos::BackSubstitution(svd_u, svd_s, svd_v, svd_y[i], layerOut.weight[i]);
		}
		//_____________________________________________________ Compute mse
		for(i = 0; i<rows; i++)
		{
			//layerHid1.ComputeOutput(trainSetScaledIn, i);	
			//layerHid2.ComputeOutput(layerHid1.output, 0);	
			//layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
			layerOut.ComputeOutput(svd_a, i); // Instead of computing the activation again, we use svd_a
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j] - trainSetScaledTarget[i][j];
				mse += diff * diff;
			}
		}
		return mse/(rows*outputCount);
	}	
	return 9.99e300;
}

void LayerNet::SimAnnealCopy(const Math::ISimAnneal& source)
{
	Nn::LayerNet& net_source((Nn::LayerNet&)source);
	const int layerCount = GetLayerCount();

	if (layerCount == 2)
	{
		this->layerOut = net_source.layerOut;
	}
	else if (layerCount == 3)
	{
		this->layerHid1 = net_source.layerHid1;
		this->layerOut = net_source.layerOut;
	}
	else if (layerCount == 4)
	{
		this->layerHid1 = net_source.layerHid1;
		this->layerHid2 = net_source.layerHid2;
		this->layerOut = net_source.layerOut;
	}	
}

void LayerNet::GeneticInitialize(Sys::BoolArray& bits)
{
	const int bitCount = bits.GetCount();
	const int weightCount = bitCount / NN_BITS_PER_WEIGHT; 
	std::tr1::uniform_real<double> dis(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);
	int i;
	__int16 value;
	double weight = 0.0;
	for(i = 0; i < weightCount; i++)
	{
		weight = dis(Math::Statistics::random_generator);
		value = (__int16)(NN_WEIGHT_RES*weight/NN_LAYERNET_WEIGHTMAX);
		bits.SetInt16(i, value);
	}
}

double LayerNet::GeneticGetError()
{
	//
	//GeneticCopyFromBits(bits);
	return SimAnnealGetError();
}

void LayerNet::GeneticSetFromBits(const Sys::BoolArray& bits)
{
	//GeneticCopyFromBits(bits);
	//SimAnnealGetError(); // To compute the output weights using SVD at the end of the algorithm
	const int layerCount = GetLayerCount();
	int i, j, k = 0;

	if (layerCount == 2)
	{
		const int rows = (int)this->layerOut.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
		//__________________________________________________________ Output
		for (i = 0; i < rows; i++)
		{
			for (j = 0; j < cols; j++)
			{
				layerOut.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
	}
	else if (layerCount == 3)
	{
		const int rowsHid1 = (int)layerHid1.weight.size();
		const int colsHid1 = (rowsHid1 == 0) ? 0 : (int)layerHid1.weight[0].size();
		//_________________________________________________________ Hidden 1
		for (i = 0; i < rowsHid1; i++)
		{
			for (j = 0; j < colsHid1; j++)
			{
				layerHid1.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
	}
	else if (layerCount == 4)
	{
		const int rowsHid1 = (int)layerHid1.weight.size();
		const int colsHid1 = (rowsHid1 == 0) ? 0 : (int)layerHid1.weight[0].size();
		const int rowsHid2 = (int)layerHid2.weight.size();
		const int colsHid2 = (rowsHid2 == 0) ? 0 : (int)layerHid2.weight[0].size();
		//_________________________________________________________ Hidden 1
		for (i = 0; i < rowsHid1; i++)
		{
			for (j = 0; j < colsHid1; j++)
			{
				layerHid1.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
		//_________________________________________________________ Hidden 2
		for (i = 0; i < rowsHid2; i++)
		{
			for (j = 0; j < colsHid2; j++)
			{
				layerHid2.weight[i][j] = NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES;
			}
		}
	}
}

double LayerNet::ComputeCurrentTrueMse()
{
	MATRIX trainSet_target;

	wchar_t * error = NULL;

	//_____________________________________ De Scaled the training set output
	error = scalerOutput.ScaleFromStandardRange(trainSetScaledTarget, trainSet_target);
	if (error != NULL) return -1.0;
	//
	const int layerCount = GetLayerCount();
	const int rows = (int)trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	valarray<double> output;
	try
	{
		output.resize(outputCount);
	}
	catch(std::bad_alloc& )
	{
		return -1.0;
	}

	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		//__________________________________________ Compute and scale the network output
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 3)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 4)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}	
	else
	{
		return -1.0;
	}
	return mse/(rows*outputCount);
}

double LayerNet::ComputeTrueMse(const MATRIX& trainSet_in, const MATRIX& trainSet_target)
{
	wchar_t * error = NULL;

	//_____________________________________ Scaled the training set input
	error = scalerInput.ScaleToStandardRange(trainSet_in, trainSetScaledIn);
	if (error != NULL) return -1.0;

	const int layerCount = GetLayerCount();
	const int rows = (int)trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	valarray<double> output;
	try
	{
		output.resize(outputCount);
	}
	catch(std::bad_alloc& )
	{
		return -1.0;
	}

	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		//__________________________________________ Compute and scale the network output
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 3)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 4)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerHid2.ComputeOutput(layerHid1.output, 0);
			layerOut.ComputeOutput(layerHid2.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j] - output[j];
				mse += diff * diff;
			}
		}
	}	
	else
	{
		return -1.0;
	}
	return mse/(rows*outputCount);
}

//_____________________________ Static function for overfitting in prediction
bool LayerNet::IsPredictionOverfitting(int seriesLength, int numInputs, int numHid)
{
	if (numHid == 0)
	{
		const int maxInput = (int)( (seriesLength-1.2)/3.2);
		if (numInputs <= maxInput)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	else if (numHid >= 1)
	{
		const int numHidNoOverFitting = (int)( (seriesLength-numInputs+1.0)/(2.2*(1+numInputs)));
		if (numHid <= numHidNoOverFitting)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	return true;
}

void LayerNet::ComputeBestPrediction(int seriesLength, const MATRIX& mse, int& out_row, int& out_col)
{
	out_row = -1;
	out_col = -1;
	const int rows = (int)mse.size();
	if (rows == 0) return;
	const int cols = (int)mse[0].size();
	double minimum = -1.0;
	bool isFirst = true;
	int numInputs, numHid;

	for(numInputs = 0; numInputs< rows; numInputs++)
	{
		for(numHid= 0; numHid <cols; numHid++)
		{
			if (numInputs == 0) // Skip first row
			{
				continue;
			}
			else if (Nn::LayerNet::IsPredictionOverfitting(seriesLength, numInputs, numHid) == false)
			{
				if (isFirst == true)
				{
					isFirst = false;
					minimum = mse[numInputs][numHid];
					out_row = numInputs;
					out_col = numHid;
				}
				else
				{
					if (mse[numInputs][numHid] < minimum)
					{
						minimum = mse[numInputs][numHid];
						out_row = numInputs;
						out_col = numHid;
					}
				}
			}
			else //___ Overfitting
			{
				continue;
			}
		}
	}
	
	////_________________________________ Try to induce if it is mse analysis
	//isPredictionAnalysisMse = true;
	//for(numInputs = 0; numInputs< rows; numInputs++)
	//{
	//	for(numHid= 0; numHid <cols; numHid++)
	//	{
	//		numHidNoOverFitting = (int)( (seriesLength-numInputs)/(2.2*(1+numInputs)));
	//		if (numInputs <= 2 || numHid == 0) // Short memory
	//		{
	//			continue;
	//		}
	//		else if (numHid <= numHidNoOverFitting)
	//		{
	//		}
	//		else //___ Overfitting
	//		{
	//			continue;
	//		}
	//		if (matrix[numInputs][numHid] < 0.0)
	//		{
	//			isPredictionAnalysisMse = false;
	//			return;
	//		}
	//		if (matrix[numInputs][numHid] >= 1.0)
	//		{
	//			isPredictionAnalysisMse = false;
	//			return;
	//		}
	//	}
	//}
}

//_____________________________________________________________________ LayerNetC
MATRIXC LayerNetC::trainSetScaledIn;
MATRIXC LayerNetC::trainSetScaledTarget;
MATRIX LayerNetC::svd_a;
MATRIX LayerNetC::svd_u;
MATRIX LayerNetC::svd_v;
MATRIX LayerNetC::svd_y;
valarray<double> LayerNetC::svd_b;
valarray<complex<double> > LayerNetC::deltaOutput;
valarray<Nn::ComplexDerivative> LayerNetC::out_derivative;
valarray<Nn::ComplexDerivative> LayerNetC::hid_derivative;

LayerNetC::LayerNetC()
{
	Constructor();
}

LayerNetC::~LayerNetC()
{
}

LayerNetC::LayerNetC(const LayerNetC& init)
{
	Constructor();
	Copy(init);
}

LayerNetC& LayerNetC::operator=(const LayerNetC& init)
{
	Delete();
	Copy(init);
	return *this;
}

int LayerNetC::GetMinNumTrainCases()
{   
	const int rows = (int)layerHid1.weight.size();
	if (rows == 0) return 0;
	const int numWeights = 2 * ((int)layerHid1.weight[0].size() * rows);
	return (int)(2.2*numWeights+0.99999999);
}

void LayerNetC::CopyThisToPoint(valarray<double>& point) const
{
	int r, c, j=0;
	const int numLayers = GetLayerCount();

	//_______________________________________ Copy Output Layer
	if (numLayers >= 2)
	{
		const int rowsO = (int)layerOut.weight.size();
		const int colsO = (rowsO == 0) ? 0 : (int)layerOut.weight[0].size();
		for(r = 0; r < rowsO; r++) 
		{
			for(c = 0; c < colsO; c++)
			{
				point[j++] = layerOut.weight[r][c].real();
				point[j++] = layerOut.weight[r][c].imag();
			}
		}
	}

	//_______________________________________ Copy Hidden1 Layer
	if (numLayers == 3)
	{
		const int rowsH = (int)layerHid1.weight.size();
		const int colsH = (rowsH == 0) ? 0 : (int)layerHid1.weight[0].size();
		for(r = 0; r < rowsH; r++) 
		{
			for(c = 0; c<colsH; c++)
			{
				point[j++] = layerHid1.weight[r][c].real();
				point[j++] = layerHid1.weight[r][c].imag();
			}
		}
	}
}

void LayerNetC::CopyPointToThis(const valarray<double>& point)
{
	size_t r, c, j=0;
	const int numLayers = GetLayerCount();

	//_______________________________________ Copy Output Layer
	if (numLayers >= 2)
	{
		const size_t rowsO = layerOut.weight.size();
		const size_t colsO = (rowsO == 0) ? 0 : layerOut.weight[0].size();
		for(r = 0; r < rowsO; r++) 
		{
			for(c = 0; c < colsO; c++)
			{
				layerOut.weight[r][c].real(point[j++]);
				layerOut.weight[r][c].imag(point[j++]);
			}
		}
	}

	//_______________________________________ Copy Hidden 1 Layer
	if (numLayers == 3)
	{
		const size_t rowsH = layerHid1.weight.size();
		const size_t colsH = (rowsH == 0) ? 0 : layerHid1.weight[0].size();
		for(r = 0; r < rowsH; r++) 
		{
			for(c = 0; c < colsH; c++)
			{
				layerHid1.weight[r][c].real(point[j++]);
				layerHid1.weight[r][c].imag(point[j++]);
			}
		}
	}
}

void LayerNetC::Copy(const LayerNetC &init)
{
	this->layerHid1 = init.layerHid1;
	this->layerOut = init.layerOut;
	this->scalerInput = init.scalerInput;
	this->scalerOutput = init.scalerOutput;
	this->hasTrainSet = false;
	this->trainSetScaledIn.clear();
	this->trainSetScaledTarget.clear();
}

double LayerNetC::EvaluateFunc(const valarray<double>& x)
{
	this->CopyPointToThis(x);
	int i, j;
	const int rows = (int)trainSetScaledIn.size();
	double divergence;
	const int numOut = GetOutputCount();
	const int layerCount = GetLayerCount();
	double gradError = 0.0;

	if (layerCount == 2)
	{
		for(i=0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i);//it updates layerOut.output	
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j].real() - trainSetScaledTarget[i][j].real();
				gradError += (divergence*divergence);
				//
				divergence = layerOut.output[0][j].imag() - trainSetScaledTarget[i][j].imag();
				gradError += (divergence*divergence);
			}
		}
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		for(i=0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0);
			for(j=0; j<numOut; j++)
			{
				divergence = layerOut.output[0][j].real() - trainSetScaledTarget[i][j].real();
				gradError += (divergence*divergence);
				//
				divergence = layerOut.output[0][j].imag() - trainSetScaledTarget[i][j].imag();
				gradError += (divergence*divergence);
			}
		}
	}
	return gradError/(2*rows*numOut);
}

//void LayerNetC::EvaluateGrad(const valarray<double>& x, valarray<double>& outGrad)
void LayerNetC::EvaluateFuncAndGrad(const valarray<double>& x, double& Fx, valarray<double>& gradient)
{
	this->CopyPointToThis(x);
	const int gradSize = (int)gradient.size();
	int i, j, m, index=0;

	
	//________________________________________________ Set the gradient to zero
	for(i = 0; i < gradSize; i++) gradient[i] = 0.0;
	//
	const int rows = (int)trainSetScaledIn.size();
	double diff_real;
	double diff_imag;
	const int numIn = GetInputCount();
	const int numOut = GetOutputCount();
	double delta_real = 0.0;
	double delta_imag = 0.0;
	const int layerCount = GetLayerCount();
	Fx = 0.0;

	if (layerCount == 2)
	{
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerOut.ComputeOutputAndDerivative(trainSetScaledIn, i, out_derivative);
			for(j=0; j<numOut; j++)
			{
				diff_real = layerOut.output[0][j].real() - trainSetScaledTarget[i][j].real();
				diff_imag = layerOut.output[0][j].imag()- trainSetScaledTarget[i][j].imag();
				//
				Fx += (diff_real*diff_real);
				Fx += (diff_imag*diff_imag);
				//
				diff_real *= 2.0;
				diff_imag *= 2.0;
				//
				delta_real = diff_real * out_derivative[j].real_real + diff_imag * out_derivative[j].real_imag;
				delta_imag = diff_real * out_derivative[j].real_imag + diff_imag * out_derivative[j].imag_imag;
				//
				for(m=0; m<numIn; m++)
				{
					gradient[index++] += (delta_real * trainSetScaledIn[i][m].real() + delta_imag * trainSetScaledIn[i][m].imag());
					gradient[index++] += (-delta_real * trainSetScaledIn[i][m].imag() + delta_imag * trainSetScaledIn[i][m].real());
				}
				gradient[index++] += delta_real; // trainSetScaledIn is: 1 + 0j
				gradient[index++] += delta_imag; // trainSetScaledIn is: 1 + 0j
			}
		}
	}
	else if (layerCount == 3)
	{
		const int numHid1 = GetHidden1NeuronCount();
		double sum_real;
		double sum_imag;
		double delta_real;
		double delta_imag;
		for(i=0; i<rows; i++)
		{
			index = 0;
			layerHid1.ComputeOutputAndDerivative(trainSetScaledIn, i, hid_derivative);
			layerOut.ComputeOutputAndDerivative(layerHid1.output, 0, out_derivative);
			for(j=0; j<numOut; j++)
			{
				diff_real = layerOut.output[0][j].real() - trainSetScaledTarget[i][j].real();
				diff_imag = layerOut.output[0][j].imag()- trainSetScaledTarget[i][j].imag();
				//
				Fx += (diff_real*diff_real);
				Fx += (diff_imag*diff_imag);
				//
				diff_real *= 2.0;
				diff_imag *= 2.0;
				//
				delta_real = diff_real * out_derivative[j].real_real + diff_imag * out_derivative[j].real_imag;
				delta_imag = diff_real * out_derivative[j].real_imag + diff_imag * out_derivative[j].imag_imag;
				// store deltaOutput
				deltaOutput[j].real(delta_real);
				deltaOutput[j].imag(delta_imag);
				//
				for(m=0; m<numHid1; m++)
				{
					gradient[index++] += (delta_real * layerHid1.output[0][m].real() + delta_imag * layerHid1.output[0][m].imag());
					gradient[index++] += (-delta_real * layerHid1.output[0][m].imag() + delta_imag * layerHid1.output[0][m].real());
				}
				gradient[index++] += delta_real; // layerHid1.output is: 1 + 0j
				gradient[index++] += delta_imag; // layerHid1.output is: 1 + 0j
			}
			//____________________________________________________________ Hid1 layer gradient
			for(m=0; m<numHid1; m++)
			{
				sum_real = 0.0;
				sum_imag = 0.0;
				for(j=0; j<numOut; j++)
				{
					sum_real += (deltaOutput[j].real() * layerOut.weight[j][m].real() + deltaOutput[j].imag() * layerOut.weight[j][m].imag());
					sum_imag += (-deltaOutput[j].real() * layerOut.weight[j][m].imag() + deltaOutput[j].imag() * layerOut.weight[j][m].real());
				}
				delta_real = sum_real * hid_derivative[m].real_real + sum_imag * hid_derivative[m].real_imag;
				delta_imag = sum_real * hid_derivative[m].real_imag + sum_imag * hid_derivative[m].imag_imag;
				for(j=0; j<numIn; j++) 
				{
					gradient[index++] += (delta_real * trainSetScaledIn[i][j].real() + delta_imag * trainSetScaledIn[i][j].imag());
					gradient[index++] += (-delta_real * trainSetScaledIn[i][j].imag() + delta_imag * trainSetScaledIn[i][j].real());
				}
				gradient[index++] += delta_real; //trainSetScaledIn[i][j] is: 1 + 0j
				gradient[index++] += delta_imag;//trainSetScaledIn[i][j] is: 1 + 0j
			}
		}
	}
	
	gradient /= rows;
	Fx = Fx /(2.0*rows*numOut);


//=========================================================
//double LayerNet2::EvaluateGradientReal(Math::Vector& gradient)//returns error // XXX
//{
//	gradient.SetElementsToZero();
//	//_______________________________________________________ Real networks
//	const int rows = pTrainSet->GetRowCount();
//	double error = 0, divergence;	
//	int i, j, k, m, index;
//	double delta = 0.0;
//	Math::Matrix &trainSet = *pTrainSet;
//
//	if (netType==Nn::NT_CLASSIFIER)
//	{
//		const double ON = pLayerOut->pAf->getNeuronOn();
//		const double OFF = pLayerOut->pAf->getNeuronOff();
//		const int classIndex = trainSet.GetColCount()-1;
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			this->ComputeOutput(trainSet, i);//it updates pLayerOut->output
//			//____________________________________________________________ Output layer gradient
//			for(j=0; j<numOut; j++)
//			{
//				if (j==(int)(trainSet[i][classIndex])-1)
//					divergence = pLayerOut->output[0][j] - ON;
//				else
//					divergence = pLayerOut->output[0][j] - OFF;
//				error += (divergence*divergence);
//				delta = 2.0*divergence * pLayerOut->pAf->derivative(pLayerOut->output[0][j]);
//				outDelta[j]= delta;
//				for(m=0; m<numHid1; m++) gradient[index++] += delta * pLayerHid1->output[0][m];
//				gradient[index++] += delta;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numOut; j++) delta += outDelta[j]*pLayerOut->weight[j][m];
//				delta *= pLayerHid1->pAf->derivative(pLayerHid1->output[0][m]);
//				for(j=0; j<numIn; j++) 
//				{
//					gradient[index++] += delta*trainSet[i][j];
//				}
//				gradient[index++] += delta;
//			}
//		}
//	}
//	else
//	{
//		const int offset = (netType != Nn::NT_OUTISIN) ? numIn : 0; 
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			this->ComputeOutput(trainSet, i);//it updates pLayerOut->output
//			//____________________________________________________________ Output layer gradient
//			for(j=0, k=offset; j<numOut; j++, k++)
//			{
//				divergence = pLayerOut->output[0][j] -trainSet[i][k];
//				error += (divergence*divergence);
//				delta = 2.0*divergence * pLayerOut->pAf->derivative(pLayerOut->output[0][j]);
//				outDelta[j]= delta;
//				for(m=0; m<numHid1; m++) gradient[index++] += delta * pLayerHid1->output[0][m];
//				gradient[index++] += delta;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				delta = 0.0;
//				for(j=0; j<numOut; j++) delta += outDelta[j]*pLayerOut->weight[j][m];
//				delta *= pLayerHid1->pAf->derivative(pLayerHid1->output[0][m]);
//				for(j=0; j<numIn; j++) 
//				{
//					gradient[index++] += delta*trainSet[i][j];
//				}
//				gradient[index++] += delta;
//			}
//		}
//	}
//	const int gradSize = gradient.GetSize();
//	if (pLayerOut->pAf->getType()==Nn::IActiFunc::Type::AF_TANH)
//	{
//		for(i=0; i<gradSize; i++) gradient[i]/=(4.0*rows);
//		return error/(4.0*rows*numOut);
//	}
//	else
//	{
//		for(i=0; i<gradSize; i++) gradient[i]/=rows;
//		return error/(rows*numOut);
//	}
//}
//
//double LayerNet2::EvaluateGradientComplex(Math::Vector& gradient)//returns error // XXX
//{
//	gradient.SetElementsToZero();
//	//_______________________________________________________ Real networks
//	const int rows = pTrainSet->GetRowCount();
//	double error = 0, divergence;	
//	int i, j, m, index;
//	double delta_real = 0.0, delta_imag = 0.0, suma_real = 0.0, suma_imag = 0.0;
//	Math::Matrix &trainSet = *pTrainSet;
//
//	if (netType==Nn::NT_CLASSIFIER)
//	{
//		const double ON = pLayerOut->pAf->getNeuronOn();
//		const double OFF = pLayerOut->pAf->getNeuronOff();
//		const int classIndex = trainSet.GetColCount()-1;
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			this->ComputeOutput(trainSet, i);//it updates pLayerOut->output
//			//____________________________________________________________ Output layer gradient
//			for(j=0; j<numOut; j++)
//			{
//				//__________________real________________________
//				if (j==(int)(trainSet[i][classIndex])-1)
//				{
//					divergence = pLayerOut->output[0][2*j] -ON;
//				}
//				else
//				{
//					divergence = pLayerOut->output[0][2*j] -OFF;
//				}
//				error += (divergence*divergence);
//				delta_real = 2*divergence*pLayerOut->pAf->derivative(pLayerOut->output[0][2*j]);
//				outDelta[2*j]= delta_real;
//				//__________________imag_______________________
//				if (j==(int)(trainSet[i][classIndex])-1)
//				{
//					divergence = pLayerOut->output[0][2*j+1] -ON;
//				}
//				else
//				{
//					divergence = pLayerOut->output[0][2*j+1] -OFF;
//				}
//				error += (divergence*divergence);
//				delta_imag = 2*divergence*pLayerOut->pAf->derivative(pLayerOut->output[0][2*j+1]);
//				outDelta[2*j+1]= delta_imag;
//				//
//				for(m=0; m<numHid1; m++) 
//				{
//					gradient[index++] += (delta_real * pLayerHid1->output[0][2*m]+delta_imag * pLayerHid1->output[0][2*m+1]);
//					gradient[index++] += (-delta_real * pLayerHid1->output[0][2*m+1]+delta_imag * pLayerHid1->output[0][2*m]);
//				}
//				gradient[index++] += delta_real;
//				gradient[index++] += delta_imag;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				suma_real = 0.0;
//				suma_imag = 0.0;
//				for(j=0; j<numOut; j++) 
//				{
//					suma_real += (outDelta[2*j]*pLayerOut->weight[j][2*m]+outDelta[2*j+1]*pLayerOut->weight[j][2*m+1]);
//					suma_imag += (-outDelta[2*j]*pLayerOut->weight[j][2*m+1]+outDelta[2*j+1]*pLayerOut->weight[j][2*m]);
//				}
//				delta_real = suma_real*pLayerHid1->pAf->derivative(pLayerHid1->output[0][2*m]);
//				delta_imag = suma_imag*pLayerHid1->pAf->derivative(pLayerHid1->output[0][2*m+1]);
//				for(j=0; j<numIn; j++) 
//				{
//					gradient[index++] += (delta_real*trainSet[i][2*j]+delta_imag*trainSet[i][2*j+1]);
//					gradient[index++] += (-delta_real*trainSet[i][2*j+1]+delta_imag*trainSet[i][2*j]);
//				}
//				gradient[index++] += delta_real;
//				gradient[index++] += delta_imag;
//			}
//		}
//	}
//	else
//	{
//		const int offset = (netType != Nn::NT_OUTISIN) ? 2*numIn : 0; 
//		for(i=0; i<rows; i++)
//		{
//			index = 0;
//			this->ComputeOutput(trainSet, i);//it updates pLayerOut->output
//			//____________________________________________________________ Output layer gradient
//			for(j=0; j<numOut; j++)
//			{
//				//__________________real________________________
//				divergence = pLayerOut->output[0][2*j] -trainSet[i][offset+2*j];
//				error += (divergence*divergence);
//				delta_real = 2*divergence*pLayerOut->pAf->derivative(pLayerOut->output[0][2*j]);
//				outDelta[2*j]= delta_real;
//				//
//				//__________________imag_______________________
//				divergence = pLayerOut->output[0][2*j+1] -trainSet[i][offset+2*j+1];
//				error += (divergence*divergence);
//				delta_imag = 2*divergence*pLayerOut->pAf->derivative(pLayerOut->output[0][2*j+1]);
//				outDelta[2*j+1]= delta_imag;
//				//
//				for(m=0; m<numHid1; m++) 
//				{
//					gradient[index++] += (delta_real * pLayerHid1->output[0][2*m]+delta_imag * pLayerHid1->output[0][2*m+1]);
//					gradient[index++] += (-delta_real * pLayerHid1->output[0][2*m+1]+delta_imag * pLayerHid1->output[0][2*m]);
//				}
//				gradient[index++] += delta_real;
//				gradient[index++] += delta_imag;
//			}
//			//____________________________________________________________ Hid1 layer gradient
//			for(m=0; m<numHid1; m++)
//			{
//				suma_real = 0.0;
//				suma_imag = 0.0;
//				for(j=0; j<numOut; j++) 
//				{
//					suma_real += (outDelta[2*j]*pLayerOut->weight[j][2*m]+outDelta[2*j+1]*pLayerOut->weight[j][2*m+1]);
//					suma_imag += (-outDelta[2*j]*pLayerOut->weight[j][2*m+1]+outDelta[2*j+1]*pLayerOut->weight[j][2*m]);
//				}
//				delta_real = suma_real*pLayerHid1->pAf->derivative(pLayerHid1->output[0][2*m]);
//				delta_imag = suma_imag*pLayerHid1->pAf->derivative(pLayerHid1->output[0][2*m+1]);
//				for(j=0; j<numIn; j++) 
//				{
//					gradient[index++] += (delta_real*trainSet[i][2*j]+delta_imag*trainSet[i][2*j+1]);
//					gradient[index++] += (-delta_real*trainSet[i][2*j+1]+delta_imag*trainSet[i][2*j]);
//				}
//				gradient[index++] += delta_real;
//				gradient[index++] += delta_imag;
//			}
//		}
//	}
//	const int gradSize = gradient.GetSize();
//	if (pLayerOut->pAf->getType()==Nn::IActiFunc::Type::AF_TANH)
//	{
//		for(i=0; i<gradSize; i++) gradient[i]/=(4.0*rows);
//		return error/(4.0*rows*numOut);
//	}
//	else
//	{
//		for(i=0; i<gradSize; i++) gradient[i]/=rows;
//		return error/(rows*numOut);
//	}
//}

}

void LayerNetC::Constructor()
{
	hasTrainSet = false;
}

void LayerNetC::Delete()
{
	layerHid1.Delete();
	layerOut.Delete();
	scalerInput.Delete();
	scalerOutput.Delete();
	hasTrainSet = false;
	text[0] = '\0';
	//trainSetScaledIn.clear();
	//trainSetScaledTarget.clear();
	//SvdDelete();
}

bool LayerNetC::SvdCreate()
{
	// This for regression in Simulated Annealing and Genetic Algorithm for one hidden layer
	const int layerCount = GetLayerCount();
	if (layerCount != 3) return false; 
	//___________________________________________ input layer, hidden layer, output layer
	const int numTrainCases = (int)trainSetScaledIn.size();
	const int numOutputs = GetOutputCount();
	const int numInputs = GetInputCount();
	const int numRows = 2*numTrainCases;
	const int numCols = 2*(GetHidden1NeuronCount()+1);
	complex<double> input;

	int i, j;
	if (Math::Oper::CreateMatrix(svd_y, numOutputs, numRows) == false) return false;
	//__________________________________________________________  Expected y'
	for(i = 0; i<numOutputs; i++)
	{
		for(j = 0; j<numTrainCases; j++)
		{
			layerHid1.InverseActivationFunction(trainSetScaledTarget[j][i], input);
			svd_y[i][2*j] = input.real();
			svd_y[i][2*j+1] = input.imag();
		}
	}

	try
	{
		svd_b.resize(numCols);
	}
	catch(std::bad_alloc& )
	{
		return false;
	}

	if (Math::Oper::CreateMatrix(svd_a, numRows, numCols) == false) return false;
	if (Math::Oper::CreateMatrix(svd_u, numRows, numCols) == false) return false;

	return true;
}

void LayerNetC::SvdDelete()
{
	svd_a.clear();
	svd_u.clear();
	svd_v.clear();
	svd_y.clear();
	svd_s.resize(0);
	svd_b.resize(0);
}

bool LayerNetC::DeltaCreate()
{
	const int layerCount = GetLayerCount();
	try
	{
		if (layerCount == 2)
		{
			out_derivative.resize(GetOutputCount());
			return true;
		}
		else if (layerCount == 3)
		{
			hid_derivative.resize(GetHidden1NeuronCount());
			out_derivative.resize(GetOutputCount());
			deltaOutput.resize(GetOutputCount());
			return true;
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	return false;
}

void LayerNetC::DeltaDelete()
{
	deltaOutput.resize(0);
	out_derivative.resize(0);
	hid_derivative.resize(0);
}

void LayerNetC::GetDescription(wchar_t* description, int length)
{
	_snwprintf_s(description, length, _TRUNCATE, L"%d, %d, %d", GetInputCount(), GetHidden1NeuronCount(), GetOutputCount());
}

int LayerNetC::GetLayerCount() const
{
	if (GetHidden1NeuronCount() == 0) return 2; // Input and Output Layer
	return 3;// Input, Hidden1 and Output Layer
}

bool LayerNetC::Create(int inputCount, int hidden1Count, int outputCount)
{
	Delete();
	//___________________________________________ check and correct input values
	if (inputCount <= 0) inputCount = 1;
	if (outputCount <= 0) outputCount = 1;
	if (hidden1Count < 0) hidden1Count = 0;
	//___________________________________________ computer layer count
	int layerCount = 0;
	if (hidden1Count == 0)
	{
		layerCount = 2; // Input and Output Layer
	}
	else
	{
		layerCount = 3; // Input, Hidden1 and Output Layer
	}
	//__________________________________________ allocate layers
	bool ok = false;
	switch(layerCount)
	{
	case 2:
		ok = Math::Oper::CreateMatrix(layerOut.weight, outputCount, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	case 3:
		ok = Math::Oper::CreateMatrix(layerHid1.weight, hidden1Count, inputCount+1);
		ok = ok && Math::Oper::CreateMatrix(layerHid1.output, 1, hidden1Count);
		ok = ok && Math::Oper::CreateMatrix(layerOut.weight, outputCount, hidden1Count+1);
		ok = ok && Math::Oper::CreateMatrix(layerOut.output, 1, outputCount);
		break;
	}
	if (ok==false)
	{
		this->Delete();
		return false;
	}
	if (scalerInput.Create(inputCount) == false)
	{
		Delete();
		return false;
	}
	if (scalerOutput.Create(outputCount) == false)
	{
		Delete();
		return false;
	}
	return true;
}

const wchar_t* LayerNetC::Load(const wchar_t* filename)
{
	this->Delete();
	Sys::File file;

	if (file.CreateForReading(filename)== false) return L"The file couldn't be read";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Read(&version, sizeof(int))==false) return L"Unable to read version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Read(&subversion, sizeof(int))==false) return L"Unable to read sub version";
	//
	if (version != NN_NEURAL_LAB_VERSION)// || subversion != NN_NEURAL_LAB_SUBVERSION)
	{
		_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Neural Lab %d.%d does not open files of version %d.%d",
			NN_NEURAL_LAB_VERSION, NN_NEURAL_LAB_SUBVERSION, version, subversion);
		return text;
	}
	//
	if (Sys::SerialAssistant::Load(file, layerHid1.weight) == false) {this->Delete(); return L"Unable to read hidden layer 1";}
	if (layerHid1.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerHid1.output, 1, (int)layerHid1.weight.size()) == false) { this->Delete(); return L"No enough memory for layer hidden 1"; }
	}
	//
	if (Sys::SerialAssistant::Load(file, layerOut.weight) == false) {this->Delete(); return L"Unable to read output layer";}
	if (layerOut.weight.size() > 0)
	{
		if (Math::Oper::CreateMatrix(layerOut.output, 1, (int)layerOut.weight.size()) == false) { this->Delete(); return L"No enough memory for output layer"; }
	}
	//
	if (this->scalerInput.Load(file)==false) {this->Delete(); return L"Unable to read network input scaler";}
	if (this->scalerOutput.Load(file)==false) {this->Delete(); return L"Unable to read network output scaler";}
	return NULL;
}

const wchar_t* LayerNetC::Save(const wchar_t* filename)
{
	Sys::File file;
	wchar_t * error = NULL;

	if (file.CreateForWritting(filename)==false) return L"Unable to write file";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Write(&version, sizeof(int))==false) return L"Unable to write version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Write(&subversion, sizeof(int))==false) return L"Unable to write sub version";
	//
	if (Sys::SerialAssistant::Save(file, layerHid1.weight) == false) return L"Unable to save weights from hidden layer 1";
	if (Sys::SerialAssistant::Save(file, layerOut.weight) == false) return L"Unable to save weights from output layer";
	//
	//
	if (this->scalerInput.Save(file)==false) return L"Unable to save network input scaler";
	if (this->scalerOutput.Save(file)==false) return L"Unable to save network output scaler";
	return NULL;
}

bool LayerNetC::SetWeights(int layerIndex, const MATRIXC& weights)
{
	const int layerCount = GetLayerCount();
	switch(layerCount)
	{
	case 2:
		if (layerIndex == 2) break; // Output
		return false;
	case 3:
		if (layerIndex == 1) break; // Hidden 1
		if (layerIndex == 2) break; // Output
		return false;
	}
	if (layerIndex == 1) //______________ Hidden 1
	{
		if (AreMatrixSameSize(layerHid1.weight, weights) == false) return false;
		layerHid1.weight = weights;
		Math::Oper::CreateMatrix(layerHid1.output, 1, (int)weights.size());
		return true;
	}
	else if (layerIndex ==2) //______________ Output
	{
		if (AreMatrixSameSize(layerOut.weight, weights) == false) return false;
		layerOut.weight = weights;
		Math::Oper::CreateMatrix(layerOut.output, 1, (int)weights.size());
		return true;
	}
	return false;
}

bool LayerNetC::AreMatrixSameSize(const MATRIXC& a, const MATRIXC& b)
{
	if (a.size() != b.size()) return false;
	if (a.size() == 0) return true;
	if (a[0].size() != b[0].size()) return false;
	return true;
}

bool LayerNetC::GetActivation(int layerIndex, valarray<complex<double> > & activation)
{
	const int layerCount = GetLayerCount();
	if (layerIndex == 1)
	{
		if (layerCount != 3) return false;
		activation = layerHid1.output[0];
		return true;
	}
	else if (layerIndex == 2)
	{
		activation = layerOut.output[0];
		return true;
	}
	return false;
}

bool LayerNetC::GetWeights(int layerIndex, MATRIXC& weights)
{
	if (layerIndex == 1)
	{
		weights = layerHid1.weight;
		return true;
	}
	else if (layerIndex == 2)
	{
		weights = layerOut.weight;
		return true;
	}
	return false;
}

int LayerNetC::GetInputCount() const
{
	const int layerCount = GetLayerCount();
	int rows = 0;
	int inputCount = 0;
	switch(layerCount)
	{
	case 2:
		rows = (int)layerOut.weight.size();
		inputCount = (rows == 0) ? 0 : (int)layerOut.weight[0].size() - 1;
		break;
	case 3:
		rows = (int)layerHid1.weight.size();
		inputCount = (rows == 0) ? 0 : (int)layerHid1.weight[0].size() - 1;
		break;
	}
	return inputCount;
}

int LayerNetC::GetOutputCount() const
{
	return (int)layerOut.weight.size();
}

int LayerNetC::GetHidden1NeuronCount() const
{
	return (int)layerHid1.weight.size();
}

void LayerNetC::Unlearn()
{
	this->SimAnnealInitialize();
}

bool LayerNetC::AutoSetInputScaler(MATRIXC& input)
{
	return scalerInput.AutoSet(input);
}

bool LayerNetC::AutoSetOutputScaler(MATRIXC& output)
{
	return scalerOutput.AutoSet(output);
}

bool LayerNetC::SetInputScaler(int index, double minimum, double maximum)
{
	return scalerInput.Set(index, minimum, maximum);
}

bool LayerNetC::SetOutputScaler(int index, double minimum, double maximum)
{
	return scalerOutput.Set(index, minimum, maximum);
}

bool LayerNetC::GetInputScaler(int index, double& minimum, double& maximum)
{
	Nn::ScalingInfo si;
	if (scalerInput.GetScalingInfo(index, si) == false) return false;
	minimum = si.minimum;
	maximum = si.maximum;
	return true;
}

bool LayerNetC::GetOutputScaler(int index, double& minimum, double& maximum)
{
	Nn::ScalingInfo si;
	if (scalerOutput.GetScalingInfo(index, si) == false) return false;
	minimum = si.minimum;
	maximum = si.maximum;
	return true;
}

const wchar_t * LayerNetC::ScaleInputDataSet(const MATRIXC& input, MATRIXC& scaledInput, bool ignoreWarnings)
{
	const int rows = (int)input.size();
	if (rows == 0) return L"The input data set is empty";
	const int cols = (rows == 0) ? 0 : (int)input[0].size();
	if (cols == 0) return L"The input data set is empty";
	if (cols != GetInputCount()) return L"The numb of cols in the input set and the numb of inputs in the network must be equal";
	wchar_t * error  = scalerInput.ScaleToStandardRange(input, scaledInput);
	if (error) return error;

	int i, j;
	double value;
	//______________________________________ Check range
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = scaledInput[i][j].real();
			if (value < NN_LAYERNETC_OFF-0.001  || NN_LAYERNETC_ON+0.001 < value)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The network scaling in input %d is invalid", j);
				return text;
			}
			//
			value = scaledInput[i][j].imag();
			if (value < NN_LAYERNETC_OFF-0.001  || NN_LAYERNETC_ON+0.001 < value)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The network scaling in input %d is invalid", j);
				return text;
			}
		}
	}
	if (ignoreWarnings == false)
	{
		double rsum, rsums;
		double isum, isums;
		double rvariance, ivariance;
		//_____________________________________ Check the set
		for(j = 0; j<cols; j++)
		{
			rsum = 0.0;
			rsums = 0.0;
			//
			isum = 0.0;
			isums = 0.0;
			for(i = 0; i<rows; i++)
			{
				value = input[i][j].real();
				rsum += value;
				rsums += (value*value);
				//
				value = input[i][j].imag();
				isum += value;
				isums += (value*value);
			}
			rvariance = fabs(rsums/(rows-1.0) - (rsum*rsum)/(rows*(rows-1.0)));
			ivariance = fabs(isums/(rows-1.0) - (isum*isum)/(rows*(rows-1.0)));
			if (rvariance < NN_MIN_VARIANCE && ivariance < NN_MIN_VARIANCE)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The colum %i in the input data set has very little information", j);
				return text;
			}
		}
	}
	return NULL;
}

wchar_t* LayerNetC::GetScaledOutput(MATRIXC& scaledOutput)
{
	return scalerOutput.ScaleFromStandardRange(layerOut.output, scaledOutput);
	return NULL;
}

const wchar_t * LayerNetC::ScaleOutputDataSet(const MATRIXC& output, MATRIXC& scaledOutput, bool ignoreWarnings)
{
	const int rows = (int)output.size();
	if (rows == 0) return L"The output set is empty";
	const int cols = (rows == 0) ? 0 : (int)output[0].size();
	if (cols == 0) return L"The output set is empty";
	if (cols != GetOutputCount()) return L"The numb of cols in the output set must be equal to the numb of outputs in the network";
	wchar_t * error  = scalerOutput.ScaleToStandardRange(output, scaledOutput);
	if (error) return error;

	int i, j;
	double value;
	//______________________________________ Check range
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = scaledOutput[i][j].real();
			if (value < NN_LAYERNETC_OFF-0.01 || NN_LAYERNETC_ON+0.01 < value)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Network scaling in output %i is invalid", j);
				return text;
			}
			//
			value = scaledOutput[i][j].imag();
			if (value < NN_LAYERNETC_OFF-0.01 || NN_LAYERNETC_ON+0.01 < value)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Network scaling in output %i is invalid", j);
				return text;
			}
		}
	}

	//_____________________________________ Check variance
	if (ignoreWarnings == false)
	{
		double rsum, rsums;
		double rvariance;
		//
		double isum, isums;
		double ivariance;
		//_____________________________________ Check the set
		for(j = 0; j<cols; j++)
		{
			rsum = 0.0;
			rsums = 0.0;
			//
			isum = 0.0;
			isums = 0.0;
			for(i = 0; i<rows; i++)
			{
				value = scaledOutput[i][j].real();
				rsum += value;
				rsums += (value*value);
				//
				value = scaledOutput[i][j].imag();
				isum += value;
				isums += (value*value);
			}
			rvariance = fabs(rsums/(rows-1.0) - (rsum*rsum)/(rows*(rows-1.0)));
			ivariance = fabs(isums/(rows-1.0) - (isum*isum)/(rows*(rows-1.0)));
			if (rvariance < NN_MIN_VARIANCE && ivariance < NN_MIN_VARIANCE)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Column %i in the target set has little information", j);
				return text;
			}
		}
	}
	return NULL;
}

const wchar_t* LayerNetC::SetTrainingSet(const MATRIXC& trainSetIn, const MATRIXC& trainSetTarget, bool ignoreWarnings)
{
	////trainSetScaledIn.clear();
	////trainSetScaledTarget.clear();

	hasTrainSet = false;
	wchar_t * error = NULL;

	if (trainSetIn.size() != trainSetTarget.size()) return L"The number of rows in the input set and the target set must be equal";

	error = (wchar_t*)ScaleInputDataSet(trainSetIn, trainSetScaledIn, ignoreWarnings);
	if (error) return error;

	error = (wchar_t*)ScaleOutputDataSet(trainSetTarget, trainSetScaledTarget, ignoreWarnings);
	if (error) return error;

	if (ignoreWarnings == false)
	{
		const int minNumTrainCases = GetMinNumTrainCases();
		if (trainSetIn.size() < (size_t)minNumTrainCases)
		{
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The minimum number of training cases is %d", minNumTrainCases);
			return text;
		}
	}

	hasTrainSet = true;

	return NULL;
}

const wchar_t* LayerNetC::TrainGenetic(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::GeneticParam& param)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;
	int individualSize = 0;
	int i, j, k;

	Math::GeneticAlgorithm ga;
	ga.initPopulationSize = param.initPopulationSize;
	ga.numGenerations = param.numGenerations;
	ga.overPopulation = param.overPopulation;
	ga.mutationProbability = param.mutationProbability;
	ga.crossoverProbability = param.crossoverProbability;
	ga.goal = param.goal;
	//
	ga.stopWhenDone = false;
	//
	const int rows = (int)this->layerOut.weight.size();
	const int cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
	const int rowsHid1 = (int)layerHid1.weight.size();
	const int colsHid1 = (rowsHid1 == 0) ? 0 : (int)layerHid1.weight[0].size();

	if (layerCount == 2)
	{
		
		individualSize = 2*rows*cols*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rows; i++)
		{
			for(j = 0; j < cols; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerOut.weight[i][j].real()/NN_LAYERNET_WEIGHTMAX));
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerOut.weight[i][j].imag()/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		SimAnnealGetError(); // To compute the output weights using SVD at the end of the algorithm
		mse.Set(ComputeCurrentTrueMse());
	}
	else if (layerCount == 3)
	{
		SvdCreate();
		individualSize = 2*rowsHid1*colsHid1*NN_BITS_PER_WEIGHT;
		ga.Setup(mse, individualSize, *this);
		//_____________________________Copy Best individual
		k = 0;
		for(i = 0; i<rowsHid1; i++)
		{
			for(j = 0; j < colsHid1; j++)
			{
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid1.weight[i][j].real()/NN_LAYERNET_WEIGHTMAX));
				ga.bestIndividual.bits.SetInt16(k++, (int)(NN_WEIGHT_RES*layerHid1.weight[i][j].imag()/NN_LAYERNET_WEIGHTMAX));
			}
		}
		//____________________________ 
		ga.ThreadFunc(running, progress, resetTime);
		SimAnnealGetError(); // To compute the output weights using SVD at the end of the algorithm
		mse.Set(ComputeCurrentTrueMse());
		SvdDelete();
	}
	return NULL;
}

const wchar_t* LayerNetC::TrainSimAnneal(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, Math::SimAnnealParam& param)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;

	Math::SimulatedAnnealing sa;
	sa.numTemps = param.numTemps;
	sa.numIterations = param.numIterations;
	sa.initialTemp = param.initialTemp;
	sa.finalTemp = param.finalTemp;
	sa.isCoolingScheduleLinear = param.isCoolingScheduleLinear;
	sa.cycles = param.cycles;
	sa.goal = param.goal;

	Nn::LayerNetC work1, work2;
	if (work1.Create(this->GetInputCount(), this->GetHidden1NeuronCount(), this->GetOutputCount()) == false)
	{
		return L"No enough memory to train using Simulated Annealing";
	}
	if (work2.Create(this->GetInputCount(), this->GetHidden1NeuronCount(), this->GetOutputCount()) == false)
	{
		return L"No enough memory to train using Simulated Annealing";
	}
	sa.stopWhenDone = false;
	sa.Setup(mse, *this, work1, work2);

	if (layerCount == 2)
	{
		sa.ThreadFunc(running, progress, resetTime);
	}
	else if (layerCount == 3)
	{
		SvdCreate();
		sa.ThreadFunc(running, progress, resetTime);
		SvdDelete();
	}
	mse.Set(ComputeCurrentTrueMse());
	return NULL;
}

const wchar_t* LayerNetC::TrainConjugateGradient(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return TrainCGVM(running, progress, mse, epochs, goal, WT_MATH_CONJGRAD);
}

const wchar_t* LayerNetC::TrainVariableMetric(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal)
{
	return TrainCGVM(running, progress, mse, epochs, goal, WT_MATH_VARMETRIC);
}

const wchar_t * LayerNetC::TrainCGVM(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, int epochs, double goal, int method)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call SetTrainingSet()";
	if (DeltaCreate() == false) return L"No enough memory";
	const int layerCount = GetLayerCount();
	Mt::BoolTs resetTime;
	const int weightCount = GetWeightCount();
	valarray<double> x(weightCount);
	this->CopyThisToPoint(x);

	Math::FindMinimumMV fmmv;
	fmmv.Setup(mse, *this, x, epochs, goal, method);
	fmmv.stopWhenDone = false;
	fmmv.ThreadFunc(running, progress, resetTime);
	mse.Set(ComputeCurrentTrueMse());

	DeltaDelete();
	return NULL;
}

int LayerNetC::GetWeightCount() const
{
	const int layerCount = GetLayerCount();
	int count = 0;
	int rows, cols;
	if (layerCount >= 2)
	{
		rows = (int)layerOut.weight.size();
		cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
		count += (rows*cols);
	}
	if (layerCount >= 3)
	{
		rows = (int)layerHid1.weight.size();
		cols = (rows == 0) ? 0 : (int)layerHid1.weight[0].size();
		count += (rows*cols);
	}

	return 2*count;
}

bool LayerNetC::Run(const MATRIXC& input, MATRIXC& output)
{
	const int rows = (int)input.size();
	const int cols = (rows == 0) ? 0 : (int)input[0].size();
	if (cols != GetInputCount()) return false;
	MATRIXC scaledInput;
	scalerInput.ScaleToStandardRange(input, scaledInput);
	const int layerCount = GetLayerCount();
	const int outputCount = GetOutputCount();
	//______________________________ Create the output matrix
	try
	{
		output.resize(rows);
	
		for(int i = 0; i<rows; i++)
		{
			ComputeOutput(scaledInput, i, layerCount);  // it updates layerOut.output[0]
			output[i].resize(outputCount);
			scalerOutput.ScaleFromStandardRange(layerOut.output[0], output[i]);
		}
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

void LayerNetC::ComputeOutput(const MATRIXC& input, int inputRowIndex, int layerCount)
{
	switch(layerCount)
	{
	case 2:
		layerOut.ComputeOutput(input, inputRowIndex); //it updates layerOut.output
		break;
	case 3:
		layerHid1.ComputeOutput(input, inputRowIndex);
		layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
		break;
	}
}

void LayerNetC::SimAnnealInitialize()
{
	layerHid1.Initialize();
	layerOut.Initialize();
}

void LayerNetC::SimAnnealPerturb(Math::ISimAnneal& original, double temperature, double initialTemperature)
{
	const double pertubRatio = temperature/initialTemperature;
	const int layerCount = GetLayerCount();
	if (layerCount == 2)
	{
		layerOut.Agitate(pertubRatio, ((Nn::LayerNetC&)original).layerOut);
	}
	else if (layerCount == 3)
	{
		layerHid1.Agitate(pertubRatio, ((Nn::LayerNetC&)original).layerHid1);
		//__________________ LayerOut is not perturbed as Regression is used at the output level
	}
}

double LayerNetC::SimAnnealGetError()
{
	const int layerCount = GetLayerCount();
	const int rows = (int)trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	const int numHid1 = GetHidden1NeuronCount();
	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j].real() - trainSetScaledTarget[i][j].real();
				mse += diff * diff;
				//
				diff = layerOut.output[0][j].imag() - trainSetScaledTarget[i][j].imag();
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 3)
	{
		//______________________________________________________ A = [areal00, -aimag00, areal01, -iamag01, ... 1, 0]   yreal
		//______________________________________________________ A = [aimag00, areal00, aimag01, areal01, ... 0, 1]     yimag
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);	
			
			for(j = 0; j<numHid1; j++)
			{
				//______________________________________ Even rows
				svd_a[2*i][2*j] = layerHid1.output[0][j].real();
				svd_a[2*i][2*j+1] = -layerHid1.output[0][j].imag();
				//______________________________________ Odd rows
				svd_a[2*i+1][2*j] = layerHid1.output[0][j].imag();
				svd_a[2*i+1][2*j+1] = layerHid1.output[0][j].real();
			}
			//______________________________________ Even rows
			svd_a[2*i][2*numHid1] = 1.0; // Bias real
			svd_a[2*i][2*numHid1+1] = 0.0; // Bias imag
			//______________________________________ Odd rows
			svd_a[2*i+1][2*numHid1] = 0.0; // Bias imag
			svd_a[2*i+1][2*numHid1+1] = 1.0; // Bias real			
		}
		//______________________________________________________ Compute Ouput Weights using SVD
		Math::SingValDecompos::Decompose(svd_a, svd_u, svd_s, svd_v);
		double value;
		for(i=0; i<outputCount; i++)
		{
			Math::SingValDecompos::BackSubstitution(svd_u, svd_s, svd_v, svd_y[i], svd_b);
			// Copy the weights from svd_b to layerOut.weight
			for(j = 0; j < numHid1+1; j++)
			{
				value = svd_b[2*j];
				if (value > 30.0) value = NN_LAYERNET_WEIGHTMAX;
				if (value < -30.0) value = -NN_LAYERNET_WEIGHTMAX;
				layerOut.weight[i][j].real(value);
				//
				value = svd_b[2*j+1];
				if (value > 30.0) value = NN_LAYERNET_WEIGHTMAX;
				if (value < -30.0) value = -NN_LAYERNET_WEIGHTMAX;
				layerOut.weight[i][j].imag(value);
			}
		}
		
		//_____________________________________________________ Compute mse
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);	
			layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			//layerOut.ComputeOutput(svd_a, i); // Instead of computing the activation again, we use svd_a
			for(j = 0; j < outputCount; j++)
			{
				diff = layerOut.output[0][j].real() - trainSetScaledTarget[i][j].real();
				mse += diff * diff;
				//
				diff = layerOut.output[0][j].imag() - trainSetScaledTarget[i][j].imag();
				mse += diff * diff;
			}
		}
	}
	return mse/(2*rows*outputCount);
}

void LayerNetC::SimAnnealCopy(const Math::ISimAnneal& source)
{
	Nn::LayerNetC& net_source((Nn::LayerNetC&)source);
	const int layerCount = GetLayerCount();

	if (layerCount == 2)
	{
		this->layerOut = net_source.layerOut;
	}
	else if (layerCount == 3)
	{
		this->layerHid1 = net_source.layerHid1;
		this->layerOut = net_source.layerOut;
	}	
}

void LayerNetC::GeneticInitialize(Sys::BoolArray& bits)
{
	const int bitCount = bits.GetCount();
	const int weightCount = bitCount / NN_BITS_PER_WEIGHT; 
	std::tr1::uniform_real<double> dis(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);
	int i;
	__int16 value;
	double weight = 0.0;
	for(i = 0; i < weightCount; i++)
	{
		weight = dis(Math::Statistics::random_generator);
		value = (__int16)(NN_WEIGHT_RES*weight/NN_LAYERNET_WEIGHTMAX);
		bits.SetInt16(i, value);
	}
}

double LayerNetC::GeneticGetError()
{
	return SimAnnealGetError();
}

void LayerNetC::GeneticSetFromBits(const Sys::BoolArray& bits)
{
	const int layerCount = GetLayerCount();
	int i, j, k = 0;

	if (layerCount == 2)
	{
		const int rows = (int)this->layerOut.weight.size();
		const int cols = (rows == 0) ? 0 : (int)layerOut.weight[0].size();
		//__________________________________________________________ Output
		for (i = 0; i < rows; i++)
		{
			for (j = 0; j < cols; j++)
			{
				layerOut.weight[i][j].real(NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES);
				layerOut.weight[i][j].imag(NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES);
			}
		}
	}
	else if (layerCount == 3)
	{
		const int rowsHid1 = (int)layerHid1.weight.size();
		const int colsHid1 = (rowsHid1 == 0) ? 0 : (int)layerHid1.weight[0].size();
		//_________________________________________________________ Hidden 1
		for (i = 0; i < rowsHid1; i++)
		{
			for (j = 0; j < colsHid1; j++)
			{
				layerHid1.weight[i][j].real(NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES);
				layerHid1.weight[i][j].imag(NN_LAYERNET_WEIGHTMAX *bits.GetInt16(k++)/(double)NN_WEIGHT_RES);
			}
		}
	}
}


double LayerNetC::ComputeCurrentTrueMse()
{
	MATRIXC trainSet_target;

	wchar_t * error = NULL;

	//_____________________________________ De Scaled the training set output
	error = scalerOutput.ScaleFromStandardRange(trainSetScaledTarget, trainSet_target);
	if (error != NULL) return -1.0;
	//
	const int layerCount = GetLayerCount();
	const int rows = (int)trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	valarray<complex<double> >output;
	try
	{
		output.resize(outputCount);
	}
	catch(std::bad_alloc& )
	{
		return -1.0;
	}

	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		//__________________________________________ Compute and scale the network output
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j].real() - output[j].real();
				mse += diff * diff;
				//
				diff = trainSet_target[i][j].imag() - output[j].imag();
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 3)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j].real() - output[j].real();
				mse += diff * diff;
				//
				diff = trainSet_target[i][j].imag() - output[j].imag();
				mse += diff * diff;
			}
		}
	}	
	else
	{
		return -1.0;
	}
	return mse/(2*rows*outputCount);
}

double LayerNetC::ComputeTrueMse(const MATRIXC& trainSet_in, const MATRIXC& trainSet_target)
{
	wchar_t * error = NULL;

	//_____________________________________ Scaled the training set input
	error = scalerInput.ScaleToStandardRange(trainSet_in, trainSetScaledIn);
	if (error != NULL) return -1.0;

	const int layerCount = GetLayerCount();
	const int rows = (int)trainSetScaledIn.size();
	const int outputCount = GetOutputCount();
	valarray<complex<double> > output;
	try
	{
		output.resize(outputCount);
	}
	catch(std::bad_alloc& )
	{
		return -1.0;
	}

	int i, j;
	double mse = 0.0;
	double diff  = 0.0;

	if (layerCount == 2)
	{
		//__________________________________________ Compute and scale the network output
		for(i = 0; i<rows; i++)
		{
			layerOut.ComputeOutput(trainSetScaledIn, i); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j].real() - output[j].real();
				mse += diff * diff;
				//
				diff = trainSet_target[i][j].imag() - output[j].imag();
				mse += diff * diff;
			}
		}
	}
	else if (layerCount == 3)
	{
		for(i = 0; i<rows; i++)
		{
			layerHid1.ComputeOutput(trainSetScaledIn, i);
			layerOut.ComputeOutput(layerHid1.output, 0); //it updates layerOut.output
			error = scalerOutput.ScaleFromStandardRange(layerOut.output[0], output);
			if (error != NULL) return -1.0;
			for(j = 0; j < outputCount; j++)
			{
				diff = trainSet_target[i][j].real() - output[j].real();
				mse += diff * diff;
				//
				diff = trainSet_target[i][j].imag() - output[j].imag();
				mse += diff * diff;
			}
		}
	}
	else
	{
		return -1.0;
	}
	return mse/(2.0*rows*outputCount);
}


//_____________________________________________________________________ KohoNet
KohoNet::KohoNet()
{
	Constructor();
}

KohoNet::~KohoNet()
{
	Delete();
}

KohoNet::KohoNet(const KohoNet& init)
{
	Constructor();
	Copy(init);
}

KohoNet& KohoNet::operator=(const KohoNet& init)
{
	Delete();
	Copy(init);
	return *this;
}

// normType: NN_KOHONET_NORM_MULTIPLICATIVE, NN_KOHONET_NORM_ZAXIS
bool KohoNet::Create(int numInputs, int numOutputs, int inputNormType)
{
	Delete();
	int i, j;
	//__________________________________________ Create weights
	try
	{
		weights.resize(numOutputs);
		for(i = 0; i<numOutputs; i++)
		{
			weights[i].resize(numInputs+1);
			for(j = 0; j <numInputs+1; j ++) weights[i][j] = 0.0;
		}
	}
	catch (const std::bad_alloc& )
	{
		return false;
	}
	//__________________________________________ inputNormalization
	if (inputNormType == NN_KOHONET_NORM_MULTIPLICATIVE)
	{
		this->inputNormType = NN_KOHONET_NORM_MULTIPLICATIVE;
	} 
	else
	{
		this->inputNormType = NN_KOHONET_NORM_ZAXIS;
	}
	if (this->scalerInput.Create(numInputs) == false)
	{
		Delete();
		return L"No enough memory to create input scaler";
	}
	return true;
}

void KohoNet::Copy(const KohoNet &init)
{
	this->weights = init.weights;
	this->scalerInput = init.scalerInput;
	this->hasTrainSet = init.hasTrainSet;
}

void KohoNet::Constructor()
{
	inputNormType = NN_KOHONET_NORM_MULTIPLICATIVE;
	text[0] = '\0';
	hasTrainSet = false;
	stopWhenDone = true; 
}

void KohoNet::Delete()
{
	inputNormType = NN_KOHONET_NORM_MULTIPLICATIVE;
	text[0] = '\0';
	hasTrainSet = false;
	//
	weights.clear();
	scalerInput.Delete();
}

void KohoNet::GetDescription(wchar_t* description, int length)
{
	_snwprintf_s(description, length, _TRUNCATE, L"%d,%d", GetInputCount(), GetOutputCount());
}

const wchar_t* KohoNet::Load(const wchar_t* filename)
{
	this->Delete();
	Sys::File file;

	if (file.CreateForReading(filename)== false) return L"The file couldn't be read";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Read(&version, sizeof(int))==false) return L"Unable to read version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Read(&subversion, sizeof(int))==false) return L"Unable to read sub version";
	//
	if (version != NN_NEURAL_LAB_VERSION)// || subversion != NN_NEURAL_LAB_SUBVERSION)
	{
		_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Neural Lab %d.%d does not open files of version %d.%d",
			NN_NEURAL_LAB_VERSION, NN_NEURAL_LAB_SUBVERSION, version, subversion);
		return text;
	}
	//
	if (Sys::SerialAssistant::Load(file, weights) == false) {this->Delete(); return L"Unable to read network weights";}

	if (this->scalerInput.Load(file)==false) {this->Delete(); return L"Unable to read network input scaler";}
	//________________________________________________________ Read inputNormType
	if (file.Read(&inputNormType, sizeof(int))==false) return L"Unable to read normalization type";
	if (inputNormType != NN_KOHONET_NORM_MULTIPLICATIVE) inputNormType = NN_KOHONET_NORM_ZAXIS;

	return NULL;
}

const wchar_t* KohoNet::Save(const wchar_t* filename)
{
	Sys::File file;
	wchar_t * error = NULL;

	if (file.CreateForWritting(filename)==false) return L"Unable to write file";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Write(&version, sizeof(int))==false) return L"Unable to write version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Write(&subversion, sizeof(int))==false) return L"Unable to write sub version";
	//
	if (Sys::SerialAssistant::Save(file, weights) == false) return L"Unable to save weights";
	//
	if (this->scalerInput.Save(file)==false) return L"Unable to save network input scaler";
	//
	if (file.Write(&inputNormType, sizeof(int))==false) return L"Unable to write inputNormType";
	return NULL;
}

bool KohoNet::SetWeights(const MATRIX& weights)
{
	if (this->weights.size() != weights.size()) return false;
	if (this->weights.size() == 0) return true;
	if (this->weights[0].size() != weights[0].size()) return false;
	this->weights = weights;
	return true;
}

void KohoNet::GetWeights(MATRIX& weights)
{
	weights = this->weights;
}

void KohoNet::GetNormalizedInput(MATRIX& normInput)
{
	normInput = this->normInput;
}

int KohoNet::GetInputCount() const
{
	const int outputCount = (int)weights.size();
	if (outputCount == 0) return 0;
	return (int)(weights[0].size() - 1);// There is always an extra input
}

int KohoNet::GetOutputCount() const
{
	return (int)weights.size();
}

bool KohoNet::SetInputScaler(int index, double minimum, double maximum)
{
	return scalerInput.Set(index, minimum, maximum);
}

bool KohoNet::GetInputScaler(int index, double& minimum, double& maximum)
{
	Nn::ScalingInfo si;
	if (scalerInput.GetScalingInfo(index, si) == false) return false;
	minimum = si.minimum;
	maximum = si.maximum;
	return true;
}

bool KohoNet::AutoSetInputScaler(MATRIX& input)
{
	return scalerInput.AutoSet(input);
}

double KohoNet::SumSquares(const valarray<double>& input)
{
	const int count = (int)input.size();
	double sum = 0.0;
	for(int i = 0; i < count; i++) sum += (input[i] * input[i]);
	return sum;
}

const wchar_t* KohoNet::SetTrainingSet(const MATRIX& trainSetIn, bool ignoreWarnings)
{
	hasTrainSet = false;
	wchar_t * error = (wchar_t*)ScaleInputDataSet(trainSetIn, normInput, ignoreWarnings);
	if (error) return error;

	hasTrainSet = true;
	return NULL;
}

const wchar_t * KohoNet::ScaleInputDataSet(const MATRIX& input, MATRIX& scaledInput, bool ignoreWarnings)
{
	const int rows = (int)input.size();
	if (rows == 0) return L"The input data set is empty";
	const int cols = (rows == 0) ? 0 : (int)input[0].size();
	if (cols == 0) return L"The input data set is empty";
	const int numInputs = GetInputCount();
	if (cols != numInputs) return L"The numb of cols in the input set and the numb of inputs in the network must be equal";
	wchar_t * error  = scalerInput.ScaleTo11(input, scaledInput);
	if (error) return error;

	int i, j;
	double value;
	//______________________________________ Check range
	for(i = 0; i<rows; i++)
	{
		for(j = 0; j<cols; j++)
		{
			value = scaledInput[i][j];
			if (-1.001 <= value && value <= 1.001) continue;
			_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The network scaling in input %d is invalid", j);
			return text;
		}
	}
	if (ignoreWarnings == false)
	{
		double sum, sums;
		double variance;
		//_____________________________________ Check the input set for minimum variance
		for(j = 0; j<cols; j++)
		{
			sum = 0.0;
			sums = 0.0;
			for(i = 0; i<rows; i++)
			{
				value = input[i][j];
				sum += value;
				sums += (value*value);
			}
			variance = fabs(sums/(rows-1.0) - (sum*sum)/(rows*(rows-1.0)));
			if (variance < NN_MIN_VARIANCE)
			{
				_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"The colum %i in the input data set has very little information", j);
				return text;
			}
		}
	}
	//________________________________________ Normalize the Training Set Input
	if (inputNormType == NN_KOHONET_NORM_MULTIPLICATIVE)
	{
		double length; // ___________________Masters 18-2 (Page 330)
		for (i = 0; i < rows; i++) 
		{
			length = sqrt(Nn::KohoNet::SumSquares(normInput[i]));
			if (length < 1.0e-25) return L"There is a zero length input";
			for(j = 0; j < cols; j ++)
			{
				normInput[i][j] = normInput[i][j] / length; 
			}
			normInput[i][cols] = 0.0;  // Be sure synthetic input is zero
		}
	}
	else if (inputNormType == NN_KOHONET_NORM_ZAXIS)
	{
		const double n = (double)numInputs;
		const double f = 1.0/sqrt(n);   //____________ Masters 18-3 (Page 331)
		double sumSquares;
		for (i = 0; i < rows; i++) 
		{
			sumSquares = Nn::KohoNet::SumSquares(normInput[i]);
			for(j = 0; j < cols; j ++)
			{
				normInput[i][j] = f*normInput[i][j];
			}
			normInput[i][cols] = f*sqrt(n- sumSquares);  // Compute Synthetic input
		}
	}
	return NULL;
}

const wchar_t* KohoNet::TrainAdditive(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& error, double learningRate, int numIterations)
{
	return Train(NN_KOHONET_TRAIN_ADDITIVE, running, progress, error, learningRate, numIterations);
}

const wchar_t* KohoNet::TrainSubtractive(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& error, double learningRate, int numIterations)
{
	return Train(NN_KOHONET_TRAIN_SUBTRACTIVE, running, progress, error, learningRate, numIterations);
}

const wchar_t* KohoNet::Train(int trainMethod, Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& error, const double learningRate, int numIterations)
{
	if (hasTrainSet == false) return L"The training set is missing.  Call net.SetTrainingSet()";
	const int maxRetries = (int)(0.2*numIterations+0.5);
	int i;
	//__________________________________________________________ Best weights
	MATRIX bestWeights;
	const int numOutputs = GetOutputCount();
	const int numInputs = GetInputCount();
	if (Math::Oper::CreateMatrix(bestWeights, numOutputs, numInputs+1) == false) return L"No enough memory";
	//__________________________________________________________ Correction Matrix (same size as weights)
	MATRIX correction;
	if (Math::Oper::CreateMatrix(correction, numOutputs, numInputs+1) == false) return L"No enough memory";
	//
	//__________________________________________________________ Next weight valarray for Additive only
	valarray<double> next_weight;
	if (trainMethod == NN_KOHONET_TRAIN_ADDITIVE)
	{
		try
		{
			next_weight.resize(numInputs+1);
		}
		catch (std::bad_alloc& )
		{
			 return L"No enough memory";
		}
	}
	//__________________________________________________________ output & neuronWinCount
	valarray<double> output;
	valarray<int> neuronWinCount;
	try
	{
		output.resize(numOutputs);
		//
		neuronWinCount.resize(numOutputs);
		for(i = 0; i < numOutputs; i++) neuronWinCount[i] = 0;
	}
	catch (std::bad_alloc& )
	{
		return L"No enough memory";
	}
	//
	progress.SetTry(0.0);
	//________________________________________________________ Initialize Current Network
	InitializeWeights(weights, inputNormType);
	double neterr = 1.0;
//
	int neuronCountWinnerPerIteration = 0; // Compute the total number of Neurons that win per iteration
	double epochError = 1.0e10; 
	double bestError = 1.0e10;  // This keeps track of the error of bestWeights
	const int numTrainCases = (int)normInput.size();
	bool firstTime = true;

	bool isRunning = false;
	double currentLearnRate = learningRate;
	int retriesCount = 0;

	for (int iterationCount=0; iterationCount < numIterations; iterationCount++) 
	{
		epochError = ComputeMaxErrorAndCorrection(trainMethod, currentLearnRate, correction, neuronWinCount, next_weight);

		if (epochError < bestError || firstTime == true)
		{  
			bestError = epochError;
			bestWeights = this->weights;
			error.SetTry(bestError*bestError/10.0); // Report squared error
			firstTime = false;
		}
		//____________________________ Compute the number of neurons which won this iteration
		neuronCountWinnerPerIteration = 0;     
		for (i = 0; i < numOutputs; i++)
		{
			if (neuronWinCount[i] > 0) neuronCountWinnerPerIteration++;
		}
		progress.SetTry((iterationCount+1.0)/numIterations);
	
		if (running.GetTry(isRunning) == true)
		{
			if (isRunning == false) break;
		}

		if (neuronCountWinnerPerIteration < numOutputs  &&  neuronCountWinnerPerIteration < numTrainCases) 
		{
			ForceNeuronToWin(neuronWinCount, output);
			continue;
		}
		if (ApplyCorrection(trainMethod, correction, neuronWinCount)/currentLearnRate < 1.0e-5) //______ Tiny Improvement
		{ 
			retriesCount++;
			if (retriesCount > maxRetries) break;
			//_________________________________ Start Over
			InitializeWeights(weights, inputNormType);
			iterationCount= -1; 
			currentLearnRate = learningRate; 
			epochError = 1.0e10; 
			//firstTime = true;  // We comment this line out to keep the current error
			continue;
		}
		if (currentLearnRate > 0.01) currentLearnRate *= 0.98;
	}
	
	progress.SetTry(1.0);
	if (stopWhenDone == true) running.Set(false);
	this->weights = bestWeights; 
	//______________________ Normalize weights
	for (i = 0; i < numOutputs; i++)
	{
		NormalizeWeights(weights[i], inputNormType);
	}
	//______________________ Compute error
	bestError= ComputeMaxErrorAndCorrection(trainMethod, currentLearnRate, correction, neuronWinCount, next_weight);
	error.SetTry(bestError*bestError/10.0); // Report squared error

	return NULL;
}

void KohoNet::NormalizeWeights(valarray<double>& weights, int inputNormType)
{
	const int numInputs = (int)weights.size() - 1;
	double squared_len = 0.0;
	int i = 0;
	if (inputNormType == NN_KOHONET_NORM_MULTIPLICATIVE)
	{
		for(i = 0; i < numInputs; i++) squared_len += (weights[i]*weights[i]); // Ignore last weight
	}
	else //________________ NN_KOHONET_NORM_ZAXIS
	{
		for(i = 0; i <= numInputs; i++) squared_len += (weights[i]*weights[i]);
	}
	
	const double f = 1.0 / sqrt(squared_len);
	for (int i = 0; i <= numInputs; i++) weights[i] *= f;
	if (inputNormType == NN_KOHONET_NORM_MULTIPLICATIVE) weights[numInputs] = 0.0; //Set last weight to zero
}

const wchar_t* KohoNet::Run(const MATRIX& input, MATRIX& output)
{
	hasTrainSet = false; // Force user to call SetTrainingSet, if he wants to train again
	const wchar_t * error = ScaleInputDataSet(input, normInput, false);
	if (error != NULL) return error;
	const int rows = (int)normInput.size();
	for(int i = 0; i < rows; i++) Run(i, output[i]);
	return NULL;
}

const wchar_t* KohoNet::ComputeWinner(const MATRIX& input, valarray<double>& output)
{
	hasTrainSet = false; // Force the user to call SetTrainingSet, if he wants to train again
	const wchar_t * error = ScaleInputDataSet(input, normInput, false);
	if (error != NULL) return error;
	const int rows = (int)normInput.size();
	try
	{
		if (output.size() != rows) output.resize(rows);
	}
	catch(std::bad_alloc&)
	{
		return L"No enough memory";
	}
	for(int i = 0; i < rows; i++) output[i] = ComputeWinner(i);
	return NULL;
}

const wchar_t* KohoNet::ComputeWinner(const MATRIX& input, valarray<int>& output)
{
	hasTrainSet = false; // Force the user to call SetTrainingSet, if he wants to train again
	const wchar_t * error = ScaleInputDataSet(input, normInput, false);
	if (error != NULL) return error;
	const int rows = (int)normInput.size();
	try
	{
		if (output.size() != rows) output.resize(rows);
	}
	catch(std::bad_alloc&)
	{
		return L"No enough memory";
	}
	for(int i = 0; i < rows; i++) output[i] = ComputeWinner(i);
	return NULL;
}

// Compute the winner and the output for the train case specificied by the index in trainCaseIndex
int KohoNet::Run(int trainCaseIndex, valarray<double>& output)
{
	int winnerIndex = -1; // Invalid value
	double winnerOutput = -1.0e50; // Invalid value
	const int cols = GetInputCount() +1;
	const int numOutputs = GetOutputCount();
	double _output = 0.0;
	int i, j;
	for (i = 0; i < numOutputs; i++) 
	{
		_output = 0.0;
		for(j = 0; j < cols; j++)
		{
			_output += weights[i][j] * normInput[trainCaseIndex][j];
		}
		
		_output= 0.5 * (_output + 1.0);   // Convert from [-1 1] to [0 1]
		//____________________ Compute biggest
		if (_output > winnerOutput || winnerIndex < 0) // Accept first value 
		{
			winnerOutput = _output;
			winnerIndex = i;
		}
		if (_output > 1.0) _output = 1.0;
		if (_output < -1.0) _output = -1.0;
		output[i] = _output;
	}
	return winnerIndex;
}

// Compute the winner for the specific train case by the index trainCaseIndex
int KohoNet::ComputeWinner(int trainCaseIndex)
{
	int winnerIndex = -1;  // Invalid neuron index
	double winnerOutput = -1.0e-50; // Invalid output
	const int cols = GetInputCount() +1;
	const int numOutputs = GetOutputCount();
	double output = 0.0;
	int i, j;
	for (i = 0; i < numOutputs; i++) 
	{
		output = 0.0;
		for(j = 0; j < cols; j++)
		{
			output += weights[i][j] * normInput[trainCaseIndex][j];
		}
		
		output = 0.5 * (output + 1.0);   // Convert from [-1 1] to [0 1]
		//____________________ Compute biggest
		if (output > winnerOutput || winnerIndex < 0) // Accept this: when the output is the first time (winnerIndex is negative) 
		{
			winnerOutput = output;
			winnerIndex = i;
		}
	}
	return winnerIndex;
}

void KohoNet::Unlearn()
{
	Nn::KohoNet::InitializeWeights(weights, inputNormType);
}

void KohoNet::InitializeWeights(MATRIX& weights, int inputNormType)
{
	const int rows = (int)weights.size();
	if (rows<=0) return;
	const int cols = (weights.size() == 0) ? 0 : (int)weights[0].size();
	if (cols<=0) return;
	std::tr1::uniform_real<double> dist(-NN_LAYERNET_WEIGHTMAX, NN_LAYERNET_WEIGHTMAX);

	int i, j;
	for(i = 0; i<rows; i++)
	{
		for(j=0; j<cols; j++)
		{
			weights[i][j] = dist(Math::Statistics::random_generator);
		}
		Nn::KohoNet::NormalizeWeights(weights[i], inputNormType);
	}
}

// It returns the maximum error
// It returns the variables: correction, neuronWinCount
double KohoNet::ComputeMaxErrorAndCorrection(int trainMethod, double learningRate, MATRIX& correction, valarray<int>& neuronWinCount, valarray<double> next_weight)
{
	int i, j;
	const int numInputs = GetInputCount();
	const int numOutputs = GetOutputCount();
	//_______________________________________________________ Reset: correction and neuronWinCount
	Math::Oper::SetTo(correction, 0.0);
	for(i = 0; i < numOutputs; i++) neuronWinCount[i] = 0;

//
	double maximumError = 0.0;
	const int rows = (int)normInput.size();

	int winnerNeuronIndex;
	double diff = 0.0;
	double sumSquares = 0.0;
	//____________________________________________________  For each train case
	for (i = 0; i < rows; i++) 
	{
		winnerNeuronIndex = ComputeWinner(i);
		if (winnerNeuronIndex < 0 || winnerNeuronIndex >= numOutputs) continue;  // Impossible to get here
		neuronWinCount[winnerNeuronIndex]++;
		sumSquares = 0.0;
		//_______________________________________ Inputs
		for (j = 0; j <= numInputs; j++) 
		{
			diff = normInput[i][j] - weights[winnerNeuronIndex][j]; 
			
			if (trainMethod == NN_KOHONET_TRAIN_ADDITIVE)
			{
				next_weight[j] = weights[winnerNeuronIndex][j] + learningRate*normInput[i][j]; 
			}
			else //__________NN_KOHONET_TRAIN_SUBTRACTIVE
			{
				correction[winnerNeuronIndex][j] += (learningRate*diff); 
			}
			sumSquares += (diff*diff); 
		}

		if (sumSquares > maximumError) maximumError = sumSquares;

		if (trainMethod == NN_KOHONET_TRAIN_ADDITIVE) 
		{ 
			NormalizeWeights(next_weight, inputNormType);
			for (j = 0; j <= numInputs; j++)  correction[winnerNeuronIndex][j] += (next_weight[j] - weights[winnerNeuronIndex][j]); // Cumulate dw
		}
	}
	//_________________________________________________________ Compute the mean correction
	for (i = 0; i < numOutputs; i++) 
	{     
		if (neuronWinCount[i] == 0) continue; // Nothing to apply
		for (j = 0; j <= numInputs; j++) correction[i][j] /= neuronWinCount[i];
	}
	return sqrt(maximumError);
}

double KohoNet::ApplyCorrection(int trainMethod, MATRIX& correction, valarray<int>& neuronWinCount)
{
	double maximumCorrection = 0.0;
	double sumSquares = 0.0;
	const int numInputs = GetInputCount();
	const int numOutputs = GetOutputCount();
	double tmp;
	int i, j;
	for (i = 0; i < numOutputs; i++) 
	{     
		if (neuronWinCount[i] == 0) continue; // Nothing to apply
		sumSquares = 0.0; 

		for (j = 0; j <= numInputs; j++) // Weight vector for this neuron
		{   
			tmp = correction[i][j];
			weights[i][j] += tmp;
			sumSquares += (tmp*tmp); 
		}

		if (sumSquares > maximumCorrection) maximumCorrection = sumSquares; 		
	}
	//____________________________________ 
	return sqrt(maximumCorrection);
}

void KohoNet::ForceNeuronToWin(valarray<int>& neuronWinCount, valarray<double>& output)   
{
	const int numInputs = GetInputCount();
	const int numOutputs = GetOutputCount();
	const int numTrainCases = (int)this->normInput.size();

	int i;
	int winnerIndex = 0;

	//_____________________________________________ Find the case that produced the Least Activation
	int trainCaseWithLeastActivation = -1; // Invalid index value
	double smallestOutput = 1.0e100;// Invalid value
	for (i = 0; i < numTrainCases; i++) 
	{
		winnerIndex = Run(i, output);
		if (output[winnerIndex] < smallestOutput || trainCaseWithLeastActivation < 0) // Accept the first time 
		{ 
			smallestOutput = output[winnerIndex]; 
			trainCaseWithLeastActivation = i; 
		}
	}

	//_____________________________________________ Find the second winner for the case that produced the Least Activation
	Run(trainCaseWithLeastActivation, output);
	double maximumOutput = 0.0; // Invalid value
	int secondWinnerNeuron = -1; // Invalid index value
	for(i = 0; i < numOutputs; i++)
	{
		if (neuronWinCount[i] == 0) // This is a loser neuron
		{
			if (output[i] > maximumOutput || secondWinnerNeuron < 0) // Accept the first time 
			{ 
				maximumOutput = output[i]; 
				secondWinnerNeuron = i;
			}
		}
	}
	
	//____________________________________________ Set the weights of this neuron to the train case input (as input is normalized, weights are normalized)
	for(i = 0; i <= numInputs; i++)
	{
		this->weights[secondWinnerNeuron][i] = normInput[trainCaseWithLeastActivation][i]; 
	}
}

//_____________________________________________________________________ ProbNet
ProbNet::ProbNet()
{
	Constructor();
}

ProbNet::~ProbNet()
{
}

ProbNet::ProbNet(const ProbNet& init)
{
	Constructor();
	Copy(init);
}

void ProbNet::Constructor()
{
	numOutputs = 0;
	numTrainCases = 0;
	text[0] = '\0';
}

int ProbNet::GetInputCount()
{
	return (int)weight.size();
}

int ProbNet::GetOutputCount()
{
	return numOutputs;
}

void ProbNet::GetWeights(valarray<double>& weights)
{
	weights = this->weight;
}

void ProbNet::SetWeights(const valarray<double>& weights)
{
	this->weight = weights;
}

const wchar_t* ProbNet::Load(const wchar_t* filename)
{
	this->Delete();
	Sys::File file;

	if (file.CreateForReading(filename)== false) return L"The file couldn't be read";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Read(&version, sizeof(int))==false) return L"Unable to read version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Read(&subversion, sizeof(int))==false) return L"Unable to read sub version";
	//
	if (version != NN_NEURAL_LAB_VERSION)// || subversion != NN_NEURAL_LAB_SUBVERSION)
	{
		_snwprintf_s(text, NN_LAYERNET_TEXTMAX, _TRUNCATE, L"Neural Lab %d.%d does not open files of version %d.%d",
			NN_NEURAL_LAB_VERSION, NN_NEURAL_LAB_SUBVERSION, version, subversion);
		return text;
	}
	//
	if (Sys::SerialAssistant::Load(file, weight) == false) {this->Delete(); return L"Unable to read network weights";}
	if (file.Read(&numOutputs, sizeof(int))==false) return L"Unable to read the number of outputs";
	if (file.Read(&numTrainCases, sizeof(int))==false) return L"Unable to read the number of training cases";

	return NULL;
}

const wchar_t* ProbNet::Save(const wchar_t* filename)
{
	Sys::File file;
	wchar_t * error = NULL;

	if (file.CreateForWritting(filename)==false) return L"Unable to write file";
	//
	int version = NN_NEURAL_LAB_VERSION;
	if (file.Write(&version, sizeof(int))==false) return L"Unable to write version";
	//
	int subversion = NN_NEURAL_LAB_SUBVERSION;
	if (file.Write(&subversion, sizeof(int))==false) return L"Unable to write sub version";
	//
	if (Sys::SerialAssistant::Save(file, weight) == false) return L"Unable to save weights";
	if (file.Write(numOutputs) == false) return L"Unable to save the number of outputs";
	if (file.Write(numTrainCases) == false) return L"Unable to save the number of trainining cases";
	return NULL;
}

ProbNet& ProbNet::operator=(const ProbNet& init)
{
	Delete();
	Copy(init);
	return *this;
}

void ProbNet::Copy(const ProbNet &init)
{
	this->weight = init.weight;
	this->numOutputs = init.numOutputs;
	this->numTrainCases = init.numTrainCases;
	//__________________________ They are not part of the PNN, they are used for training.  So they do need to be copied
	this->trainSetInput.clear();
	this->trainSetTarget.clear();
}

void ProbNet::Delete()
{
	numOutputs = 0;
	numTrainCases = 0;
	weight.resize(0);
	//_______________________ The following deletes are just for safety.  They are not necessary.
	trainSetInput.clear();
	trainSetTarget.clear();
	out.resize(0);
	text[0] = '\0';
}

void ProbNet::GetDescription(wchar_t* description, int length)
{
	const int numInputs = (int)weight.size();
	_snwprintf_s(description, length, _TRUNCATE, L"%d,%d", numInputs, numOutputs);
}

const wchar_t* ProbNet::TrainConjugateGradient(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, const MATRIX& trainSetInput, const MATRIX& trainSetTarget, int epochs, double goal)
{
	return Train(running, progress, mse, trainSetInput, trainSetTarget, epochs, goal, WT_MATH_CONJGRAD);
}

const wchar_t* ProbNet::TrainVariableMetric(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, const MATRIX& trainSetInput, const MATRIX& trainSetTarget, int epochs, double goal)
{
	return Train(running, progress, mse, trainSetInput, trainSetTarget, epochs, goal, WT_MATH_VARMETRIC);
}

const wchar_t* ProbNet::Train(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::DoubleTs& mse, const MATRIX& trainSetInput, const MATRIX& trainSetTarget, int epochs, double goal, int method)
{
	//_________________________________________ check trainining set input and training set target
	if (trainSetInput.size() != trainSetTarget.size()) return L"The number of rows in the input and the target must be the same";
	if (trainSetInput.size() == 0) return L"The training set is empty";
	numOutputs = (int)trainSetTarget[0].size();
	if (numOutputs == 0) return L"The training set target is empty";
	numTrainCases = (int)trainSetInput.size();
	const int numInputs = (int)trainSetInput[0].size();
	if (numInputs == 0)
	{
		numOutputs = 0;
		numTrainCases = 0;
		 return L"The training set input is empty";
	}
	//__________________________________________ We are ready to train
	try
	{
		this->trainSetInput = trainSetInput;
		this->trainSetTarget = trainSetTarget;
		weight.resize(trainSetInput[0].size());
		out.resize(numOutputs);
	}
	catch(std::bad_alloc& )
	{
		return L"No enough memory";
	}
	//_____________________________________________ Find initial weight (We use Brent with derivatives with all weights equal to each other)
	Math::Point a, b, c;
	double minX;
	double x = 1.0;
	a.x = 0.0001;
	b.x = 10.0;
	//_________________________________________ Bracketing
	if (running.Get() == false) return NULL;
	Math::FindMinimum::Bracketing(*this, a, b, c);
	if (running.Get() == false) return NULL;
	//_________________________________________ BrentWithDerivative
	Math::FindMinimum::BrentWithDerivative(*this, a.x, b.x, x, 1.0e-6, minX);
	if (running.Get() == false) return NULL;
	for(int i = 0; i < numInputs; i++) weight[i] = x;
	//_________________________________________FindMinimumMV
	Mt::BoolTs resetTime;
	Math::FindMinimumMV fmmv;
	fmmv.Setup(mse, *this, weight, epochs, goal, method);
	fmmv.stopWhenDone = false;
	fmmv.ThreadFunc(running, progress, resetTime);
	mse.Set(ComputeCurrentMse());
	this->trainSetInput.clear();
	this->trainSetTarget.clear();
	this->out.resize(0);
	return NULL;
}

double ProbNet::ComputeCurrentMse()
{
	int i, k;
	double diff;
	double mse = 0.0;
	for(i = 0; i < numTrainCases; i++)
	{
		Run(trainSetInput, trainSetTarget, trainSetInput[i], out);
		for(k = 0; k < numOutputs; k++)
		{
			diff = out[k] - trainSetTarget[i][k];
			mse += (diff*diff);
		}
	}
	return mse/(numTrainCases*numOutputs);
}

const wchar_t* ProbNet::Run(const MATRIX& trainSetInput, const MATRIX& trainSetTarget, const MATRIX& input, MATRIX& output)
{
	//__________________________________________________________________________________ Verify input
	if (trainSetInput.size() == 0 || trainSetTarget.size() == 0)
	{
		output.clear();
		return NULL;
	}
	if (trainSetInput.size() != numTrainCases) return L"The training set input used for training and for running must be the same";
	if (trainSetTarget.size() != numTrainCases) return L"The training set target used for training and for running must be the same";
	if (trainSetTarget[0].size() != numOutputs) return L"The num of cols in trainSetTarget and the num of outputs in the PNN must be the same";
	if (weight.size() != trainSetInput[0].size()) return L"The num of cols in trainSetInput and the num of inputs in the PNN must be the same";
	//__________________________________________________________________________________ Allocate memory for output
	int i;
	const int numRows = (int)input.size();
	if (output.size() == numRows)
	{
		try
		{
			for(i = 0; i < numRows; i++)
			{
				if (output[i].size() !=numOutputs) output[i].resize(numOutputs);
			}
		}
		catch(std::bad_alloc& )
		{
			return L"No enough memory";
		}		
	}
	else
	{
		try
		{
			output.resize(numRows);
			for(i = 0; i < numRows; i++) output[i].resize(numOutputs);
		}
		catch(std::bad_alloc& )
		{
			return L"No enough memory";
		}
	}
	for(i = 0; i < numRows; i++)
	{
		Run(trainSetInput, trainSetTarget, input[i], output[i]);
	}
	return NULL;
}

//Computes the output of the specified inputRowIndex excluding that case (row) from the output calculation
void ProbNet::Run(const MATRIX& trainSetInput, const MATRIX& trainSetTarget, int inputIndex, valarray<double>& output)
{
	const int numCases = numTrainCases;
	const int numInputs = (int)weight.size();
	const int numOutputs = (int)output.size();
	int i;
	int k;
	double sum;
	double sumz = 0.0;
	double diff;
	double z;

	//_____________________________________ Set output to zero
	for(i = 0; i < numOutputs; i++) output[i] = 0.0;
	//
	for(i = 0; i < numCases; i++)
	{
		if (i == inputIndex) continue; // Exclude this case from output calculation
		sum = 0.0;
		for(k = 0; k < numInputs; k++)
		{
			diff = trainSetInput[i][k] - trainSetInput[inputIndex][k];
			sum += diff*diff/weight[k];
		}
		z = exp(-sum);
		sumz += z;
		for(k = 0; k < numOutputs; k++)
		{
			output[k] += z*trainSetTarget[i][k];
		}
	}
	//___________________________________ Divide output over the sum of the z's
	for(k = 0; k < numOutputs; k++) output[k] /= sumz;
}

void ProbNet::Run(const MATRIX& trainSetInput, const MATRIX& trainSetTarget, const valarray<double>& input, valarray<double>& output)
{
	const int numCases = numTrainCases;
	const int numInputs = (int)weight.size();
	const int numOutputs = (int)output.size();
	int i;
	int k;
	double sum;
	double sumz = 0.0;
	double diff;
	double z;

	//_____________________________________ Set output to zero
	for(i = 0; i < numOutputs; i++) output[i] = 0.0;
	//
	for(i = 0; i < numCases; i++)
	{
		sum = 0.0;
		for(k = 0; k < numInputs; k++)
		{
			diff = trainSetInput[i][k] - input[k];
			sum += diff*diff/weight[k];
		}
		z = exp(-sum);
		sumz += z;
		for(k = 0; k < numOutputs; k++)
		{
			output[k] += z*trainSetTarget[i][k];
		}
	}
	//___________________________________ Divide output over the sum of the z's
	for(k = 0; k < numOutputs; k++) output[k] /= sumz;
}

double ProbNet::EvaluateFunc(const valarray<double>& x)
{
	const int numInputs = (int)weight.size();
	int i, k;
	//____________________________________________________ Copy x to the PNN weights
	for(i = 0; i < numInputs; i++) weight[i] = x[i];
	double diff;
	double mse = 0.0;
	for(i = 0; i < numTrainCases; i++)
	{
		Run(trainSetInput, trainSetTarget, i, out);
		for(k = 0; k < numOutputs; k++)
		{
			diff = out[k] - trainSetTarget[i][k];
			mse += (diff*diff);
		}
	}
	return mse/(numTrainCases*numOutputs);
}

//void ProbNet::EvaluateGrad(const valarray<double>& x, valarray<double>& outGrad)
void ProbNet::EvaluateFuncAndGrad(const valarray<double>& x, double& Fx, valarray<double>& gradient)
{
	Fx = 0.0;  // Cumulate error here
	//____________________________________________________ Compute gradient
	const int N = numTrainCases;
	const int mu = numOutputs;
	const int lambda = (int)weight.size();
	int m, k, i, j, r;
	double sumx;
	double sumz = 0.0;
	double diff;
	double z;
	double sumN = 0.0;
	double sumMu = 0.0;
	double sumTotal = 0.0;

	//____________________________________________________ Copy x to the PNN weights
	for(i = 0; i < lambda; i++) weight[i] = x[i];
	//
	for(r = 0; r < lambda; r++)
	{
		for(m = 0; m < N; m++)
		{
			Run(trainSetInput, trainSetTarget, m, out); // Compute y_m for all k
			sumMu = 0.0;
			for(k = 0; k < mu; k++)
			{
				sumN = 0.0;
				if (r == 0) // Compute error
				{
					diff = out[k] - trainSetTarget[m][k];
					Fx += (diff*diff);
				}
				for(i = 0; i < N; i++)
				{
					if (i == m) continue;
					//________________________ Compute z
					sumx = 0.0;
					for(j = 0; j < lambda; j++)
					{
						diff = (trainSetInput[m][j]-trainSetInput[i][j])/weight[j];
						sumx += (diff*diff);
					}
					z = exp(-sumx);
					//________________________ End Compute z
					sumz += z;
					diff = (trainSetInput[m][r] - trainSetInput[i][r])/weight[r];
					sumN += (   (trainSetTarget[i][k]-out[k])*diff*diff*z  );
				}
				sumMu += (   (out[k] - trainSetTarget[m][k])*sumN   );
			}
			sumTotal += sumMu;
		}
		gradient[r] = (4.0*sumTotal)/(N*mu*weight[r]*sumz);
	}
	Fx /= (numTrainCases*numOutputs);
}

double ProbNet::EvaluateFunc(const double x)
{
	const int numInputs = (int)weight.size();
	int i, k;
	//____________________________________________________ Copy x to the PNN weights
	for(i = 0; i < numInputs; i++) weight[i] = x;
	double diff;
	double mse = 0.0;
	for(i = 0; i < numTrainCases; i++)
	{
		Run(trainSetInput, trainSetTarget, i, out);
		for(k = 0; k < numOutputs; k++)
		{
			diff = out[k] - trainSetTarget[i][k];
			mse += (diff*diff);
		}
	}
	return mse/(numTrainCases*numOutputs);
}

//double ProbNet::EvaluateDeri(const double x)
void ProbNet::EvaluateFuncAndDeriv(const double x, double& Fx, double& dFx)
{
	Fx = 0.0;  // Cumulate error here
	//
	const int N = numTrainCases;
	const int mu = numOutputs;
	const int lambda = (int)weight.size();
	int m, k, i, j;
	double sumx;
	double sumz = 0.0;
	double diff;
	double z;
	double sumN = 0.0;
	double sumMu = 0.0;
	double sumTotal = 0.0;
	//____________________________________________________ Copy x to the PNN weights
	for(i = 0; i < lambda; i++) weight[i] = x;
	//
	for(m = 0; m < N; m++)
	{
		Run(trainSetInput, trainSetTarget, m, out); // Compute y_m for all k
		sumMu = 0.0;
		for(k = 0; k < mu; k++)
		{
			//___________________________ Compute error
			diff = out[k] - trainSetTarget[m][k];
			Fx += (diff*diff);
			//
			sumN = 0.0;
			for(i = 0; i < N; i++)
			{
				if (i == m) continue;
				//________________________ Compute z
				sumx = 0.0;
				for(j = 0; j < lambda; j++)
				{
					diff = (trainSetInput[m][j]-trainSetInput[i][j]);
					sumx += (diff*diff);
				}
				sumx /= (x*x);  // sumx /= (weight*weight)
				z = exp(-sumx);
				//________________________ End Compute z
				sumz += z;
				sumN += (   (trainSetTarget[i][k]-out[k])*z*sumx  );
			}
			sumMu += (   (out[k] - trainSetTarget[m][k])*sumN   );
		}
		sumTotal += sumMu;
	}
	Fx /= (numTrainCases*numOutputs);
	dFx = (4.0*sumTotal)/(N*mu*x*sumz); //return (4.0*sumTotal)/(N*mu*x*sumz);
}

}//________________________________________ namespace Nn::End

namespace Cpl //________________________________________ namespace Cpl::Ini
{
//_____________________________________________________________________ LexicalAnalyzer
LexicalAnalyzer::LexicalAnalyzer(void)
{
	inputString = NULL;
	index = 0;
	length = 0;
	constTextDeliminator = '"';
}

LexicalAnalyzer::~LexicalAnalyzer(void)
{
	Destroy();
}

void LexicalAnalyzer::FillKeywords(unordered_map<wstring, int>& keyword)
{
	int type;
	wchar_t * text = NULL;
	//_____________________________________________________________________ Data type
	for (type = LEX_DATATYPE_BOOL; type <= LEX_DATATYPE_PROBNET; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) break;
		keyword[text] = type;
	}
	//_____________________________________________________________________ Data type (other C++)
	for (type = LEX_DATATYPE_CHAR; type <= LEX_DATATYPE_LONG; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) break;
		keyword[text] = type;
	}
	//_____________________________________________________________________ Control
	for (type = LEX_IF; type <= LEX_RETURN; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) break;
		keyword[text] = type;
	}
	//_____________________________________________________________________ General
	for (type = LEX_STRUCT; type <= LEX_BROKEN_BAR; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) break;
		keyword[text] = type;
	}
	//_____________________________________________________________________ Function
	for (type = LEX_FUNC_SIN; type <= LEX_FUNC_ISPRIME; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) break;
		keyword[text] = type;
	}
}

void LexicalAnalyzer::Destroy()
{
	if (this->inputString) delete [] this->inputString;
	this->inputString = NULL;
	index = 0;
	length = 0;
	line_number = 1;
	keyword.clear();
}

bool LexicalAnalyzer::Create(const wchar_t* inputString)
{
	Destroy();
	if (inputString==NULL) return true;
	//________________________________________________________ Prepare keyword set
	FillKeywords(keyword);
	//
	this->length = wcslen(inputString)+1;
	this->inputString = new wchar_t[length];
	if (this->inputString==NULL) return false;
	_snwprintf_s(this->inputString, length, _TRUNCATE, L"%s", inputString);
	//___Replace \r with spaces to be sure to get \n only
	for(register int i = 0; i<(int)this->length; i++) 
	{
		if (this->inputString[i] == '\r') this->inputString[i] = ' ';
	}
	return true;
}

bool LexicalAnalyzer::Create(HWND hWnd)
{
	Destroy();
	this->length = ::GetWindowTextLength(hWnd) + 1;
	if (length <= 1) return false;
	this->inputString = new wchar_t[length];
	if (this->inputString==NULL) return false;
	::GetWindowText(hWnd, this->inputString, (int)this->length);
	//___Replace \r with spaces to be sure to get \n only
	for(register int i = 0; i<(int)this->length; i++)
	{
		if (this->inputString[i] == '\r') this->inputString[i] = ' ';
	}
	return true;
}

bool LexicalAnalyzer::IsError(LexicalAnalyzer::Token& token)
{
	if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR) return true;
	if (token.type == LEX_ERROR_STRING_TOO_LONG) return true;
	if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR) return true;
	if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR) return true;
	return false;
}

void LexicalAnalyzer::ExtractInt(wchar_t& c, int& index, int &i, Cpl::LexicalAnalyzer::Token& token)
{
	while(iswdigit(c))
	{
		token.string_value[i]=c;
		i++;
		if (i>=LEX_STRINGMAX)
		{
			token.type = LEX_ERROR_STRING_TOO_LONG ;
			token.line_number = line_number;
			token.string_value[i-1] = '\0';
			return;
		}
		c = inputString[index++];
	}
	index--;
}

void LexicalAnalyzer::GetNextText(wchar_t* buffer, int buffer_len)
{
	buffer[0] = '\0';
	const int new_len = (int)length - index + 1;
	const int min_len = (new_len < buffer_len) ? new_len : buffer_len;
	for(int i = 0; i<min_len; i++)
	{
		buffer[i] = inputString[index+i];
		if (Sys::TextAssistant::IsSeparator(buffer[i]) == true)
		{
			buffer[i] = '\0';
			return;
		}
	}
}

bool LexicalAnalyzer::ProcessQuotedString(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	if (c != constTextDeliminator) return false;
	bool isSequenceEscape = false;
	int i = 0;
	c = inputString[index++];
	if (c == constTextDeliminator) // empty string
	{
		token.type = LEX_CONST_VALUE_STRING;
		token.line_number = line_number;
		token.string_value[0] = '\0';
		c = inputString[index++]; // Closing "
		return true;
	}
	if (c == '\\')
	{
		c = inputString[index++];
		isSequenceEscape = true;
	}
	else
	{
		isSequenceEscape = false;
	}
	if (c == '\0')
	{
		token.type = LEX_END_OF_FILE;
		token.line_number = line_number;
		token.string_value[0] = '\0';
		return true;
	}
	do
	{
		token.string_value[i] = c;
		i++;
		if (i >= LEX_STRINGMAX)
		{
			token.type = LEX_ERROR_STRING_TOO_LONG;
			token.line_number = line_number;
			token.string_value[i - 1] = '\0';
			//_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"String too long in line %d", line_number);
			//___________ discard rest of the string and return
			do
			{
				c = inputString[index++];
				if (c == '\n') line_number++; //update line number	
				if (c == '\\')
				{
					c = inputString[index++];
					if (c == '\n') line_number++; //update line number	
					isSequenceEscape = true;
				}
				else
				{
					isSequenceEscape = false;
				}
			} while ((c != constTextDeliminator || isSequenceEscape == true) && c != '\0');
			return true;
		}
		c = inputString[index++];
		if (c == '\n') line_number++; //update line number	
		if (c == '\\')
		{
			c = inputString[index++];
			if (c == '\n') line_number++; //update line number	
			isSequenceEscape = true;
		}
		else
		{
			isSequenceEscape = false;
		}
	} while ((c != constTextDeliminator || isSequenceEscape == true) && c != '\0');
	token.type = LEX_CONST_VALUE_STRING;
	token.line_number = line_number;
	token.string_value[i] = '\0';
	if (c == '\0') index--;
	return true;
}

bool LexicalAnalyzer::ProcessCharSequence(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	return false;
}

bool LexicalAnalyzer::ProcessComments(wchar_t& c, LexicalAnalyzer::Token& token)
{
	wchar_t prev;
	if (c != '/') return false;

	c = inputString[index++];
	if (c=='/')  //_______________________ single line comments
	{
		while(c!='\n' && c!='\0')
		{
			c = inputString[index++];
		}
	}
	else if (c=='*')//___________________ multi-line comments
	{
		do
		{
			c = inputString[index++];
			prev = c;
			if (c == '\0') break;
			if (c == '\n') line_number++; //update line number
			if (c == '*')
			{
				c = inputString[index++];
				if (c == '\0')
				{
					token.type = LEX_ERROR_MISSING_COMMENT_TERMINATOR ;
					token.line_number = line_number;
					token.string_value[0] = '\0';
					_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"Missing comment terminator in line %d", line_number);
					index--;
					return true;
				}
				if (c=='\n') line_number++; //update line number			
			}
		}
		while(prev != '*' || c != '/'); // NOT (prev == '*' && c =='/')
		c = inputString[index++]; // Advance /
	}
	else
	{
		//_____________________________________ It is not a comment
		index-=2;
		c = inputString[index++];
	}
	return false;
}

bool LexicalAnalyzer::Next(Cpl::LexicalAnalyzer::Token& token)
{
	GetNextToken(token);
	if (token.type == LEX_END_OF_FILE) return false;
	return true;
}

void LexicalAnalyzer::GetNextToken(Cpl::LexicalAnalyzer::Token& token)
{
	int i=0;
	wchar_t* text = NULL;
	wchar_t c;
	bool isSequenceEscape = false;
	//___________________ clear token
	token.type = LEX_ERROR_UNRECOGNIZED_CHAR ;
	token.int_value = 0;
	token.double_value = 0.0;
	token.string_value[0]='\0';
	token.line_number = line_number;

	//_________________________ Have we reached the end of the file?
	if (index >= (int)length)
	{
		token.type = LEX_END_OF_FILE;
		token.line_number = line_number;
		token.string_value[i] = '\0';
		return;
	}
	//_________________________ find the token
	while(true)
	{
		c = inputString[index++];
		if (ProcessComments(c, token) == true)
		{
			continue;
		}
		else if (c==' ' || c=='\t') //________________strip out white space
		{
			continue;
		}
		else if (c=='\n') //_________________ update line number
		{
			line_number++;
		}
		else if (ProcessCharSequence(c, token) == true)
		{
			return;
		}
		else if (ProcessQuotedString(c, token) == true) //_________________ const string
		{
			return;
		}
		else if (iswdigit(c)) //_________________  it is a digit
		{
			ProcessNumericValues(c, token);
			return;
		}
		else if (iswalnum(c) || c == '_') //_________________ it is a letter
		{
			ProcessString(c, token);
			return;
		}
		else if (ProcessSeparator(c, token) == true)
		{
			return;
		}
		else if (c == '\0')
		{
			token.type = LEX_END_OF_FILE;
			token.line_number = line_number;
			token.string_value[i] = '\0';
			return;
		}
		else
		{
			token.type = LEX_ERROR_UNRECOGNIZED_CHAR;
			_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"Unrecognized character %c", c);
			token.line_number = line_number;
			return;
		}
	}
}

bool LexicalAnalyzer::ProcessSeparator(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	if (CheckToken(token, c, '>', '=', LEX_IS_BIGGER_EQ)) return true;
	else if (CheckToken(token, c, '<', '=', LEX_IS_LESS_EQ)) return true;
	else if (CheckToken(token, c, '=', '=', LEX_IS_EQUAL)) return true;
	else if (CheckToken(token, c, '!', '=', LEX_IS_DIFFERENT)) return true;
	else if (CheckToken(token, c, '|', '|', LEX_OR)) return true;
	else if (CheckToken(token, c, '&', '&', LEX_AND)) return true;
	else if (CheckToken(token, c, '+', '+', LEX_PLUS_PLUS)) return true;
	else if (CheckToken(token, c, '-', '-', LEX_MINUS_MINUS)) return true;
	else if (CheckToken(token, c, '+', '=', LEX_PLUS_EQUAL)) return true;
	else if (CheckToken(token, c, '-', '=', LEX_MINUS_EQUAL)) return true;
	else if (CheckToken(token, c, '*', '=', LEX_PRODUCT_EQUAL)) return true;
	else if (CheckToken(token, c, '/', '=', LEX_DIVISION_EQUAL)) return true;
	else if (CheckToken(token, c, '-', '>', LEX_POINTER_ARROW)) return true;
	else if (CheckToken(token, c, '|', LEX_BROKEN_BAR)) return true;
	else if (CheckToken(token, c, '&', LEX_AMPERSAND)) return true;
	else if (CheckToken(token, c, '(', LEX_LEFT_PARENTHESIS)) return true;
	else if (CheckToken(token, c, ')', LEX_RIGHT_PARENTHESIS)) return true;
	else if (CheckToken(token, c, '[', LEX_LEFT_BRACKET)) return true;
	else if (CheckToken(token, c, ']', LEX_RIGHT_BRACKET)) return true;
	else if (CheckToken(token, c, '{', LEX_LEFT_CURLY_BRACKET)) return true;
	else if (CheckToken(token, c, '}', LEX_RIGHT_CURLY_BRACKET)) return true;
	else if (CheckToken(token, c, ',', LEX_COMMA)) return true;
	else if (CheckToken(token, c, '.', LEX_DOT)) return true;
	else if (CheckToken(token, c, ';', LEX_SEMICOLON)) return true;
	else if (CheckToken(token, c, ':', LEX_COLON)) return true;
	else if (CheckToken(token, c, '+', LEX_PLUS)) return true;
	else if (CheckToken(token, c, '-', LEX_MINUS)) return true;
	else if (CheckToken(token, c, '*', LEX_ASTERISK)) return true;
	else if (CheckToken(token, c, '/', LEX_DIVISION)) return true;
	else if (CheckToken(token, c, '>', LEX_IS_BIGGER)) return true;
	else if (CheckToken(token, c, '<', LEX_IS_LESS)) return true;
	else if (CheckToken(token, c, '=', LEX_EQUAL)) return true;
	else if (CheckToken(token, c, '%', LEX_PERCENT_SIGN)) return true;
	else if (CheckToken(token, c, '#', LEX_NUMBER_SIGN)) return true;
	else if (CheckToken(token, c, '\\', LEX_REVERSE_SOLIDUS)) return true;
	else if (CheckToken(token, c, '~', LEX_TILDE)) return true;
	else if (CheckToken(token, c, '?', LEX_QUESTION_MARK)) return true;
	else if (CheckToken(token, c, '!', LEX_EXCLAMATION_MARK)) return true;
	else if (CheckToken(token, c, '\'', LEX_APOSTROPHE)) return true;
	else if (CheckToken(token, c, '@', LEX_AT)) return true;
	return false;
}

bool LexicalAnalyzer::ProcessKeywords(Cpl::LexicalAnalyzer::Token& token)
{
	unordered_map<wstring, int>::iterator p = keyword.find(token.string_value);
	if (p != keyword.end())
	{
		token.type = p->second;
		token.line_number = line_number;
		return true;
	}
	return false;
}

void LexicalAnalyzer::ProcessString(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	int b = 0;
	int i = 0;
	do
	{
		token.string_value[i] = c;
		i++;
		c = inputString[index++];
		b++;
		if (b >= LEX_STRINGMAX)
		{
			token.type = LEX_ERROR_STRING_TOO_LONG;
			token.line_number = line_number;
			token.string_value[b] = '\0';
			//_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"String too long in line %d", line_number);
			return;
		}
	} while (iswalnum(c) || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' || c == '_');
	token.string_value[i] = '\0';
	index--;

	if (ProcessKeywords(token) == true) return;
	////______________________________________ is bool value (true or false)?
	//if (wcscmp(token.string_value, L"true") == 0)
	//{
	//	token.type = LEX_CONST_VALUE_BOOL;
	//	token.int_value = 1;
	//	token.double_value = 1.0;
	//	token.line_number = line_number;
	//	return;
	//}
	//if (wcscmp(token.string_value, L"false") == 0)
	//{
	//	token.type = LEX_CONST_VALUE_BOOL;
	//	token.int_value = 0;
	//	token.double_value = 0.0;
	//	token.line_number = line_number;
	//	return;
	//}
	token.type = LEX_ID;
	token.line_number = line_number;
}

void LexicalAnalyzer::ProcessNumericValues(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	int i = 0;
	while (iswdigit(c))
	{
		token.string_value[i] = c;
		i++;
		if (i >= LEX_STRINGMAX)
		{
			token.type = LEX_ERROR_STRING_TOO_LONG;
			token.line_number = line_number;
			token.string_value[i - 1] = '\0';
			//_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"String too long in line %d", line_number);
			return;
		}
		c = inputString[index++];
	}
	if (c == '.') //_______________________ const double
	{
		token.string_value[i] = c;
		i++;
		c = inputString[index++];
		if (c == 'e' || c == 'E')
		{
			token.string_value[i] = c;
			i++;
			c = inputString[index++];
			if (c == '-')
			{
				token.string_value[i] = c;
				i++;
				c = inputString[index++];
			}
			ExtractInt(c, index, i, token);
			token.string_value[i] = '\0';
			token.type = LEX_CONST_VALUE_DOUBLE;
			token.double_value = _wtof(token.string_value);
			token.int_value = (int)token.double_value;
			token.line_number = line_number;
			return;
		}
		else
		{
			//___________________________________________ a floating value without E
			ExtractInt(c, index, i, token);
			c = inputString[index++];
			if (c == 'e' || c == 'E')
			{
				token.string_value[i] = c;
				i++;
				c = inputString[index++];
				if (c == '-')
				{
					token.string_value[i] = c;
					i++;
					c = inputString[index++];
				}
				ExtractInt(c, index, i, token);
				token.string_value[i] = '\0';
				token.type = LEX_CONST_VALUE_DOUBLE;
				token.double_value = _wtof(token.string_value);
				token.int_value = (int)token.double_value;
				token.line_number = line_number;
				return;
			}
			token.string_value[i] = c;
			i++;
			index--;
			token.string_value[i - 1] = '\0';
			token.type = LEX_CONST_VALUE_DOUBLE;
			token.double_value = _wtof(token.string_value);
			token.int_value = (int)token.double_value;
			token.line_number = line_number;
			return;
		}
	}
	else //___________________________ const integer
	{
		index--;
		token.string_value[i] = '\0';
		token.type = LEX_CONST_VALUE_INTEGER;
		token.int_value = _wtoi(token.string_value);
		token.double_value = token.int_value;
		token.line_number = line_number;
	}
}

bool LexicalAnalyzer::GetTokens(const wchar_t* inputString, vector<Cpl::LexicalAnalyzer::Token>& output)
{
	Cpl::LexicalAnalyzer lex;
	Cpl::LexicalAnalyzer::Token token;
	if (lex.Create(inputString) == false) return false;
	do
	{
		lex.GetNextToken(token);
		output.push_back(token);
	}
	while (token.type != LEX_END_OF_FILE);
	return true;
}

bool LexicalAnalyzer::GetTokens(HWND hWndInput, vector<Cpl::LexicalAnalyzer::Token>& output)
{
	Cpl::LexicalAnalyzer lex;
	Cpl::LexicalAnalyzer::Token token;
	if (lex.Create(hWndInput) == false) return false;
	do
	{
		lex.GetNextToken(token);
		output.push_back(token);
	}
	while (token.type != LEX_END_OF_FILE);
	return true;
}

bool LexicalAnalyzer::CheckToken(LexicalAnalyzer::Token& token, const int first, const int last)
{
	wchar_t * text = NULL;
	for(int type = first; type <= last; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) return false;
		if (wcscmp(token.string_value, text) == 0)
		{
			token.type = type;
			token.line_number = line_number;
			return true;
		}
	}
	return false;
}

bool LexicalAnalyzer::CheckTokenNoCase(LexicalAnalyzer::Token& token, const int first, const int last)
{
	wchar_t * text = NULL;
	for(int type = first; type <= last; type++)
	{
		text = GetTokenText(type);
		if (text == NULL) return false;

		if (_wcsicmp(token.string_value, text) == 0)
		{
			token.type = type;
			token.line_number = line_number;
			return true;
		}
	}
	return false;
}

bool LexicalAnalyzer::CheckToken(LexicalAnalyzer::Token& token, const wchar_t c, const wchar_t match, int lex_type)
{
	if (c != match) return false;
	//index++;
	token.type = lex_type;
	token.string_value[0]=match;
	token.string_value[1]='\0';
	token.line_number = line_number;
	return true;
}

bool LexicalAnalyzer::CheckToken(LexicalAnalyzer::Token& token, const wchar_t c, const wchar_t match1, const wchar_t match2, int lex_type)
{
	if (c != match1) return false;
	if (inputString[index] != match2) return false;
	index++;
	token.type = lex_type;
	token.string_value[0]=match1;
	token.string_value[1]=match2;
	token.string_value[2]='\0';
	token.line_number = line_number;
	return true;
}

void LexicalAnalyzer::GetErrorText(LexicalAnalyzer::Token& token, wstring& out_text)
{
	if (Cpl::LexicalAnalyzer::IsError(token) == false)
	{
		Sys::Format(out_text, L"%d\tERROR(unrecognized character) %s", token.line_number, token.string_value);
	}
	else if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR)
	{
		Sys::Format(out_text, L"%d\tERROR(unrecognized character) %s\r\n", token.line_number, token.string_value);
	}
	else if (token.type == LEX_ERROR_STRING_TOO_LONG)
	{
		Sys::Format(out_text, L"%d\tERROR(string too long) %s\r\n", token.line_number, token.string_value);
	}
	else if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR)
	{
		Sys::Format(out_text, L"%d\tERROR(missing comment terminator)\r\n", token.line_number);
	}
	else if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR)
	{
		Sys::Format(out_text, L"%d\tERROR(missing quotes) %s\r\n", token.line_number, token.string_value);
	}
	else
	{
		Sys::Format(out_text, L"%d\t%s\t\t%g\t\t%d\r\n",
			token.line_number, token.string_value, token.double_value, token.int_value);
	}
}

void LexicalAnalyzer::Debug(wstring& outputDebugString)
{
	outputDebugString = L"Line\tstring\t\tdouble\t\tint/bool\r\n";
	Token token;
	wstring text;
	while(true)
	{
		GetNextToken(token);
		if (token.type == LEX_END_OF_FILE) break;

		if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR)
		{
			Sys::Format(text, L"%d\tERROR(unrecognized character) %s\r\n", token.line_number, token.string_value);
		}
		else if (token.type == LEX_ERROR_STRING_TOO_LONG)
		{
			Sys::Format(text, L"%d\tERROR(string too long) %s\r\n", token.line_number, token.string_value);
		}
		else if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR)
		{
			Sys::Format(text, L"%d\tERROR(missing comment terminator)\r\n", token.line_number);
		}
		else if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR)
		{
			Sys::Format(text, L"%d\tERROR(missing quotes) %s\r\n", token.line_number, token.string_value);
		}
		else
		{
			Sys::Format(text, L"%d\t%s\t\t%g\t\t%d\r\n", 
				token.line_number, token.string_value, token.double_value, token.int_value);
		}
		outputDebugString += text;
	}
}

const wchar_t * LexicalAnalyzer::GetTokenConstant(int type)
{
	switch (type)
	{
	//__________________________________________________ ERROR
	case LEX_STRINGMAX: return L"LEX_STRINGMAX";
	case LEX_ERROR_UNRECOGNIZED_CHAR: return L"LEX_ERROR_UNRECOGNIZED_CHAR";
	case LEX_ERROR_STRING_TOO_LONG: return L"LEX_ERROR_STRING_TOO_LONG";
	case LEX_ERROR_MISSING_COMMENT_TERMINATOR: return L"LEX_ERROR_MISSING_COMMENT_TERMINATOR";
	case LEX_ERROR_MISSING_STRING_TERMINATOR: return L"LEX_ERROR_MISSING_STRING_TERMINATOR";
	//
	case LEX_PLUS: return L"LEX_PLUS";
	case LEX_MINUS: return L"LEX_MINUS";
	case LEX_ASTERISK: return L"LEX_ASTERISK";
	case LEX_DIVISION: return L"LEX_DIVISION";
	case LEX_EQUAL: return L"LEX_EQUAL";
	case LEX_PERCENT_SIGN: return L"LEX_PERCENT_SIGN";
		//___________________________ Unary operators
	case LEX_MINUS_SIGN: return L"LEX_MINUS_SIGN";
	case LEX_PLUS_PLUS: return L"LEX_PLUS_PLUS";
	case LEX_MINUS_MINUS: return L"LEX_MINUS_MINUS";
		//___________________________ Binary expressions
	case LEX_PLUS_EQUAL: return L"LEX_PLUS_EQUAL";
	case LEX_MINUS_EQUAL: return L"LEX_MINUS_EQUAL";
	case LEX_PRODUCT_EQUAL: return L"LEX_PRODUCT_EQUAL";
	case LEX_DIVISION_EQUAL: return L"LEX_DIVISION_EQUAL";
		//_____________________________ Separator
	case LEX_LEFT_PARENTHESIS: return L"LEX_LEFT_PARENTHESIS";
	case LEX_RIGHT_PARENTHESIS: return L"LEX_RIGHT_PARENTHESIS";
	case LEX_LEFT_BRACKET: return L"LEX_LEFT_BRACKET";
	case LEX_RIGHT_BRACKET: return L"LEX_RIGHT_BRACKET";
	case LEX_LEFT_CURLY_BRACKET: return L"LEX_LEFT_CURLY_BRACKET";
	case LEX_RIGHT_CURLY_BRACKET: return L"LEX_RIGHT_CURLY_BRACKET";
	case LEX_COMMA: return L"LEX_COMMA";
	case LEX_DOT: return L"LEX_DOT";
	case LEX_SEMICOLON: return L"LEX_SEMICOLON";
		//____________________________ Relation
	case LEX_IS_BIGGER: return L"LEX_IS_BIGGER";
	case LEX_IS_BIGGER_EQ: return L"LEX_IS_BIGGER_EQ";
	case LEX_IS_LESS: return L"LEX_IS_LESS";
	case LEX_IS_LESS_EQ: return L"LEX_IS_LESS_EQ";
	case LEX_INSERTION_OPERATOR: return L"LEX_INSERTION_OPERATOR";
	case LEX_EXTRACTION_OPERATOR: return L"LEX_EXTRACTION_OPERATOR";
	case LEX_IS_EQUAL: return L"LEX_IS_EQUAL";
	case LEX_IS_DIFFERENT: return L"LEX_IS_DIFFERENT";
		//____________________________ Boolean operators
	case LEX_OR: return L"LEX_OR";
	case LEX_AND: return L"LEX_AND";
		//____________________________ Control
	case LEX_IF: return L"LEX_IF";
	case LEX_ELSE: return L"LEX_ELSE";
	case LEX_FOR: return L"LEX_FOR";
	case LEX_WHILE: return L"LEX_WHILE";
	case LEX_BREAK: return L"LEX_BREAK";
	case LEX_CONTINUE: return L"LEX_CONTINUE";
	case LEX_DO: return L"LEX_DO";
	case LEX_SWITCH: return L"LEX_SWITCH";
	case LEX_CASE: return L"LEX_CASE";
	case LEX_DEFAULT: return L"LEX_DEFAULT";
	case LEX_TRY: return L"LEX_TRY";
	case LEX_CATCH: return L"LEX_CATCH";
	case LEX_FINALLY: return L"LEX_FINALLY";
	case LEX_RETURN: return L"LEX_RETURN";
	case LEX_STRUCT: return L"LEX_STRUCT";
	case LEX_NULL: return L"LEX_NULL";
	case LEX_THIS: return L"LEX_THIS";
	case LEX_CLASS: return L"LEX_CLASS";
	case LEX_PRIVATE: return L"LEX_PRIVATE";
	case LEX_PROTECTED: return L"LEX_PROTECTED";
	case LEX_PUBLIC: return L"LEX_PUBLIC";
	case LEX_STATIC: return L"LEX_STATIC";
	case LEX_NAMESPACE: return L"LEX_NAMESPACE";
	case LEX_NEW: return L"LEX_NEW";
	case LEX_DELETE: return L"LEX_DELETE";
	case LEX_INLINE: return L"LEX_INLINE";
	case LEX_VIRTUAL: return L"LEX_VIRTUAL";
	case LEX_USING: return L"LEX_USING";
	case LEX_CONST: return L"LEX_CONST";
	case LEX_UNSIGNED: return L"LEX_UNSIGNED";
	case LEX_TRUE: return L"LEX_TRUE";
	case LEX_FALSE: return L"LEX_FALSE";
	case LEX_NUMBER_SIGN: return L"LEX_NUMBER_SIGN";
	case LEX_AMPERSAND: return L"LEX_AMPERSAND";
	case LEX_AT: return L"LEX_AT";
	case LEX_APOSTROPHE: return L"LEX_APOSTROPHE";
	case LEX_REVERSE_SOLIDUS: return L"LEX_REVERSE_SOLIDUS";
	case LEX_TILDE: return L"LEX_TILDE";
	case LEX_QUESTION_MARK: return L"LEX_QUESTION_MARK";
	case LEX_EXCLAMATION_MARK: return L"LEX_EXCLAMATION_MARK";
	case LEX_POINTER_ARROW: return L"LEX_POINTER_ARROW";
	case LEX_DEFINE: return L"LEX_DEFINE";
	case LEX_INCLUDE: return L"LEX_INCLUDE";
	case LEX_PRAGMA: return L"LEX_PRAGMA";
	case LEX_IFDEF: return L"LEX_IFDEF";
	case LEX_IFNDEF: return L"LEX_IFNDEF";
	case LEX_UNDEF: return L"LEX_UNDEF";
	case LEX_ENDIF: return L"LEX_ENDIF";
	case LEX_DOLLAR_SIGN: return L"LEX_DOLLAR_SIGN";
	case LEX_ASM: return L"LEX_ASM";
	case LEX_IMPORTLIB: return L"LEX_IMPORTLIB";
	case LEX_HELPSTRING: return L"LEX_HELPSTRING";
	case LEX_STDMETHODIMP: return L"LEX_STDMETHODIMP";
	case LEX_STDMETHODIMP_: return L"LEX_STDMETHODIMP_";
	case LEX_STDMETHOD: return L"LEX_STDMETHOD";
	case LEX_BEGIN_COM_MAP: return L"LEX_BEGIN_COM_MAP";
	case LEX_COM_INTERFACE_ENTRY: return L"LEX_COM_INTERFACE_ENTRY";
	case LEX_COM_INTERFACE_ENTRY2: return L"LEX_COM_INTERFACE_ENTRY2";
	case LEX_END_COM_MAP: return L"LEX_END_COM_MAP";
	case LEX_BROKEN_BAR: return L"LEX_BROKEN_BAR";
		//_____________________________ Datatype
	case LEX_DATATYPE_BOOL: return L"LEX_DATATYPE_BOOL";
	case LEX_DATATYPE_DOUBLE: return L"LEX_DATATYPE_DOUBLE";
	case LEX_DATATYPE_INTEGER: return L"LEX_DATATYPE_INTEGER";
	case LEX_DATATYPE_VOID: return L"LEX_DATATYPE_VOID";
	case LEX_DATATYPE_MATRIX: return L"LEX_DATATYPE_MATRIX";
	case LEX_DATATYPE_VECTOR: return L"LEX_DATATYPE_VECTOR";
	case LEX_DATATYPE_COMPLEX: return L"LEX_DATATYPE_COMPLEX";
	case LEX_DATATYPE_COMPLEX_VECTOR: return L"LEX_DATATYPE_COMPLEX_VECTOR";
	case LEX_DATATYPE_COMPLEX_MATRIX: return L"LEX_DATATYPE_COMPLEX_MATRIX";
	case LEX_DATATYPE_LAYERNET: return L"LEX_DATATYPE_LAYERNET";
	case LEX_DATATYPE_LAYERNETC: return L"LEX_DATATYPE_LAYERNETC";
	case LEX_DATATYPE_KOHONET: return L"LEX_DATATYPE_KOHONET";
	case LEX_DATATYPE_PROBNET: return L"LEX_DATATYPE_PROBNET";
	case LEX_DATATYPE_CONTROL: return L"LEX_DATATYPE_CONTROL"; // For special use only
	case LEX_DATATYPE_CHAR: return L"LEX_DATATYPE_CHAR";
	case LEX_DATATYPE_WCHAR_T: return L"LEX_DATATYPE_WCHAR_T";
	case LEX_DATATYPE_OBJECT: return L"LEX_DATATYPE_OBJECT";
	case LEX_DATATYPE_DWORD: return L"LEX_DATATYPE_DWORD";
	case LEX_DATATYPE_WINDOWS_LONG: return L"LEX_DATATYPE_WINDOWS_LONG";
	case LEX_DATATYPE_COLORREF: return L"LEX_DATATYPE_COLORREF";
	case LEX_DATATYPE_STL_VALARRAY: return L"LEX_DATATYPE_STL_VALARRAY";
	case LEX_DATATYPE_STL_WSTRING: return L"LEX_DATATYPE_STL_WSTRING";
	case LEX_DATATYPE_STL_VECTOR: return L"LEX_DATATYPE_STL_VECTOR";
	case LEX_DATATYPE_STL_COMPLEX: return L"LEX_DATATYPE_STL_COMPLEX";
	case LEX_DATATYPE_STL_MAP: return L"LEX_DATATYPE_STL_MAP";
	case LEX_DATATYPE_REFIID: return L"LEX_DATATYPE_REFIID";
	case LEX_DATATYPE_CLSID: return L"LEX_DATATYPE_CLSID";
	case LEX_DATATYPE_HWND: return L"LEX_DATATYPE_HWND";
	case LEX_DATATYPE_LRESULT: return L"LEX_DATATYPE_LRESULT";
	case LEX_DATATYPE_WINDOWS_BOOL: return L"LEX_DATATYPE_WINDOWS_BOOL";
	case LEX_DATATYPE_LOGFONT: return L"LEX_DATATYPE_LOGFONT";
	case LEX_DATATYPE_VARIANT_T: return L"LEX_DATATYPE_VARIANT_T";
	case LEX_DATATYPE_COCLASS: return L"LEX_DATATYPE_COCLASS";
	case LEX_DATATYPE_UUID: return L"LEX_DATATYPE_UUID";
	case LEX_DATATYPE_UUIDOF: return L"LEX_DATATYPE_UUIDOF";
	case LEX_DATATYPE_HRESULT: return L"LEX_DATATYPE_HRESULT";
	case LEX_DATATYPE_IUNKNOWN: return L"LEX_DATATYPE_IUNKNOWN";
	case LEX_DATATYPE_IDISPATCH: return L"LEX_DATATYPE_IDISPATCH";
	case LEX_DATATYPE_ICLASSFACTORY: return L"LEX_DATATYPE_ICLASSFACTORY";
	case LEX_DATATYPE_INTERFACE: return L"LEX_DATATYPE_INTERFACE";
	case LEX_DATATYPE_SHORT: return L"LEX_DATATYPE_SHORT";
	case LEX_DATATYPE_LONG: return L"LEX_DATATYPE_LONG";
	//______________________________ Value
	//case LEX_CONST_VALUE_BOOL: return L"const bool";
	case LEX_CONST_VALUE_INTEGER: return L"LEX_CONST_VALUE_INTEGER";
	case LEX_CONST_VALUE_DOUBLE: return L"LEX_CONST_VALUE_DOUBLE";
	case LEX_CONST_VALUE_STRING: return L"LEX_CONST_VALUE_STRING";
	//_____________________________________  FUNCTION SUBTYPE
	case LEX_FUNC_SIN: return L"LEX_FUNC_SIN";
	case LEX_FUNC_COS: return L"LEX_FUNC_COS";
	case LEX_FUNC_TAN: return L"LEX_FUNC_TAN";
	case LEX_FUNC_ASIN: return L"LEX_FUNC_ASIN";
	case LEX_FUNC_ACOS: return L"LEX_FUNC_ACOS";
	case LEX_FUNC_ATAN: return L"LEX_FUNC_ATAN";
	case LEX_FUNC_SINH: return L"LEX_FUNC_SINH";
	case LEX_FUNC_COSH: return L"LEX_FUNC_COSH";
	case LEX_FUNC_TANH: return L"LEX_FUNC_TANH";
	case LEX_FUNC_SQRT: return L"LEX_FUNC_SQRT";
	case LEX_FUNC_LOG10: return L"LEX_FUNC_LOG10";
	case LEX_FUNC_LOG: return L"LEX_FUNC_LOG";
	case LEX_FUNC_EXP: return L"LEX_FUNC_EXP";
	case LEX_FUNC_POW: return L"LEX_FUNC_POW";
	case LEX_FUNC_ABS: return L"LEX_FUNC_ABS";
	case LEX_FUNC_SINC: return L"LEX_FUNC_SINC";
	case LEX_FUNC_TRIANG: return L"LEX_FUNC_TRIANG";
	case LEX_FUNC_SAW: return L"LEX_FUNC_SAW";
	case LEX_FUNC_RECT: return L"LEX_FUNC_RECT";
	case LEX_FUNC_CEIL: return L"LEX_FUNC_CEIL";
	case LEX_FUNC_FLOOR: return L"LEX_FUNC_FLOOR";
	case LEX_FUNC_TOINT: return L"LEX_FUNC_TOINT";
	case LEX_FUNC_FFT: return L"LEX_FUNC_FFT";
	case LEX_FUNC_FFTNORM: return L"LEX_FUNC_FFTNORM";
	case LEX_FUNC_IFFT: return L"LEX_FUNC_IFFT";
	case LEX_FUNC_REALFFT: return L"LEX_FUNC_REALFFT";
	case LEX_FUNC_REALFFTNORM: return L"LEX_FUNC_REALFFTNORM";
	case LEX_FUNC_IREALFFT: return L"LEX_FUNC_IREALFFT";
	case LEX_FUNC_SPECTRUM: return L"LEX_FUNC_SPECTRUM";
	case LEX_FUNC_CONVOLUTION: return L"LEX_FUNC_CONVOLUTION";
	case LEX_FUNC_SHORT_CONVOLUTION: return L"LEX_FUNC_SHORT_CONVOLUTION";
	case LEX_FUNC_COMPUTE_MSE: return L"LEX_FUNC_COMPUTE_MSE";
	case LEX_FUNC_MAKE_COMPLEX: return L"LEX_FUNC_MAKE_COMPLEX";
	case LEX_FUNC_CONFUSION_MATRIX: return L"LEX_FUNC_CONFUSION_MATRIX";
	case LEX_FUNC_COVARIANCE_MATRIX: return L"LEX_FUNC_COVARIANCE_MATRIX";
	case LEX_FUNC_CORRELATION_MATRIX: return L"LEX_FUNC_CORRELATION_MATRIX";
	case LEX_FUNC_EIGENSYSTEM: return L"LEX_FUNC_EIGENSYSTEM";
	case LEX_FUNC_RAND: return L"LEX_FUNC_RAND";
	case LEX_FUNC_RANDI: return L"LEX_FUNC_RANDI";
	case LEX_FUNC_ISPRIME: return L"LEX_FUNC_ISPRIME";
	//_____________________________________ ID
	case LEX_ID: return L"LEX_ID";
	case LEX_HTML_TEXT: return L"LEX_HTML_TEXT";
	case LEX_END_OF_FILE: return L"LEX_END_OF_FILE";
	//_____________________________ SQL DATATYPE
	case LEX_SQLTYPE_BIT: return L"LEX_SQLTYPE_BIT";
	//
	case LEX_SQLTYPE_INTEGER: return L"LEX_SQLTYPE_INTEGER";
	case LEX_SQLTYPE_SMALLINT: return L"LEX_SQLTYPE_SMALLINT";
	case LEX_SQLTYPE_BIGINT: return L"LEX_SQLTYPE_BIGINT";
	case LEX_SQLTYPE_TINYINT: return L"LEX_SQLTYPE_TINYINT";
	case LEX_SQLTYPE_INT: return L"LEX_SQLTYPE_INT";
		//
	case LEX_SQLTYPE_DOUBLE: return L"LEX_SQLTYPE_DOUBLE";
	case LEX_SQLTYPE_DECIMAL: return L"LEX_SQLTYPE_DECIMAL";
	case LEX_SQLTYPE_REAL: return L"LEX_SQLTYPE_REAL";
	case LEX_SQLTYPE_NUMERIC: return L"LEX_SQLTYPE_NUMERIC";
	case LEX_SQLTYPE_MONEY: return L"LEX_SQLTYPE_MONEY";
	case LEX_SQLTYPE_SMALLMONEY: return L"LEX_SQLTYPE_SMALLMONEY";
		//
	case LEX_SQLTYPE_VARCHAR2: return L"LEX_SQLTYPE_VARCHAR2";
	case LEX_SQLTYPE_VARCHAR: return L"LEX_SQLTYPE_VARCHAR";
	case LEX_SQLTYPE_CHAR: return L"LEX_SQLTYPE_CHAR";
	case LEX_SQLTYPE_TEXT: return L"LEX_SQLTYPE_TEXT";
	case LEX_SQLTYPE_NVARCHAR: return L"LEX_SQLTYPE_NVARCHAR";
	case LEX_SQLTYPE_NCHAR: return L"LEX_SQLTYPE_NCHAR";
	case LEX_SQLTYPE_NTEXT: return L"LEX_SQLTYPE_NTEXT";
		//
	case LEX_SQLTYPE_DATETIME: return L"LEX_SQLTYPE_DATETIME";
	case LEX_SQLTYPE_DATETIME2: return L"LEX_SQLTYPE_DATETIME2";
	case LEX_SQLTYPE_SMALLDATETIME: return L"LEX_SQLTYPE_SMALLDATETIME";
	case LEX_SQLTYPE_DATE: return L"LEX_SQLTYPE_DATE";
	case LEX_SQLTYPE_TIME: return L"LEX_SQLTYPE_TIME";
	case LEX_SQLTYPE_TIMESTAMP: return L"LEX_SQLTYPE_TIMESTAMP";
		//_____________________________ SQL MAIN	
	case LEX_SQL_CREATE: return L"LEX_SQL_CREATE";
	case LEX_SQL_INSERT: return L"LEX_SQL_INSERT";
	case LEX_SQL_UPDATE: return L"LEX_SQL_UPDATE";
	case LEX_SQL_SELECT: return L"LEX_SQL_SELECT";
	case LEX_SQL_DELETE: return L"LEX_SQL_DELETE";
	case LEX_SQL_DROP: return L"LEX_SQL_DROP";
	case LEX_SQL_GRANT: return L"LEX_SQL_GRANT";
	case LEX_SQL_REVOKE: return L"LEX_SQL_REVOKE";
	case LEX_SQL_ROLLBACK: return L"LEX_SQL_ROLLBACK";
	case LEX_SQL_SAVEPOINT: return L"LEX_SQL_SAVEPOINT";
	case LEX_SQL_USE: return L"LEX_SQL_USE";
	case LEX_SQL_ALTER: return L"LEX_SQL_ALTER";
		//_____________________________ SQL OBJECTS
	case LEX_SQL_TABLE: return L"LEX_SQL_TABLE";
	case LEX_SQL_VIEW: return L"LEX_SQL_VIEW";
	case LEX_SQL_TRIGGER: return L"LEX_SQL_TRIGGER";
	case LEX_SQL_INDEX: return L"LEX_SQL_INDEX";
	case LEX_SQL_PROCEDURE: return L"LEX_SQL_PROCEDURE";
	case LEX_SQL_DATABASE: return L"LEX_SQL_DATABASE";
	case LEX_SQL_CURSOR: return L"LEX_SQL_CURSOR";
	//_____________________________ SQL KEYWORDS
	case LEX_SQL_WHERE: return L"LEX_SQL_WHERE";
	case LEX_SQL_FROM: return L"LEX_SQL_FROM";
	case LEX_SQL_AS: return L"LEX_SQL_AS";
	case LEX_SQL_GROUP: return L"LEX_SQL_GROUP";
	case LEX_SQL_ORDER: return L"LEX_SQL_ORDER";
	case LEX_SQL_CONSTRAINT: return L"LEX_SQL_CONSTRAINT";
	case LEX_SQL_IDENTITY: return L"LEX_SQL_IDENTITY";
	case LEX_SQL_AUTO_INCREMENT: return L"LEX_SQL_AUTO_INCREMENT";
	case LEX_SQL_INNER: return L"LEX_SQL_INNER";
	case LEX_SQL_JOIN: return L"LEX_SQL_JOIN";
	case LEX_SQL_ON: return L"LEX_SQL_ON";
	case LEX_SQL_UNIQUE: return L"LEX_SQL_UNIQUE";
	case LEX_SQL_BY: return L"LEX_SQL_BY";
	case LEX_SQL_HAVING: return L"LEX_SQL_HAVING";
	case LEX_SQL_UNION: return L"LEX_SQL_UNION";
	case LEX_SQL_INTERSECT: return L"LEX_SQL_INTERSECT";
	case LEX_SQL_INTO: return L"LEX_SQL_INTO";
	case LEX_SQL_VALUES: return L"LEX_SQL_VALUES";
	case LEX_SQL_REPLACE: return L"LEX_SQL_REPLACE";
	case LEX_SQL_PRIMARY: return L"LEX_SQL_PRIMARY";
	case LEX_SQL_FOREIGN: return L"LEX_SQL_FOREIGN";
	case LEX_SQL_KEY: return L"LEX_SQL_KEY";
	case LEX_SQL_REFERENCES: return L"LEX_SQL_REFERENCES";
	case LEX_SQL_CASCADE: return L"LEX_SQL_CASCADE";
	case LEX_SQL_AND: return L"LEX_SQL_AND";
	case LEX_SQL_OR: return L"LEX_SQL_OR";
	case LEX_SQL_NOT: return L"LEX_SQL_NOT";
	case LEX_SQL_BEGIN: return L"LEX_SQL_BEGIN";
	case LEX_SQL_END: return L"LEX_SQL_END";
	case LEX_SQL_DISTINCT: return L"LEX_SQL_DISTINCT";
	case LEX_SQL_LIKE: return L"LEX_SQL_LIKE";
	case LEX_SQL_CHECK: return L"LEX_SQL_CHECK";
	case LEX_SQL_READ: return L"LEX_SQL_READ";
	case LEX_SQL_ONLY: return L"LEX_SQL_ONLY";
	case LEX_SQL_READ_ONLY: return L"LEX_SQL_READ_ONLY";
	case LEX_SQL_OPTION: return L"LEX_SQL_OPTION";
	case LEX_SQL_TRANSACTION: return L"LEX_SQL_TRANSACTION";
	case LEX_SQL_COMMIT: return L"LEX_SQL_COMMIT";
	case LEX_SQL_SET: return L"LEX_SQL_SET";
	case LEX_SQL_IF: return L"LEX_SQL_IF";
	case LEX_SQL_WITH: return L"LEX_SQL_WITH";
	case LEX_SQL_RAISERROR: return L"LEX_SQL_RAISERROR";
	case LEX_SQL_GO: return L"LEX_SQL_GO";
	case LEX_SQL_DECLARE: return L"LEX_SQL_DECLARE";
	case LEX_SQL_FOR: return L"LEX_SQL_FOR";
	case LEX_SQL_OPEN: return L"LEX_SQL_OPEN";
	case LEX_SQL_CLOSE: return L"LEX_SQL_CLOSE";
	case LEX_SQL_WHILE: return L"LEX_SQL_WHILE";
	case LEX_SQL_NEXT: return L"LEX_SQL_NEXT";
	case LEX_SQL_FETCH: return L"LEX_SQL_FETCH";
	case LEX_SQL_DEALLOCATE: return L"LEX_SQL_DEALLOCATE";
	case LEX_SQL_RETURN: return L"LEX_SQL_RETURN";
	case LEX_SQL_CASE: return L"LEX_SQL_CASE";
	case LEX_SQL_FETCH_STATUS: return L"LEX_SQL_FETCH_STATUS";
	case LEX_SQL_EXISTS: return L"LEX_SQL_EXISTS";
	case LEX_SQL_DBO: return L"LEX_SQL_DBO";
	case LEX_SQL_DEFAULT: return L"LEX_SQL_DEFAULT";
	case LEX_SQL_NULL: return L"LEX_SQL_NULL";
		//_____________________________ SQL FUNCTIONS
	case LEX_SQL_ABS: return L"LEX_SQL_ABS";
	case LEX_SQL_MOD: return L"LEX_SQL_MOD";
	case LEX_SQL_TRUNCATE: return L"LEX_SQL_TRUNCATE";
	case LEX_SQL_POWER: return L"LEX_SQL_POWER";
	case LEX_SQL_ROUND: return L"LEX_SQL_ROUND";
	case LEX_SQL_AVG: return L"LEX_SQL_AVG";
	case LEX_SQL_MIN: return L"LEX_SQL_MIN";
	case LEX_SQL_MAX: return L"LEX_SQL_MAX";
	case LEX_SQL_SUM: return L"LEX_SQL_SUM";
	case LEX_SQL_NVL: return L"LEX_SQL_NVL";
	case LEX_SQL_TO_NUMBER: return L"LEX_SQL_TO_NUMBER";
	case LEX_SQL_TO_CHAR: return L"LEX_SQL_TO_CHAR";
	case LEX_SQL_TO_DATE: return L"LEX_SQL_TO_DATE";
	case LEX_SQL_DATEFORMAT: return L"LEX_SQL_DATEFORMAT";
	case LEX_SQL_DATEPART: return L"LEX_SQL_DATEPART";
	case LEX_SQL_DATEDIFF: return L"LEX_SQL_DATEDIFF";
	case LEX_SQL_ISDATE: return L"LEX_SQL_ISDATE";
	case LEX_SQL_CONVERT: return L"LEX_SQL_CONVERT";
	case LEX_SQL_CAST: return L"LEX_SQL_CAST";
	case LEX_SQL_GETDATE: return L"LEX_SQL_GETDATE";
	case LEX_SQL_DB_NAME: return L"LEX_SQL_DB_NAME";
		//____________________________________________________ HTML
	case LEX_HTML_HTML: return L"LEX_HTML_HTML";
	case LEX_HTML_BODY: return L"LEX_HTML_BODY";
	case LEX_HTML_HEAD: return L"LEX_HTML_HEAD";
	case LEX_HTML_TITLE: return L"LEX_HTML_TITLE";
	case LEX_HTML_META: return L"LEX_HTML_META";
	case LEX_HTML_STYLE: return L"LEX_HTML_STYLE";
	case LEX_HTML_A: return L"LEX_HTML_A";
	case LEX_HTML_SPAN: return L"LEX_HTML_SPAN";
	case LEX_HTML_P: return L"LEX_HTML_P";
	case LEX_HTML_DIV: return L"LEX_HTML_DIV";
	case LEX_HTML_TABLE: return L"LEX_HTML_TABLE";
	case LEX_HTML_TR: return L"LEX_HTML_TR";
	case LEX_HTML_TD: return L"LEX_HTML_TD";
	case LEX_HTML_OL: return L"LEX_HTML_OL";
	case LEX_HTML_UL: return L"LEX_HTML_UL";
	case LEX_HTML_LI: return L"LEX_HTML_LI";
	case LEX_HTML_IMG: return L"LEX_HTML_IMG";
	case LEX_HTML_SELECT: return L"LEX_HTML_SELECT";
	case LEX_HTML_TEXTAREA: return L"LEX_HTML_TEXTAREA";
	case LEX_HTML_B: return L"LEX_HTML_B";
	case LEX_HTML_I: return L"LEX_HTML_I";
	case LEX_HTML_U: return L"LEX_HTML_U";
	case LEX_HTML_FORM: return L"LEX_HTML_FORM";
	case LEX_HTML_HR: return L"LEX_HTML_HR";
	case LEX_HTML_BR: return L"LEX_HTML_BR";
	case LEX_HTML_H1: return L"LEX_HTML_H1";
	case LEX_HTML_H2: return L"LEX_HTML_H2";
	case LEX_HTML_H3: return L"LEX_HTML_H3";
	case LEX_HTML_H4: return L"LEX_HTML_H4";
	case LEX_HTML_H5: return L"LEX_HTML_H5";
	case LEX_HTML_H6: return L"LEX_HTML_H6";
	case LEX_HTML_SCRIPT: return L"LEX_HTML_SCRIPT";
	case LEX_HTML_INPUT: return L"LEX_HTML_INPUT";
	//____________________________________________ HTMLtag properties
	case LEX_HTML_HREF: return L"LEX_HTML_HREF";
	case LEX_HTML_TARGET: return L"LEX_HTML_TARGET";
	case LEX_HTML_CLASS: return L"LEX_HTML_CLASS";
	case LEX_HTML_TYPE: return L"LEX_HTML_TYPE";
	case LEX_HTML_NAME: return L"LEX_HTML_NAME";
	case LEX_HTML_SRC: return L"LEX_HTML_SRC";
	case LEX_HTML_ALT: return L"LEX_HTML_ALT";
	case LEX_HTML_METHOD: return L"LEX_HTML_METHOD";
	case LEX_HTML_ID: return L"LEX_HTML_ID";
	case LEX_HTML_WIDTH: return L"LEX_HTML_WIDTH";
	case LEX_HTML_HEIGHT: return L"LEX_HTML_HEIGHT";
	case LEX_HTML_ALIGN: return L"LEX_HTML_ALIGN";
	case LEX_HTML_VALIGN: return L"LEX_HTML_VALIGN";
	case LEX_HTML_BORDER: return L"LEX_HTML_BORDER";
	case LEX_HTML_CELLPADDING: return L"LEX_HTML_CELLPADDING";
	case LEX_HTML_CELLSPACING: return L"LEX_HTML_CELLSPACING";
	//__________________________________________ HTML javascript events
	case LEX_HTML_ONKEYDOWN: return L"LEX_HTML_ONKEYDOWN";
	case LEX_HTML_ONKEYPRESS: return L"LEX_HTML_ONKEYPRESS";
	case LEX_HTML_ONKEYUP: return L"LEX_HTML_ONKEYUP";
	case LEX_HTML_ONCLICK: return L"LEX_HTML_ONCLICK";
	case LEX_HTML_ONDBLCLICK: return L"LEX_HTML_ONDBLCLICK";
	case LEX_HTML_ONDRAG: return L"LEX_HTML_ONDRAG";
	case LEX_HTML_ONDRAGEND: return L"LEX_HTML_ONDRAGEND";
	case LEX_HTML_ONDRAGENTER: return L"LEX_HTML_ONDRAGENTER";
	case LEX_HTML_ONDRAGLEAVE: return L"LEX_HTML_ONDRAGLEAVE";
	case LEX_HTML_ONDRAGOVER: return L"LEX_HTML_ONDRAGOVER";
	case LEX_HTML_ONDRAGSTART: return L"LEX_HTML_ONDRAGSTART";
	case LEX_HTML_ONDROP: return L"LEX_HTML_ONDROP";
	case LEX_HTML_ONERROR: return L"LEX_HTML_ONERROR";
	case LEX_HTML_ONLOAD: return L"LEX_HTML_ONLOAD";
	case LEX_HTML_ONMOUSEDOWN: return L"LEX_HTML_ONMOUSEDOWN";
	case LEX_HTML_ONMOUSEMOVE: return L"LEX_HTML_ONMOUSEMOVE";
	case LEX_HTML_ONMOUSEOUT: return L"LEX_HTML_ONMOUSEOUT";
	case LEX_HTML_ONMOUSEOVER: return L"LEX_HTML_ONMOUSEOVER";
	case LEX_HTML_ONMOUSEUP: return L"LEX_HTML_ONMOUSEUP";
	case LEX_HTML_ONMOUSEWHEEL: return L"LEX_HTML_ONMOUSEWHEEL";
	case LEX_HTML_ONSCROLL: return L"LEX_HTML_ONSCROLL";
	case LEX_HTML_ONBLUR: return L"LEX_HTML_ONBLUR";
	case LEX_HTML_ONCHANGE: return L"LEX_HTML_ONCHANGE";
	case LEX_HTML_ONCONTEXTMENU: return L"LEX_HTML_ONCONTEXTMENU";
	case LEX_HTML_ONFOCUS: return L"LEX_HTML_ONFOCUS";
	case LEX_HTML_ONINPUT: return L"LEX_HTML_ONINPUT";
	case LEX_HTML_ONINVALID: return L"LEX_HTML_ONINVALID";
	case LEX_HTML_ONSELECT: return L"LEX_HTML_ONSELECT";
	//___________________________________ HTML Page javascript events
	//case LEX_HTML_ONAFTERPRINT: return L"LEX_HTML_ONAFTERPRINT";
	//case LEX_HTML_BEFOREPRINT: return L"LEX_HTML_BEFOREPRINT";
	//case LEX_HTML_BEFOREUNLOAD: return L"LEX_HTML_BEFOREUNLOAD";
	//case LEX_HTML_ERROR: return L"LEX_HTML_ERROR";
	//case LEX_HTML_HASCHANGE: return L"LEX_HTML_HASCHANGE";
	//case LEX_HTML_LOAD: return L"LEX_HTML_LOAD";
	//case LEX_HTML_MESSAGE: return L"LEX_HTML_MESSAGE";
	//case LEX_HTML_OFFLINE: return L"LEX_HTML_OFFLINE";
	//case LEX_HTML_ONLINE: return L"LEX_HTML_ONLINE";
	//case LEX_HTML_PAGEHIDE: return L"LEX_HTML_PAGEHIDE";
	//case LEX_HTML_PAGESHOW: return L"LEX_HTML_PAGESHOW";
	//case LEX_HTML_POPSTATE: return L"LEX_HTML_POPSTATE";
	//case LEX_HTML_REDO: return L"LEX_HTML_REDO";
	//case LEX_HTML_RESIZE: return L"LEX_HTML_RESIZE";
	//case LEX_HTML_STORAGE: return L"LEX_HTML_STORAGE";
	//case LEX_HTML_UNDO: return L"LEX_HTML_UNDO";
	//case LEX_HTML_UNLOAD: return L"LEX_HTML_UNLOAD";
	//case LEX_HTML_FORMCHANGE: return L"LEX_HTML_FORMCHANGE";
	//case LEX_HTML_FORMINPUT: return L"LEX_HTML_FORMINPUT";
	//case LEX_HTML_SUBMIT: return L"LEX_HTML_SUBMIT";
	//case LEX_HTML_RESET: return L"LEX_HTML_RESET";
	//___________________________________ HTML Media javascript events
	case LEX_HTML_ONABORT: return L"LEX_HTML_ONABORT";
	case LEX_HTML_ONCANPLAY: return L"LEX_HTML_ONCANPLAY";
	case LEX_HTML_ONCANPLAYTHROUGH: return L"LEX_HTML_ONCANPLAYTHROUGH";
	case LEX_HTML_ONDURATIONCHANGE: return L"LEX_HTML_ONDURATIONCHANGE";
	case LEX_HTML_ONEMPTIED: return L"LEX_HTML_ONEMPTIED";
	case LEX_HTML_ONENDED: return L"LEX_HTML_ONENDED";
	case LEX_HTML_ONERROR_MEDIA: return L"LEX_HTML_ONERROR_MEDIA";
	case LEX_HTML_ONLOADEDDATA: return L"LEX_HTML_ONLOADEDDATA";
	case LEX_HTML_ONLOADEDMETADATA: return L"LEX_HTML_ONLOADEDMETADATA";
	case LEX_HTML_ONLOADSTART: return L"LEX_HTML_ONLOADSTART";
	case LEX_HTML_ONPAUSE: return L"LEX_HTML_ONPAUSE";
	case LEX_HTML_ONPLAY: return L"LEX_HTML_ONPLAY";
	case LEX_HTML_ONPLAYING: return L"LEX_HTML_ONPLAYING";
	case LEX_HTML_ONPROGRESS: return L"LEX_HTML_ONPROGRESS";
	case LEX_HTML_ONRATECHANGE: return L"LEX_HTML_ONRATECHANGE";
	case LEX_HTML_ONREADYSTATECHANGE: return L"LEX_HTML_ONREADYSTATECHANGE";
	case LEX_HTML_ONSEEKED: return L"LEX_HTML_ONSEEKED";
	case LEX_HTML_ONSEEKING: return L"LEX_HTML_ONSEEKING";
	case LEX_HTML_ONSTALLED: return L"LEX_HTML_ONSTALLED";
	case LEX_HTML_ONSUSPEND: return L"LEX_HTML_ONSUSPEND";
	case LEX_HTML_ONTIMEUPDATE: return L"LEX_HTML_ONTIMEUPDATE";
	case LEX_HTML_ONVOLUMECHANGE: return L"LEX_HTML_ONVOLUMECHANGE";
	case LEX_HTML_ONWAITING: return L"LEX_HTML_ONWAITING";
	//________________________________________________ HTML SPECIAL
	case LEX_TAG_CLOSING: return L"LEX_TAG_CLOSING";
	case LEX_MONO_TAG_CLOSING: return L"LEX_MONO_TAG_CLOSING";
	case LEX_HTML_SPECIAL_SYMBOL: return L"LEX_HTML_SPECIAL_SYMBOL";
	//_________________________________________________ PDF
	case LEX_PDF_NAME: return L"LEX_PDF_NAME";
	case LEX_PDF_DATA: return L"LEX_PDF_DATA";
	case LEX_PDF_OBJ: return L"LEX_PDF_OBJ";
	case LEX_PDF_ENDOBJ: return L"LEX_PDF_ENDOBJ";
	case LEX_PDF_STREAM: return L"LEX_PDF_STREAM";
	case LEX_PDF_ENDSTREAM: return L"LEX_PDF_ENDSTREAM";
	case LEX_PDF_XREF: return L"LEX_PDF_XREF";
	case LEX_PDF_TRAILER: return L"LEX_PDF_TRAILER";
	case LEX_PDF_STARTXREF: return L"LEX_PDF_STARTXREF";
	case LEX_PDF_BSLASH_BSLASH: return L"LEX_PDF_BSLASH_BSLASH";
	case LEX_PDF_BSLASH_LPARENTHESIS: return L"LEX_PDF_BSLASH_LPARENTHESIS";
	case LEX_PDF_BSLASH_RPARENTHESIS: return L"LEX_PDF_BSLASH_RPARENTHESIS";
	case LEX_PDF_BSLASH_LBRACKET: return L"LEX_PDF_BSLASH_LBRACKET";
	case LEX_PDF_BSLASH_RBRACKET: return L"LEX_PDF_BSLASH_RBRACKET";
	case LEX_PDF_BSLASH_LESS: return L"LEX_PDF_BSLASH_LESS";
	case LEX_PDF_BSLASH_BIGGER: return L"LEX_PDF_BSLASH_BIGGER";
	case LEX_PDF_BSLASH_DIAGONAL: return L"LEX_PDF_BSLASH_DIAGONAL";
	//_______________________________________________
	//case LEX_FUNC_BESSELJ0: return L"LEX_FUNC_BESSELJ0";
	//case LEX_FUNC_BESSELJ1: return L"LEX_FUNC_BESSELJ1";
	//case LEX_FUNC_BESSELY0: return L"LEX_FUNC_BESSELY0";
	//case LEX_FUNC_BESSELY1: return L"LEX_FUNC_BESSELY1";
	}
	return NULL;
}

wchar_t * LexicalAnalyzer::GetTokenText(int type)
{
	switch(type)
	{
	case LEX_PLUS: return L"+";
	case LEX_MINUS: return L"-";
	case LEX_ASTERISK: return L"*";
	case LEX_DIVISION: return L"/";
	case LEX_EQUAL: return L"=";
	case LEX_PERCENT_SIGN: return L"%";
	//___________________________ Unary operators
	case LEX_MINUS_SIGN: return L"-";
	case LEX_PLUS_PLUS: return L"++";
	case LEX_MINUS_MINUS: return L"--";
	//___________________________ Binary expressions
	case LEX_PLUS_EQUAL: return L"+=";
	case LEX_MINUS_EQUAL: return L"-=";
	case LEX_PRODUCT_EQUAL: return L"*=";
	case LEX_DIVISION_EQUAL: return L"/=";
	//_____________________________ Separator
	case LEX_LEFT_PARENTHESIS: return L"(";
	case LEX_RIGHT_PARENTHESIS: return L")";
	case LEX_LEFT_BRACKET: return L"[";
	case LEX_RIGHT_BRACKET: return L"]";
	case LEX_LEFT_CURLY_BRACKET: return L"{";
	case LEX_RIGHT_CURLY_BRACKET: return L"}";
	case LEX_COMMA: return L",";
	case LEX_DOT: return L".";
	case LEX_SEMICOLON: return L";";
	//____________________________ Relation
	case LEX_IS_BIGGER: return L">";
	case LEX_IS_BIGGER_EQ: return L">=";
	case LEX_IS_LESS: return L"<";
	case LEX_IS_LESS_EQ: return L"<=";
	case LEX_INSERTION_OPERATOR: return L"<<";
	case LEX_EXTRACTION_OPERATOR: return L">>";
	case LEX_IS_EQUAL: return L"==";
	case LEX_IS_DIFFERENT: return L"!="; 
	//____________________________ Boolean operators
	case LEX_OR: return L"||";
	case LEX_AND: return L"&&";
	//____________________________ Control
	case LEX_IF: return L"if";
	case LEX_ELSE: return L"else";
	case LEX_FOR: return L"for";
	case LEX_WHILE: return L"while";
	case LEX_BREAK: return L"break";
	case LEX_CONTINUE: return L"continue";
	case LEX_DO: return L"do";
	case LEX_SWITCH: return L"switch";
	case LEX_CASE: return L"case";
	case LEX_DEFAULT: return L"default";
	case LEX_TRY: return L"try";
	case LEX_CATCH: return L"catch";
	case LEX_FINALLY: return L"finally";
	case LEX_RETURN: return L"return";
	case LEX_STRUCT: return L"struct";
	case LEX_NULL: return L"NULL";
	case LEX_THIS: return L"this";
	case LEX_CLASS: return L"class";
	case LEX_PRIVATE: return L"private";
	case LEX_PROTECTED: return L"protected";
	case LEX_PUBLIC: return L"public";
	case LEX_STATIC: return L"static";
	case LEX_NAMESPACE: return L"namespace";
	case LEX_NEW: return L"new";
	case LEX_DELETE: return L"delete";
	case LEX_INLINE: return L"inline";
	case LEX_VIRTUAL: return L"virtual";
	case LEX_USING: return L"using";
	case LEX_CONST: return L"const";
	case LEX_UNSIGNED: return L"unsigned";
	case LEX_TRUE: return L"true";
	case LEX_FALSE: return L"false";
	case LEX_NUMBER_SIGN: return L"#";
	case LEX_AMPERSAND: return L"&";
	case LEX_AT: return L"@";
	case LEX_APOSTROPHE: return L"\'";
	case LEX_REVERSE_SOLIDUS: return L"\\";
	case LEX_TILDE: return L"~";
	case LEX_QUESTION_MARK: return L"?";
	case LEX_EXCLAMATION_MARK: return L"!";
	case LEX_POINTER_ARROW: return L"->";
	case LEX_DEFINE: return L"define";
	case LEX_INCLUDE: return L"include";
	case LEX_PRAGMA: return L"pragma";
	case LEX_IFDEF: return L"ifdef";
	case LEX_IFNDEF: return L"ifndef";
	case LEX_UNDEF: return L"undef";
	case LEX_ENDIF: return L"endif";
	case LEX_DOLLAR_SIGN: return L"$";
	case LEX_ASM: return L"__asm";
	case LEX_IMPORTLIB: return L"importlib";
	case LEX_HELPSTRING: return L"helpstring";
	case LEX_STDMETHODIMP: return L"STDMETHODIMP";
	case LEX_STDMETHODIMP_: return L"STDMETHODIMP_";
	case LEX_STDMETHOD: return L"STDMETHOD";
	case LEX_BEGIN_COM_MAP: return L"BEGIN_COM_MAP";
	case LEX_COM_INTERFACE_ENTRY: return L"COM_INTERFACE_ENTRY";
	case LEX_COM_INTERFACE_ENTRY2: return L"COM_INTERFACE_ENTRY2";
	case LEX_END_COM_MAP: return L"END_COM_MAP";
	case LEX_BROKEN_BAR: return L"|";
	//_____________________________ Datatype
	case LEX_DATATYPE_BOOL: return L"bool";
	case LEX_DATATYPE_DOUBLE: return L"double";
	case LEX_DATATYPE_INTEGER: return L"int";
	case LEX_DATATYPE_VOID: return L"void";
	case LEX_DATATYPE_MATRIX: return L"Matrix";
	case LEX_DATATYPE_VECTOR: return L"Vector";
	case LEX_DATATYPE_COMPLEX: return L"Complex";
	case LEX_DATATYPE_COMPLEX_VECTOR: return L"ComplexVector";
	case LEX_DATATYPE_COMPLEX_MATRIX: return L"ComplexMatrix";
	case LEX_DATATYPE_LAYERNET: return L"LayerNet";
	case LEX_DATATYPE_LAYERNETC: return L"ComplexLayerNet";
	case LEX_DATATYPE_KOHONET: return L"KohoNet";
	case LEX_DATATYPE_PROBNET: return L"ProbNet";
	case LEX_DATATYPE_CONTROL: return L"Control"; // For special use only
	case LEX_DATATYPE_CHAR: return L"char"; 
	case LEX_DATATYPE_WCHAR_T: return L"wchar_t";
	case LEX_DATATYPE_OBJECT: return L"Object";
	case LEX_DATATYPE_DWORD: return L"DWORD";
	case LEX_DATATYPE_WINDOWS_LONG: return L"LONG";
	case LEX_DATATYPE_COLORREF: return L"COLORREF";
	case LEX_DATATYPE_STL_VALARRAY: return L"valarray";
	case LEX_DATATYPE_STL_WSTRING: return L"wstring";
	case LEX_DATATYPE_STL_VECTOR: return L"vector";
	case LEX_DATATYPE_STL_COMPLEX: return L"complex";
	case LEX_DATATYPE_STL_MAP: return L"map";
	case LEX_DATATYPE_REFIID: return L"REFIID";
	case LEX_DATATYPE_CLSID: return L"CLSID";
	case LEX_DATATYPE_HWND: return L"HWND";
	case LEX_DATATYPE_LRESULT: return L"LRESULT";
	case LEX_DATATYPE_WINDOWS_BOOL: return L"BOOL";
	case LEX_DATATYPE_LOGFONT: return L"LOGFONT";
	case LEX_DATATYPE_VARIANT_T: return L"_variant_t";
	case LEX_DATATYPE_COCLASS: return L"coclass";
	case LEX_DATATYPE_UUID: return L"uuid";
	case LEX_DATATYPE_UUIDOF: return L"__uuidof";
	case LEX_DATATYPE_HRESULT: return L"HRESULT";
	case LEX_DATATYPE_IUNKNOWN: return L"IUnknown";
	case LEX_DATATYPE_IDISPATCH: return L"IDispatch";
	case LEX_DATATYPE_ICLASSFACTORY : return L"IClassFactory";
	case LEX_DATATYPE_INTERFACE: return L"interface";
	case LEX_DATATYPE_SHORT: return L"short";
	case LEX_DATATYPE_LONG: return L"long"; 
	//______________________________ Value
	//case LEX_CONST_VALUE_BOOL: return L"const bool";
	case LEX_CONST_VALUE_INTEGER: return L"const int";
	case LEX_CONST_VALUE_DOUBLE: return L"const double";
	case LEX_CONST_VALUE_STRING: return L"const text";
	//_____________________________________  FUNCTION SUBTYPE
	case LEX_FUNC_SIN: return L"sin";
	case LEX_FUNC_COS: return L"cos";
	case LEX_FUNC_TAN: return L"tan";
	case LEX_FUNC_ASIN: return L"asin";
	case LEX_FUNC_ACOS: return L"acos";
	case LEX_FUNC_ATAN: return L"atan";
	case LEX_FUNC_SINH: return L"sinh";
	case LEX_FUNC_COSH: return L"cosh";
	case LEX_FUNC_TANH: return L"tanh";
	case LEX_FUNC_SQRT: return L"sqrt";
	case LEX_FUNC_LOG10: return L"log10";
	case LEX_FUNC_LOG: return L"log";
	case LEX_FUNC_EXP: return L"exp";
	case LEX_FUNC_POW: return L"pow";
	case LEX_FUNC_ABS: return L"abs";
	case LEX_FUNC_SINC: return L"sinc";
	case LEX_FUNC_TRIANG: return L"triang";
	case LEX_FUNC_SAW: return L"saw";
	case LEX_FUNC_RECT: return L"rect";
	case LEX_FUNC_CEIL: return L"ceil";
	case LEX_FUNC_FLOOR: return L"floor";
	case LEX_FUNC_TOINT: return L"toint";
	case LEX_FUNC_FFT: return L"fft";
	case LEX_FUNC_FFTNORM: return L"fftnorm";
	case LEX_FUNC_IFFT: return L"ifft";
	case LEX_FUNC_REALFFT: return L"realfft";
	case LEX_FUNC_REALFFTNORM: return L"realfftnorm";
	case LEX_FUNC_IREALFFT: return L"irealfft";
	case LEX_FUNC_SPECTRUM: return L"spectrum";
	case LEX_FUNC_CONVOLUTION: return L"Convolution";
	case LEX_FUNC_SHORT_CONVOLUTION: return L"ShortConvolution";
	case LEX_FUNC_COMPUTE_MSE: return L"ComputeMse";
	case LEX_FUNC_MAKE_COMPLEX: return L"MakeComplex";
	case LEX_FUNC_CONFUSION_MATRIX: return L"ConfusionMatrix";
	case LEX_FUNC_COVARIANCE_MATRIX: return L"CovarianceMatrix";
	case LEX_FUNC_CORRELATION_MATRIX: return L"CorrelationMatrix";
	case LEX_FUNC_EIGENSYSTEM: return L"EigenSystem";
	case LEX_FUNC_RAND: return L"rand";
	case LEX_FUNC_RANDI: return L"randi";
	case LEX_FUNC_ISPRIME: return L"isprime";
	//_____________________________ SQL DATATYPE
	case LEX_SQLTYPE_BIT: return L"BIT";
	//
	case LEX_SQLTYPE_INTEGER: return L"INTEGER";
	case LEX_SQLTYPE_SMALLINT: return L"SMALLINT";
	case LEX_SQLTYPE_BIGINT: return L"BIGINT";
	case LEX_SQLTYPE_TINYINT: return L"TINYINT";
	case LEX_SQLTYPE_INT: return L"INT";
	//
	case LEX_SQLTYPE_DOUBLE: return L"DOUBLE";
	case LEX_SQLTYPE_DECIMAL: return L"DECIMAL";
	case LEX_SQLTYPE_REAL: return L"REAL";
	case LEX_SQLTYPE_NUMERIC: return L"NUMERIC";
	case LEX_SQLTYPE_MONEY: return L"MONEY";
	case LEX_SQLTYPE_SMALLMONEY: return L"SMALLMONEY";
	//
	case LEX_SQLTYPE_VARCHAR2: return L"VARCHAR2";
	case LEX_SQLTYPE_VARCHAR: return L"VARCHAR";
	case LEX_SQLTYPE_CHAR: return L"CHAR";
	case LEX_SQLTYPE_TEXT: return L"TEXT";
	case LEX_SQLTYPE_NVARCHAR: return L"NVARCHAR";
	case LEX_SQLTYPE_NCHAR: return L"NCHAR";
	case LEX_SQLTYPE_NTEXT: return L"NTEXT";
	//
	case LEX_SQLTYPE_DATETIME: return L"DATETIME";
	case LEX_SQLTYPE_DATETIME2: return L"DATETIME2";
	case LEX_SQLTYPE_SMALLDATETIME: return L"SMALLDATETIME";
	case LEX_SQLTYPE_DATE: return L"DATE";
	case LEX_SQLTYPE_TIME: return L"TIME";
	case LEX_SQLTYPE_TIMESTAMP: return L"TIMESTAMP";
	//_____________________________ SQL MAIN	
	case LEX_SQL_CREATE: return L"CREATE";
	case LEX_SQL_INSERT: return L"INSERT";
	case LEX_SQL_UPDATE: return L"UPDATE";
	case LEX_SQL_SELECT: return L"SELECT";
	case LEX_SQL_DELETE: return L"DELETE";
	case LEX_SQL_DROP: return L"DROP";
	case LEX_SQL_GRANT: return L"GRANT";
	case LEX_SQL_REVOKE: return L"REVOKE";
	case LEX_SQL_ROLLBACK: return L"ROLLBACK";
	case LEX_SQL_SAVEPOINT: return L"SAVEPOINT";
	case LEX_SQL_USE: return L"USE";
	case LEX_SQL_ALTER: return L"ALTER";
	//_____________________________ SQL OBJECTS
	case LEX_SQL_TABLE: return L"TABLE";
	case LEX_SQL_VIEW: return L"VIEW";
	case LEX_SQL_TRIGGER: return L"TRIGGER";
	case LEX_SQL_INDEX: return L"INDEX";
	case LEX_SQL_PROCEDURE: return L"PROCEDURE";
	case LEX_SQL_DATABASE: return L"DATABASE";
	case LEX_SQL_CURSOR: return L"CURSOR";
	//_____________________________ SQL KEYWORDS
	case LEX_SQL_WHERE: return L"WHERE";
	case LEX_SQL_FROM: return L"FROM";
	case LEX_SQL_AS: return L"AS";
	case LEX_SQL_GROUP: return L"GROUP";
	case LEX_SQL_ORDER: return L"ORDER";
	case LEX_SQL_CONSTRAINT: return L"CONSTRAINT";
	case LEX_SQL_IDENTITY: return L"IDENTITY";
	case LEX_SQL_AUTO_INCREMENT: return L"AUTO_INCREMENT";
	case LEX_SQL_INNER: return L"INNER";
	case LEX_SQL_JOIN: return L"JOIN";
	case LEX_SQL_ON: return L"ON";
	case LEX_SQL_UNIQUE: return L"UNIQUE";
	case LEX_SQL_BY: return L"BY";
	case LEX_SQL_HAVING: return L"HAVING";
	case LEX_SQL_UNION: return L"UNION";
	case LEX_SQL_INTERSECT: return L"INTERSECT";
	case LEX_SQL_INTO: return L"INTO";
	case LEX_SQL_VALUES: return L"VALUES";
	case LEX_SQL_REPLACE: return L"REPLACE";
	case LEX_SQL_PRIMARY: return L"PRIMARY";
	case LEX_SQL_FOREIGN: return L"FOREIGN";
	case LEX_SQL_KEY: return L"KEY";
	case LEX_SQL_REFERENCES: return L"REFERENCES";
	case LEX_SQL_CASCADE: return L"CASCADE";
	case LEX_SQL_AND: return L"AND";
	case LEX_SQL_OR: return L"OR";
	case LEX_SQL_NOT: return L"NOT";
	case LEX_SQL_BEGIN: return L"BEGIN";
	case LEX_SQL_END: return L"END";
	case LEX_SQL_DISTINCT: return L"DISTINCT";
	case LEX_SQL_LIKE: return L"LIKE";
	case LEX_SQL_CHECK: return L"CHECK";
	case LEX_SQL_READ: return L"READ";
	case LEX_SQL_ONLY: return L"ONLY";
	case LEX_SQL_READ_ONLY: return L"READ_ONLY";
	case LEX_SQL_OPTION: return L"OPTION";
	case LEX_SQL_TRANSACTION: return L"TRANSACTION";
	case LEX_SQL_COMMIT: return L"COMMIT";
	case LEX_SQL_SET: return L"SET";
	case LEX_SQL_IF: return L"IF";
	case LEX_SQL_WITH: return L"WITH";
	case LEX_SQL_RAISERROR: return L"RAISERROR";
	case LEX_SQL_GO: return L"GO";
	case LEX_SQL_DECLARE: return L"DECLARE";
	case LEX_SQL_FOR: return L"FOR";
	case LEX_SQL_OPEN: return L"OPEN";
	case LEX_SQL_CLOSE: return L"CLOSE";
	case LEX_SQL_WHILE: return L"WHILE";
	case LEX_SQL_NEXT: return L"NEXT";
	case LEX_SQL_FETCH: return L"FETCH";
	case LEX_SQL_DEALLOCATE: return L"DEALLOCATE";
	case LEX_SQL_RETURN: return L"RETURN";
	case LEX_SQL_CASE: return L"CASE";
	case LEX_SQL_FETCH_STATUS: return L"FETCH_STATUS";
	case LEX_SQL_EXISTS: return L"EXISTS";
	case LEX_SQL_DBO: return L"DBO";
	case LEX_SQL_DEFAULT: return L"DEFAULT";
	case LEX_SQL_NULL: return L"NULL";
	//_____________________________ SQL FUNCTIONS
	case LEX_SQL_ABS: return L"ABS";
	case LEX_SQL_MOD: return L"MOD";
	case LEX_SQL_TRUNCATE: return L"TRUNCATE";
	case LEX_SQL_POWER: return L"POWER";
	case LEX_SQL_ROUND: return L"ROUND";
	case LEX_SQL_AVG: return L"AVG";
	case LEX_SQL_MIN: return L"MIN";
	case LEX_SQL_MAX: return L"MAX";
	case LEX_SQL_SUM: return L"SUM";
	case LEX_SQL_NVL: return L"NVL";
	case LEX_SQL_TO_NUMBER: return L"TO_NUMBER";
	case LEX_SQL_TO_CHAR: return L"TO_CHAR";
	case LEX_SQL_TO_DATE: return L"TO_DATE";
	case LEX_SQL_DATEFORMAT: return L"DATEFORMAT";
	case LEX_SQL_DATEPART: return L"DATEPART";
	case LEX_SQL_DATEDIFF: return L"DATEDIFF";
	case LEX_SQL_ISDATE: return L"ISDATE";
	case LEX_SQL_CONVERT: return L"CONVERT";
	case LEX_SQL_CAST: return L"CAST";
	case LEX_SQL_GETDATE: return L"GETDATE";
	case LEX_SQL_DB_NAME: return L"DB_NAME";
	//____________________________________________________ HTML
	case LEX_HTML_HTML: return L"html";
	case LEX_HTML_BODY: return L"body";
	case LEX_HTML_HEAD: return L"head";
	case LEX_HTML_TITLE: return L"title";
	case LEX_HTML_META: return L"meta";
	case LEX_HTML_STYLE: return L"style";
	case LEX_HTML_A: return L"a";
	case LEX_HTML_SPAN: return L"span";
	case LEX_HTML_P: return L"p";
	case LEX_HTML_DIV: return L"div";
	case LEX_HTML_TABLE: return L"table";
	case LEX_HTML_TR: return L"tr";
	case LEX_HTML_TD: return L"td";
	case LEX_HTML_OL: return L"ol";
	case LEX_HTML_UL: return L"ul";
	case LEX_HTML_LI: return L"li";
	case LEX_HTML_IMG: return L"img";
	case LEX_HTML_SELECT: return L"select";
	case LEX_HTML_TEXTAREA: return L"textarea";
	case LEX_HTML_B: return L"b";
	case LEX_HTML_I: return L"i";
	case LEX_HTML_U: return L"u";
	case LEX_HTML_FORM: return L"form";
	case LEX_HTML_HR: return L"hr";
	case LEX_HTML_BR: return L"br";
	case LEX_HTML_H1: return L"h1";
	case LEX_HTML_H2: return L"h2";
	case LEX_HTML_H3: return L"h3";
	case LEX_HTML_H4: return L"h4";
	case LEX_HTML_H5: return L"h5";
	case LEX_HTML_H6: return L"h6";
	case LEX_HTML_SCRIPT: return L"script";
	case LEX_HTML_INPUT: return L"input";
	//____________________________________________ HTMLtag properties
	case LEX_HTML_HREF: return L"href";
	case LEX_HTML_TARGET: return L"target";
	case LEX_HTML_CLASS: return L"class";
	case LEX_HTML_TYPE: return L"type";
	case LEX_HTML_NAME: return L"name";
	case LEX_HTML_SRC: return L"src";
	case LEX_HTML_ALT: return L"alt";
	case LEX_HTML_METHOD: return L"method";
	case LEX_HTML_ID: return L"id";
	case LEX_HTML_WIDTH: return L"width";
	case LEX_HTML_HEIGHT: return L"height";
	case LEX_HTML_ALIGN: return L"align";
	case LEX_HTML_VALIGN: return L"valign";
	case LEX_HTML_BORDER: return L"border";
	case LEX_HTML_CELLPADDING: return L"cellpadding";
	case LEX_HTML_CELLSPACING: return L"cellspacing";
	//__________________________________________ HTML javascript events
	case LEX_HTML_ONKEYDOWN: return L"onkeydown";
	case LEX_HTML_ONKEYPRESS: return L"onkeypress";
	case LEX_HTML_ONKEYUP: return L"onkeyup";
	case LEX_HTML_ONCLICK: return L"onclick";
	case LEX_HTML_ONDBLCLICK: return L"ondblclick";
	case LEX_HTML_ONDRAG: return L"ondrag";
	case LEX_HTML_ONDRAGEND: return L"ondragend";
	case LEX_HTML_ONDRAGENTER: return L"ondragenter";
	case LEX_HTML_ONDRAGLEAVE: return L"ondragleave";
	case LEX_HTML_ONDRAGOVER: return L"ondragover";
	case LEX_HTML_ONDRAGSTART: return L"ondragstart";
	case LEX_HTML_ONDROP: return L"ondrop";
	case LEX_HTML_ONERROR: return L"onerror";
	case LEX_HTML_ONLOAD: return L"onload";
	case LEX_HTML_ONMOUSEDOWN: return L"onmousedown";
	case LEX_HTML_ONMOUSEMOVE: return L"onmousemove";
	case LEX_HTML_ONMOUSEOUT: return L"onmouseout";
	case LEX_HTML_ONMOUSEOVER: return L"onmouseover";
	case LEX_HTML_ONMOUSEUP: return L"onmouseup";
	case LEX_HTML_ONMOUSEWHEEL: return L"onmousewheel";
	case LEX_HTML_ONSCROLL: return L"onscroll";
	case LEX_HTML_ONBLUR: return L"onblur";
	case LEX_HTML_ONCHANGE: return L"onchange";
	case LEX_HTML_ONCONTEXTMENU: return L"oncontextmenu";
	case LEX_HTML_ONFOCUS: return L"onfocus";
	case LEX_HTML_ONINPUT: return L"oninput";
	case LEX_HTML_ONINVALID: return L"oninvalid";
	case LEX_HTML_ONSELECT: return L"onselect";
	//___________________________________ HTML Page javascript events
	//case LEX_HTML_ONAFTERPRINT: return L"onafterprint";
	//case LEX_HTML_BEFOREPRINT: return L"onbeforeprint";
	//case LEX_HTML_BEFOREUNLOAD: return L"onbeforeunload";
	//case LEX_HTML_ERROR: return L"onerror";
	//case LEX_HTML_HASCHANGE: return L"haschange";
	//case LEX_HTML_LOAD: return L"onload";
	//case LEX_HTML_MESSAGE: return L"onmessage";
	//case LEX_HTML_OFFLINE: return L"offline";
	//case LEX_HTML_ONLINE: return L"online";
	//case LEX_HTML_PAGEHIDE: return L"pagehide";
	//case LEX_HTML_PAGESHOW: return L"pageshow";
	//case LEX_HTML_POPSTATE: return L"popstate";
	//case LEX_HTML_REDO: return L"redo";
	//case LEX_HTML_RESIZE: return L"resize";
	//case LEX_HTML_STORAGE: return L"storage";
	//case LEX_HTML_UNDO: return L"undo";
	//case LEX_HTML_UNLOAD: return L"unload";
	//case LEX_HTML_FORMCHANGE: return L"formchange";
	//case LEX_HTML_FORMINPUT: return L"forminput";
	//case LEX_HTML_SUBMIT: return L"submit";
	//case LEX_HTML_RESET: return L"reset";
	//___________________________________ HTML Media javascript events
	case LEX_HTML_ONABORT: return L"onabort";
	case LEX_HTML_ONCANPLAY: return L"oncanplay";
	case LEX_HTML_ONCANPLAYTHROUGH: return L"oncanplaythrough";
	case LEX_HTML_ONDURATIONCHANGE: return L"ondurationchange";
	case LEX_HTML_ONEMPTIED: return L"onemptied";
	case LEX_HTML_ONENDED: return L"onended";
	case LEX_HTML_ONERROR_MEDIA: return L"onerror";
	case LEX_HTML_ONLOADEDDATA: return L"onloadeddata";
	case LEX_HTML_ONLOADEDMETADATA: return L"onloadedmetadata";
	case LEX_HTML_ONLOADSTART: return L"onloadstart";
	case LEX_HTML_ONPAUSE: return L"onpause";
	case LEX_HTML_ONPLAY: return L"onplay";
	case LEX_HTML_ONPLAYING: return L"onplaying";
	case LEX_HTML_ONPROGRESS: return L"onprogress";
	case LEX_HTML_ONRATECHANGE: return L"onratechange";
	case LEX_HTML_ONREADYSTATECHANGE: return L"onreadystatechange";
	case LEX_HTML_ONSEEKED: return L"onseeked";
	case LEX_HTML_ONSEEKING: return L"onseeking";
	case LEX_HTML_ONSTALLED: return L"onstalled";
	case LEX_HTML_ONSUSPEND: return L"onsuspend";
	case LEX_HTML_ONTIMEUPDATE: return L"ontimeupdate";
	case LEX_HTML_ONVOLUMECHANGE: return L"onvolumechange";
	case LEX_HTML_ONWAITING: return L"onwaiting";
	//________________________________________________ HTML SPECIAL
	case LEX_TAG_CLOSING: return L"</";
	case LEX_MONO_TAG_CLOSING: return L"/>";
	case LEX_HTML_SPECIAL_SYMBOL: return L"&XX;";
	//_________________________________________________ PDF
	case LEX_PDF_NAME: return L"LEX_PDF_NAME";
	case LEX_PDF_DATA: return L"LEX_PDF_DATA";
	//
	case LEX_PDF_OBJ: return L"obj";
	case LEX_PDF_ENDOBJ: return L"endobj";
	case LEX_PDF_STREAM: return L"stream";
	case LEX_PDF_ENDSTREAM: return L"endstream";
	case LEX_PDF_XREF: return L"xref";
	case LEX_PDF_TRAILER: return L"trailer";
	case LEX_PDF_STARTXREF: return L"startxref";
	case LEX_PDF_BSLASH_BSLASH: return L"\\\\";
	case LEX_PDF_BSLASH_LPARENTHESIS: return L"\\(";
	case LEX_PDF_BSLASH_RPARENTHESIS: return L"\\)";
	case LEX_PDF_BSLASH_LBRACKET: return L"\\[";
	case LEX_PDF_BSLASH_RBRACKET: return L"\\]";
	case LEX_PDF_BSLASH_LESS: return L"\\<";
	case LEX_PDF_BSLASH_BIGGER: return L"\\>";
	case LEX_PDF_BSLASH_DIAGONAL: return L"\\/";
		//_______________________________________________
	//case LEX_FUNC_BESSELJ0: return L"besselj0";
	//case LEX_FUNC_BESSELJ1: return L"besselj1";
	//case LEX_FUNC_BESSELY0: return L"bessely0";
	//case LEX_FUNC_BESSELY1: return L"bessely1";
	case LEX_ID: return L"ID";
	}
	return NULL;
}

//_____________________________________________________________________ Compiler
Compiler::Compiler(void)
{
	variableInfo.clear();
	for(int i = 0; i<LEX_DATATYPE_COUNT; i++) memInfo[i] = 0;
	//isError = false;
}

Compiler::~Compiler(void)
{
}

bool Compiler::Compile(const wchar_t* inputString, vector<Compiler::Instruction>& outputMachineCode)
{
	Clean(outputMachineCode);
	if (lex.Create(inputString)==false) return false;
	//
	lex.GetNextToken(lookahead);
	if (lookahead.type == LEX_END_OF_FILE) return false;
	return InternalCompile(outputMachineCode);
}

bool Compiler::Compile(HWND hWnd, vector<Cpl::Compiler::Instruction>& outputMachineCode)
{
	Clean(outputMachineCode);
	if (lex.Create(hWnd)==false) return false;
	//
	lex.GetNextToken(lookahead);
	if (lookahead.type == LEX_END_OF_FILE) return false;
	return InternalCompile(outputMachineCode);
}

bool Compiler::InternalCompile(vector<Cpl::Compiler::Instruction>& outputMachineCode)
{
	intelliSenseInfo.clear();
	vector<int> index_break;
	vector<int> index_continue;
	while(sisfi.empty() == false) sisfi.pop(); // Clean the IntelliSense stack
	try
	{
		while(lookahead.type != LEX_END_OF_FILE)
		{
			Block_SingleLine(outputMachineCode, false, index_break, index_continue); 
		}
	}
	catch(int x)
	{
		x++;
		return false;
	}
	return true;
	//return (isError==false);
}

bool Compiler::Debug(const wchar_t* inputString, wstring& outputDebugString)
{
	vector<Compiler::Instruction> machineCode;
	const bool ok = Compile(inputString, machineCode);
	ListCode(machineCode, outputDebugString);
	return ok;
}

bool Compiler::Debug(HWND hWnd, wstring& outputDebugString)
{
	vector<Compiler::Instruction> machineCode;
	const bool ok = Compile(hWnd, machineCode);
	ListCode(machineCode, outputDebugString);
	return ok;
}

void Compiler::ListCode(vector<Compiler::Instruction>& inputMachineCode, wstring& outputDebugString)
{
	wchar_t * text = NULL;
	wchar_t *tokenText = NULL;
	wchar_t info[256];
	vector<Compiler::Instruction>::iterator p;
	int i = 0;
	for(p = inputMachineCode.begin(); p != inputMachineCode.end(); p++, i++)
	{
		text = GetInstructionText(*p);
		tokenText = LexicalAnalyzer::GetTokenText(p->subtype);
		if (text == NULL) continue;
		if (tokenText)
		{
			_snwprintf_s(info, 256, _TRUNCATE, L"%02d/%03d\t%d\t%g\t%s\t%s/%s\r\n",
				i, p->line_number, p->int_value, p->double_value, p->name, text, tokenText);
		}
		else
		{
			_snwprintf_s(info, 256, _TRUNCATE, L"%02d/%03d\t%d\t%g\t%s\t%s/%d\r\n",
				i, p->line_number, p->int_value, p->double_value, p->name, text, p->subtype);
		}
		outputDebugString += info;
	}
}

wchar_t* Compiler::GetInstructionText(Compiler::Instruction& inst)
{
	switch(inst.type)
	{
	case VM_ERROR: return L"Error";
	case VM_CREATE: return L"Create";
	case VM_VALUE: return L"Value";
	case VM_REFVALUE: return L"RefVal";
	case VM_SETVALUE: return L"SetVal";
	case VM_SET_VECTORCELL: return L"SetVCell";
	case VM_SET_MATRIXCELL: return L"SetMCell";
	//case VM_SETREF_VECTORCELL: return L"SetRefVCell";
	//case VM_SETREF_MATRIXCELL: return L"SetRefMCell";
	case VM_VECTOR_CELL: return L"VCell";
	case VM_MATRIX_CELL: return L"MCell";
	case VM_OPER: return L"Oper";
	case VM_OPER_MONO: return L"OperMono";
	case VM_OPER_BINA: return L"OperBina";
	case VM_FUNC: return L"Func";
	case VM_OBJFUNC: return L"ObjFunc";
	case VM_GOTO: return L"GoTo";
	case VM_GOFALSE: return L"GoFalse";
	case VM_GOTRUE: return L"GoTrue";
	}
	return L"Error";
}

void Compiler::Clean(vector<Compiler::Instruction>& machineCode)
{
	machineCode.clear();
	variableInfo.clear();
	for(int i = 0; i<LEX_DATATYPE_COUNT; i++) memInfo[i] = 0;
	//isError = false;
}

void Compiler::Next(vector<Compiler::Instruction>& machine_code)
{
	//lex.GetNextToken(lookahead);
	//if (lookahead.type == LEX_END_OF_FILE) return false;

	lex.GetNextToken(lookahead);
	if (lex.IsError(lookahead)) AddError(machine_code, lookahead, ERROR_LEX, 0);
}

void Compiler::Match(vector<Compiler::Instruction>& machine_code, int type)
{
	if (lookahead.type != type ) AddError(machine_code, lookahead, ERROR_SYNTAX, type);	
	Next(machine_code);
}

//void Compiler::Match(vector<Compiler::Instruction>& machine_code, int type, int func_id, int datatype, int parameterIndex)
//{
//	if (lookahead.type != type ) 
//	{
//		ListMethods(func_id, datatype, NULL, parameterIndex);
//		AddError(machine_code, lookahead, ERROR_SYNTAX, type);	
//		return;
//	}
//	Next(machine_code);
//}

void Compiler::AddError(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& token, int error_type, int correct_token_type)
{
	//___________________________  Create IntelliSense
	IntelliSenseFuncInfo isfi;
	while (sisfi.empty() == false)
	{
		isfi = sisfi.top();
		sisfi.pop();
		ListMethods(isfi.func_id, isfi.datatype, NULL, isfi.parameterIndex);
	}
	//
	Instruction inst;
	inst.type = VM_ERROR;
	inst.subtype = error_type;
	inst.line_number= token.line_number;
	inst.int_value = 0;
	inst.double_value = 0.0;
	wchar_t * descr = NULL;
	switch(error_type)
	{
	case ERROR_SYNTAX:
		descr = LexicalAnalyzer::GetTokenText(correct_token_type);
		if (descr)
		{			
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing %s", inst.line_number, descr);
		}
		else
		{
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error", inst.line_number);
		}
		break;
	case ERROR_VARIABLE_ALREADY_DEFINED:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has already been defined", inst.line_number);
		break;
	case ERROR_VARIABLE_NOEXISTS:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable does not exist", inst.line_number);
		break;
	case ERROR_INVALID_OBJECT_FUNC:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the object does not support this method", inst.line_number);
		break;
	case ERROR_VARIABLE_UNINIT:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has not been initialized", inst.line_number);
		break;
	case ERROR_INVALID_PARAM:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the function parameter is invalid", inst.line_number);
		break;
	case ERROR_MISSING_TOKEN:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing terminator", inst.line_number);
		break;
	case ERROR_INCOMPLETE_COMMAND:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the command is incomplete", inst.line_number);
		break;
	case ERROR_MISSING_VARIABLE:
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d a variable is missing", inst.line_number);
		break;
	case ERROR_LEX:
		{
			if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d unrecognized character %s", inst.line_number, token.string_value);
			}
			else if (token.type == LEX_ERROR_STRING_TOO_LONG)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d string too long %s", inst.line_number, token.string_value);
			}
			else if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing comment terminator", inst.line_number);
			}
			else if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR)
			{
				_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing string terminator %s", inst.line_number, token.string_value);
			}
		}
		break;
	}
	machineCode.push_back(inst);
	throw 0;
}

void Compiler::Block_MultiLine(vector<Compiler::Instruction>& machineCode, bool isLoop, vector<int>& index_break, vector<int>& index_continue)
{
	//break_go.clear();  // We erase any previous breaks
	Next(machineCode); // {
	do
	{
		Block_SingleLine(machineCode, isLoop, index_break, index_continue);
	}
	while (lookahead.type != LEX_RIGHT_CURLY_BRACKET);
	Next(machineCode); // }
}

void Compiler::Block_SingleLine(vector<Compiler::Instruction>& machineCode, bool isLoop, vector<int>& index_break, vector<int>& index_continue)
{
	if (LEX_DATATYPE_BOOL <= lookahead.type && lookahead.type <= LEX_DATATYPE_PROBNET)
	{
		DataType(machineCode);
	}
	else if (LEX_IF == lookahead.type)
	{
		If(machineCode, isLoop, index_break, index_continue);
	}
	else if (LEX_FOR == lookahead.type)
	{
		For(machineCode);
	}
	else if (LEX_WHILE == lookahead.type)
	{
		While(machineCode);
	}
	else if (LEX_DO == lookahead.type)
	{
		Do(machineCode);
	}
	//else if (LEX_SWITCH == lookahead.type)
	//{
	//	Switch(machineCode);
	//}
	else if (LEX_LEFT_CURLY_BRACKET == lookahead.type)
	{
		vector<int> index_break;
		vector<int> index_continue;
		Block_MultiLine(machineCode, false, index_break, index_continue); 
	}
	else if (LEX_ID == lookahead.type)
	{
		VariableId(machineCode);
		Match(machineCode, LEX_SEMICOLON);
	}
	else if (LEX_CONTINUE == lookahead.type && isLoop == true)
	{
		Instruction inst;
		inst.type = VM_GOTO;
		inst.subtype = 0;
		inst.line_number= lookahead.line_number;
		inst.int_value = -1; // We will update this value later 
		inst.double_value = 0.0;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", lookahead.string_value);
		machineCode.push_back(inst);
		index_continue.push_back((int)machineCode.size() - 1);
		//
		Next(machineCode); // continue
		Match(machineCode, LEX_SEMICOLON);
	}
	else if (LEX_BREAK == lookahead.type && isLoop == true)
	{
		Instruction inst;
		inst.type = VM_GOTO;
		inst.subtype = 0;
		inst.line_number= lookahead.line_number;
		inst.int_value = -1; // We will update this value later 
		inst.double_value = 0.0;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", lookahead.string_value);
		machineCode.push_back(inst);
		index_break.push_back((int)machineCode.size() - 1);
		//
		Next(machineCode); // break
		Match(machineCode, LEX_SEMICOLON);
	}
	else
	{
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}


void Compiler::DataType(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token tokenDataType = lookahead;
 	Next(machineCode); //Variable ID
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	if (lookahead.type == LEX_ID)
	{
		CreateVariable(machineCode, tokenDataType, tokenVariableId);
		Next(machineCode);
		if (lookahead.type == LEX_EQUAL)
		{
			VariableSet(machineCode, tokenVariableId);
		}
		Match(machineCode, LEX_SEMICOLON);
	}
	else
	{
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
		return;
	}
}

void Compiler::If(vector<Compiler::Instruction>& machineCode, bool isLoop, vector<int>& index_break, vector<int>& index_continue)
{
	// 1. Expression
	// 2. GOTOFALSE 4
	// 3. Block

	Instruction inst;
	int go_false;
	int go_to;
	int instruction_index;

	LexicalAnalyzer::Token tokenIf = lookahead;
	Next(machineCode);
	Match(machineCode, LEX_LEFT_PARENTHESIS);
	Expression(machineCode);
	Match(machineCode, LEX_RIGHT_PARENTHESIS);

	//_______________________________ inst
	inst.type = VM_GOFALSE;
	inst.subtype = 0;
	inst.line_number= tokenIf.line_number;
	inst.int_value = -1; // We will update the correct instruction_index
	inst.double_value = -1.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenIf.string_value);
	machineCode.push_back(inst);
	go_false = (int)machineCode.size() - 1;
	Block(machineCode, isLoop, index_break, index_continue); 
	instruction_index = (int)machineCode.size();
	machineCode[go_false].int_value = instruction_index;

	if (lookahead.type == LEX_ELSE)
	{
		machineCode[go_false].int_value = instruction_index+1;
		// 1. Expression
		// 2. GOTOFALSE 5
		// 3. CommandList
		// 4. GOTO 7
		// 5. ELSE
		// 6. CommandList

		//_______________________________ inst
		inst.type = VM_GOTO;
		inst.subtype = 0;
		inst.line_number= tokenIf.line_number;
		inst.int_value = -1; // We will update the correct instruction_index
		inst.double_value = 0.0;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", lookahead.string_value);
		machineCode.push_back(inst);
		go_to = (int)machineCode.size() - 1;
		//
		Next(machineCode); // else
		//
		Block(machineCode, isLoop, index_break, index_continue); 
		instruction_index = (int)machineCode.size();
		machineCode[go_to].int_value = instruction_index;
	}
}

void Compiler::For(vector<Compiler::Instruction>& machineCode)
{
	// 1. Statement
	// 2. Expression
	// 3. GOTOFALSE 7
	// 4. Block
	// 5. Statement
	// 6. GOTO 2
	// 7.
	vector<Compiler::Instruction>::iterator p;
	Instruction inst;
	int go_to;
	int go_tofalse;
	//int instruction_index;
	vector<Compiler::Instruction> statement3;

	// for(Statement; Expression; Statement)
	LexicalAnalyzer::Token tokenFor= lookahead;
	Next(machineCode); // for
	Match(machineCode, LEX_LEFT_PARENTHESIS); // (
	Statement(machineCode); // Statement
	go_to = (int)machineCode.size();
	Match(machineCode, LEX_SEMICOLON); // ;
	Expression(machineCode); // Expression
	Match(machineCode, LEX_SEMICOLON); // ;
	try
	{
		Statement(statement3); // Statement (We store Statement 3, so that we can add it later)
	}
	catch(int tmp)
	{
		//If there is an error in statement 3, we copy to the errors to the original code
		tmp++;
		for(p = statement3.begin(); p != statement3.end(); p++)
		{
			machineCode.push_back(*p);
		}
		throw 0;
	}
	Match(machineCode, LEX_RIGHT_PARENTHESIS); // )

	//_______________________________ inst
	inst.type = VM_GOFALSE;
	inst.subtype = 0;
	inst.line_number= tokenFor.line_number;
	inst.int_value = -1; // We will update the correct instruction_index
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFor.string_value);
	go_tofalse = (int)machineCode.size();
	machineCode.push_back(inst);
	//
	vector<int> index_break;
	vector<int> index_continue;
	Block(machineCode, true, index_break, index_continue);

	//______________________________ Statement 3
	const int go_statement = (int)machineCode.size();
	for(p = statement3.begin(); p != statement3.end(); p++)
	{
		machineCode.push_back(*p);
	}

	//_______________________________ inst
	inst.type = VM_GOTO;
	inst.subtype = 0;
	inst.line_number= tokenFor.line_number;
	inst.int_value = go_to; 
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFor.string_value);
	machineCode.push_back(inst);
	//
	machineCode[go_tofalse].int_value = (int)machineCode.size();
	//
	//_____________________________ Update breaks
	const int go_break = (int)machineCode.size();
	const int lenBreak = (int)index_break.size();
	int i;
	for(i = 0; i <lenBreak; i++)
	{
		machineCode[index_break[i]].int_value = go_break;
	}
	//_____________________________ Update continues
	const int lenContinue = (int)index_continue.size();
	for(i = 0; i <lenContinue; i++)
	{
		machineCode[index_continue[i]].int_value = go_statement;
	}
}

void Compiler::While(vector<Compiler::Instruction>& machineCode)
{
	// 1. Expression
	// 2. GOTOFALSE 5
	// 3. Block
	// 4. GOTO 1
	Instruction inst;
	int go_false;
	int go_to;

	LexicalAnalyzer::Token tokenWhile= lookahead; 
	Next(machineCode); // while
	Match(machineCode, LEX_LEFT_PARENTHESIS); // (
	go_to = (int)machineCode.size();
	Expression(machineCode);
	Match(machineCode, LEX_RIGHT_PARENTHESIS); // )

	//_______________________________ inst
	inst.type = VM_GOFALSE;
	inst.subtype = 0;
	inst.line_number= tokenWhile.line_number;
	inst.int_value = -1; // We will update the correct instruction_index
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenWhile.string_value);
	machineCode.push_back(inst);
	go_false = (int)machineCode.size() - 1;
	vector<int> index_break;
	vector<int> index_continue;
	Block(machineCode, true, index_break, index_continue);
	//_______________________________ inst
	inst.type = VM_GOTO;
	inst.subtype = 0;
	inst.line_number= tokenWhile.line_number;
	inst.int_value = go_to; 
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenWhile.string_value);
	machineCode.push_back(inst);
	//
	machineCode[go_false].int_value = (int)machineCode.size();
	//
	//_____________________________ Update breaks
	const int go_break = (int)machineCode.size();
	const int lenBreak = (int)index_break.size();
	int i;
	for(i = 0; i <lenBreak; i++)
	{
		machineCode[index_break[i]].int_value = go_break;
	}
	//_____________________________ Update continues
	const int lenContinue = (int)index_continue.size();
	for(i = 0; i <lenContinue; i++)
	{
		machineCode[index_continue[i]].int_value = go_to;
	}
}

void Compiler::Do(vector<Compiler::Instruction>& machineCode)
{
	// 1. Block
	// 2. Expression
	// 3. GOTOTRUE 1
	Instruction inst;
	int go_true;

	LexicalAnalyzer::Token tokenDo= lookahead;
	Next(machineCode); // Do
	go_true = (int)machineCode.size();
	//
	vector<int> index_break;
	vector<int> index_continue;
	Block(machineCode, true, index_break, index_continue); 
	//
	Match(machineCode, LEX_WHILE);
	Match(machineCode, LEX_LEFT_PARENTHESIS);
	const int go_expression = (int)machineCode.size();
	Expression(machineCode);
	Match(machineCode, LEX_RIGHT_PARENTHESIS);
	Match(machineCode, LEX_SEMICOLON);
	

	//_______________________________ inst
	inst.type = VM_GOTRUE;
	inst.subtype = 0;
	inst.line_number= tokenDo.line_number;
	inst.int_value = go_true; 
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenDo.string_value);
	machineCode.push_back(inst);
	
	//_____________________________ Update breaks
	const int go_break = (int)machineCode.size();
	const int lenBreak = (int)index_break.size();
	int i;
	for(i = 0; i <lenBreak; i++)
	{
		machineCode[index_break[i]].int_value = go_break;
	}
	//_____________________________ Update continues
	const int lenContinue = (int)index_continue.size();
	for(i = 0; i <lenContinue; i++)
	{
		machineCode[index_continue[i]].int_value = go_expression;
	}
}

void Compiler::Switch(vector<Compiler::Instruction>& machineCode)
{
}

void Compiler::Block(vector<Compiler::Instruction>& machineCode, bool isLoop, vector<int>& index_break, vector<int>& index_continue)
{
	if (lookahead.type == LEX_LEFT_CURLY_BRACKET)
	{
		Block_MultiLine(machineCode, isLoop, index_break, index_continue);
	}
	else
	{
		Block_SingleLine(machineCode, isLoop, index_break, index_continue);
	}
}

//bool Compiler::IsValidId(LexicalAnalyzer::Token& token)
//{
//	map<wstring, Compiler::VariableInfo>::iterator p = variableInfo.find(token.string_value);
//	if (p ==variableInfo.end()) return false;
//	return true;
//}

void Compiler::VariableId(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	Compiler::VariableInfo vi = GetVariableInfo(tokenVariableId);
	if (vi.datatype == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, lookahead, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	Next(machineCode); // ID

	switch(lookahead.type)
	{
	case LEX_EQUAL:
		VariableSet(machineCode, tokenVariableId);
		//Match(machineCode, LEX_SEMICOLON);
		break;
	case LEX_DOT:
		ObjectFunction(machineCode, tokenVariableId, vi);
		break;
	case LEX_LEFT_BRACKET:
		VariableArray(machineCode, tokenVariableId, vi);
		break;
	case LEX_PLUS_PLUS:
	case LEX_MINUS_MINUS:
		OperMono(machineCode, tokenVariableId, vi);
		break;
	case LEX_PLUS_EQUAL:
	case LEX_MINUS_EQUAL:
	case LEX_PRODUCT_EQUAL:
	case LEX_DIVISION_EQUAL:
		OperBina(machineCode, tokenVariableId, vi);
		break;
	default:
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::Statement(vector<Compiler::Instruction>& machineCode)
{
	if (lookahead.type != LEX_ID)
	{
		AddError(machineCode, lookahead, ERROR_MISSING_VARIABLE, ERROR_INVALID_VALUE);
		return;
	}
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	Compiler::VariableInfo vi = GetVariableInfo(tokenVariableId);
	if (vi.datatype == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, lookahead, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	if (lookahead.type == LEX_END_OF_FILE)
	{
		AddError(machineCode, lookahead, ERROR_INCOMPLETE_COMMAND, ERROR_INVALID_VALUE);
		return;
	}
	Next(machineCode); // ID

	switch(lookahead.type)
	{
	case LEX_EQUAL:
		VariableSet(machineCode, tokenVariableId);
		break;
	case LEX_PLUS_PLUS:
	case LEX_MINUS_MINUS:
		OperMono(machineCode, tokenVariableId, vi);
		break;
	case LEX_PLUS_EQUAL:
	case LEX_MINUS_EQUAL:
	case LEX_PRODUCT_EQUAL:
	case LEX_DIVISION_EQUAL:
		OperBina(machineCode, tokenVariableId, vi);
		break;
	default:
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::OperMono(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	if (lookahead.type == LEX_PLUS_PLUS || lookahead.type ==LEX_MINUS_MINUS)
	{	
		wchar_t * descr = Cpl::LexicalAnalyzer::GetTokenText(lookahead.type);
		//___________ Instruction
		Instruction inst;
		inst.type = VM_OPER_MONO;
		inst.subtype =vi.datatype;  
		inst.line_number = lookahead.line_number;
		inst.int_value = vi.index;
		inst.double_value = lookahead.type; //LEX_PLUS_PLUS, LEX_MINUS_MINUS
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s%s", tokenVariableId.string_value, descr);
		machineCode.push_back(inst);
		Next(machineCode); // ++, --
		return;
	}
	AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
}

void Compiler::OperBina(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	if (lookahead.type == LEX_PLUS_EQUAL || lookahead.type ==LEX_MINUS_EQUAL
		|| lookahead.type == LEX_PRODUCT_EQUAL || lookahead.type ==LEX_DIVISION_EQUAL)
	{	
		wchar_t * descr = Cpl::LexicalAnalyzer::GetTokenText(lookahead.type);
		Cpl::LexicalAnalyzer::Token operation = lookahead;
		Next(machineCode); // +=, -=, *=, /=
		Expression(machineCode);
		//___________ Instruction
		Instruction inst;
		inst.type = VM_OPER_BINA;
		inst.subtype =vi.datatype;  
		inst.line_number = operation.line_number;
		inst.int_value = vi.index;
		inst.double_value = operation.type; //LEX_PLUS_EQUAL, LEX_MINUS_EQUAL, LEX_PRODUCT_EQUAL, LEX_DIVISION_EQUAL
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s%s", tokenVariableId.string_value, descr);
		machineCode.push_back(inst);
		return;
	}
	AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
}

// x = expression
void Compiler::VariableSet(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId)
{
	Compiler::VariableInfo vi = GetVariableInfo(tokenVariableId);
	if (vi.datatype == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, tokenVariableId, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	Next(machineCode); // =
	Expression(machineCode);
	//___________ Instruction
	Instruction inst;
	inst.type = VM_SETVALUE;
	inst.subtype = vi.datatype;
	inst.line_number = tokenVariableId.line_number;
	inst.int_value = vi.index;
	inst.double_value = 0.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
	machineCode.push_back(inst);
}

void Compiler::ListMethods(int datatype, list<Cpl::Compiler::FuncInfo>& out_funcInfo)
{
	out_funcInfo.clear();
	Cpl::Compiler::FuncInfo fi;
	const int initial_func_id = GetInitialFuncId(datatype); 
	if (initial_func_id == -1) return;
	wchar_t * func_name = NULL;
	int func_id;
	int count = 0; // prevent infine loop: impossible
	for (func_id = initial_func_id; count < 100; func_id++, count++)
	{
		func_name = GetFunctionName(datatype, func_id);
		if (func_name == NULL) break;
		fi.id = func_id;
		_snwprintf_s(fi.name, LEX_STRINGMAX, _TRUNCATE, L"%s", func_name);
		out_funcInfo.push_back(fi);
	}
	out_funcInfo.sort();
}

int Compiler::GetInitialFuncId(int datatype)
{
	switch(datatype)
	{
	case LEX_DATATYPE_VECTOR: return LEX_FUNC_VECTOR_CREATE;
	case LEX_DATATYPE_MATRIX: return LEX_FUNC_MATRIX_CREATE;
	case LEX_DATATYPE_COMPLEX_VECTOR: return LEX_FUNC_VECTOR_CREATE;
	case LEX_DATATYPE_COMPLEX_MATRIX: return LEX_FUNC_MATRIX_CREATE;
	case LEX_DATATYPE_LAYERNET: return LEX_FUNC_LAYERNET_CREATE;
	case LEX_DATATYPE_LAYERNETC: return LEX_FUNC_LAYERNETC_CREATE;
	case LEX_DATATYPE_KOHONET: return LEX_FUNC_KOHONET_CREATE;
	case LEX_DATATYPE_PROBNET: return LEX_FUNC_PROBNET_LOAD;
	}
	return -1;
}

void Compiler::ListMethods(int func_id, int datatype, wchar_t* next_text,  int parameterIndex)
{
	wchar_t *func_name = NULL;
	IntelliSenseInfo isi;
	isi.type = (next_text == NULL) ? LEX_ISI_METHOD_ARG : LEX_ISI_METHOD;
	isi.func_id = func_id;

	if (next_text == NULL)//__________________________ list all methods of func_id
	{
		wchar_t * datatype_text = NULL;
		const int paramType = Cpl::Compiler::GetObjectFuncReturnType(datatype, func_id);
		if (paramType != ERROR_INVALID_VALUE)
		{
			datatype_text = Cpl::LexicalAnalyzer::GetTokenText(paramType);
		}
		func_name = GetFunctionName(datatype, func_id);
		if (func_name == NULL) return;
		if (datatype_text != NULL)
		{
			isi.name = datatype_text;
			isi.name += L" ";
			isi.name += func_name;
		}
		else
		{
			isi.name = func_name;
		}
		
		intelliSenseInfo.push_back(isi);
		ListParameters(func_id, datatype, parameterIndex);
		return;
	}
	int initial_func_id = GetInitialFuncId(datatype);
	
	//____________________________________________ list methods that match the next_text
	const int next_len = (int)wcslen(next_text);
	int i;
	bool equal;
	int func_len;

	do
	{
		func_name = GetFunctionName(datatype, initial_func_id);
		if (func_name != NULL)
		{
			if (next_len == 0)
			{
				isi.name = func_name;
				intelliSenseInfo.push_back(isi);
				if (next_text == NULL) ListParameters(func_id, datatype, parameterIndex);
			}
			else //_____________ Filter functions
			{
				func_len = (int)wcslen(func_name);
				equal = true;
				for(i = 0; i<next_len; i++)
				{
					if (next_len<=func_len)
					{
						if (next_text[i] != func_name[i])
						{
							equal = false;
							break;
						}
					}
					else
					{
						equal = false;
						break;
					}
				}
				if (equal == true)// && i != 0)
				{
					isi.name = func_name;
					intelliSenseInfo.push_back(isi);
					if (next_text == NULL) ListParameters(func_id, datatype, parameterIndex);
				}
			}
		}
		initial_func_id++;
	}
	while(func_name != NULL);
	if (next_text != NULL)
	{
		intelliSenseInfo.sort();
	}
}

void Compiler::ListParameters(int func_id, int datatype, int parameterIndex)
{
	IntelliSenseInfo isi;
	isi.type = LEX_ISI_ARGUMENT;
	isi.func_id = func_id;

	const int paramCount = GetFuncParamCount(func_id);
	int paramType = -1;
	wchar_t* datatype_text = NULL;
	wchar_t* paramName = NULL;
	for(int i = 0; i < paramCount; i++)
	{
		paramType = Cpl::Compiler::GetObjectFuncParamType(func_id, i);
		datatype_text = Cpl::LexicalAnalyzer::GetTokenText(paramType);
		if (datatype_text == NULL) continue;
		//
		paramName = GetObjectFuncParamName(func_id, i);
		if (paramName == NULL) continue;
		isi.name = datatype_text;
		isi.name += L" ";
		isi.name += paramName;
		if (i == parameterIndex)
		{
			isi.type = LEX_ISI_ARGUMENT_SEL;
		}
		else
		{
			isi.type = LEX_ISI_ARGUMENT;
		}
		if (i == paramCount -1)
		{
			if (i == parameterIndex)
			{
				isi.type = LEX_ISI_LAST_ARGUMENT_SEL;
			}
			else
			{
				isi.type = LEX_ISI_LAST_ARGUMENT;
			}
		}
		intelliSenseInfo.push_back(isi);
	}
}

void Compiler::ObjectFunction(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	wchar_t next_text[64];
	lex.GetNextText(next_text, 64);
	//_________________________________________
	Next(machineCode);  // .
	//
	LexicalAnalyzer::Token tokenFunction = lookahead;
	const int func_id = GetObjectFuncIndex(vi.datatype, tokenFunction.string_value);
	if (func_id == ERROR_INVALID_VALUE)
	{
		ListMethods(func_id, vi.datatype, next_text, -1);
		//
		AddError(machineCode, tokenFunction, ERROR_INVALID_OBJECT_FUNC, ERROR_INVALID_VALUE);
		return;
	}
	if (tokenFunction.type == ERROR_INVALID_VALUE)
	{
		AddError(machineCode, tokenFunction, ERROR_INVALID_OBJECT_FUNC, ERROR_INVALID_VALUE);
		return;
	}
	const int paramCount = GetFuncParamCount(func_id);

	Next(machineCode);  // Function Name
	//_________________________________________________________ LEFT PARENTHESIS
	IntelliSenseFuncInfo isfi;
	isfi.func_id = func_id;
	isfi.datatype = vi.datatype;
	isfi.parameterIndex = 0;
	sisfi.push(isfi);
	Match(machineCode, LEX_LEFT_PARENTHESIS);
	sisfi.pop();
	//
	for(int i=0; i<paramCount; i++)
	{
		if (lookahead.type == LEX_END_OF_FILE)
		{
			ListMethods(func_id, vi.datatype, NULL, i);
			AddError(machineCode, tokenFunction, ERROR_SYNTAX, -1);
			return;
		}
		//____________________________________________ Expression
		isfi.func_id = func_id;
		isfi.datatype = vi.datatype;
		isfi.parameterIndex = i;
		sisfi.push(isfi);
		Expression(machineCode);
		sisfi.pop();
		//____________________________________________ COMMA
		if (i<paramCount-1)
		{
			isfi.func_id = func_id;
			isfi.datatype = vi.datatype;
			isfi.parameterIndex = i;
			sisfi.push(isfi);
			Match(machineCode, LEX_COMMA);
			sisfi.pop();
		}
	}
	//__________________________________________________________ RIGHT PARENTHESIS
	isfi.func_id = func_id;
	isfi.datatype = vi.datatype;
	isfi.parameterIndex = paramCount-1;
	sisfi.push(isfi);
	Match(machineCode, LEX_RIGHT_PARENTHESIS);
	sisfi.pop();
	//
	Compiler::Instruction inst;
	//_____________________________ emitObject
	inst.type = VM_REFVALUE;
	inst.subtype = vi.datatype; // Object datatype
	inst.int_value = vi.index; // Object index
	inst.double_value = -1.0;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
	inst.line_number = tokenVariableId.line_number;
	machineCode.push_back(inst);

	//_______________ emit Object Function
	inst.type = VM_OBJFUNC;
	inst.line_number = tokenFunction.line_number;
	inst.subtype = func_id;//tokenFunction.type;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFunction.string_value);
	inst.int_value = paramCount;
	inst.double_value = vi.datatype; // Object datatype
	machineCode.push_back(inst);
}

void Compiler::VariableArray(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenVariableId, VariableInfo vi)
{
	//Next(machineCode); // ID

	if (lookahead.type != LEX_LEFT_BRACKET)
	{
		AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
		return;
	}

	if (vi.datatype == LEX_DATATYPE_MATRIX || vi.datatype == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		Next(machineCode); // [
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_BRACKET); // ]
		Match(machineCode, LEX_LEFT_BRACKET); // [
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_BRACKET); // ]
		
		
		if (lookahead.type == LEX_EQUAL)//  x = expression;
		{
			Next(machineCode); // =
			Expression(machineCode);
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_SET_MATRIXCELL;
			inst.subtype = vi.datatype;
			inst.int_value = vi.index;
			inst.double_value = 0.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s[][]", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
		}
	}
	else if (vi.datatype == LEX_DATATYPE_VECTOR || vi.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		Next(machineCode); // [
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_BRACKET); // ]
		
		if (lookahead.type == LEX_EQUAL)//  x = expression;
		{
			Next(machineCode); // =
			Expression(machineCode);
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_SET_VECTORCELL;
			inst.subtype = vi.datatype;
			inst.int_value = vi.index;
			inst.double_value = 0.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s[]", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
		}
	}
	else
	{
		AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

Compiler::VariableInfo Compiler::GetVariableInfo(LexicalAnalyzer::Token& token)
{
	Compiler::VariableInfo vi;
	vi.index = ERROR_INVALID_VALUE;
	vi.datatype = ERROR_INVALID_VALUE;
	map<wstring, Compiler::VariableInfo>::iterator p = variableInfo.find(token.string_value);
	if (p ==variableInfo.end()) return vi;
	return p->second;
}

// 5*x+8/y
void Compiler::Expression(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token token;
	Term(machineCode);
	while(true)
	{
		if (lookahead.type== LEX_PLUS || lookahead.type== LEX_MINUS
			|| lookahead.type == LEX_OR || lookahead.type == LEX_AND)
		{
			token = lookahead;
			Next(machineCode);
			Term(machineCode);
			//_________________________ Instruction
			Instruction inst;
			inst.type = VM_OPER;
			inst.line_number = token.line_number;
			inst.subtype = token.type;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", token.string_value);
			inst.int_value = -1;
			inst.double_value = -1.0;
			machineCode.push_back(inst);
			continue;
		}
		break;
	}
}

void Compiler::Term(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token token;
	Factor(machineCode);
	while(true)
	{
		if (lookahead.type == LEX_ASTERISK || lookahead.type == LEX_DIVISION || lookahead.type == LEX_PERCENT_SIGN
				|| lookahead.type== LEX_IS_BIGGER || lookahead.type== LEX_IS_BIGGER_EQ
				|| lookahead.type== LEX_IS_LESS || lookahead.type== LEX_IS_LESS_EQ
				|| lookahead.type== LEX_IS_EQUAL || lookahead.type== LEX_IS_DIFFERENT)
		{
			token = lookahead;
			Next(machineCode);
			Factor(machineCode);
			//___________________ Instruction
			Compiler::Instruction inst;
			inst.type = VM_OPER;
			inst.line_number = token.line_number;
			inst.subtype = token.type;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", token.string_value);
			inst.int_value = 2;
			inst.double_value = 2.0;
			machineCode.push_back(inst);
			continue;
		}
		break;
	}
}

void Compiler::Factor(vector<Compiler::Instruction>& machineCode)
{
	if (lookahead.type == LEX_LEFT_PARENTHESIS)
	{
		Next(machineCode);  // (
		Expression(machineCode);
		Match(machineCode, LEX_RIGHT_PARENTHESIS); // )
	}
	else if (lookahead.type == LEX_MINUS) // -2.0, -sin(x), -x
	{
		Next(machineCode); // -
		if  (lookahead.type == LEX_CONST_VALUE_INTEGER || lookahead.type == LEX_CONST_VALUE_DOUBLE)
		{
			//______________________________ Instruction
			Compiler::Instruction inst;
			inst.type = VM_VALUE;
			inst.line_number = lookahead.line_number;
			if (lookahead.type == LEX_CONST_VALUE_INTEGER)
			{
				inst.subtype = LEX_DATATYPE_INTEGER;
			}
			else if (lookahead.type == LEX_CONST_VALUE_DOUBLE)
			{
				inst.subtype = LEX_DATATYPE_DOUBLE;
			}
			inst.int_value = - lookahead.int_value;
			inst.double_value = - lookahead.double_value;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"-%s", lookahead.string_value);
			machineCode.push_back(inst);
			//
			Next(machineCode); // integer or double value
		}
		else if (lookahead.type == LEX_ID)
		{
			//_______________________________________ Push a -1
			Compiler::Instruction inst;
			inst.type = VM_VALUE;
			inst.line_number = lookahead.line_number;
			inst.subtype = LEX_DATATYPE_DOUBLE;
			inst.int_value = - 1;
			inst.double_value = - 1.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"-1.0");
			machineCode.push_back(inst);
			//
			FactorId(machineCode);
			//
			//_______________________________________ Push a product
			inst.type = VM_OPER;
			//inst.line_number = token.line_number; // Use the same line number
			inst.subtype = LEX_ASTERISK;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"*");
			inst.int_value = -1;
			inst.double_value = -1.0;
			machineCode.push_back(inst);
		}
		else if (LEX_FUNC_SIN <= lookahead.type && lookahead.type<=LEX_FUNC_ISPRIME)
		{
			//_______________________________________ Push a -1
			Compiler::Instruction inst;
			inst.type = VM_VALUE;
			inst.line_number = lookahead.line_number;
			inst.subtype = LEX_DATATYPE_DOUBLE;
			inst.int_value = - 1;
			inst.double_value = - 1.0;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"-1.0");
			machineCode.push_back(inst);
			//
			FunctionCall(machineCode);
			//_______________________________________ Push a product
			inst.type = VM_OPER;
			//inst.line_number = token.line_number; // Use the same line number
			inst.subtype = LEX_ASTERISK;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"*");
			inst.int_value = -1;
			inst.double_value = -1.0;
			machineCode.push_back(inst);
		}
		else
		{
			AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
		}
	}
	else if  ( lookahead.type == LEX_TRUE || lookahead.type == LEX_FALSE 
		|| lookahead.type == LEX_CONST_VALUE_INTEGER 
		|| lookahead.type == LEX_CONST_VALUE_DOUBLE)
	{
		//______________________________ Instruction
		Compiler::Instruction inst;
		inst.type = VM_VALUE;
		inst.line_number = lookahead.line_number;
		if (lookahead.type == LEX_TRUE)
		{
			inst.subtype = LEX_DATATYPE_BOOL;
			inst.int_value = 1;
			inst.double_value = 1.0;
		}
		else if (lookahead.type == LEX_FALSE)
		{
			inst.subtype = LEX_DATATYPE_BOOL;
			inst.int_value = 0;
			inst.double_value = 0.0;
		}
		else if (lookahead.type == LEX_CONST_VALUE_INTEGER)
		{
			inst.subtype = LEX_DATATYPE_INTEGER;
			inst.int_value = lookahead.int_value;
			inst.double_value = lookahead.double_value;
		}
		else if (lookahead.type == LEX_CONST_VALUE_DOUBLE)
		{
			inst.subtype = LEX_DATATYPE_DOUBLE;
			inst.int_value = lookahead.int_value;
			inst.double_value = lookahead.double_value;
		}
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", lookahead.string_value);
		machineCode.push_back(inst);
		//
		Next(machineCode);
	}
	else if (lookahead.type == LEX_ID)
	{
		FactorId(machineCode);
	}
	else if (LEX_FUNC_SIN <= lookahead.type && lookahead.type<=LEX_FUNC_ISPRIME)
	{
		FunctionCall(machineCode);
	}
	else
	{
		AddError(machineCode, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::FactorId(vector<Compiler::Instruction>& machineCode)
{
	LexicalAnalyzer::Token tokenVariableId = lookahead;
	map<wstring, VariableInfo>::iterator p = variableInfo.find(lookahead.string_value);
	Next(machineCode);
	if (p== variableInfo.end())
	{
		AddError(machineCode, tokenVariableId, ERROR_VARIABLE_NOEXISTS, ERROR_INVALID_VALUE);
		return;
	}
	
	if (lookahead.type == LEX_LEFT_BRACKET)
	{
		if (p->second.datatype == LEX_DATATYPE_MATRIX || p->second.datatype == LEX_DATATYPE_COMPLEX_MATRIX)
		{
			Next(machineCode); // [
			Expression(machineCode);
			Match(machineCode, LEX_RIGHT_BRACKET); // ]
			Match(machineCode, LEX_LEFT_BRACKET); // [
			Expression(machineCode);
			Match(machineCode, LEX_RIGHT_BRACKET); // ]
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_MATRIX_CELL;
			inst.subtype = tokenVariableId.type;
			inst.int_value = p->second.index;
			inst.double_value = p->second.datatype;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
			return;
		}
		else if (p->second.datatype == LEX_DATATYPE_VECTOR || p->second.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
		{
			Next(machineCode); // [
			Expression(machineCode);
			Match(machineCode, LEX_RIGHT_BRACKET); // ]
			//_____________________________ emit
			Compiler::Instruction inst;
			inst.type = VM_VECTOR_CELL;
			inst.subtype = tokenVariableId.type;
			inst.int_value = p->second.index;
			inst.double_value = p->second.datatype;
			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
			inst.line_number = tokenVariableId.line_number;
			machineCode.push_back(inst);
			return;
		}
		else
		{
			AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
			return;
		}
	}
	else if (lookahead.type == LEX_DOT)
	{
		ObjectFunction(machineCode, tokenVariableId, p->second);
	}
	else if (tokenVariableId.type == LEX_DATATYPE_MATRIX || LEX_DATATYPE_COMPLEX_MATRIX 
		|| tokenVariableId.type == LEX_DATATYPE_VECTOR || tokenVariableId.type == LEX_DATATYPE_COMPLEX_VECTOR
		|| tokenVariableId.type == LEX_DATATYPE_BOOL || tokenVariableId.type == LEX_DATATYPE_DOUBLE
		|| tokenVariableId.type == LEX_DATATYPE_INTEGER)
	{
		//_____________________________ emit
		Compiler::Instruction inst;
		inst.type = VM_REFVALUE;
		inst.subtype = p->second.datatype;
		inst.int_value = p->second.index;
		inst.double_value = -1.0;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenVariableId.string_value);
		inst.line_number = tokenVariableId.line_number;
		machineCode.push_back(inst);
	}
	else
	{
		AddError(machineCode, tokenVariableId, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::FunctionCall(vector<Compiler::Instruction>& machineCode)
{
		LexicalAnalyzer::Token tokenFunction = lookahead;
		Next(machineCode);
		//
		Match(machineCode, LEX_LEFT_PARENTHESIS);
		const int paramCount = GetFuncParamCount(tokenFunction.type);
		for(int i = 0; i < paramCount; i++)
		{
			if (i == 0)
			{
				Expression(machineCode);
			}
			else
			{
				Match(machineCode, LEX_COMMA);
				Expression(machineCode);
			}
		}
		Match(machineCode, LEX_RIGHT_PARENTHESIS);
		//_____________________________ emit
		Compiler::Instruction inst;
		inst.type = VM_FUNC;
		inst.subtype = tokenFunction.type;
		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenFunction.string_value);
		inst.line_number = tokenFunction.line_number;
		inst.int_value = GetFuncParamCount(tokenFunction.type); // The number of parameters
		inst.double_value = inst.int_value;
		machineCode.push_back(inst);
}

// It returns the next variable index
void Compiler::CreateVariable(vector<Compiler::Instruction>& machineCode, LexicalAnalyzer::Token& tokenDataType, LexicalAnalyzer::Token& tokenID)
{
	int index = -1;
	if (LEX_DATATYPE_BOOL <= tokenDataType.type  && tokenDataType.type <= LEX_DATATYPE_PROBNET)
	{
		index = memInfo[tokenDataType.type-LEX_DATATYPE_BOOL]++;
	}

	if (index == -1)
	{
		AddError(machineCode, tokenDataType, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}

	Instruction inst;
	inst.type = VM_CREATE;
	inst.subtype = tokenDataType.type;
	inst.line_number = tokenDataType.line_number;
	inst.int_value = index;
	inst.double_value = index;
	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"%s", tokenID.string_value);
	
	//____________________________________ store IDs
	VariableInfo vi;
	vi.index = index;
	vi.datatype = tokenDataType.type;
	pair< map<wstring, VariableInfo>::iterator, bool > pr;
	pr = variableInfo.insert(std::pair<wstring, Compiler::VariableInfo>(lookahead.string_value, vi));
	if (pr.second==false)
	{
		AddError(machineCode, tokenID, ERROR_VARIABLE_ALREADY_DEFINED, ERROR_INVALID_VALUE);
	}
	//
	machineCode.push_back(inst);
}

int Compiler::GetObjectFuncIndex(int datatype, const wchar_t* text)
{
	switch(datatype)
	{
	//case LEX_DATATYPE_BOOL:
	//case LEX_DATATYPE_DOUBLE:
	//case LEX_DATATYPE_INTEGER:
	//case LEX_DATATYPE_VOID:
	//	return LEX_ERROR;
	case LEX_DATATYPE_MATRIX:
	case LEX_DATATYPE_COMPLEX_MATRIX:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_MATRIX_CREATE;
		else if (wcscmp(text, L"CreateRandom")==0) return LEX_FUNC_MATRIX_CREATE_RANDOM;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_MATRIX_SAVE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_MATRIX_LOAD;
		else if (wcscmp(text, L"AppendRight")==0) return LEX_FUNC_MATRIX_APPEND_RIGHT;
		else if (wcscmp(text, L"AppendDown")==0) return LEX_FUNC_MATRIX_APPEND_DOWN;
		else if (wcscmp(text, L"DeleteRow")==0) return LEX_FUNC_MATRIX_DELETE_ROW;
		else if (wcscmp(text, L"DeleteCol")==0) return LEX_FUNC_MATRIX_DELETE_COL;
		else if (wcscmp(text, L"InsertRow")==0) return LEX_FUNC_MATRIX_INSERT_ROW;
		else if (wcscmp(text, L"InsertCol")==0) return LEX_FUNC_MATRIX_INSERT_COL;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_MATRIX_DELETE;
		else if (wcscmp(text, L"GetRowCount")==0) return LEX_FUNC_MATRIX_GET_ROW_COUNT;
		else if (wcscmp(text, L"GetColCount")==0) return LEX_FUNC_MATRIX_GET_COL_COUNT;
		else if (wcscmp(text, L"GetSum")==0) return LEX_FUNC_MATRIX_GET_SUM;
		else if (wcscmp(text, L"GetDiagonalSum")==0) return LEX_FUNC_MATRIX_GET_DIAGONAL_SUM;
		else if (wcscmp(text, L"GetMean")==0) return LEX_FUNC_MATRIX_GET_MEAN;
		else if (wcscmp(text, L"GetVariance")==0) return LEX_FUNC_MATRIX_GET_VARIANCE;
		else if (wcscmp(text, L"GetMin")==0) return LEX_FUNC_MATRIX_GET_MINIMUM;
		else if (wcscmp(text, L"GetMax")==0) return LEX_FUNC_MATRIX_GET_MAXIMUM;
		else if (wcscmp(text, L"GetMinPos")==0) return LEX_FUNC_MATRIX_GET_MIN_POS;
		else if (wcscmp(text, L"GetMaxPos")==0) return LEX_FUNC_MATRIX_GET_MAX_POS;
		else if (wcscmp(text, L"GetSumSquares")==0) return LEX_FUNC_MATRIX_GET_SUM_SQUARES;
		else if (wcscmp(text, L"GetRows")==0) return LEX_FUNC_MATRIX_GET_ROWS;
		else if (wcscmp(text, L"GetCols")==0) return LEX_FUNC_MATRIX_GET_COLS;
		else if (wcscmp(text, L"DeleteRows")==0) return LEX_FUNC_MATRIX_DELETE_ROWS;
		else if (wcscmp(text, L"DeleteCols")==0) return LEX_FUNC_MATRIX_DELETE_COLS;
		else if (wcscmp(text, L"GetClass")==0) return LEX_FUNC_MATRIX_GET_CLASS;
		else if (wcscmp(text, L"Transpose")==0) return LEX_FUNC_MATRIX_TRANSPOSE;
		else if (wcscmp(text, L"Prediction")==0) return LEX_FUNC_MATRIX_PREDICTION;
		else if (wcscmp(text, L"NormRows")==0) return LEX_FUNC_MATRIX_NORM_ROWS;
		else if (wcscmp(text, L"NormCols")==0) return LEX_FUNC_MATRIX_NORM_COLS;
		else if (wcscmp(text, L"RowsVar")==0) return LEX_FUNC_MATRIX_ROWS_VAR;
		else if (wcscmp(text, L"ColsVar")==0) return LEX_FUNC_MATRIX_COLS_VAR;
		else if (wcscmp(text, L"RowsMean")==0) return LEX_FUNC_MATRIX_ROWS_MEAN;
		else if (wcscmp(text, L"ColsMean")==0) return LEX_FUNC_MATRIX_COLS_MEAN;
		else if (wcscmp(text, L"RowsMin")==0) return LEX_FUNC_MATRIX_ROWS_MIN;
		else if (wcscmp(text, L"ColsMin")==0) return LEX_FUNC_MATRIX_COLS_MIN;
		else if (wcscmp(text, L"RowsMax")==0) return LEX_FUNC_MATRIX_ROWS_MAX;
		else if (wcscmp(text, L"ColsMax")==0) return LEX_FUNC_MATRIX_COLS_MAX;
		else if (wcscmp(text, L"GetRow")==0) return LEX_FUNC_MATRIX_GET_ROW;
		else if (wcscmp(text, L"GetCol")==0) return LEX_FUNC_MATRIX_GET_COL;
		break;
	case LEX_DATATYPE_VECTOR:
	case LEX_DATATYPE_COMPLEX_VECTOR:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_VECTOR_CREATE;
		else if (wcscmp(text, L"CreateSeries")==0) return LEX_FUNC_VECTOR_CREATE_SERIES;
		else if (wcscmp(text, L"CreateRandom") == 0) return LEX_FUNC_VECTOR_CREATE_RANDOM;
		else if (wcscmp(text, L"CreateBinary") == 0) return LEX_FUNC_VECTOR_CREATE_BINARY;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_VECTOR_SAVE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_VECTOR_LOAD;
		else if (wcscmp(text, L"InsertCell")==0) return LEX_FUNC_VECTOR_INSERT_CELL;
		else if (wcscmp(text, L"DeleteCell")==0) return LEX_FUNC_VECTOR_DELETE_CELL;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_VECTOR_DELETE;
		else if (wcscmp(text, L"GetSize")==0) return LEX_FUNC_VECTOR_GET_SIZE;
		else if (wcscmp(text, L"GetSum")==0) return LEX_FUNC_VECTOR_GET_SUM;
		else if (wcscmp(text, L"GetMean")==0) return LEX_FUNC_VECTOR_GET_MEAN;
		else if (wcscmp(text, L"GetVariance")==0) return LEX_FUNC_VECTOR_GET_VARIANCE;
		else if (wcscmp(text, L"GetMin")==0) return LEX_FUNC_VECTOR_GET_MINIMUM;
		else if (wcscmp(text, L"GetMax")==0) return LEX_FUNC_VECTOR_GET_MAXIMUM;
		else if (wcscmp(text, L"GetMinPos")==0) return LEX_FUNC_VECTOR_GET_MIN_POS;
		else if (wcscmp(text, L"GetMaxPos")==0) return LEX_FUNC_VECTOR_GET_MAX_POS;
		else if (wcscmp(text, L"GetSquaredSum")==0) return LEX_FUNC_VECTOR_GET_SQUARED_SUM;
		else if (wcscmp(text, L"CreateLoPassIR")==0) return LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP;
		else if (wcscmp(text, L"CreateLoPassFR")==0) return LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP;
		else if (wcscmp(text, L"CreateHiPassIR")==0) return LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP;
		else if (wcscmp(text, L"CreateHiPassFR")==0) return LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP;
		else if (wcscmp(text, L"CreateKaiser")==0) return LEX_FUNC_VECTOR_CREATE_KAISER;
		else if (wcscmp(text, L"CreateRandomSet")==0) return LEX_FUNC_VECTOR_CREATE_RANDOM_SET;
		else if (wcscmp(text, L"Wrap")==0) return LEX_FUNC_VECTOR_WRAP;
		else if (wcscmp(text, L"LineFit")==0) return LEX_FUNC_VECTOR_LINE_FIT;
			//	return LEX_ERROR;
	//case LEX_DATATYPE_COMPLEX:
			//	return LEX_ERROR;
	//
			//	return LEX_ERROR;
	//case LEX_DATATYPE_COMPLEX_MATRIX:
			//	return LEX_ERROR;
	//case LEX_DATATYPE_SCALER:
	//	if (wcscmp(text, L"CreateInputScaler")==0) return LEX_FUNC_SCALER_CREATEINPUTSCALER;
	//	else if (wcscmp(text, L"CreateOutputScaler")==0) return LEX_FUNC_SCALER_CREATEOUTPUTSCALER;
	//	else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_SCALER_DELETE;
	//	else if (wcscmp(text, L"GetSize")==0) return LEX_FUNC_SCALER_GETSIZE;
	//	else if (wcscmp(text, L"Save")==0) return LEX_FUNC_SCALER_SAVE;
	//	else if (wcscmp(text, L"Load")==0) return LEX_FUNC_SCALER_LOAD;
	//	else if (wcscmp(text, L"Set")==0) return LEX_FUNC_SCALER_SET;
	//	else if (wcscmp(text, L"Scale")==0) return LEX_FUNC_SCALER_SCALE;
	//	else if (wcscmp(text, L"GetMinimum")==0) return LEX_FUNC_SCALER_GETMINIMUM;
	//	else if (wcscmp(text, L"GetMaximum")==0) return LEX_FUNC_SCALER_GETMAXIMUM;
	//	else if (wcscmp(text, L"AutoSetInputScaler")==0) return LEX_FUNC_SCALER_AUTOSETINPUTSCALER;
	//	else if (wcscmp(text, L"AutoSetOutputScaler")==0) return LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER;
	//	break;
	case LEX_DATATYPE_LAYERNET:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_LAYERNET_CREATE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_LAYERNET_LOAD;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_LAYERNET_SAVE;
		else if (wcscmp(text, L"SetWeights")==0) return LEX_FUNC_LAYERNET_SET_WEIGHTS;
		else if (wcscmp(text, L"GetWeights")==0) return LEX_FUNC_LAYERNET_GET_WEIGHTS;
		else if (wcscmp(text, L"GetInputCount")==0) return LEX_FUNC_LAYERNET_GET_INPUT_COUNT;
		else if (wcscmp(text, L"GetOutputCount")==0) return LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT;
		else if (wcscmp(text, L"GetHid1NeCount")==0) return LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT;
		else if (wcscmp(text, L"GetHid2NeCount")==0) return LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT;
		else if (wcscmp(text, L"GetLayerCount")==0) return LEX_FUNC_LAYERNET_GET_LAYER_COUNT;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_LAYERNET_DELETE;
		else if (wcscmp(text, L"Unlearn")==0) return LEX_FUNC_LAYERNET_UNLEARN;
		else if (wcscmp(text, L"AutoSetInScaler")==0) return LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER;
		else if (wcscmp(text, L"AutoSetOutScaler")==0) return LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER;
		else if (wcscmp(text, L"SetInScaler")==0) return LEX_FUNC_LAYERNET_SET_INPUT_SCALER;
		else if (wcscmp(text, L"SetOutScaler")==0) return LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER;
		else if (wcscmp(text, L"GetInScaler")==0) return LEX_FUNC_LAYERNET_GET_INPUT_SCALER;
		else if (wcscmp(text, L"GetOutScaler")==0) return LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER;
		else if (wcscmp(text, L"SetTrainSet")==0) return LEX_FUNC_LAYERNET_SET_TRAINING_SET;
		else if (wcscmp(text, L"TrainGenetic")==0) return LEX_FUNC_LAYERNET_TRAIN_GENETIC;
		else if (wcscmp(text, L"TrainSimAnneal")==0) return LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING;
		else if (wcscmp(text, L"TrainConjGrad")==0) return LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT;
		else if (wcscmp(text, L"TrainVarMetric")==0) return LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC;
		else if (wcscmp(text, L"TrainLevenMar")==0) return LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT;
		else if (wcscmp(text, L"TrainRegression")==0) return LEX_FUNC_LAYERNET_TRAIN_REGRESSION;
		else if (wcscmp(text, L"GetMinNoTrCs")==0) return LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES;
		else if (wcscmp(text, L"Run")==0) return LEX_FUNC_LAYERNET_RUN;
		break;
	case LEX_DATATYPE_LAYERNETC:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_LAYERNETC_CREATE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_LAYERNETC_LOAD;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_LAYERNETC_SAVE;
		else if (wcscmp(text, L"SetWeights")==0) return LEX_FUNC_LAYERNETC_SET_WEIGHTS;
		else if (wcscmp(text, L"GetWeights")==0) return LEX_FUNC_LAYERNETC_GET_WEIGHTS;
		else if (wcscmp(text, L"GetInputCount")==0) return LEX_FUNC_LAYERNETC_GET_INPUT_COUNT;
		else if (wcscmp(text, L"GetOutputCount")==0) return LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT;
		else if (wcscmp(text, L"GetHid1NeCount")==0) return LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_LAYERNETC_DELETE;
		else if (wcscmp(text, L"Unlearn")==0) return LEX_FUNC_LAYERNETC_UNLEARN;
		else if (wcscmp(text, L"AutoSetInScaler")==0) return LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER;
		else if (wcscmp(text, L"AutoSetOutScaler")==0) return LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER;
		else if (wcscmp(text, L"SetInScaler")==0) return LEX_FUNC_LAYERNETC_SET_INPUT_SCALER;
		else if (wcscmp(text, L"SetOutScaler")==0) return LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER;
		else if (wcscmp(text, L"GetInScaler")==0) return LEX_FUNC_LAYERNETC_GET_INPUT_SCALER;
		else if (wcscmp(text, L"GetOutScaler")==0) return LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER;
		else if (wcscmp(text, L"SetTrainSet")==0) return LEX_FUNC_LAYERNETC_SET_TRAINING_SET;
		else if (wcscmp(text, L"TrainGenetic")==0) return LEX_FUNC_LAYERNETC_TRAIN_GENETIC;
		else if (wcscmp(text, L"TrainSimAnneal")==0) return LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING;
		else if (wcscmp(text, L"TrainConjGrad")==0) return LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT;
		else if (wcscmp(text, L"TrainVarMetric")==0) return LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC;
		else if (wcscmp(text, L"GetMinNoTrCs")==0) return LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES;
		else if (wcscmp(text, L"Run")==0) return LEX_FUNC_LAYERNETC_RUN;
		break;
	case LEX_DATATYPE_KOHONET:
		if (wcscmp(text, L"Create")==0) return LEX_FUNC_KOHONET_CREATE;
		else if (wcscmp(text, L"Load")==0) return LEX_FUNC_KOHONET_LOAD;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_KOHONET_SAVE;		
		else if (wcscmp(text, L"SetWeights")==0) return LEX_FUNC_KOHONET_SET_WEIGHTS;
		else if (wcscmp(text, L"GetWeights")==0) return LEX_FUNC_KOHONET_GET_WEIGHTS;
		else if (wcscmp(text, L"GetInputCount")==0) return LEX_FUNC_KOHONET_GET_INPUT_COUNT;
		else if (wcscmp(text, L"GetOutputCount")==0) return LEX_FUNC_KOHONET_GET_OUTPUT_COUNT;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_KOHONET_DELETE;
		else if (wcscmp(text, L"Unlearn")==0) return LEX_FUNC_KOHONET_UNLEARN;
		else if (wcscmp(text, L"AutoSetInScaler")==0) return LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER;
		else if (wcscmp(text, L"SetInScaler")==0) return LEX_FUNC_KOHONET_SET_INPUT_SCALER;
		else if (wcscmp(text, L"GetInScaler")==0) return LEX_FUNC_KOHONET_GET_INPUT_SCALER;
		else if (wcscmp(text, L"SetTrainingSet")==0) return LEX_FUNC_KOHONET_SET_TRAINING_SET;
		else if (wcscmp(text, L"TrainAdditive")==0) return LEX_FUNC_KOHONET_TRAIN_ADDITIVE;
		else if (wcscmp(text, L"TrainSubtractive")==0) return LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE;
		else if (wcscmp(text, L"ComputeWinner")==0) return LEX_FUNC_KOHONET_COMPUTE_WINNER;
		else if (wcscmp(text, L"Run")==0) return LEX_FUNC_KOHONET_RUN;
		break;
	case LEX_DATATYPE_PROBNET:
		if (wcscmp(text, L"Load")==0) return LEX_FUNC_PROBNET_LOAD;
		else if (wcscmp(text, L"Save")==0) return LEX_FUNC_PROBNET_SAVE;
		else if (wcscmp(text, L"TrainConjGrad")==0) return LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT;
		else if (wcscmp(text, L"TrainVarMetric")==0) return LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC;
		else if (wcscmp(text, L"SetWeights")==0) return LEX_FUNC_PROBNET_SET_WEIGHTS;
		else if (wcscmp(text, L"GetWeights")==0) return LEX_FUNC_PROBNET_GET_WEIGHTS;
		else if (wcscmp(text, L"GetInputCount")==0) return LEX_FUNC_PROBNET_GET_INPUT_COUNT;
		else if (wcscmp(text, L"GetOutputCount")==0) return LEX_FUNC_PROBNET_GET_OUTPUT_COUNT;
		else if (wcscmp(text, L"Delete")==0) return LEX_FUNC_PROBNET_DELETE;
		else if (wcscmp(text, L"Run")==0) return LEX_FUNC_PROBNET_RUN;
		break;
	}
	return ERROR_INVALID_VALUE;
}

int Compiler::GetObjectFuncReturnType(int datatype, int func_id)
{
	switch(func_id)
	{
	case LEX_FUNC_SIN: return datatype;
	case LEX_FUNC_COS: return datatype;
	case LEX_FUNC_TAN: return datatype;
	case LEX_FUNC_ASIN: return datatype;
	case LEX_FUNC_ACOS: return datatype;
	case LEX_FUNC_ATAN: return datatype;
	case LEX_FUNC_SINH: return datatype;
	case LEX_FUNC_COSH: return datatype;
	case LEX_FUNC_TANH: return datatype;
	case LEX_FUNC_SQRT: return datatype;
	case LEX_FUNC_LOG10: return datatype;
	case LEX_FUNC_LOG: return datatype;
	case LEX_FUNC_EXP: return datatype;
	case LEX_FUNC_POW: return datatype;
	case LEX_FUNC_ABS: return datatype;
	case LEX_FUNC_SINC: return datatype;
	case LEX_FUNC_TRIANG: return datatype;
	case LEX_FUNC_SAW: return datatype;
	case LEX_FUNC_RECT: return datatype;
	case LEX_FUNC_CEIL: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_FLOOR: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TOINT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_FFT:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_FFTNORM:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_IFFT:
		if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		//if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_COMPLEX_VECTOR;
		//if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_COMPLEX_MATRIX;
		return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_REALFFT:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_REALFFTNORM:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_IREALFFT:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_SPECTRUM:
		if (datatype == LEX_DATATYPE_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		if (datatype == LEX_DATATYPE_COMPLEX_VECTOR) return LEX_DATATYPE_VECTOR;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_CONVOLUTION: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_SHORT_CONVOLUTION: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_COMPUTE_MSE: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_MAKE_COMPLEX: return LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_CONFUSION_MATRIX:
		if (datatype == LEX_DATATYPE_MATRIX) return LEX_DATATYPE_MATRIX;
		if (datatype == LEX_DATATYPE_COMPLEX_MATRIX) return LEX_DATATYPE_MATRIX;
		return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_COVARIANCE_MATRIX: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_CORRELATION_MATRIX: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_EIGENSYSTEM: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_RAND: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_RANDI: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_ISPRIME: return LEX_DATATYPE_BOOL;
	//
	case LEX_FUNC_MATRIX_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_CREATE_RANDOM: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_APPEND_RIGHT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_APPEND_DOWN: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE_ROW: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE_COL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_INSERT_ROW: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_INSERT_COL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_MATRIX_GET_SUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_MEAN: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case  LEX_FUNC_MATRIX_GET_MIN_POS: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_GET_MAX_POS: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_MATRIX_GET_ROWS: return datatype;
	case LEX_FUNC_MATRIX_GET_COLS: return datatype;
	case LEX_FUNC_MATRIX_DELETE_ROWS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_DELETE_COLS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_MATRIX_GET_CLASS: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_TRANSPOSE: return datatype;
	case LEX_FUNC_MATRIX_PREDICTION: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_NORM_ROWS: return LEX_DATATYPE_VOID;
	case LEX_FUNC_MATRIX_NORM_COLS: return LEX_DATATYPE_VOID;
	case LEX_FUNC_MATRIX_ROWS_VAR: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_COLS_VAR: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_ROWS_MEAN: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_COLS_MEAN: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_ROWS_MIN: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_COLS_MIN: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_ROWS_MAX: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_COLS_MAX: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_MATRIX_GET_ROW: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_VECTOR : LEX_DATATYPE_COMPLEX_VECTOR;
	case LEX_FUNC_MATRIX_GET_COL: return datatype == LEX_DATATYPE_MATRIX ? LEX_DATATYPE_VECTOR : LEX_DATATYPE_COMPLEX_VECTOR;
	//________________________________________________________________________________
	case LEX_FUNC_VECTOR_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_SERIES: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_RANDOM: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_BINARY: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_VECTOR_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_INSERT_CELL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_DELETE_CELL: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_VECTOR_GET_SIZE: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_VECTOR_GET_SUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_MEAN: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_GET_MIN_POS: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_VECTOR_GET_MAX_POS: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_DOUBLE : LEX_DATATYPE_COMPLEX;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_KAISER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_VECTOR_WRAP: return datatype == LEX_DATATYPE_VECTOR ? LEX_DATATYPE_MATRIX : LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_VECTOR_LINE_FIT: return datatype;
	//
	case LEX_FUNC_LAYERNET_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_LAYERNET_UNLEARN: return LEX_DATATYPE_VOID;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNET_RUN: return LEX_DATATYPE_MATRIX;
	//
	case LEX_FUNC_LAYERNETC_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_SET_WEIGHTS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_GET_WEIGHTS: return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_LAYERNETC_GET_INPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNETC_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_LAYERNETC_UNLEARN: return LEX_DATATYPE_VOID;
	case LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_GET_INPUT_SCALER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_LAYERNETC_SET_TRAINING_SET: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_TRAIN_GENETIC: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_LAYERNETC_RUN: return LEX_DATATYPE_COMPLEX_MATRIX;
	//
	case LEX_FUNC_KOHONET_CREATE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_SET_WEIGHTS: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_GET_WEIGHTS: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_KOHONET_GET_INPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_KOHONET_GET_OUTPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_KOHONET_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_KOHONET_UNLEARN: return LEX_DATATYPE_VOID;
	case LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_SET_INPUT_SCALER: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_GET_INPUT_SCALER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_KOHONET_SET_TRAINING_SET: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_TRAIN_ADDITIVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_KOHONET_COMPUTE_WINNER: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_KOHONET_RUN: return LEX_DATATYPE_MATRIX;
	//
	case LEX_FUNC_PROBNET_LOAD: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_PROBNET_SAVE: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC: return LEX_DATATYPE_BOOL;
	case LEX_FUNC_PROBNET_SET_WEIGHTS: return LEX_DATATYPE_VOID;
	case LEX_FUNC_PROBNET_GET_WEIGHTS: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_PROBNET_GET_INPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_PROBNET_GET_OUTPUT_COUNT: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_PROBNET_DELETE: return LEX_DATATYPE_VOID;
	case LEX_FUNC_PROBNET_RUN: return LEX_DATATYPE_MATRIX;
	}
	return ERROR_INVALID_VALUE;
}

int Compiler::GetFuncParamCount(int func_id)
{
	switch(func_id)
	{
	case LEX_FUNC_SIN: return 1;
	case LEX_FUNC_COS: return 1;
	case LEX_FUNC_TAN: return 1;
	case LEX_FUNC_ASIN: return 1;
	case LEX_FUNC_ACOS: return 1;
	case LEX_FUNC_ATAN: return 1;
	case LEX_FUNC_SINH: return 1;
	case LEX_FUNC_COSH: return 1;
	case LEX_FUNC_TANH: return 1;
	case LEX_FUNC_SQRT: return 1;
	case LEX_FUNC_LOG10: return 1;
	case LEX_FUNC_LOG: return 1;
	case LEX_FUNC_EXP: return 1;
	case LEX_FUNC_POW: return 2;
	case LEX_FUNC_ABS: return 1;
	case LEX_FUNC_SINC: return 1;
	case LEX_FUNC_TRIANG: return 1;
	case LEX_FUNC_SAW: return 1;
	case LEX_FUNC_RECT: return 1;
	case LEX_FUNC_CEIL: return 1;
	case LEX_FUNC_FLOOR: return 1;
	case LEX_FUNC_TOINT: return 1;
	case LEX_FUNC_FFT: return 1;
	case LEX_FUNC_FFTNORM: return 1;
	case LEX_FUNC_IFFT: return 1;
	case LEX_FUNC_REALFFT: return 1;
	case LEX_FUNC_REALFFTNORM: return 1;
	case LEX_FUNC_IREALFFT: return 1;
	case LEX_FUNC_SPECTRUM: return 1;
	case LEX_FUNC_CONVOLUTION: return 2;
	case LEX_FUNC_SHORT_CONVOLUTION: return 2;
	case LEX_FUNC_COMPUTE_MSE: return 2;
	case LEX_FUNC_MAKE_COMPLEX: return 2;
	case LEX_FUNC_CONFUSION_MATRIX: return 3;
	case LEX_FUNC_COVARIANCE_MATRIX: return 1;
	case LEX_FUNC_CORRELATION_MATRIX: return 1;
	case LEX_FUNC_EIGENSYSTEM: return 1;
	case LEX_FUNC_RAND: return 1;	
	//case LEX_FUNC_INT_BIT: return 1;
	case LEX_FUNC_RANDI: return 1;
	case LEX_FUNC_ISPRIME: return 1;
	//case LEX_FUNC_BESSELJ0: return 1;
	//case LEX_FUNC_BESSELJ1: return 1;
	//case LEX_FUNC_BESSELY0: return 1;
	//case LEX_FUNC_BESSELY1: return 1;
	//
	case LEX_FUNC_MATRIX_CREATE: return 2;
	case LEX_FUNC_MATRIX_CREATE_RANDOM: return 4;
	case LEX_FUNC_MATRIX_SAVE: return 0;
	case LEX_FUNC_MATRIX_LOAD: return 0;
	case LEX_FUNC_MATRIX_APPEND_RIGHT: return 1;
	case LEX_FUNC_MATRIX_APPEND_DOWN: return 1;
	case LEX_FUNC_MATRIX_DELETE_ROW: return 1;
	case LEX_FUNC_MATRIX_DELETE_COL: return 1;
	case LEX_FUNC_MATRIX_INSERT_ROW: return 1;
	case LEX_FUNC_MATRIX_INSERT_COL: return 1;
	case LEX_FUNC_MATRIX_DELETE: return 0;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return 0;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return 0;
	case LEX_FUNC_MATRIX_GET_SUM: return 0;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return 0;
	case LEX_FUNC_MATRIX_GET_MEAN: return 0;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return 0;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return 0;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return 0;
	case LEX_FUNC_MATRIX_GET_MIN_POS: return 0;
	case LEX_FUNC_MATRIX_GET_MAX_POS: return 0;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return 0;
	case LEX_FUNC_MATRIX_GET_ROWS: return 1;
	case LEX_FUNC_MATRIX_GET_COLS: return 1;
	case LEX_FUNC_MATRIX_DELETE_ROWS: return 1;
	case LEX_FUNC_MATRIX_DELETE_COLS: return 1;
	case LEX_FUNC_MATRIX_GET_CLASS: return 0;
	case LEX_FUNC_MATRIX_TRANSPOSE: return 0;
	case LEX_FUNC_MATRIX_PREDICTION: return 1;
	case LEX_FUNC_MATRIX_NORM_ROWS: return 0;
	case LEX_FUNC_MATRIX_NORM_COLS: return 0;
	case LEX_FUNC_MATRIX_ROWS_VAR: return 0;
	case LEX_FUNC_MATRIX_COLS_VAR: return 0;
	case LEX_FUNC_MATRIX_ROWS_MEAN: return 0;
	case LEX_FUNC_MATRIX_COLS_MEAN: return 0;
	case LEX_FUNC_MATRIX_ROWS_MIN: return 0;
	case LEX_FUNC_MATRIX_COLS_MIN: return 0;
	case LEX_FUNC_MATRIX_ROWS_MAX: return 0;
	case LEX_FUNC_MATRIX_COLS_MAX: return 0;
	case LEX_FUNC_MATRIX_GET_ROW: return 1;
	case LEX_FUNC_MATRIX_GET_COL: return 1;
	//
	case LEX_FUNC_VECTOR_CREATE: return 1;
	case LEX_FUNC_VECTOR_CREATE_SERIES: return 3;
	case LEX_FUNC_VECTOR_CREATE_RANDOM: return 3;
	case LEX_FUNC_VECTOR_CREATE_BINARY: return 2;
	case LEX_FUNC_VECTOR_SAVE: return 0;
	case LEX_FUNC_VECTOR_LOAD: return 0;
	case LEX_FUNC_VECTOR_INSERT_CELL: return 2;
	case LEX_FUNC_VECTOR_DELETE_CELL: return 1;
	case LEX_FUNC_VECTOR_DELETE: return 0;
	case LEX_FUNC_VECTOR_GET_SIZE: return 0;
	case LEX_FUNC_VECTOR_GET_SUM: return 0;
	case LEX_FUNC_VECTOR_GET_MEAN: return 0;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return 0;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return 0;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return 0;		
	case LEX_FUNC_VECTOR_GET_MIN_POS: return 0;	
	case LEX_FUNC_VECTOR_GET_MAX_POS: return 0;	
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return 0;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return 3;
	case LEX_FUNC_VECTOR_CREATE_KAISER: return 2;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return 2;
	case LEX_FUNC_VECTOR_WRAP: return 1;
	case LEX_FUNC_VECTOR_LINE_FIT: return 0;
	//
	case LEX_FUNC_LAYERNET_CREATE: return 4;
	case LEX_FUNC_LAYERNET_LOAD: return 0;
	case LEX_FUNC_LAYERNET_SAVE: return 0;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS: return 2;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS: return 1;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return 0;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return 0;
	case LEX_FUNC_LAYERNET_DELETE: return 0;
	case LEX_FUNC_LAYERNET_UNLEARN: return 0;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return 3;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return 3;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return 3;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return 6;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return 7;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return 2;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return 2;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return 2;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return 0;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return 0;
	case LEX_FUNC_LAYERNET_RUN: return 1;
		//
	case LEX_FUNC_LAYERNETC_CREATE: return 3;
	case LEX_FUNC_LAYERNETC_LOAD: return 0;
	case LEX_FUNC_LAYERNETC_SAVE: return 0;
	case LEX_FUNC_LAYERNETC_SET_WEIGHTS: return 2;
	case LEX_FUNC_LAYERNETC_GET_WEIGHTS: return 1;
	case LEX_FUNC_LAYERNETC_GET_INPUT_COUNT: return 0;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT: return 0;
	case LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT: return 0;
	case LEX_FUNC_LAYERNETC_DELETE: return 0;
	case LEX_FUNC_LAYERNETC_UNLEARN: return 0;
	case LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNETC_SET_INPUT_SCALER: return 3;
	case LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER: return 3;
	case LEX_FUNC_LAYERNETC_GET_INPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER: return 1;
	case LEX_FUNC_LAYERNETC_SET_TRAINING_SET: return 3;
	case LEX_FUNC_LAYERNETC_TRAIN_GENETIC: return 6;
	case LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING: return 7;
	case LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT: return 2;
	case LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC: return 2;
	case LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES: return 0;
	case LEX_FUNC_LAYERNETC_RUN: return 1;
	//
	case LEX_FUNC_KOHONET_CREATE: return 3;
	case LEX_FUNC_KOHONET_LOAD: return 0;
	case LEX_FUNC_KOHONET_SAVE: return 0;
	case LEX_FUNC_KOHONET_SET_WEIGHTS: return 1;
	case LEX_FUNC_KOHONET_GET_WEIGHTS: return 0;
	case LEX_FUNC_KOHONET_GET_INPUT_COUNT: return 0;
	case LEX_FUNC_KOHONET_GET_OUTPUT_COUNT: return 0;
	case LEX_FUNC_KOHONET_DELETE: return 0;
	case LEX_FUNC_KOHONET_UNLEARN: return 0;
	case LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER: return 1;
	case LEX_FUNC_KOHONET_SET_INPUT_SCALER: return 3;
	case LEX_FUNC_KOHONET_GET_INPUT_SCALER: return 1;
	case LEX_FUNC_KOHONET_SET_TRAINING_SET: return 2;
	case LEX_FUNC_KOHONET_TRAIN_ADDITIVE: return 2;
	case LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE: return 2;
	case LEX_FUNC_KOHONET_COMPUTE_WINNER: return 1;
	case LEX_FUNC_KOHONET_RUN: return 1;
	//
	case LEX_FUNC_PROBNET_LOAD: return 0;
	case LEX_FUNC_PROBNET_SAVE: return 0;
	case LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT: return 4;
	case LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC: return 4;
	case LEX_FUNC_PROBNET_SET_WEIGHTS: return 1;
	case LEX_FUNC_PROBNET_GET_WEIGHTS: return 0;
	case LEX_FUNC_PROBNET_GET_INPUT_COUNT: return 0;
	case LEX_FUNC_PROBNET_GET_OUTPUT_COUNT: return 0;
	case LEX_FUNC_PROBNET_DELETE: return 0;
	case LEX_FUNC_PROBNET_RUN: return 3;
	}
	return -1;
}

int Compiler::GetObjectFuncParamType(int func_id, int paramIndex)
{
	switch(func_id)
	{
	//_____________________________________________ General Functions
	case LEX_FUNC_SIN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_COS: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TAN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ASIN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ACOS: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ATAN: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SINH: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_COSH: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TANH: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SQRT: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_LOG10: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_LOG: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_EXP: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_POW: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_ABS: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SINC: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TRIANG: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_SAW: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_RECT: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_CEIL: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_FLOOR: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_TOINT: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_FFT: return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_FFTNORM: return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_IFFT: return LEX_DATATYPE_COMPLEX_MATRIX;
	case LEX_FUNC_REALFFT: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_REALFFTNORM: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_IREALFFT: return LEX_DATATYPE_MATRIX;
	case LEX_FUNC_SPECTRUM: return LEX_DATATYPE_VECTOR;
	case LEX_FUNC_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		case 1: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_SHORT_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		case 1: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_COMPUTE_MSE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_MAKE_COMPLEX:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_CONFUSION_MATRIX:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_COVARIANCE_MATRIX: 
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_CORRELATION_MATRIX:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_EIGENSYSTEM:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_RAND: return LEX_DATATYPE_DOUBLE;
	case LEX_FUNC_RANDI: return LEX_DATATYPE_INTEGER;
	case LEX_FUNC_ISPRIME: return LEX_DATATYPE_INTEGER;
	//_____________________________________________ Matrix
	case LEX_FUNC_MATRIX_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_MATRIX_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_APPEND_RIGHT:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_MATRIX_APPEND_DOWN:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_ROW:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_COL:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_ROW:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_COL:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MEAN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MIN_POS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_MAX_POS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_ROWS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_GET_COLS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_ROWS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_COLS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_MATRIX_GET_CLASS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_TRANSPOSE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_PREDICTION:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_NORM_ROWS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_NORM_COLS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_ROWS_VAR: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_COLS_VAR: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_ROWS_MEAN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_COLS_MEAN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_ROWS_MIN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_COLS_MIN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_ROWS_MAX: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_COLS_MAX: return ERROR_INVALID_VALUE;
	case LEX_FUNC_MATRIX_GET_ROW:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_MATRIX_GET_COL:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	//___________________________________________________ Vector
	case LEX_FUNC_VECTOR_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_SERIES:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_BINARY:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_INSERT_CELL :
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_DELETE_CELL :
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_SIZE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MEAN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MIN_POS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_MAX_POS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return ERROR_INVALID_VALUE;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_KAISER:
		switch(paramIndex)
		{
		case 1: return LEX_DATATYPE_DOUBLE;
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_WRAP:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_VECTOR_LINE_FIT: return ERROR_INVALID_VALUE;

	//______________________________________________ LayerNet
	case LEX_FUNC_LAYERNET_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_INTEGER;
		case 3: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_UNLEARN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		case 2: return LEX_DATATYPE_BOOL;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		case 4: return LEX_DATATYPE_DOUBLE;
		case 5: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		case 4: return LEX_DATATYPE_BOOL;
		case 5: return LEX_DATATYPE_INTEGER;
		case 6: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNET_RUN:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	//______________________________________________ LayerNetC
	case LEX_FUNC_LAYERNETC_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNETC_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_COMPLEX_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_INPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_UNLEARN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_COMPLEX_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_COMPLEX_MATRIX;
		}
		break;
	case LEX_FUNC_LAYERNETC_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_LAYERNETC_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_COMPLEX_MATRIX;
		case 1: return LEX_DATATYPE_COMPLEX_MATRIX;
		case 2: return LEX_DATATYPE_BOOL;
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_GENETIC:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		case 4: return LEX_DATATYPE_DOUBLE;
		case 5: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_DOUBLE;
		case 3: return LEX_DATATYPE_DOUBLE;
		case 4: return LEX_DATATYPE_BOOL;
		case 5: return LEX_DATATYPE_INTEGER;
		case 6: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES: return ERROR_INVALID_VALUE;
	case LEX_FUNC_LAYERNETC_RUN:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_COMPLEX_MATRIX;
		}
		break;
	//______________________________________________ KohoNet
	case LEX_FUNC_KOHONET_CREATE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_INTEGER;
		case 2: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_KOHONET_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_KOHONET_GET_WEIGHTS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_GET_INPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_GET_OUTPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_UNLEARN: return ERROR_INVALID_VALUE;
	case LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_KOHONET_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_INTEGER;
		case 1: return LEX_DATATYPE_DOUBLE;
		case 2: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_KOHONET_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_KOHONET_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_BOOL;
		}
		break;
	case LEX_FUNC_KOHONET_TRAIN_ADDITIVE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_DOUBLE;
		case 1: return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_FUNC_KOHONET_COMPUTE_WINNER:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_FUNC_KOHONET_RUN:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		}
		break;
	//______________________________________________ ProbNet
	case LEX_FUNC_PROBNET_LOAD: return ERROR_INVALID_VALUE;
	case LEX_FUNC_PROBNET_SAVE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT:
	case LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		case 2: return LEX_DATATYPE_INTEGER;
		case 3: return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_FUNC_PROBNET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_FUNC_PROBNET_GET_WEIGHTS: return ERROR_INVALID_VALUE;
	case LEX_FUNC_PROBNET_GET_INPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_PROBNET_GET_OUTPUT_COUNT: return ERROR_INVALID_VALUE;
	case LEX_FUNC_PROBNET_DELETE: return ERROR_INVALID_VALUE;
	case LEX_FUNC_PROBNET_RUN:
		switch(paramIndex)
		{
		case 0: return LEX_DATATYPE_MATRIX;
		case 1: return LEX_DATATYPE_MATRIX;
		case 2: return LEX_DATATYPE_MATRIX;
		}
		break;
	}
	return ERROR_INVALID_VALUE;
}

wchar_t* Compiler::GetObjectFuncParamName(int func_id, int paramIndex)
{
	switch(func_id)
	{
	//_____________________________________________ General Functions
	case LEX_FUNC_SIN: return L"x";
	case LEX_FUNC_COS: return L"x";
	case LEX_FUNC_TAN: return L"x";
	case LEX_FUNC_ASIN: return L"x";
	case LEX_FUNC_ACOS: return L"x";
	case LEX_FUNC_ATAN: return L"x";
	case LEX_FUNC_SINH: return L"x";
	case LEX_FUNC_COSH: return L"x";
	case LEX_FUNC_TANH: return L"x";
	case LEX_FUNC_SQRT: return L"x";
	case LEX_FUNC_LOG10: return L"x";
	case LEX_FUNC_LOG: return L"x";
	case LEX_FUNC_EXP: return L"x";
	case LEX_FUNC_POW: 
		if (paramIndex == 0) return L"x";
		return L"y";
		break;
	case LEX_FUNC_ABS: return L"x";
	case LEX_FUNC_SINC: return L"x";
	case LEX_FUNC_TRIANG: return L"x";
	case LEX_FUNC_SAW: return L"x";
	case LEX_FUNC_RECT: return L"x";
	case LEX_FUNC_CEIL: return L"x";
	case LEX_FUNC_FLOOR: return L"x";
	case LEX_FUNC_TOINT: return L"x";
	case LEX_FUNC_FFT: return L"x";
	case LEX_FUNC_FFTNORM: return L"x";
	case LEX_FUNC_IFFT: return L"x";
	case LEX_FUNC_REALFFT: return L"x";
	case LEX_FUNC_REALFFTNORM: return L"x";
	case LEX_FUNC_IREALFFT: return L"x";
	case LEX_FUNC_SPECTRUM: return L"x";
	case LEX_FUNC_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return L"x";
		case 1: return L"y";
		}
		break;
	case LEX_FUNC_SHORT_CONVOLUTION:
		switch(paramIndex)
		{
		case 0: return L"input";
		case 1: return L"impulseResponse";
		}
		break;
	case LEX_FUNC_COMPUTE_MSE:
		switch(paramIndex)
		{
		case 0: return L"output";
		case 1: return L"target";
		}
		break;
	case LEX_FUNC_MAKE_COMPLEX:
		switch(paramIndex)
		{
		case 0: return L"real";
		case 1: return L"imag";
		}
		break;
	case LEX_FUNC_CONFUSION_MATRIX:
		switch(paramIndex)
		{
		case 0: return L"output";
		case 1: return L"target";
		case 2: return L"threshold";
		}
		break;
	case LEX_FUNC_COVARIANCE_MATRIX:
		switch(paramIndex)
		{
		case 0: return L"x";
		}
		break;
	case LEX_FUNC_CORRELATION_MATRIX:
		switch(paramIndex)
		{
		case 0: return L"x";
		}
		break;
	case LEX_FUNC_EIGENSYSTEM:
		switch(paramIndex)
		{
		case 0: return L"x";
		}
		break;
	case LEX_FUNC_RAND: return L"x";
	case LEX_FUNC_RANDI: return L"x";
	case LEX_FUNC_ISPRIME: return L"x";
	//_____________________________________________ Matrix
	case LEX_FUNC_MATRIX_CREATE:
		switch(paramIndex)
		{
		case 0: return L"rowCount";
		case 1: return L"colCount";
		}
		break;
	case LEX_FUNC_MATRIX_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return L"rowCount";
		case 1: return L"colCount";
		case 2: return L"minValue";
		case 3: return L"maxValue";
		}
		break;
	case LEX_FUNC_MATRIX_SAVE: return NULL;
	case LEX_FUNC_MATRIX_LOAD: return NULL;
	case LEX_FUNC_MATRIX_APPEND_RIGHT:
		switch(paramIndex)
		{
		case 0: return L"x";
		}
		break;
	case LEX_FUNC_MATRIX_APPEND_DOWN:
		switch(paramIndex)
		{
		case 0: return L"x";
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_ROW:
		switch(paramIndex)
		{
		case 0: return L"rowIndex";
		}
		break;
	case LEX_FUNC_MATRIX_DELETE_COL:
		switch(paramIndex)
		{
		case 0: return L"colIndex";
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_ROW:
		switch(paramIndex)
		{
		case 0: return L"rowIndex";
		}
		break;
	case LEX_FUNC_MATRIX_INSERT_COL:
		switch(paramIndex)
		{
		case 0: return L"colIndex";
		}
		break;
	case LEX_FUNC_MATRIX_DELETE: return NULL;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT: return NULL;
	case LEX_FUNC_MATRIX_GET_COL_COUNT: return NULL;
	case LEX_FUNC_MATRIX_GET_SUM: return NULL;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return NULL;
	case LEX_FUNC_MATRIX_GET_MEAN: return NULL;
	case LEX_FUNC_MATRIX_GET_VARIANCE: return NULL;
	case LEX_FUNC_MATRIX_GET_MINIMUM: return NULL;
	case LEX_FUNC_MATRIX_GET_MAXIMUM: return NULL;
	case LEX_FUNC_MATRIX_GET_MIN_POS: return NULL;
	case LEX_FUNC_MATRIX_GET_MAX_POS: return NULL;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return NULL;
	case LEX_FUNC_MATRIX_GET_ROWS: return L"indexes";
	case LEX_FUNC_MATRIX_GET_COLS: return L"indexes";
	case LEX_FUNC_MATRIX_DELETE_ROWS: return L"indexes";
	case LEX_FUNC_MATRIX_DELETE_COLS: return L"indexes";
	case LEX_FUNC_MATRIX_GET_CLASS: return NULL;
	case LEX_FUNC_MATRIX_TRANSPOSE: return NULL;
	case LEX_FUNC_MATRIX_PREDICTION: return L"seriesLength";
	case LEX_FUNC_MATRIX_NORM_ROWS: return NULL;
	case LEX_FUNC_MATRIX_NORM_COLS: return NULL;
	case LEX_FUNC_MATRIX_ROWS_VAR: return NULL;
	case LEX_FUNC_MATRIX_COLS_VAR: return NULL;
	case LEX_FUNC_MATRIX_ROWS_MEAN: return NULL;
	case LEX_FUNC_MATRIX_COLS_MEAN: return NULL;
	case LEX_FUNC_MATRIX_ROWS_MIN: return NULL;
	case LEX_FUNC_MATRIX_COLS_MIN: return NULL;
	case LEX_FUNC_MATRIX_ROWS_MAX: return NULL;
	case LEX_FUNC_MATRIX_COLS_MAX: return NULL;
	case LEX_FUNC_MATRIX_GET_ROW: return L"rowIndex";
	case LEX_FUNC_MATRIX_GET_COL: return L"colIndex";
	//___________________________________________________ Vector
	case LEX_FUNC_VECTOR_CREATE:
		switch(paramIndex)
		{
		case 0: return L"size";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_SERIES:
		switch(paramIndex)
		{
		case 0: return L"firstValue";
		case 1: return L"lastValue";
		case 2: return L"size";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM:
		switch(paramIndex)
		{
		case 0: return L"length";
		case 1: return L"minValue";
		case 2: return L"maxValue";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_BINARY:
		switch(paramIndex)
		{
		case 0: return L"bitCount";
		case 1: return L"decimalValue";
		}
		break;
	case LEX_FUNC_VECTOR_SAVE: return NULL;
	case LEX_FUNC_VECTOR_LOAD: return NULL;
	case LEX_FUNC_VECTOR_INSERT_CELL:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"value";
		}
		break;
	case LEX_FUNC_VECTOR_DELETE_CELL:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_VECTOR_DELETE: return NULL;
	case LEX_FUNC_VECTOR_GET_SIZE: return NULL;
	case LEX_FUNC_VECTOR_GET_SUM: return NULL;
	case LEX_FUNC_VECTOR_GET_MEAN: return NULL;
	case LEX_FUNC_VECTOR_GET_VARIANCE: return NULL;
	case LEX_FUNC_VECTOR_GET_MINIMUM: return NULL;
	case LEX_FUNC_VECTOR_GET_MAXIMUM: return NULL;
	case LEX_FUNC_VECTOR_GET_MIN_POS: return NULL;
	case LEX_FUNC_VECTOR_GET_MAX_POS: return NULL;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return NULL;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		case 2: return L"radCutFreq";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_KAISER:
		switch(paramIndex)
		{
		case 0: return L"beta";
		case 1: return L"length";
		}
		break;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET:
		switch(paramIndex)
		{
		case 0: return L"length";
		case 1: return L"maxValue";
		}
		break;
	case LEX_FUNC_VECTOR_WRAP:
		switch(paramIndex)
		{
		case 0: return L"colCount";
		}
		break;
	case LEX_FUNC_VECTOR_LINE_FIT: return NULL;

	//______________________________________________ LayerNet
	case LEX_FUNC_LAYERNET_CREATE:
		switch(paramIndex)
		{
		case 0: return L"inputCount";
		case 1: return L"hidden1Count";
		case 2: return L"hidden2Count";
		case 3: return L"outputCount";
		}
		break;
	case LEX_FUNC_LAYERNET_LOAD: return NULL;
	case LEX_FUNC_LAYERNET_SAVE: return NULL;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"layerIndex";
		case 1: return L"layerWeights";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"layerIndex";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return NULL;
	case LEX_FUNC_LAYERNET_DELETE: return NULL;
	case LEX_FUNC_LAYERNET_UNLEARN: return NULL;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"output";
		}
		break;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"minimum";
		case 2: return L"maximum";
		}
		break;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"minimum";
		case 2: return L"maximum";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return L"trainSetIn";
		case 1: return L"trainSetTarget";
		case 2: return L"ignoreWarnings";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC:
		switch(paramIndex)
		{
		case 0: return L"initPopulationSize";
		case 1: return L"numGenerations";
		case 2: return L"overPopulation";
		case 3: return L"mutationProbability";
		case 4: return L"crossoverProbability";
		case 5: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING:
		switch(paramIndex)
		{
		case 0: return L"numTemps";
		case 1: return L"numIterations";
		case 2: return L"initialTemp";
		case 3: return L"finalTemp";
		case 4: return L"isCoolingScheduleLinear";
		case 5: return L"cycles";
		case 6: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return NULL;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return NULL;
	case LEX_FUNC_LAYERNET_RUN:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	//______________________________________________ LayerNetC
	case LEX_FUNC_LAYERNETC_CREATE:
		switch(paramIndex)
		{
		case 0: return L"inputCount";
		case 1: return L"hidden1Count";
		case 2: return L"outputCount";
		}
		break;
	case LEX_FUNC_LAYERNETC_LOAD: return NULL;
	case LEX_FUNC_LAYERNETC_SAVE: return NULL;
	case LEX_FUNC_LAYERNETC_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"layerIndex";
		case 1: return L"layerWeights";
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"layerIndex";
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_INPUT_COUNT: return NULL;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT: return NULL;
	case LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT: return NULL;
	case LEX_FUNC_LAYERNETC_DELETE: return NULL;
	case LEX_FUNC_LAYERNETC_UNLEARN: return NULL;
	case LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	case LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"output";
		}
		break;
	case LEX_FUNC_LAYERNETC_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"minimum";
		case 2: return L"maximum";
		}
		break;
	case LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"minimum";
		case 2: return L"maximum";
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_LAYERNETC_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return L"trainSetIn";
		case 1: return L"trainSetTarget";
		case 2: return L"ignoreWarnings";
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_GENETIC:
		switch(paramIndex)
		{
		case 0: return L"initPopulationSize";
		case 1: return L"numGenerations";
		case 2: return L"overPopulation";
		case 3: return L"mutationProbability";
		case 4: return L"crossoverProbability";
		case 5: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING:
		switch(paramIndex)
		{
		case 0: return L"numTemps";
		case 1: return L"numIterations";
		case 2: return L"initialTemp";
		case 3: return L"finalTemp";
		case 4: return L"isCoolingScheduleLinear";
		case 5: return L"cycles";
		case 6: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return L"epochs";
		case 1: return L"goal";
		}
		break;
	case LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES: return NULL;
	case LEX_FUNC_LAYERNETC_RUN:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	//_____________________________________________________ KohoNet
	case LEX_FUNC_KOHONET_CREATE:
		switch(paramIndex)
		{
		case 0: return L"numInputs";
		case 1: return L"numOutputs";
		case 2: return L"inputNormType";
		}
		break;
	case LEX_FUNC_KOHONET_LOAD: return NULL;
	case LEX_FUNC_KOHONET_SAVE: return NULL;
	case LEX_FUNC_KOHONET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"numInputs";
		case 1: return L"numOutputs";
		case 2: return L"inputNormType";
		}
		break;
	case LEX_FUNC_KOHONET_GET_WEIGHTS: return NULL;
	case LEX_FUNC_KOHONET_GET_INPUT_COUNT: return NULL;
	case LEX_FUNC_KOHONET_GET_OUTPUT_COUNT: return NULL;
	case LEX_FUNC_KOHONET_DELETE: return NULL;
	case LEX_FUNC_KOHONET_UNLEARN: return NULL;
	case LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	case LEX_FUNC_KOHONET_SET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		case 1: return L"minimum";
		case 2: return L"maximum";
		}
		break;
	case LEX_FUNC_KOHONET_GET_INPUT_SCALER:
		switch(paramIndex)
		{
		case 0: return L"index";
		}
		break;
	case LEX_FUNC_KOHONET_SET_TRAINING_SET:
		switch(paramIndex)
		{
		case 0: return L"trainSetIn";
		case 1: return L"ignoreWarnings";
		}
		break;
	case LEX_FUNC_KOHONET_TRAIN_ADDITIVE:
		switch(paramIndex)
		{
		case 0: return L"learningRate";
		case 1: return L"numIterations";
		}
		break;
	case LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE:
		switch(paramIndex)
		{
		case 0: return L"learningRate";
		case 1: return L"numIterations";
		}
		break;
	case LEX_FUNC_KOHONET_COMPUTE_WINNER:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	case LEX_FUNC_KOHONET_RUN:
		switch(paramIndex)
		{
		case 0: return L"input";
		}
		break;
	//_____________________________________________________ ProbNet
	case LEX_FUNC_PROBNET_LOAD: return NULL;
	case LEX_FUNC_PROBNET_SAVE: return NULL;
	case LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT:
	case LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC:
		switch(paramIndex)
		{
		case 0: return L"trainSetIn";
		case 1: return L"trainSetTarget";
		case 2: return L"epochs";
		case 3: return L"goal";
		}
		break;
	case LEX_FUNC_PROBNET_SET_WEIGHTS:
		switch(paramIndex)
		{
		case 0: return L"weights";
		}
		break;
	case LEX_FUNC_PROBNET_GET_WEIGHTS: return NULL;
	case LEX_FUNC_PROBNET_GET_INPUT_COUNT: return NULL;
	case LEX_FUNC_PROBNET_GET_OUTPUT_COUNT: return NULL;
	case LEX_FUNC_PROBNET_RUN:
		switch(paramIndex)
		{
		case 0: return L"trainSetIn";
		case 1: return L"trainSetTarget";
		case 2: return L"input";
		}
		break;
	}
	return NULL;
}

wchar_t* Compiler::GetFunctionName(int datatype, int func_id)
{
	switch(datatype)
	{
	case LEX_DATATYPE_DOUBLE:
	case LEX_DATATYPE_COMPLEX:
		switch(func_id)
		{
		case LEX_FUNC_SIN: return L"sin";
		case LEX_FUNC_COS: return L"cos";
		case LEX_FUNC_TAN: return L"tan";
		case LEX_FUNC_ASIN: return L"asin";
		case LEX_FUNC_ACOS: return L"acos";
		case LEX_FUNC_ATAN: return L"atan";
		case LEX_FUNC_SINH: return L"sinh";
		case LEX_FUNC_COSH: return L"cosh";
		case LEX_FUNC_TANH: return L"tanh";
		case LEX_FUNC_SQRT: return L"sqrt";
		case LEX_FUNC_LOG10: return L"log10";
		case LEX_FUNC_LOG: return L"log";
		case LEX_FUNC_EXP: return L"exp";
		case LEX_FUNC_POW: return L"pow";
		case LEX_FUNC_ABS: return L"abs";
		case LEX_FUNC_SINC: return L"sinc";
		case LEX_FUNC_TRIANG: return L"triang";
		case LEX_FUNC_SAW: return L"saw";
		case LEX_FUNC_RECT: return L"rect";
		case LEX_FUNC_CEIL: return L"ceil";
		case LEX_FUNC_FLOOR: return L"floor";
		case LEX_FUNC_TOINT: return L"toint";
		case LEX_FUNC_FFT: return L"fft";
		case LEX_FUNC_FFTNORM: return L"fftnorm";
		case LEX_FUNC_IFFT: return L"ifft";
		case LEX_FUNC_REALFFT: return L"realfft";
		case LEX_FUNC_REALFFTNORM: return L"realfftnorm";
		case LEX_FUNC_IREALFFT: return L"irealfft";
		case LEX_FUNC_SPECTRUM: return L"spectrum";
		case LEX_FUNC_CONVOLUTION: return L"Convolution";
		case LEX_FUNC_SHORT_CONVOLUTION: return L"ShortConvolution";
		case LEX_FUNC_COMPUTE_MSE: return L"ComputeMse";
		case LEX_FUNC_MAKE_COMPLEX: return L"MakeComplex";
		case LEX_FUNC_CONFUSION_MATRIX: return L"ConfusionMatrix";
		case LEX_FUNC_COVARIANCE_MATRIX: return L"CovarianceMatrix";
		case LEX_FUNC_CORRELATION_MATRIX: return L"CorrelationMatrix";
		case LEX_FUNC_EIGENSYSTEM: return L"EigenSystem";
		//case LEX_FUNC_BESSELJ0: return L"Returns the Bessel functions of the first kind of order zero";
		//case LEX_FUNC_BESSELJ1: return L"Returns the Bessel functions of the first kind of order one";
		//case LEX_FUNC_BESSELY0: return L"Returns the Bessel functions of the second kind of order zero";
		//case LEX_FUNC_BESSELY1: return L"Returns the Bessel functions of the second kind of order one";
		case LEX_FUNC_RAND: return L"rand";	
		}
		break;
	case LEX_DATATYPE_INTEGER:
		switch(func_id)
		{
		//case LEX_FUNC_INT_BIT: return L"It returns the indicated bit of the binary representation of the second number";
		case LEX_FUNC_RANDI: return L"randi";
		case LEX_FUNC_ISPRIME: return L"isprime";
		}
		break;
	case LEX_DATATYPE_MATRIX:
	case LEX_DATATYPE_COMPLEX_MATRIX:
		switch(func_id)
		{
		case LEX_FUNC_MATRIX_CREATE: return L"Create";
		case LEX_FUNC_MATRIX_CREATE_RANDOM: return L"CreateRandom";
		case LEX_FUNC_MATRIX_SAVE: return L"Save";
		case LEX_FUNC_MATRIX_LOAD: return L"Load";
		case LEX_FUNC_MATRIX_APPEND_RIGHT: return L"AppendRight";
		case LEX_FUNC_MATRIX_APPEND_DOWN: return L"AppendDown";
		case LEX_FUNC_MATRIX_DELETE_ROW: return L"DeleteRow";
		case LEX_FUNC_MATRIX_DELETE_COL: return L"DeleteCol";
		case LEX_FUNC_MATRIX_INSERT_ROW: return L"InsertRow";
		case LEX_FUNC_MATRIX_INSERT_COL: return L"InsertCol";
		case LEX_FUNC_MATRIX_DELETE: return L"Delete";
		case LEX_FUNC_MATRIX_GET_ROW_COUNT: return L"GetRowCount";
		case LEX_FUNC_MATRIX_GET_COL_COUNT: return L"GetColCount";
		case LEX_FUNC_MATRIX_GET_SUM: return L"GetSum";
		case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return L"GetDiagonalSum";
		case LEX_FUNC_MATRIX_GET_MEAN: return L"GetMean";
		case LEX_FUNC_MATRIX_GET_VARIANCE: return L"GetVariance";
		case LEX_FUNC_MATRIX_GET_MINIMUM: return L"GetMin";
		case LEX_FUNC_MATRIX_GET_MAXIMUM: return L"GetMax";
		case LEX_FUNC_MATRIX_GET_MIN_POS: return L"GetMinPos";
		case LEX_FUNC_MATRIX_GET_MAX_POS: return L"GetMaxPos";
		case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return L"GetSumSquares";
		case LEX_FUNC_MATRIX_GET_ROWS: return L"GetRows";
		case LEX_FUNC_MATRIX_GET_COLS: return L"GetCols";
		case LEX_FUNC_MATRIX_DELETE_ROWS: return L"DeleteRows";
		case LEX_FUNC_MATRIX_DELETE_COLS: return L"DeleteCols";
		case LEX_FUNC_MATRIX_GET_CLASS: return L"GetClass";
		case LEX_FUNC_MATRIX_TRANSPOSE: return L"Transpose";
		case LEX_FUNC_MATRIX_PREDICTION: return L"Prediction";
		case LEX_FUNC_MATRIX_NORM_ROWS: return L"NormRows";
		case LEX_FUNC_MATRIX_NORM_COLS: return L"NormCols";
		case LEX_FUNC_MATRIX_ROWS_VAR: return L"RowsVar";
		case LEX_FUNC_MATRIX_COLS_VAR: return L"ColsVar";
		case LEX_FUNC_MATRIX_ROWS_MEAN: return L"RowsMean";
		case LEX_FUNC_MATRIX_COLS_MEAN: return L"ColsMean";
		case LEX_FUNC_MATRIX_ROWS_MIN: return L"RowsMin";
		case LEX_FUNC_MATRIX_COLS_MIN: return L"ColsMin";
		case LEX_FUNC_MATRIX_ROWS_MAX: return L"RowsMax";
		case LEX_FUNC_MATRIX_COLS_MAX: return L"ColsMax";
		case LEX_FUNC_MATRIX_GET_ROW: return L"GetRow";
		case LEX_FUNC_MATRIX_GET_COL: return L"GetCol";
		}
		break;
	case LEX_DATATYPE_VECTOR:
	case LEX_DATATYPE_COMPLEX_VECTOR:
		switch(func_id)
		{
		case LEX_FUNC_VECTOR_CREATE: return L"Create";
		case LEX_FUNC_VECTOR_CREATE_SERIES: return L"CreateSeries";
		case LEX_FUNC_VECTOR_CREATE_RANDOM: return L"CreateRandom";
		case LEX_FUNC_VECTOR_CREATE_BINARY: return L"CreateBinary";
		case LEX_FUNC_VECTOR_SAVE: return L"Save";
		case LEX_FUNC_VECTOR_LOAD: return L"Load";
		case LEX_FUNC_VECTOR_INSERT_CELL: return L"InsertCell";
		case LEX_FUNC_VECTOR_DELETE_CELL: return L"DeleteCell";
		case LEX_FUNC_VECTOR_DELETE: return L"Delete";
		case LEX_FUNC_VECTOR_GET_SIZE: return L"GetSize";
		case LEX_FUNC_VECTOR_GET_SUM: return L"GetSum";
		case LEX_FUNC_VECTOR_GET_MEAN: return L"GetMean";
		case LEX_FUNC_VECTOR_GET_VARIANCE: return L"GetVariance";
		case LEX_FUNC_VECTOR_GET_MINIMUM: return L"GetMin";
		case LEX_FUNC_VECTOR_GET_MAXIMUM: return L"GetMax";
		case LEX_FUNC_VECTOR_GET_MIN_POS: return L"GetMinPos";
		case LEX_FUNC_VECTOR_GET_MAX_POS: return L"GetMaxPos";
		case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return L"GetSquaredSum";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return L"CreateLoPassIR";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return L"CreateLoPassFR";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return L"CreateHiPassIR";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return L"CreateHiPassFR";
		case LEX_FUNC_VECTOR_CREATE_KAISER: return L"CreateKaiser";
		case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return L"CreateRandomSet";
		case LEX_FUNC_VECTOR_WRAP: return L"Wrap";
		case LEX_FUNC_VECTOR_LINE_FIT: return L"LineFit";
		}
		break;
	case LEX_DATATYPE_LAYERNET:
		switch(func_id)
		{
		case LEX_FUNC_LAYERNET_CREATE: return L"Create";
		case LEX_FUNC_LAYERNET_LOAD: return L"Load";
		case LEX_FUNC_LAYERNET_SAVE: return L"Save";	
		case LEX_FUNC_LAYERNET_SET_WEIGHTS: return L"SetWeights";	
		case LEX_FUNC_LAYERNET_GET_WEIGHTS: return L"GetWeights";	
		case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return L"GetInputCount";	
		case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return L"GetOutputCount";	
		case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return L"GetHid1NeCount";	
		case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return L"GetHid2NeCount";	
		case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return L"GetLayerCount";
		case LEX_FUNC_LAYERNET_DELETE: return L"Delete";	
		case LEX_FUNC_LAYERNET_UNLEARN: return L"Unlearn";	
		case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return L"AutoSetInScaler";	
		case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return L"AutoSetOutScaler";	
		case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return L"SetInScaler";	
		case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return L"SetOutScaler";	
		case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return L"GetInScaler";	
		case  LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return L"GetOutScaler";	
		case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return L"SetTrainSet";
		case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return L"TrainGenetic";
		case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return L"TrainSimAnneal";	
		case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return L"TrainConjGrad";	
		case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return L"TrainVarMetric";	
		case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return L"TrainLevenMar";	
		case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return L"TrainRegression";
		case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return L"GetMinNoTrCs";
		case LEX_FUNC_LAYERNET_RUN: return L"Run";	
		}
		break;
	case LEX_DATATYPE_LAYERNETC:
		switch(func_id)
		{
		case LEX_FUNC_LAYERNETC_CREATE: return L"Create";
		case LEX_FUNC_LAYERNETC_LOAD: return L"Load";
		case LEX_FUNC_LAYERNETC_SAVE: return L"Save";	
		case LEX_FUNC_LAYERNETC_SET_WEIGHTS: return L"SetWeights";	
		case LEX_FUNC_LAYERNETC_GET_WEIGHTS: return L"GetWeights";	
		case LEX_FUNC_LAYERNETC_GET_INPUT_COUNT: return L"GetInputCount";	
		case LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT: return L"GetOutputCount";	
		case LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT: return L"GetHid1NeCount";	
		case LEX_FUNC_LAYERNETC_DELETE: return L"Delete";	
		case LEX_FUNC_LAYERNETC_UNLEARN: return L"Unlearn";	
		case LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER: return L"AutoSetInScaler";	
		case LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER: return L"AutoSetOutScaler";	
		case LEX_FUNC_LAYERNETC_SET_INPUT_SCALER: return L"SetInScaler";	
		case LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER: return L"SetOutScaler";	
		case LEX_FUNC_LAYERNETC_GET_INPUT_SCALER: return L"GetInScaler";	
		case  LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER: return L"GetOutScaler";	
		case LEX_FUNC_LAYERNETC_SET_TRAINING_SET: return L"SetTrainSet";
		case LEX_FUNC_LAYERNETC_TRAIN_GENETIC: return L"TrainGenetic";
		case LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING: return L"TrainSimAnneal";	
		case LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT: return L"TrainConjGrad";	
		case LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC: return L"TrainVarMetric";	
		case LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES: return L"GetMinNoTrCs";
		case LEX_FUNC_LAYERNETC_RUN: return L"Run";	
		}
		break;
	case LEX_DATATYPE_KOHONET:
		switch(func_id)
		{
		case LEX_FUNC_KOHONET_CREATE: return L"Create";
		case LEX_FUNC_KOHONET_LOAD: return L"Load";
		case LEX_FUNC_KOHONET_SAVE: return L"Save";
		case LEX_FUNC_KOHONET_SET_WEIGHTS: return L"SetWeights";
		case LEX_FUNC_KOHONET_GET_WEIGHTS: return L"GetWeights";
		case LEX_FUNC_KOHONET_GET_INPUT_COUNT: return L"GetInputCount";
		case LEX_FUNC_KOHONET_GET_OUTPUT_COUNT: return L"GetOutputCount";
		case LEX_FUNC_KOHONET_DELETE: return L"Delete";
		case LEX_FUNC_KOHONET_UNLEARN: return L"Unlearn";
		case LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER: return L"AutoSetInScaler";
		case LEX_FUNC_KOHONET_SET_INPUT_SCALER: return L"SetInScaler";
		case LEX_FUNC_KOHONET_GET_INPUT_SCALER: return L"GetInScaler";
		case LEX_FUNC_KOHONET_SET_TRAINING_SET: return L"SetTrainingSet";
		case LEX_FUNC_KOHONET_TRAIN_ADDITIVE: return L"TrainAdditive";
		case LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE: return L"TrainSubtractive";
		case LEX_FUNC_KOHONET_COMPUTE_WINNER: return L"ComputeWinner";
		case LEX_FUNC_KOHONET_RUN: return L"Run";
		}
		break;
	case LEX_DATATYPE_PROBNET:
		switch(func_id)
		{
		case LEX_FUNC_PROBNET_LOAD: return L"Load";
		case LEX_FUNC_PROBNET_SAVE: return L"Save";
		case LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT: return L"TrainConjGrad";
		case LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC: return L"TrainVarMetric";
		case LEX_FUNC_PROBNET_SET_WEIGHTS: return L"SetWeights";
		case LEX_FUNC_PROBNET_GET_WEIGHTS: return L"GetWeights";
		case LEX_FUNC_PROBNET_GET_INPUT_COUNT: return L"GetInputCount";
		case LEX_FUNC_PROBNET_GET_OUTPUT_COUNT: return L"GetOutputCount";
		case LEX_FUNC_PROBNET_DELETE: return L"Delete";
		case LEX_FUNC_PROBNET_RUN: return L"Run";
		}
		break;
	case LEX_DATATYPE_CONTROL:
		switch(func_id)
		{
		case LEX_IF: return L"if";
		case LEX_ELSE: return L"else";
		case LEX_FOR: return L"for";
		case LEX_WHILE: return L"while";
		case LEX_DO: return L"do";
		case LEX_SWITCH: return L"switch";
		case LEX_CASE: return L"case";
		case LEX_BREAK: return L"break";
		case LEX_CONTINUE: return L"continue";
		case LEX_RETURN: return L"return";
		}
		break;
	}
	return NULL;
}

void Compiler::GetFunctionDisplay(int func_id, wstring& help)
{
	wchar_t * text = Cpl::LexicalAnalyzer::GetTokenText(Cpl::Compiler::GetObjectFuncReturnType(LEX_DATATYPE_MATRIX, func_id));
	if (text != NULL) help += text;
	help += L" ";
	text = Cpl::Compiler::GetFunctionName(LEX_DATATYPE_DOUBLE, func_id);
	if (text != NULL) help += text;
	help += L"(";
	//
	const int paramCount = Cpl::Compiler::GetFuncParamCount(func_id);
	//
	for(int i = 0; i < paramCount; i++)
	{
		text = Cpl::LexicalAnalyzer::GetTokenText(Cpl::Compiler::GetObjectFuncParamType(func_id, i));
		if (text != NULL) help += text;
		help += L" ";
		text = Cpl::Compiler::GetObjectFuncParamName(func_id, i);
		if (text != NULL) help += text;
		if (i == paramCount-1)
		{
			help += L")";
		}
		else
		{
			help += L", ";
		}
	}
	//
	//text = Cpl::LexicalAnalyzer::GetTokenText(Cpl::Compiler::GetObjectFuncParamType(func_id, 1));
	//if (text != NULL) help += text;
	//help += L" ";
	//text = Cpl::Compiler::GetObjectFuncParamName(func_id, 1);
	//if (text != NULL) help += text;
	//help += L")";
}

bool Compiler::GetFunctionHelp(const wchar_t* function_name, const wchar_t* separator, wstring& help)
{
	int func_id = -1;
	wchar_t* name = NULL;
	bool found = false;
	for(func_id = LEX_FUNC_SIN; func_id <=LEX_FUNC_ISPRIME; func_id++)
	{
		name = Cpl::LexicalAnalyzer::GetTokenText(func_id);
		if (name != NULL)
		{
			if (wcscmp(name, function_name) == 0)
			{
				found = true;
				break;
			}
		}
	}
	if (found == false) return false;
	if (LEX_FUNC_SIN <= func_id && func_id <= LEX_FUNC_TOINT)
	{
		help = name;
		if (func_id == LEX_FUNC_POW)
		{
			help += L"(x, y)";
		}
		else
		{
			help += L"(x)";
		}
		
	}
	else if (func_id == LEX_FUNC_RAND)
	{
		help = L"double rand(double x)";
	}
	else if (func_id == LEX_FUNC_RANDI)
	{
		help = L"int randi(int x)";
	}
	else if (func_id == LEX_FUNC_ISPRIME)
	{
		help = L"bool isprime(int x)";
	}
	else if (func_id == LEX_FUNC_FFT)
	{
		help = L"ComplexMatrix fft(ComplexMatrix x)";
	}
	else if (func_id == LEX_FUNC_FFTNORM)
	{
		help = L"ComplexMatrix fftnorm(ComplexMatrix x)";
	}
	else if (func_id == LEX_FUNC_IFFT)
	{
		help = L"ComplexMatrix ifft(ComplexMatrix x)";
	}
	else if (func_id == LEX_FUNC_REALFFT)
	{
		help = L"Matrix realfft(Matrix x)";
	}
	else if (func_id == LEX_FUNC_REALFFTNORM)
	{
		help = L"Matrix realfftnorm(Matrix x)";
	}
	else if (func_id == LEX_FUNC_IREALFFT)
	{
		help = L"Matrix irealfft(Matrix x)";
	}
	else if (func_id == LEX_FUNC_SPECTRUM)
	{
		help = L"Vector spectrum(Vector x)";
		help += separator;
		help += L"Matrix spectrum(Matrix x)";
	}
	else if (func_id == LEX_FUNC_CONVOLUTION || func_id == LEX_FUNC_SHORT_CONVOLUTION
		|| func_id == LEX_FUNC_COMPUTE_MSE || func_id == LEX_FUNC_MAKE_COMPLEX 
		|| func_id == LEX_FUNC_CONFUSION_MATRIX
		|| func_id == LEX_FUNC_COVARIANCE_MATRIX || func_id == LEX_FUNC_CORRELATION_MATRIX
		|| func_id == LEX_FUNC_EIGENSYSTEM)
	{
		GetFunctionDisplay(func_id, help);
	}
	help += separator;
	const wchar_t * descr = Cpl::Compiler::GetFunctionDescr(func_id);				
	if (descr != NULL) help += descr;
	return true;
}

wchar_t* Compiler::GetFunctionDescr(int func_id)
{
	int datatype;
	wchar_t * descr = NULL;
	for(datatype = LEX_DATATYPE_BOOL; datatype <= LEX_DATATYPE_PROBNET; datatype++)
	{
		descr = GetFunctionDescr(datatype, func_id);
		if (descr!= NULL) return descr;
	}
	return NULL;
}

wchar_t* Compiler::GetFunctionDescr(int datatype, int func_id)
{
	switch(datatype)
	{
	case LEX_DATATYPE_DOUBLE:
	case LEX_DATATYPE_COMPLEX:
		switch(func_id)
		{
		case LEX_FUNC_SIN: return L"Returns the value of the sine of the angle x (x must be in radians)";
		case LEX_FUNC_COS: return L"Returns the value of the cosine of the angle x (x must be in radians)";
		case LEX_FUNC_TAN: return L"Returns the value of the tangent of the angle x (x must be in radians)";
		case LEX_FUNC_ASIN: return L"Returns the value of the arcsine in radians of x";
		case LEX_FUNC_ACOS: return L"Returns the value of the arccosine in radians of x";
		case LEX_FUNC_ATAN: return L"Returns the value of the arctangent in radians of x";
		case LEX_FUNC_SINH: return L"Returns the value of the hyperbolic sine of x";
		case LEX_FUNC_COSH: return L"Returns the value of the hyperbolic cosine of x";
		case LEX_FUNC_TANH: return L"Returns the value of the hyperbolic tangent of x";
		case LEX_FUNC_SQRT: return L"Returns the value of the squared root of x";
		case LEX_FUNC_LOG10: return L"Returns the base 10 logarithm of x";
		case LEX_FUNC_LOG: return L"Returns the natural logarithm of x";
		case LEX_FUNC_EXP: return L"Returns the natural exponential of x";
		case LEX_FUNC_POW: return L"Returns x to the power of y";
		case LEX_FUNC_ABS: return L"Returns the absolute value of x, if x is real.  Returns the magnitude of x, if x is complex.";
		case LEX_FUNC_SINC: return L"Returns the value of the function sin(pi x)/(pi x)";
		case LEX_FUNC_TRIANG: return L"Returns the value of the triangular function of x";
		case LEX_FUNC_SAW: return L"Returns the value of the sawtooth function of x";
		case LEX_FUNC_RECT: return L"Returns the value of the rectangular function of x (a squared wave form).";
		case LEX_FUNC_CEIL: return L"Returns a double value representing the smallest integer that is greater than or equal to x";
		case LEX_FUNC_FLOOR: return L"Returns a floating-point value representing the largest integer that is less than or equal to x";
		case LEX_FUNC_TOINT: return L"Returns the integer part of a double value";
		case LEX_FUNC_FFT: return L"Returns the Fast Fourier Transform of x, length must be a power of 2";
		case LEX_FUNC_FFTNORM: return L"Returns the FFT of x with phase normalization, length must be a power of 2";
		case LEX_FUNC_IFFT: return L"Returns the inverse Fast Fourier Transform of x, length must be a power of 2";
		case LEX_FUNC_REALFFT: return L"Returns FFT (output: real and imaginary values stored sequencially). Length must be a power of 2";
		case LEX_FUNC_REALFFTNORM: return L"Returns FFT with phase normalization (output: real and imag sequencially). Length must be a power of 2";
		case LEX_FUNC_IREALFFT: return L"Returns IFFT (input: real and imaginary values stored secuencially). Length must be a power of 2";
		case LEX_FUNC_SPECTRUM: return L"Returns the magnitude of the FFT of x.  Length must be a power of 2.";
		case LEX_FUNC_CONVOLUTION: return L"Returns the convolution";
		case LEX_FUNC_SHORT_CONVOLUTION: return L"Returns the output for the specified impulse response and input";
		case LEX_FUNC_COMPUTE_MSE: return L"Returns the mean squared error";
		case LEX_FUNC_MAKE_COMPLEX: return L"Creates a complex value";
		case LEX_FUNC_CONFUSION_MATRIX: return L"Returns the confussion matrix used for classification for the given threshold.";
		case LEX_FUNC_COVARIANCE_MATRIX: return L"Returns the covariance matrix.";
		case LEX_FUNC_CORRELATION_MATRIX: return L"Returns the correlation matrix.";
		case LEX_FUNC_EIGENSYSTEM: return L"Returns the eigen values (returned in the last row) and eigen vectors of a symmetric matrix.";
		//case LEX_FUNC_BESSELJ0: return L"Returns the Bessel functions of the first kind of order zero";
		//case LEX_FUNC_BESSELJ1: return L"Returns the Bessel functions of the first kind of order one";
		//case LEX_FUNC_BESSELY0: return L"Returns the Bessel functions of the second kind of order zero";
		//case LEX_FUNC_BESSELY1: return L"Returns the Bessel functions of the second kind of order one";
		case LEX_FUNC_RAND: return L"Returns a random double value in the range (0   x)";	
		}
		break;
	case LEX_DATATYPE_INTEGER:
		switch(func_id)
		{
		//case LEX_FUNC_INT_BIT: return L"It returns the indicated bit of the binary representation of the second number";
		case LEX_FUNC_RANDI: return L"It returns a random integer value in the range [0   x]";
		case LEX_FUNC_ISPRIME: return L"It returns a bool value of false when x is not a prime number; it returns a bool value of true when x is a prime number";
		}
		break;
	case LEX_DATATYPE_MATRIX:
	case LEX_DATATYPE_COMPLEX_MATRIX:
		switch(func_id)
		{
		case LEX_FUNC_MATRIX_CREATE: return L"Creates a matrix";
		case LEX_FUNC_MATRIX_CREATE_RANDOM: return L"Creates a matrix of random values";
		case LEX_FUNC_MATRIX_SAVE: return L"Stores a matrix";
		case LEX_FUNC_MATRIX_LOAD: return L"Loads a matrix";
		case LEX_FUNC_MATRIX_APPEND_RIGHT: return L"Appends the matrix x at the right";
		case LEX_FUNC_MATRIX_APPEND_DOWN: return L"Appends the matrix x at the bottom";
		case LEX_FUNC_MATRIX_DELETE_ROW: return L"Removes the specified row";
		case LEX_FUNC_MATRIX_DELETE_COL: return L"Removes the specified column";
		case LEX_FUNC_MATRIX_INSERT_ROW: return L"Insert an empty row at the specified row";
		case LEX_FUNC_MATRIX_INSERT_COL: return L"Insert an empty column at the specified column";
		case LEX_FUNC_MATRIX_DELETE: return L"Deletes all elements from the matrix";
		case LEX_FUNC_MATRIX_GET_ROW_COUNT: return L"Returns the number of rows in the matrix";
		case LEX_FUNC_MATRIX_GET_COL_COUNT: return L"Returns the number of columns in the matrix";
		case LEX_FUNC_MATRIX_GET_SUM: return L"Returns the summation of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM: return L"Returns the summation of the elements of the main diagonal of the matrix";
		case LEX_FUNC_MATRIX_GET_MEAN: return L"Returns the mean value of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_VARIANCE: return L"Returns the variance of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_MINIMUM: return L"Returns the minimum value of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_MAXIMUM: return L"Returns the maximum value of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_MIN_POS: return L"Returns the position of the minimum element in the matrix";
		case LEX_FUNC_MATRIX_GET_MAX_POS: return L"Returns the position of the maximum element in the matrix";
		case LEX_FUNC_MATRIX_GET_SUM_SQUARES: return L"Returns the summation of the squared of the elements of the matrix";
		case LEX_FUNC_MATRIX_GET_ROWS: return L"Returns the specified rows of the matrix";
		case LEX_FUNC_MATRIX_GET_COLS: return L"Returns the specified columns of the matrix";
		case LEX_FUNC_MATRIX_DELETE_ROWS: return L"Removes the rows of the matrix that are specified by the indexes in the vector";
		case LEX_FUNC_MATRIX_DELETE_COLS: return L"Removes the columns of the matrix thar are specified by the indexes in the vector";
		case LEX_FUNC_MATRIX_GET_CLASS: return L"Returns the class index for each row in the matrix";
		case LEX_FUNC_MATRIX_TRANSPOSE: return L"Returns the transposed of the matrix. The original matrix remains unchanged";
		case LEX_FUNC_MATRIX_PREDICTION: return L"Returns the row and column of the forecast from a mse matrix (without overfitting)";
		case LEX_FUNC_MATRIX_NORM_ROWS: return L"Normalize the rows so that they are in range from -1 to 1";
		case LEX_FUNC_MATRIX_NORM_COLS: return L"Normalize the colums so that they are in the range from -1 to 1";
		case LEX_FUNC_MATRIX_ROWS_VAR: return L"Returns a vector with the variance of each row";
		case LEX_FUNC_MATRIX_COLS_VAR: return L"Returns a vector with the variance of each column";
		case LEX_FUNC_MATRIX_ROWS_MEAN: return L"Returns a vector with the mean of each row";
		case LEX_FUNC_MATRIX_COLS_MEAN: return L"Returns a vector with the mean of each column";
		case LEX_FUNC_MATRIX_ROWS_MIN: return L"Returns a vector with the minimum of each row";
		case LEX_FUNC_MATRIX_COLS_MIN: return L"Returns a vector with the minimum of each column";
		case LEX_FUNC_MATRIX_ROWS_MAX: return L"Returns a vector with the maximum of each row";
		case LEX_FUNC_MATRIX_COLS_MAX: return L"Returns a vector with the maximum of each column";
		case LEX_FUNC_MATRIX_GET_ROW: return L"Returns the specified row of the matrix";
		case LEX_FUNC_MATRIX_GET_COL: return L"Returns the specified column of the matrix";
		}
		break;
	case LEX_DATATYPE_VECTOR:
	case LEX_DATATYPE_COMPLEX_VECTOR:
		switch(func_id)
		{
		case LEX_FUNC_VECTOR_CREATE: return L"Creates a vector";
		case LEX_FUNC_VECTOR_CREATE_SERIES: return L"Creates a series of values";
		case LEX_FUNC_VECTOR_CREATE_RANDOM: return L"Creates a vector with random values";
		case LEX_FUNC_VECTOR_CREATE_BINARY: return L"Creates a vector with the bits in BCD of a decimal value";
		case LEX_FUNC_VECTOR_SAVE: return L"Stores a vector into a file";
		case LEX_FUNC_VECTOR_LOAD: return L"Loads a vector from a file";
		case LEX_FUNC_VECTOR_INSERT_CELL: return L"Inserts a value in the vector";
		case LEX_FUNC_VECTOR_DELETE_CELL: return L"Removes a cell from the vector";
		case LEX_FUNC_VECTOR_DELETE: return L"Removes all cells from the vector";
		case LEX_FUNC_VECTOR_GET_SIZE: return L"Returns the size of the vector";
		case LEX_FUNC_VECTOR_GET_SUM: return L"Returns the summation of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_MEAN: return L"Returns the mean value of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_VARIANCE: return L"Returns the variance of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_MINIMUM: return L"Returns the minimum value of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_MAXIMUM: return L"Returns the maximum value of the elements of the vector";
		case LEX_FUNC_VECTOR_GET_MIN_POS: return L"Returns the position of the minimum element in the vector";
		case LEX_FUNC_VECTOR_GET_MAX_POS: return L"Returns the position of the maximum element in the vector";
		case LEX_FUNC_VECTOR_GET_SQUARED_SUM: return L"Returns the summation of the squared of the elements of the vector";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP: return L"Creates the impulse response of a low pass filter";
		case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP: return L"Creates the impulse response of a high pass filter";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP: return L"Creates the frequency response of a low pass filter";
		case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP: return L"Creates the frequency response of a high pass filter";
		case LEX_FUNC_VECTOR_CREATE_KAISER: return L"Creates a Kaiser window to use with the FFT";
		case LEX_FUNC_VECTOR_CREATE_RANDOM_SET: return L"Creates a random integer set";
		case LEX_FUNC_VECTOR_WRAP: return L"Wraps the elements of a vector to build a training set for prediction";
		case LEX_FUNC_VECTOR_LINE_FIT: return L"Returns the value of m and b that best fit y = mx+b, x = 0, 1, 2, 3, ... (b = vector[1], m = vector[0])";
		}
		break;
	//case LEX_DATATYPE_SCALER:
	//	switch(func_id)
	//	{
	//	case LEX_FUNC_SCALER_CREATEINPUTSCALER: return L"Creates an input scaler of the specified size";
	//	case LEX_FUNC_SCALER_CREATEOUTPUTSCALER: return L"Creates an output data scaler of the specified size";
	//	case LEX_FUNC_SCALER_DELETE: return L"Destroys the data scaler";
	//	case LEX_FUNC_SCALER_GETSIZE: return L"Returns the size of the data scaler";
	//	case LEX_FUNC_SCALER_SAVE: return L"Stores a data scaler into a file";
	//	case LEX_FUNC_SCALER_LOAD: return L"Loads a data scaler from a file";
	//	case LEX_FUNC_SCALER_SET: return L"Sets the scaling information for a specified scaler element";
	//	case LEX_FUNC_SCALER_SCALE: return L"Scales an input matrix and stores the results in the output matrix";
	//	case LEX_FUNC_SCALER_GETMINIMUM: return L"Returns the minimum scale value specified by index";
	//	case LEX_FUNC_SCALER_GETMAXIMUM: return L"Returns the maximum scale value specified by index";
	//	case LEX_FUNC_SCALER_AUTOSETINPUTSCALER: return L"Creates an input data scaler from the specified matrix";
	//	case LEX_FUNC_SCALER_AUTOSETOUTPUTSCALER: return L"Creates an output data scaler from the specified matrix";
	//	}
	//	break;
	case LEX_DATATYPE_LAYERNET:
		switch(func_id)
		{
		case LEX_FUNC_LAYERNET_CREATE: return L"Creates a multilayer artificial neural network";
		case LEX_FUNC_LAYERNET_LOAD: return L"Loads a multilayer artificial neural network from a file";
		case LEX_FUNC_LAYERNET_SAVE: return L"Stores a multilayer artificial neural network into a file";	
		case LEX_FUNC_LAYERNET_SET_WEIGHTS: return L"Set the weights for the specified layer (hidden1 = 1, hidden2 = 2, output = 3)";	
		case LEX_FUNC_LAYERNET_GET_WEIGHTS: return L"Returns the weights of the specified layer (hidden1 = 1, hidden2 = 2, output = 3)";	
		case LEX_FUNC_LAYERNET_GET_INPUT_COUNT: return L"Returns the number of inputs";	
		case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT: return L"Returns the number of outputs";	
		case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT: return L"Returns the number of neurons in hidden layer 1";	
		case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT: return L"Returns the number of neurons in hidden layer 2";	
		case LEX_FUNC_LAYERNET_GET_LAYER_COUNT: return L"Returns the number of layers (at least two: input and output layer)";	
		case LEX_FUNC_LAYERNET_DELETE: return L"Destroy the ANN";	
		case LEX_FUNC_LAYERNET_UNLEARN: return L"Erases any previous training";	
		case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER: return L"Set the input scaler from an input matrix";	
		case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER: return L"Set the output scaler from an output matrix";	
		case LEX_FUNC_LAYERNET_SET_INPUT_SCALER: return L"Set the scaling range for the specified input";	
		case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER: return L"Set the scaling range for the specified output";	
		case LEX_FUNC_LAYERNET_GET_INPUT_SCALER: return L"Returns the scaling range for the specified input";	
		case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER: return L"Returns the scaling range for the specified output";	
		case LEX_FUNC_LAYERNET_SET_TRAINING_SET: return L"Set the training set";
		case LEX_FUNC_LAYERNET_TRAIN_GENETIC: return L"Trains a multilayer ANN using a genetic algorithm";
		case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING: return L"Trains a multilayer ANN using simulated annealing";	
		case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT: return L"Trains a multilayer ANN using the conjugate gradient";	
		case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC: return L"Trains a multilayer ANN using the variable metric method";	
		case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT: return L"Trains a multilayer ANN using the method of Levenberg Marquardt";	
		case LEX_FUNC_LAYERNET_TRAIN_REGRESSION: return L"Trains a multilayer ANN using regression (for zero hidden layers only)";	
		case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES: return L"Returns the minimum number of training cases for training the network";
		case LEX_FUNC_LAYERNET_RUN: return L"Computes the output of the ANN for a given input";	
		}
		break;
	case LEX_DATATYPE_LAYERNETC:
		switch(func_id)
		{
		case LEX_FUNC_LAYERNETC_CREATE: return L"Creates a multilayer ANN with complex domain inputs and outputs";
		case LEX_FUNC_LAYERNETC_LOAD: return L"Loads a multilayer ANN with complex domain inputs and outputs from a file";
		case LEX_FUNC_LAYERNETC_SAVE: return L"Stores a multilayer ANN with complex domain inputs and outputs into a file";	
		case LEX_FUNC_LAYERNETC_SET_WEIGHTS: return L"Set the weights for the specified layer (hidden1 = 1, output = 2)";	
		case LEX_FUNC_LAYERNETC_GET_WEIGHTS: return L"Returns the weights of the specified layer (hidden1 = 1, output = 2)";	
		case LEX_FUNC_LAYERNETC_GET_INPUT_COUNT: return L"Returns the number of inputs";	
		case LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT: return L"Returns the number of outputs";	
		case LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT: return L"Returns the number of neurons in hidden layer 1";	
		case LEX_FUNC_LAYERNETC_DELETE: return L"Destroy the ANN";	
		case LEX_FUNC_LAYERNETC_UNLEARN: return L"Erases any previous training";	
		case LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER: return L"Set the input scaler from an input matrix";	
		case LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER: return L"Set the output scaler from an output matrix";	
		case LEX_FUNC_LAYERNETC_SET_INPUT_SCALER: return L"Set the scaling range for the specified input";	
		case LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER: return L"Set the scaling range for the specified output";	
		case LEX_FUNC_LAYERNETC_GET_INPUT_SCALER: return L"Returns the scaling range for the specified input";	
		case LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER: return L"Returns the scaling range for the specified output";	
		case LEX_FUNC_LAYERNETC_SET_TRAINING_SET: return L"Set the training set";
		case LEX_FUNC_LAYERNETC_TRAIN_GENETIC: return L"Trains a multilayer ANN using a genetic algorithm";
		case LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING: return L"Trains a multilayer ANN using simulated annealing";	
		case LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT: return L"Trains a multilayer ANN using the conjugate gradient";	
		case LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC: return L"Trains a multilayer ANN using the variable metric method";	
		case LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES: return L"Returns the minimum number of training cases for training the network";
		case LEX_FUNC_LAYERNETC_RUN: return L"Computes the output of the ANN for a given input";	
		}
		break;
	case LEX_DATATYPE_KOHONET:
		switch(func_id)
		{
		case LEX_FUNC_KOHONET_CREATE: return L"Creates a Kohonen network. inputNormType: Multiplicative = 1, Z-Axis=2";
		case LEX_FUNC_KOHONET_LOAD: return L"Load a kohonen network from a file";
		case LEX_FUNC_KOHONET_SAVE: return L"Save a kohonen network into a file";
		case  LEX_FUNC_KOHONET_SET_WEIGHTS: return L"Set the weights";
		case  LEX_FUNC_KOHONET_GET_WEIGHTS: return L"Returns the weights";	
		case  LEX_FUNC_KOHONET_GET_INPUT_COUNT: return L"Returns the number of inputs";	
		case  LEX_FUNC_KOHONET_GET_OUTPUT_COUNT: return L"Returns the number of outputs";	
		case  LEX_FUNC_KOHONET_DELETE: return L"Destroy the ANN";	
		case  LEX_FUNC_KOHONET_UNLEARN: return L"Erases any previous training";	
		case  LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER: return L"Set the input scaler from an input matrix";	
		case  LEX_FUNC_KOHONET_SET_INPUT_SCALER: return L"Set the scaling range for the specified input";	
		case  LEX_FUNC_KOHONET_GET_INPUT_SCALER: return L"Returns the scaling range for the specified input";	
		case  LEX_FUNC_KOHONET_SET_TRAINING_SET: return L"Set the training set";
		case  LEX_FUNC_KOHONET_TRAIN_ADDITIVE: return L"Trains a Kohonen network using additive update";	
		case  LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE: return L"Trains a Kohonen network using subtractive update";	
		case  LEX_FUNC_KOHONET_COMPUTE_WINNER: return L"Returns the index of the winnner neuron (0, 1, ...) for each row in the input";	
		case LEX_FUNC_KOHONET_RUN: return L"Computes the output of the ANN for  for each row in the input";	
		}
		break;
	case LEX_DATATYPE_PROBNET:
		switch(func_id)
		{
		case LEX_FUNC_PROBNET_LOAD: return L"Loads a probabilistic artificial neural network from a file.";
		case LEX_FUNC_PROBNET_SAVE: return L"Stores a probabilistic artificial neural network into a file.";
		case LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT: return L"Trains a PNN using the conjugate gradient method";	
		case LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC: return L"Trains a PNN using the variable metric method";	
		case LEX_FUNC_PROBNET_SET_WEIGHTS: return L"Set the weights";
		case LEX_FUNC_PROBNET_GET_WEIGHTS: return L"Returns the weights";	
		case LEX_FUNC_PROBNET_GET_INPUT_COUNT: return L"Returns the number of inputs";	
		case LEX_FUNC_PROBNET_GET_OUTPUT_COUNT: return L"Returns the number of outputs";	
		case LEX_FUNC_PROBNET_DELETE: return L"Destroy the PNN";	
		case LEX_FUNC_PROBNET_RUN: return L"Computes the output of the PNN for  for each row in the input";	
		}
		break;
	case LEX_DATATYPE_CONTROL:
		switch(func_id)
		{
		case LEX_IF: return L"Executes if the boolean expression is true";
		case LEX_ELSE: return L"Executes when the boolean expression of the respective if statement is false";
		case LEX_FOR: return L"Executes a block of code a specified number of times";
		case LEX_WHILE: return L"Executes a block of code until a condition changes";
		case LEX_DO: return L"Executes at least once a block of code until a condition changes";
		}
		break;
	}
	return NULL;
}

//_____________________________________________________________________ VirtualMachine
VirtualMachine::VirtualMachine(void)
{
	this->errorDescr[0]='\0';
	this->path[0] = '\0';
	//
	checkIndex = true;
	Math::Statistics::random_generator.seed((unsigned int)::GetTickCount());
}

VirtualMachine::~VirtualMachine(void)
{
}

wchar_t* VirtualMachine::GetErrorDescr()
{
	if (errorDescr[0] == '\0') return NULL;
	return errorDescr;
}

void VirtualMachine::ClearMemory()
{
	memBool.clear();
	memDouble.clear();
	memInteger.clear();
	memMatrix.clear();
	memVector.clear();
	memComplex.clear();
	memVectorC.clear();
	memMatrixC.clear();
	memLayerNet.clear();
	memLayerNetC.clear();
	memKohoNet.clear();
	memProbNet.clear();
	variableName.clear();
}

void VirtualMachine::Setup(map<wstring, Cpl::Compiler::VariableInfo>& variableInfo, vector<Cpl::Compiler::Instruction>& machineCode, const wchar_t* path)
{
	this->variableInfo = variableInfo;
	this->machineCode = machineCode;
	if (path)
	{
		_snwprintf_s(this->path, MAX_PATH, _TRUNCATE, L"%s", path);
	}
}

DWORD VirtualMachine::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	//________________________ reset
	this->errorDescr[0]='\0';
	line.Set(0);
	progress.Set(0.0);
	mse.Set(0.0);
	ClearMemory();
	while (stack.empty()==false) stack.pop();

	const int count = (int)machineCode.size();
	bool isRunning = false;
	
	for(instructionIndex=0; instructionIndex<count; instructionIndex++)
	{
		resetTime.Set(true);//resetTime.SetTry(true);
		//if (instructionIndex >= count) break;
		if (Execute(machineCode[instructionIndex], running, progress)==false) break;
		//if (instructionIndex >= count) break;
		if (running.GetTry(isRunning) == true)
		{
			if (isRunning == false) break;
		}
		//_______________________________________ Try to copy memInteger to memIntegerExange in order to communicate the values of the integer variables
		if (instructionIndex%10 == 0)
		{
			if (csIntegerExchange.Try() == true)
			{
				memIntegerExchange = memInteger;
				csIntegerExchange.Leave();
			}
		}
	}
	running.Set(false);
	return 0;
}

void VirtualMachine::SafeGetMemoryIntInfo(HWND hWnd, int gui_type)  // gui_type:  VM_GUITYPE_LISTVIEW, VM_GUITYPE_DROPDOWN
{
	//___________________________________________ Copy memIntegerExchange to tmp
	vector<int> tmp;
	if (csIntegerExchange.Try() == false) return;
	tmp = memIntegerExchange;
	csIntegerExchange.Leave();
	
	int rows = 0;
	int cols = 0;
	LVITEM lvi;
	ZeroMemory(&lvi, sizeof(LVITEM));
	lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	//
	if (gui_type == VM_GUITYPE_LISTVIEW)
	{
		::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)FALSE, 0);
		::SendMessage(hWnd, (UINT)LVM_DELETEALLITEMS, 0, 0);
	}
	else if (gui_type == VM_GUITYPE_DROPDOWN)
	{
		//::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)FALSE, 0);
		::SendMessage(hWnd, (UINT)LB_RESETCONTENT, 0, 0);
	}
	int i;
	wchar_t info[256];
	//wchar_t descr[256];
	int index = 0;
	wstring variableName;
	int new_index = 0;


	//________________________________ integer
	const int count = (int)memInteger.size();
	for(i=0; i<count; i++)
	{
		variableName = this->GetVariableName(LEX_DATATYPE_INTEGER, i);
		_snwprintf_s(info, 256, _TRUNCATE, L"%s=%d", variableName.c_str(), memInteger[i]);
		lvi.pszText = (wchar_t*)info;
		lvi.iItem = index;
		lvi.lParam = i;
		lvi.iImage = LEX_DATATYPE_INTEGER - LEX_DATATYPE_BOOL;
		if (gui_type == VM_GUITYPE_LISTVIEW)
		{
			::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
		}
		else if (gui_type == VM_GUITYPE_DROPDOWN)
		{
			new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
			if (new_index !=CB_ERR)
			{
				::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
			}
		}	
		index++;
	}
	if (gui_type == VM_GUITYPE_LISTVIEW)
	{
		::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
	}
	else if (gui_type == VM_GUITYPE_DROPDOWN)
	{
		//::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
	}
}


// Fills the listview with memory information using the specified datatype
// datatype:  LEX_DATATYPE_BOOL, ..., LEX_DATATYPE_ALL
// gui_type:  VM_GUITYPE_LISTVIEW, VM_GUITYPE_DROPDOWN
void VirtualMachine::GetMemoryInfo(HWND hWnd, int gui_type, int datatype, bool showMatrixVectorSize) 
{
	int rows = 0;
	int cols = 0;
	LVITEM lvi;
	ZeroMemory(&lvi, sizeof(LVITEM));
	lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	//
	if (gui_type == VM_GUITYPE_LISTVIEW)
	{
		::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)FALSE, 0);
		::SendMessage(hWnd, (UINT)LVM_DELETEALLITEMS, 0, 0);
	}
	else if (gui_type == VM_GUITYPE_DROPDOWN)
	{
		//::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)FALSE, 0);
		::SendMessage(hWnd, (UINT)LB_RESETCONTENT, 0, 0);
	}
	int count = 0;
	int i;
	wchar_t info[256];
	wchar_t descr[256];
	int index = 0;
	wstring variableName;
	int new_index = 0;

	//________________________________ bool
	if (datatype == LEX_DATATYPE_BOOL || datatype == LEX_DATATYPE_ALL)
	{
		count = (int)memBool.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_BOOL, i);
			if (memBool[i] == true)
				_snwprintf_s(info, 256, _TRUNCATE, L"%s=true", variableName.c_str());
			else
				_snwprintf_s(info, 256, _TRUNCATE, L"%s=false", variableName.c_str());

			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_BOOL-LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ integer
	if (datatype == LEX_DATATYPE_INTEGER || datatype == LEX_DATATYPE_ALL)
	{
		count = (int)memInteger.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_INTEGER, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s=%d", variableName.c_str(), memInteger[i]);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_INTEGER - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ double
	if (datatype == LEX_DATATYPE_DOUBLE || datatype == LEX_DATATYPE_ALL)
	{
		count = (int)memDouble.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_DOUBLE, i);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s=%g", variableName.c_str(), memDouble[i]);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_DOUBLE - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ matrix
	if (datatype == LEX_DATATYPE_MATRIX || datatype == LEX_DATATYPE_ALL)
	{
		count = (int)memMatrix.size();
		for(i=0; i<count; i++)
		{
			rows = (int)memMatrix[i].size();
			cols = (rows == 0) ? 0 : (int)memMatrix[i][0].size();
			variableName = this->GetVariableName(LEX_DATATYPE_MATRIX, i);
			if (showMatrixVectorSize == true)
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d%c%d]", variableName.c_str(), rows, WIN_MULTIPLICATION_SIGN, cols);
			}
			else
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s", variableName.c_str());
			}
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_MATRIX - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ vector
	if (datatype == LEX_DATATYPE_VECTOR || datatype == LEX_DATATYPE_ALL)
	{	
		count = (int)memVector.size();
		for(i=0; i<count; i++)
		{
			rows = (int)memVector[i].size();
			variableName = this->GetVariableName(LEX_DATATYPE_VECTOR, i);
			if (showMatrixVectorSize == true)
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d]", variableName.c_str(), rows);
			}
			else
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s", variableName.c_str());
			}
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_VECTOR - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}	
			index++;
		}
	}

	//________________________________ complex
	if (datatype == LEX_DATATYPE_COMPLEX || datatype == LEX_DATATYPE_ALL)
	{	
		wchar_t tempx[64];
		count = (int)memComplex.size();
		for(i=0; i<count; i++)
		{
			Sys::Convert::ToString(memComplex[i], tempx, 64, true, true);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s=%s", variableName.c_str(), tempx);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_COMPLEX - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//________________________________ Complex vector
	if (datatype == LEX_DATATYPE_COMPLEX_VECTOR || datatype == LEX_DATATYPE_ALL)
	{	
		count = (int)memVectorC.size();
		for(i=0; i<count; i++)
		{
			rows = (int)memVectorC[i].size();
			variableName = this->GetVariableName(LEX_DATATYPE_COMPLEX_VECTOR, i);
			if (showMatrixVectorSize == true)
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d]", variableName.c_str(), rows);
			}
			else
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s", variableName.c_str());
			}
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_COMPLEX_VECTOR - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//________________________________ Complex matrix
	if (datatype == LEX_DATATYPE_COMPLEX_VECTOR || datatype == LEX_DATATYPE_ALL)
	{	
		count = (int)memMatrixC.size();
		for(i=0; i<count; i++)
		{
			rows = (int)memMatrixC[i].size();
			cols = (rows == 0) ? 0 : (int)memMatrixC[i][0].size();
			variableName = this->GetVariableName(LEX_DATATYPE_COMPLEX_MATRIX, i);
			if (showMatrixVectorSize == true)
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s [%d%c%d]", variableName.c_str(), rows, WIN_MULTIPLICATION_SIGN, cols);
			}
			else
			{
				_snwprintf_s(info, 256, _TRUNCATE, L"%s", variableName.c_str());
			}
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_COMPLEX_MATRIX - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}
	//________________________________ layernet
	if (datatype == LEX_DATATYPE_LAYERNET || datatype == LEX_DATATYPE_ALL)
	{	
		count = (int)memLayerNet.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_LAYERNET, i);
			memLayerNet[i].GetDescription(descr, 256);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_LAYERNET - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}
	//________________________________ layernetC
	if (datatype == LEX_DATATYPE_LAYERNETC || datatype == LEX_DATATYPE_ALL)
	{	
		count = (int)memLayerNetC.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_LAYERNETC, i);
			memLayerNetC[i].GetDescription(descr, 256);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_LAYERNETC - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//________________________________ kohnet
	if (datatype == LEX_DATATYPE_KOHONET || datatype == LEX_DATATYPE_ALL)
	{	
		count = (int)memKohoNet.size();
		for(i=0; i<count; i++)
		{	
			variableName = this->GetVariableName(LEX_DATATYPE_KOHONET, i);
			memKohoNet[i].GetDescription(descr, 256);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_KOHONET - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}
	//________________________________ probnet
	if (datatype == LEX_DATATYPE_KOHONET || datatype == LEX_DATATYPE_ALL)
	{	
		count = (int)memProbNet.size();
		for(i=0; i<count; i++)
		{
			variableName = this->GetVariableName(LEX_DATATYPE_PROBNET, i);
			memProbNet[i].GetDescription(descr, 256);
			_snwprintf_s(info, 256, _TRUNCATE, L"%s [%s]", variableName.c_str(), descr);
			lvi.pszText = (wchar_t*)info;
			lvi.iItem = index;
			lvi.lParam = i;
			lvi.iImage = LEX_DATATYPE_PROBNET - LEX_DATATYPE_BOOL;
			if (gui_type == VM_GUITYPE_LISTVIEW)
			{
				::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			}
			else if (gui_type == VM_GUITYPE_DROPDOWN)
			{
				new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)(wchar_t*)info);
				if (new_index !=CB_ERR)
				{
					::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)i); 
				}
			}
			index++;
		}
	}

	//__________________________________________________ Errors
	if (wcslen(errorDescr) > 0 && datatype == LEX_DATATYPE_ALL)
	{
		lvi.pszText = errorDescr;
		lvi.iItem = index;
		lvi.lParam = machineCode[instructionIndex].line_number;
		lvi.iImage = LEX_DATATYPE_PROBNET-LEX_DATATYPE_BOOL+1;
		if (gui_type == VM_GUITYPE_LISTVIEW)
		{
			::SendMessage(hWnd, (UINT) LVM_INSERTITEM, 0, (LPARAM) (LPLVITEM)&lvi);
			::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
		}
		else if (gui_type == VM_GUITYPE_DROPDOWN)
		{
			new_index = (int)::SendMessage(hWnd, CB_INSERTSTRING, index, (LPARAM)errorDescr);
			if (new_index !=CB_ERR)
			{
				::SendMessage(hWnd, CB_SETITEMDATA, new_index, (LPARAM)machineCode[instructionIndex].line_number); 
			}
		}
		index++;
		//return;
	}


	if (gui_type == VM_GUITYPE_LISTVIEW)
	{
		::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
	}
	else if (gui_type == VM_GUITYPE_DROPDOWN)
	{
		//::SendMessage(hWnd, WM_SETREDRAW, (WPARAM)(BOOL)TRUE, 0);
	}
}

wstring VirtualMachine::GetVariableName(int datatype, int index)
{
	map<wstring, Compiler::VariableInfo>::iterator p;
	for(p= variableInfo.begin(); p!= variableInfo.end(); p++)
	{
		if (p->second.index==index && p->second.datatype==datatype)
		{
			return p->first;
		}
	}

	return L"Error";
}

bool VirtualMachine::Execute(Compiler::Instruction& inst, Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	this->line.SetTry(inst.line_number);
	switch(inst.type)
	{
	case VM_ERROR:
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d there are compilation errors",
			machineCode[instructionIndex].line_number);
		return false;
	case VM_CREATE:
		return VmCreate(inst);
	case VM_VALUE:
		return VmValue(inst);
	case VM_REFVALUE:
		return VmRefValue(inst);
	case VM_SETVALUE:
		return VmSetValue(inst);
	case VM_SET_VECTORCELL:
		return VmSetVectorCell(inst);
	case VM_SET_MATRIXCELL:
		return VmSetMatrixCell(inst);
	//case VM_SETREF_VECTORCELL:
	//	return VmSetRefMatrixCell(inst);
	//case VM_SETREF_MATRIXCELL:
	//	return VmSetRefMatrixCell(inst);
	case VM_VECTOR_CELL:
		return VmVectorCell(inst);
	case VM_MATRIX_CELL:
		return VmMatrixCell(inst);
	case VM_OPER:
		return VmOper(inst);
	case VM_OPER_MONO:
		return VmOperMono(inst);
	case VM_OPER_BINA:
		return VmOperBina(inst);
	case VM_FUNC:
		return VmFunc(inst);
	case VM_OBJFUNC:
		return VmObjFunc(inst, running, progress);
	case VM_GOTO:
		return VmGoto(inst);
	case VM_GOFALSE:
		return VmGoFalse(inst);
	case VM_GOTRUE:
		return VmGoTrue(inst);
	}
	return false;
}

bool VirtualMachine::VmValue(Compiler::Instruction& inst)
{
	VirtualMachine::Memory memory;
	memory.datatype = inst.subtype;
	memory.double_value = 0.0;
	memory.int_value = 0;
	memory.bool_value = false;

	if (memory.datatype == LEX_DATATYPE_BOOL)
	{
		memory.datatype = LEX_DATATYPE_BOOL;
		memory.bool_value = (inst.int_value != 0);
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_DOUBLE)
	{
		memory.datatype = LEX_DATATYPE_DOUBLE;
		memory.double_value = inst.double_value;
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_INTEGER)
	{
		memory.datatype = LEX_DATATYPE_INTEGER;
		memory.int_value = inst.int_value;
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid value", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmRefValue(Compiler::Instruction& inst)
{
	VirtualMachine::Memory memory;
	memory.datatype = inst.subtype;
	memory.double_value = 0.0;
	memory.int_value = inst.int_value;
	memory.bool_value = false;
	memory.string_value = inst.name;

	if (memory.datatype == LEX_DATATYPE_BOOL)
	{
		memory.bool_value = memBool[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_DOUBLE)
	{
		memory.double_value = memDouble[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_INTEGER)
	{
		memory.int_value = memInteger[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_MATRIX)
	{
		memory.matrix_value = memMatrix[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_VECTOR)
	{
		memory.vector_value = memVector[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX)
	{
		memory.complex_value = memComplex[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX_VECTOR)
	{
		memory.vectorC_value = memVectorC[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX_MATRIX)
	{
		memory.matrixC_value = memMatrixC[inst.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_LAYERNET)
	{
		memory.int_value = inst.int_value; // By reference
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_LAYERNETC)
	{
		memory.int_value = inst.int_value; // By reference
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_KOHONET)
	{
		memory.int_value = inst.int_value;  // By reference
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_PROBNET)
	{
		memory.int_value = inst.int_value; // By reference
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid data type", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmSetValue(Compiler::Instruction& inst)
{
	VirtualMachine::Memory value = stack.top();
	stack.pop();
	int datatypeTarget = inst.subtype;
	int index = (int)inst.int_value;
	if (Convert(value, datatypeTarget, NULL) == false) return false;
	if (datatypeTarget == LEX_DATATYPE_BOOL)
	{
		memBool[index] = value.bool_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_DOUBLE)
	{
		memDouble[index] = value.double_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_INTEGER)
	{
		memInteger[index] = value.int_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_MATRIX)
	{
		memMatrix[index] = value.matrix_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_VECTOR)
	{
		memVector[index] = value.vector_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX)
	{
		memComplex[index] = value.complex_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		memVectorC[index] = value.vectorC_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		memMatrixC[index] = value.matrixC_value;
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_LAYERNET)
	{
		memLayerNet[index] = memLayerNet[value.int_value]; // Copy
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_LAYERNETC)
	{
		memLayerNetC[index] = memLayerNetC[value.int_value]; // Copy
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_KOHONET)
	{
		memKohoNet[index] = memKohoNet[value.int_value];
		return true;
	}
	else if (datatypeTarget == LEX_DATATYPE_PROBNET)
	{
		memProbNet[index] = memProbNet[value.int_value];
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operation", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmSetVectorCell(Compiler::Instruction& inst)
{	
	VirtualMachine::Memory value = stack.top();
	stack.pop();

	VirtualMachine::Memory index = stack.top();
	stack.pop();
	if (Convert(index, LEX_DATATYPE_INTEGER, NULL) == false) return false;

	if (inst.subtype == LEX_DATATYPE_VECTOR)
	{
		if (Convert(value, LEX_DATATYPE_DOUBLE, NULL) == false) return false;
		if (checkIndex == true)
		{
			const int rows = (int)memVector[inst.int_value].size();
			if (index.int_value<0 || index.int_value>=rows)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memVector[inst.int_value][index.int_value]= value.double_value;
		return true;
	}
	else if (inst.subtype == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		if (Convert(value, LEX_DATATYPE_COMPLEX, NULL) == false) return false;
		if (checkIndex == true)
		{
			const int rows = (int)memVectorC[inst.int_value].size();
			if (index.int_value<0 || index.int_value>=rows)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memVectorC[inst.int_value][index.int_value] = value.complex_value;
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d a Vector or ComplexVector is expected", machineCode[instructionIndex].line_number);
	return false;
}

//bool VirtualMachine::VmSetRefVectorCell(Compiler::Instruction& inst)
//{	
//	//VirtualMachine::Memory index = stack.top();
//	//stack.pop();
//	//if (index.datatype != LEX_DATATYPE_INTEGER)
//	//{
//	//	ReportConversionError(index.datatype, LEX_DATATYPE_INTEGER, NULL);
//	//	return false;
//	//}
//
//	//VirtualMachine::Memory memory;
//	//memory.datatype = inst.subtype;
//	//memory.double_value = inst.double_value;
//	//memory.int_value = inst.int_value;
//	////
//
//	//if (memory.datatype ==LEX_DATATYPE_VECTOR)
//	//{
//	//}
//	//else if (memory.datatype ==LEX_DATATYPE_COMPLEX_VECTOR)
//	//{
//	//}
//
//	return false;
//}


bool VirtualMachine::VmSetMatrixCell(Compiler::Instruction& inst)
{
	VirtualMachine::Memory value = stack.top();
	stack.pop();

	VirtualMachine::Memory indexCol = stack.top();
	stack.pop();
	if (Convert(indexCol, LEX_DATATYPE_INTEGER, NULL) == false) return false;

	VirtualMachine::Memory indexRow = stack.top();
	stack.pop();
	if (Convert(indexRow, LEX_DATATYPE_INTEGER, NULL) == false) return false;

	if (inst.subtype == LEX_DATATYPE_MATRIX)
	{
		if (Convert(value, LEX_DATATYPE_DOUBLE, NULL) == false) return false;
		if (checkIndex == true)
		{
			const int rows = (int)memMatrix[inst.int_value].size();
			const int cols = (rows == 0) ? 0 : (int)memMatrix[inst.int_value][0].size();
			if (indexRow.int_value<0 || indexRow.int_value>=rows)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid row index", machineCode[instructionIndex].line_number);
				return false;
			}
			if (indexCol.int_value<0 || indexCol.int_value>=cols)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid column index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memMatrix[inst.int_value][indexRow.int_value][indexCol.int_value] = value.double_value;
		return true;
	}
	else if (inst.subtype == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		if (Convert(value, LEX_DATATYPE_COMPLEX, NULL) == false) return false;
		if (checkIndex == true)
		{
			const int rows = (int)memMatrixC[inst.int_value].size();
			const int cols = rows == 0 ? 0 : (int)memMatrixC[inst.int_value][0].size();
			if (indexRow.int_value<0 || indexRow.int_value>=rows)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid row index", machineCode[instructionIndex].line_number);
				return false;
			}
			if (indexCol.int_value<0 || indexCol.int_value>=cols)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid column index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memMatrixC[inst.int_value][indexRow.int_value][indexCol.int_value] = value.complex_value;
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d a Matrix or ComplexMatrix is expected", machineCode[instructionIndex].line_number);
	return false;
}

//bool VirtualMachine::VmSetRefMatrixCell(Compiler::Instruction& inst)
//{
//	return true;
//}

bool VirtualMachine::VmVectorCell(Compiler::Instruction& inst)
{
	VirtualMachine::Memory index = stack.top();
	stack.pop();
	if (index.datatype != LEX_DATATYPE_INTEGER)
	{
		ReportConversionError(index.datatype, LEX_DATATYPE_INTEGER, NULL);
		return false;
	}

	VirtualMachine::Memory memory;
	memory.double_value = 0.0;
	memory.int_value = 0;
	memory.bool_value = false;
	memory.datatype = (int)inst.double_value;
	//
	int count = 0;

	if (memory.datatype ==LEX_DATATYPE_VECTOR)
	{
		if (checkIndex == true)
		{
			if (index.int_value  >= (int)memVector[inst.int_value].size() || index.int_value<0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memory.datatype = LEX_DATATYPE_DOUBLE;
		memory.double_value = memVector[inst.int_value][index.int_value];
		stack.push(memory);
		return true;
	}
	else if (memory.datatype ==LEX_DATATYPE_COMPLEX_VECTOR)
	{
		if (checkIndex == true)
		{
			if (index.int_value  >= (int)memVectorC[inst.int_value].size() || index.int_value<0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memory.datatype = LEX_DATATYPE_COMPLEX;
		memory.complex_value = memVectorC[inst.int_value][index.int_value];
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype", machineCode[instructionIndex].line_number);
	return false;
}

// A double or complex value that will be placed in the stack
bool VirtualMachine::VmMatrixCell(Compiler::Instruction& inst)
{
	VirtualMachine::Memory indexCol = stack.top();
	stack.pop();
	if (indexCol.datatype != LEX_DATATYPE_INTEGER)
	{
		ReportConversionError(indexCol.datatype, LEX_DATATYPE_INTEGER, NULL);
		return false;
	}

	VirtualMachine::Memory indexRow = stack.top();
	stack.pop();
	if (indexRow.datatype != LEX_DATATYPE_INTEGER)
	{
		ReportConversionError(indexRow.datatype, LEX_DATATYPE_INTEGER, NULL);
		return false;
	}

	VirtualMachine::Memory memory;
	memory.double_value = 0.0;
	memory.int_value = 0;
	memory.bool_value = false;
	//
	int count = 0;
	const int datatype = (int)inst.double_value;

	if (datatype ==LEX_DATATYPE_MATRIX)
	{
		if (checkIndex == true)
		{
			if (memMatrix[inst.int_value].size() == 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix is empty", machineCode[instructionIndex].line_number);
				return false;
			}
			if (indexRow.int_value  >= (int)memMatrix[inst.int_value].size() || indexRow.int_value < 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}

			if (indexCol.int_value  >= (int)memMatrix[inst.int_value][0].size() || indexCol.int_value < 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memory.datatype = LEX_DATATYPE_DOUBLE;
		memory.double_value = memMatrix[inst.int_value][indexRow.int_value][indexCol.int_value];
		stack.push(memory);
		return true;
	}
	else if (datatype ==LEX_DATATYPE_COMPLEX_MATRIX)
	{
		if (checkIndex == true)
		{
			if (memMatrixC[inst.int_value].size() == 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix is empty", machineCode[instructionIndex].line_number);
				return false;
			}
			if (indexRow.int_value  >= (int)memMatrixC[inst.int_value].size() || indexRow.int_value < 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}

			if (indexCol.int_value  >= (int)memMatrixC[inst.int_value][0].size() || indexCol.int_value < 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		memory.datatype = LEX_DATATYPE_COMPLEX;
		memory.complex_value = memMatrixC[inst.int_value][indexRow.int_value][indexCol.int_value];
		stack.push(memory);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid [", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::FuncLayerNet(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object,
	Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_LAYERNET_CREATE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"4") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"3") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"2") == false) return false;
		if (Convert(param[3], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].Create(param[3].int_value, param[2].int_value, param[1].int_value, param[0].int_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d unable to create layer network", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.lay", path, object.string_value.c_str());
		info = (wchar_t*)memLayerNet[object.int_value].Load(filename);
		returnValue.bool_value = (info ==NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.lay", path, object.string_value.c_str());
		info = (wchar_t*)memLayerNet[object.int_value].Save(filename);
		returnValue.bool_value = (info == NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_SET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].SetWeights(param[1].int_value, param[0].matrix_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		memLayerNet[object.int_value].GetWeights(param[0].int_value, returnValue.matrix_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_INPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetInputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetOutputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_HIDD1_NEU_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetHidden1NeuronCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_HIDD2_NEU_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetHidden2NeuronCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_LAYER_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetLayerCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_DELETE:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memLayerNet[object.int_value].Delete();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_UNLEARN:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memLayerNet[object.int_value].Unlearn();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_AUTO_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].AutoSetInputScaler(param[0].matrix_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_AUTO_SET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].AutoSetOutputScaler(param[0].matrix_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].SetInputScaler(param[2].int_value, 
			param[1].double_value, param[0].double_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid input scaler index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_SET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNet[object.int_value].SetOutputScaler(param[2].int_value, 
			param[1].double_value, param[0].double_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid output scaler index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		returnValue.vector_value.resize(2);
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (memLayerNet[object.int_value].GetInputScaler(param[0].int_value, 
			returnValue.vector_value[0], returnValue.vector_value[1]) == false)
		{
			returnValue.vector_value.resize(0);
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_GET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		returnValue.vector_value.resize(2);
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (memLayerNet[object.int_value].GetOutputScaler(param[0].int_value, 
			returnValue.vector_value[0], returnValue.vector_value[1]) == false)
		{
			returnValue.vector_value.resize(0);
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_SET_TRAINING_SET:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_BOOL, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_MATRIX, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		//
		//
		info = (wchar_t*)memLayerNet[object.int_value].SetTrainingSet(param[2].matrix_value, param[1].matrix_value, param[0].bool_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_GENETIC:
		{
			Math::GeneticParam gp;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"6") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"5") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[4], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[5], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			//
			gp.initPopulationSize = param[5].int_value;
			gp.numGenerations = param[4].int_value;
			gp.overPopulation = param[3].double_value;
			gp.mutationProbability = param[2].double_value;
			gp.crossoverProbability = param[1].double_value;
			gp.goal = param[0].double_value;
			//
			info = (wchar_t*)memLayerNet[object.int_value].TrainGenetic(running, progress, mse, gp);
			stack.push(returnValue);
			returnValue.bool_value = (info == NULL);
			if (returnValue.bool_value == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
				return false;
			}
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_SIMULATE_ANNEALING:
		{
			Math::SimAnnealParam ap;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"7") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"6") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_BOOL, L"5") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[4], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[5], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[6], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			//
			ap.numTemps = param[6].int_value;
			ap.numIterations = param[5].int_value;
			ap.initialTemp = param[4].double_value;
			ap.finalTemp = param[3].double_value;
			ap.isCoolingScheduleLinear = param[2].bool_value;
			ap.cycles = param[1].int_value;
			ap.goal = param[0].double_value;
			//
			info = (wchar_t*)memLayerNet[object.int_value].TrainSimAnneal(running, progress, mse, ap);
			stack.push(returnValue);
			returnValue.bool_value = (info == NULL);
			if (returnValue.bool_value == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
				return false;
			}
			//this->mse.Set(memLayerNet[object.int_value].ComputeCurrentTrueMse());
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_CONJUGATE_GRADIENT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = (wchar_t*)memLayerNet[object.int_value].TrainConjugateGradient(running, progress, mse, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_VARIABLE_METRIC:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = (wchar_t*)memLayerNet[object.int_value].TrainVariableMetric(running, progress, mse, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_LEVENBERG_MARQUARDT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = (wchar_t*)memLayerNet[object.int_value].TrainLevenbergMarquardt(running, progress, mse, param[1].int_value, param[0].double_value, false);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_TRAIN_REGRESSION:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		//
		info = (wchar_t*)memLayerNet[object.int_value].TrainRegression(running, progress, mse);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNET_GET_MIN_NUM_TRAIN_CASES:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNet[object.int_value].GetMinNumTrainCases();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNET_RUN:
		returnValue.datatype = LEX_DATATYPE_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		if (memLayerNet[object.int_value].Run(param[0].matrix_value, returnValue.matrix_value) == false)
		{
			returnValue.matrix_value.clear();
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid input matrix", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	}
	return false;
}

bool VirtualMachine::FuncLayerNetC(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object,
	Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_LAYERNETC_CREATE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNetC[object.int_value].Create(param[2].int_value, param[1].int_value, param[0].int_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d unable to create layer network", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.lax", path, object.string_value.c_str());
		info = (wchar_t*)memLayerNetC[object.int_value].Load(filename);
		returnValue.bool_value = (info ==NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.lax", path, object.string_value.c_str());
		info = (wchar_t*)memLayerNetC[object.int_value].Save(filename);
		returnValue.bool_value = (info == NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_SET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNetC[object.int_value].SetWeights(param[1].int_value, param[0].matrixC_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_GET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		memLayerNetC[object.int_value].GetWeights(param[0].int_value, returnValue.matrixC_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_GET_INPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNetC[object.int_value].GetInputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNetC[object.int_value].GetOutputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_GET_HIDD1_NEU_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNetC[object.int_value].GetHidden1NeuronCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_DELETE:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memLayerNetC[object.int_value].Delete();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_UNLEARN:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memLayerNetC[object.int_value].Unlearn();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_AUTO_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memLayerNetC[object.int_value].AutoSetInputScaler(param[0].matrixC_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_AUTO_SET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memLayerNetC[object.int_value].AutoSetOutputScaler(param[0].matrixC_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNetC[object.int_value].SetInputScaler(param[2].int_value, 
			param[1].double_value, param[0].double_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid input scaler index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_SET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memLayerNetC[object.int_value].SetOutputScaler(param[2].int_value, 
			param[1].double_value, param[0].double_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid output scaler index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_GET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		returnValue.vector_value.resize(2);
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (memLayerNetC[object.int_value].GetInputScaler(param[0].int_value, 
			returnValue.vector_value[0], returnValue.vector_value[1]) == false)
		{
			returnValue.vector_value.resize(0);
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_GET_OUTPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		returnValue.vector_value.resize(2);
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (memLayerNetC[object.int_value].GetOutputScaler(param[0].int_value, 
			returnValue.vector_value[0], returnValue.vector_value[1]) == false)
		{
			returnValue.vector_value.resize(0);
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_SET_TRAINING_SET:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_BOOL, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_COMPLEX_MATRIX, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
		//
		//
		info = (wchar_t*)memLayerNetC[object.int_value].SetTrainingSet(param[2].matrixC_value, param[1].matrixC_value, param[0].bool_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_TRAIN_GENETIC:
		{
			Math::GeneticParam gp;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"6") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"5") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[4], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[5], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			//
			gp.initPopulationSize = param[5].int_value;
			gp.numGenerations = param[4].int_value;
			gp.overPopulation = param[3].double_value;
			gp.mutationProbability = param[2].double_value;
			gp.crossoverProbability = param[1].double_value;
			gp.goal = param[0].double_value;
			//
			info = (wchar_t*)memLayerNetC[object.int_value].TrainGenetic(running, progress, mse, gp);
			stack.push(returnValue);
			returnValue.bool_value = (info == NULL);
			if (returnValue.bool_value == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
				return false;
			}
		}
		return true;
	case LEX_FUNC_LAYERNETC_TRAIN_SIMULATE_ANNEALING:
		{
			Math::SimAnnealParam ap;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"7") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"6") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_BOOL, L"5") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[4], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[5], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[6], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			//
			ap.numTemps = param[6].int_value;
			ap.numIterations = param[5].int_value;
			ap.initialTemp = param[4].double_value;
			ap.finalTemp = param[3].double_value;
			ap.isCoolingScheduleLinear = param[2].bool_value;
			ap.cycles = param[1].int_value;
			ap.goal = param[0].double_value;
			//
			info = (wchar_t*)memLayerNetC[object.int_value].TrainSimAnneal(running, progress, mse, ap);
			stack.push(returnValue);
			returnValue.bool_value = (info == NULL);
			if (returnValue.bool_value == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
				return false;
			}
		}
		return true;
	case LEX_FUNC_LAYERNETC_TRAIN_CONJUGATE_GRADIENT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = (wchar_t*)memLayerNetC[object.int_value].TrainConjugateGradient(running, progress, mse, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_TRAIN_VARIABLE_METRIC:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		//
		info = (wchar_t*)memLayerNetC[object.int_value].TrainVariableMetric(running, progress, mse, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_LAYERNETC_GET_MIN_NUM_TRAIN_CASES:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memLayerNetC[object.int_value].GetMinNumTrainCases();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_LAYERNETC_RUN:
		returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
		if (memLayerNetC[object.int_value].Run(param[0].matrixC_value, returnValue.matrixC_value) == false)
		{
			returnValue.matrix_value.clear();
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid input matrix", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	}
	return false;
}

bool VirtualMachine::FuncKohoNet(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object,
	Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_KOHONET_CREATE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memKohoNet[object.int_value].Create(param[2].int_value, param[1].int_value, param[0].int_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d unable to create Kohonen network", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.koh", path, object.string_value.c_str());
		info = (wchar_t*)memKohoNet[object.int_value].Load(filename);
		returnValue.bool_value = (info ==NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.koh", path, object.string_value.c_str());
		info = (wchar_t*)memKohoNet[object.int_value].Save(filename);
		returnValue.bool_value = (info == NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_SET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memKohoNet[object.int_value].SetWeights(param[0].matrix_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_GET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_MATRIX;
		memKohoNet[object.int_value].GetWeights(returnValue.matrix_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid weight index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_GET_INPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memKohoNet[object.int_value].GetInputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_KOHONET_GET_OUTPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memKohoNet[object.int_value].GetOutputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_KOHONET_DELETE:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memKohoNet[object.int_value].Delete();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_KOHONET_UNLEARN:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memKohoNet[object.int_value].Unlearn();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_KOHONET_AUTO_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		returnValue.bool_value = memKohoNet[object.int_value].AutoSetInputScaler(param[0].matrix_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_KOHONET_SET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		returnValue.bool_value = memKohoNet[object.int_value].SetInputScaler(param[2].int_value, 
			param[1].double_value, param[0].double_value);
		stack.push(returnValue);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid input scaler index", machineCode[instructionIndex].line_number);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_GET_INPUT_SCALER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		returnValue.vector_value.resize(2);
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (memKohoNet[object.int_value].GetInputScaler(param[0].int_value, 
			returnValue.vector_value[0], returnValue.vector_value[1]) == false)
		{
			returnValue.vector_value.resize(0);
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index", machineCode[instructionIndex].line_number);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_KOHONET_SET_TRAINING_SET:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_BOOL, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		//
		//
		info = (wchar_t*)memKohoNet[object.int_value].SetTrainingSet(param[1].matrix_value, param[0].bool_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_TRAIN_ADDITIVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
		//
		memKohoNet[object.int_value].stopWhenDone = false;
		info = (wchar_t*)memKohoNet[object.int_value].TrainAdditive(running, progress, mse, param[1].double_value, param[0].int_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_TRAIN_SUBTRACTIVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"2") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
		//
		memKohoNet[object.int_value].stopWhenDone = false;
		info = (wchar_t*)memKohoNet[object.int_value].TrainSubtractive(running, progress, mse, param[1].double_value, param[0].int_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_KOHONET_COMPUTE_WINNER:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		info = (wchar_t*)memKohoNet[object.int_value].ComputeWinner(param[0].matrix_value, returnValue.vector_value);
		if (info != NULL)
		{
			returnValue.vector_value.resize(0);
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_KOHONET_RUN:
		returnValue.datatype = LEX_DATATYPE_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		info = (wchar_t*)memKohoNet[object.int_value].Run(param[0].matrix_value, returnValue.matrix_value);
		if (info != NULL)
		{
			returnValue.matrix_value.clear();
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		stack.push(returnValue);
		return true;
	}
	return false;
}

bool VirtualMachine::FuncProbNet(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object,
	Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_PROBNET_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.prb", path, object.string_value.c_str());
		info = (wchar_t*)memProbNet[object.int_value].Load(filename);
		returnValue.bool_value = (info ==NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_PROBNET_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.prb", path, object.string_value.c_str());
		info = (wchar_t*)memProbNet[object.int_value].Save(filename);
		returnValue.bool_value = (info == NULL);
		stack.push(returnValue);
		if (info != NULL)
		{
			Sys::GetLastErrorInformation(error, 256);
			Sys::TextAssistant::DeleteChar(error, '\r');
			Sys::TextAssistant::DeleteChar(error, '\n');
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
			return false;
		}
		return true;
	case LEX_FUNC_PROBNET_SET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_VOID;
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		memProbNet[object.int_value].SetWeights(param[0].vector_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_PROBNET_GET_WEIGHTS:
		returnValue.datatype = LEX_DATATYPE_VECTOR;
		memProbNet[object.int_value].GetWeights(returnValue.vector_value);
		stack.push(returnValue);
		return true;
	case LEX_FUNC_PROBNET_GET_INPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memProbNet[object.int_value].GetInputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_PROBNET_GET_OUTPUT_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		returnValue.int_value = memProbNet[object.int_value].GetOutputCount();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_PROBNET_DELETE:
		returnValue.datatype = LEX_DATATYPE_VOID;
		memProbNet[object.int_value].Delete();
		stack.push(returnValue);
		return true;
	case LEX_FUNC_PROBNET_TRAIN_CONJUGATE_GRADIENT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"3") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_MATRIX, L"2") == false) return false;
		if (Convert(param[3], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		//
		info = (wchar_t*)memProbNet[object.int_value].TrainConjugateGradient(running, progress, mse, param[3].matrix_value, param[2].matrix_value, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_PROBNET_TRAIN_VARIABLE_METRIC:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_INTEGER, L"3") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_MATRIX, L"2") == false) return false;
		if (Convert(param[3], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		//
		info = (wchar_t*)memProbNet[object.int_value].TrainVariableMetric(running, progress, mse, param[3].matrix_value, param[2].matrix_value, param[1].int_value, param[0].double_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	case LEX_FUNC_PROBNET_RUN:
		returnValue.datatype = LEX_DATATYPE_MATRIX;
		if (Convert(param[0], LEX_DATATYPE_MATRIX, L"3") == false) return false;
		if (Convert(param[1], LEX_DATATYPE_MATRIX, L"2") == false) return false;
		if (Convert(param[2], LEX_DATATYPE_MATRIX, L"1") == false) return false;
		info = (wchar_t*)memProbNet[object.int_value].Run(param[2].matrix_value, param[1].matrix_value, param[0].matrix_value, returnValue.matrix_value);
		stack.push(returnValue);
		returnValue.bool_value = (info == NULL);
		if (returnValue.bool_value == false)
		{
			returnValue.matrix_value.clear();
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, info);
			return false;
		}
		return true;
	}
	return false;
}

bool VirtualMachine::FuncMatrix(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object, bool isComplex)
{	
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_MATRIX_CREATE:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (isComplex)
			{
				if (Math::Oper::CreateMatrix(memMatrixC[object.int_value], param[1].int_value, param[0].int_value)==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory to create matrix", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				if (Math::Oper::CreateMatrix(memMatrix[object.int_value], param[1].int_value, param[0].int_value)==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory to create matrix", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_CREATE_RANDOM:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"4") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[3], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				if (Math::Oper::CreateRandom(memMatrix[object.int_value], param[3].int_value, param[2].int_value, param[1].double_value, param[0].double_value)==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::CreateRandom no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex == true)
		{
			if (Sys::FileAssistant::CsvSave(filename, memMatrixC[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		else
		{
			if (Sys::FileAssistant::CsvSave(filename, memMatrix[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex)
		{
			if (Sys::FileAssistant::CsvLoad(filename, memMatrixC[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		else
		{
			if (Sys::FileAssistant::CsvLoad(filename, memMatrix[object.int_value])==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_APPEND_RIGHT:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		
		if (isComplex)
		{
			if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendRight(memMatrixC[object.int_value], param[0].matrixC_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendRight(memMatrix[object.int_value], param[0].matrix_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_APPEND_DOWN:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (isComplex)
		{
			if (Convert(param[0], LEX_DATATYPE_COMPLEX_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendDown(memMatrixC[object.int_value], param[0].matrixC_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Convert(param[0], LEX_DATATYPE_MATRIX, L"1") == false) return false;
			if (Math::Oper::AppendDown(memMatrix[object.int_value], param[0].matrix_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrix size is incorrect", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_ROW:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::DeleteRow(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Math::Oper::DeleteRow(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_COL:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::DeleteCol(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Math::Oper::DeleteCol(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_INSERT_ROW:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::InsertRow(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			if (Math::Oper::InsertRow(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the row index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_INSERT_COL:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			if (Math::Oper::InsertCol(memMatrixC[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{	
			if (Math::Oper::InsertCol(memMatrix[object.int_value], param[0].int_value)==false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the column index is correct", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE:
		returnValue.datatype = LEX_DATATYPE_VOID;
		if (isComplex)
		{
			memMatrixC[object.int_value].clear();
		}
		else
		{
			memMatrix[object.int_value].clear();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_ROW_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		if (isComplex)
		{
			returnValue.int_value = (int)memMatrixC[object.int_value].size();
		}
		else
		{
			returnValue.int_value = (int)memMatrix[object.int_value].size();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_COL_COUNT:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		if (isComplex)
		{
			returnValue.int_value = (int)memMatrixC[object.int_value].size() == 0 ? 0 : (int)memMatrixC[object.int_value][0].size();
		}
		else
		{
			returnValue.int_value = (int)memMatrix[object.int_value].size() == 0 ? 0 : (int)memMatrix[object.int_value][0].size();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSum(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSum(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_DIAGONAL_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetDiagonalSum(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetDiagonalSum(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MEAN:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::MeanValue(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::MeanValue(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_VARIANCE:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::Variance(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::Variance(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MINIMUM:
		if (isComplex)
		{
			int row, col;
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMagnitudeMin(memMatrixC[object.int_value], row, col);
		}
		else
		{
			int row, col;
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMinimum(memMatrix[object.int_value], row, col);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MAXIMUM:
		if (isComplex == true)
		{
			int row, col;
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMagnitudeMax(memMatrixC[object.int_value], row, col);
		}
		else
		{
			int row, col;
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMaximum(memMatrix[object.int_value], row, col);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MIN_POS:
		if (isComplex == true)
		{
			int row, col;
			returnValue.vector_value.resize(2);
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::GetMagnitudeMin(memMatrixC[object.int_value], row, col);
			returnValue.vector_value[0] = row;
			returnValue.vector_value[1] = col;
		}
		else
		{
			int row, col;
			returnValue.vector_value.resize(2);
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::GetMinimum(memMatrix[object.int_value], row, col);
			returnValue.vector_value[0] = row;
			returnValue.vector_value[1] = col;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_MAX_POS:
		if (isComplex)
		{
			int row, col;
			returnValue.vector_value.resize(2);
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::GetMagnitudeMax(memMatrixC[object.int_value], row, col);
			returnValue.vector_value[0] = row;
			returnValue.vector_value[1] = col;
		}
		else
		{
			int row, col;
			returnValue.vector_value.resize(2);
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::GetMaximum(memMatrix[object.int_value], row, col);
			returnValue.vector_value[0] = row;
			returnValue.vector_value[1] = col;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_SUM_SQUARES:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSumOfSquares(memMatrixC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSumOfSquares(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_ROWS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetRows no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			if (isComplex)
			{
				returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				if (Math::Oper::GetRows(memMatrixC[object.int_value], returnValue.matrixC_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				returnValue.datatype = LEX_DATATYPE_MATRIX;
				if (Math::Oper::GetRows(memMatrix[object.int_value], returnValue.matrix_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_COLS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetCols no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			if (isComplex)
			{
				returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				if (Math::Oper::GetCols(memMatrixC[object.int_value], returnValue.matrixC_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				returnValue.datatype = LEX_DATATYPE_MATRIX;
				if (Math::Oper::GetCols(memMatrix[object.int_value], returnValue.matrix_value, indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::GetCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_ROWS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteRows no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			returnValue.bool_value = false;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (isComplex)
			{
				if (Math::Oper::DeleteRows(memMatrixC[object.int_value], indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				if (Math::Oper::DeleteRows(memMatrix[object.int_value], indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteRows no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_DELETE_COLS:
		if (Convert(param[0], LEX_DATATYPE_VECTOR, L"1") == false) return false;
		{
			valarray<int> indexes;
			if (Sys::Convert::ValarrayToVectorInt(param[0].vector_value, indexes) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteCols no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
			returnValue.bool_value = false;
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (isComplex)
			{
				if (Math::Oper::DeleteCols(memMatrixC[object.int_value], memMatrixC[object.int_value], indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				if (Math::Oper::DeleteCols(memMatrix[object.int_value], memMatrix[object.int_value], indexes) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix::DeleteCols no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_CLASS:
		if (isComplex == true)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix does not support this method", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double threshold = param[0].double_value;
			wchar_t * error = Math::Oper::GetClass(memMatrix[object.int_value], returnValue.vector_value, threshold);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetClass %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_TRANSPOSE:
		if (isComplex == true)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			if (Math::Oper::Transpose(memMatrixC[object.int_value], returnValue.matrixC_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::Transpose no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_MATRIX;
			if (Math::Oper::Transpose(memMatrix[object.int_value], returnValue.matrix_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::Transpose no enough memory", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_PREDICTION:
		if (isComplex == true)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexMatrix does not support this method", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			returnValue.vector_value.resize(2);
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int seriesLength = param[0].int_value;
			int row = 0;
			int col = 0;
			Nn::LayerNet::ComputeBestPrediction(seriesLength, memMatrix[object.int_value], row, col);
			returnValue.vector_value[0] = row;
			returnValue.vector_value[1] = col;
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_NORM_ROWS:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::NormRows is not supported", machineCode[instructionIndex].line_number);
			return true;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			Math::Oper::NormalizeRows(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_NORM_COLS:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::NormCols is not supported", machineCode[instructionIndex].line_number);
			return true;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VOID;
			Math::Oper::NormalizeCols(memMatrix[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_ROWS_VAR:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::RowsVar is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::RowVariance(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_COLS_VAR:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::ColsVar is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::ColumnVariance(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_ROWS_MEAN:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::RowsMean is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::RowMean(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_COLS_MEAN:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::ColsMean is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::ColumnMean(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_ROWS_MIN:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::RowsMin is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::RowMinimum(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_COLS_MIN:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::ColsMin is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::ColumnMinimum(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_ROWS_MAX:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::RowsMax is not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::RowMaximum(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_COLS_MAX:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d CompleMatrix::ColsMaxis not supported", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			Math::Statistics::ColumnMaximum(memMatrix[object.int_value], returnValue.vector_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_ROW:
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			if (Math::Oper::GetRow(memMatrixC[object.int_value], returnValue.vectorC_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetRow invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			if (Math::Oper::GetRow(memMatrix[object.int_value], returnValue.vector_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetRow invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_MATRIX_GET_COL:
		if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			if (Math::Oper::GetCol(memMatrixC[object.int_value], returnValue.vectorC_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetCol invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_VECTOR;
			if (Math::Oper::GetCol(memMatrix[object.int_value], returnValue.vector_value, param[0].int_value) == false)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix::GetCol invalid index", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		stack.push(returnValue);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Matrix does not support this method", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::FuncVector(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object, bool isComplex)
{
	wchar_t filename[4*MAX_PATH];
	wchar_t error[256];
	wchar_t * info = NULL;
	Cpl::VirtualMachine::Memory returnValue;

	switch(objectFunction.subtype)
	{
	case LEX_FUNC_VECTOR_CREATE:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			if (isComplex)
			{
				try
				{
					memVectorC[object.int_value].resize(param[0].int_value);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::Create no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				try
				{
					memVector[object.int_value].resize(param[0].int_value);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::Create no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_SERIES:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const int count = param[0].int_value;
			const double firstValue = param[2].double_value;
			const double lastValue = param[1].double_value;
			//__________________________________________________ One element series
			if (count == 1)
			{
				if (isComplex)
				{
					try
					{
						memVectorC[object.int_value].resize(1);
					}
					catch(const std::bad_alloc& )
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
						return false;
					}
					memVectorC[object.int_value][0] = firstValue;
				}
				else
				{
					try
					{
						memVector[object.int_value].resize(1);
					}
					catch(const std::bad_alloc& )
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
						return false;
					}
					memVector[object.int_value][0] = firstValue;
				}
				returnValue.bool_value = true;
				stack.push(returnValue);
				return true;
			}
			
			const double delta = (lastValue- firstValue)/(count-1);
			if (isComplex)
			{
				try
				{
					memVectorC[object.int_value].resize(count);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				for(int i=0; i<count; i++)
				{
					memVectorC[object.int_value][i] = firstValue + i*delta;
				}
			}
			else
			{
				try
				{
					memVector[object.int_value].resize(count);
				}
				catch(const std::bad_alloc& )
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateSeries no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				for(int i=0; i<count; i++)
				{
					memVector[object.int_value][i] = firstValue + i*delta;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_RANDOM:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int length = param[2].int_value;
			const double minValue = param[1].double_value;
			const double maxValue = param[0].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				if (Math::Oper::CreateRandom(memVector[object.int_value], length, minValue, maxValue) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateRandom no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_BINARY:
		{
			returnValue.datatype = LEX_DATATYPE_INTEGER;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int length = param[1].int_value;
			const int decimalValue = param[0].int_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				returnValue.int_value = Math::BinaryConverter::Convert(decimalValue, length, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_SAVE:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex == true)
		{
			if (Sys::FileAssistant::CsvSave(filename, memVectorC[object.int_value], false)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		else
		{
			if (Sys::FileAssistant::CsvSave(filename, memVector[object.int_value], false)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
		}
		returnValue.bool_value = true;
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_LOAD:
		returnValue.datatype = LEX_DATATYPE_BOOL;
		_snwprintf_s(filename, 4*MAX_PATH, _TRUNCATE, L"%s\\%s.csv", path, object.string_value.c_str());
		if (isComplex)
		{
			MATRIXC tmp;
			if (Sys::FileAssistant::CsvLoad(filename, tmp)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
			returnValue.bool_value = Math::Oper::GetCol(tmp, memVectorC[object.int_value], 0);
		}
		else
		{
			MATRIX tmp;
			if (Sys::FileAssistant::CsvLoad(filename, tmp)==false)
			{
				Sys::GetLastErrorInformation(error, 256);
				Sys::TextAssistant::DeleteChar(error, '\r');
				Sys::TextAssistant::DeleteChar(error, '\n');
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s %s", objectFunction.line_number, object.string_value.c_str(), error);
				return false;
			}
			returnValue.bool_value = Math::Oper::GetCol(tmp, memVector[object.int_value], 0);
		}
		stack.push(returnValue);
		return true;
		case LEX_FUNC_VECTOR_INSERT_CELL :
			{
				returnValue.datatype = LEX_DATATYPE_BOOL;
				if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"2") == false) return false;
				if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
				const int index = param[1].int_value;
				const double value = param[0].double_value;
				if (isComplex)
				{
					if (Math::Oper::InsertCell(memVectorC[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
					memVectorC[object.int_value][index] = value;
				}
				else
				{
					if (Math::Oper::InsertCell(memVector[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
					memVector[object.int_value][index] = value;
				}
			}
			returnValue.bool_value = true;
			stack.push(returnValue);
			return true;
		case LEX_FUNC_VECTOR_DELETE_CELL:
			{
				returnValue.datatype = LEX_DATATYPE_BOOL;
				if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
				const int index = param[0].int_value;
				if (isComplex)
				{
					if (Math::Oper::DeleteCell(memVectorC[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
				}
				else
				{
					if (Math::Oper::DeleteCell(memVector[object.int_value], index) == false)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"LIne %d invalid index in vector", machineCode[instructionIndex].line_number);
						return false;
					}
				}
			}
			returnValue.bool_value = true;
			stack.push(returnValue);
			return true;
	case LEX_FUNC_VECTOR_DELETE:
			{
				returnValue.datatype = LEX_DATATYPE_VOID;
				if (isComplex)
				{
					memVectorC[object.int_value].resize(0);
				}
				else
				{
					memVector[object.int_value].resize(0);
				}
			}
			stack.push(returnValue);
			return true;
	case LEX_FUNC_VECTOR_GET_SIZE:
		returnValue.datatype = LEX_DATATYPE_INTEGER;
		if (isComplex)
		{
			returnValue.int_value = (int)memVectorC[object.int_value].size();
		}
		else
		{
			returnValue.int_value = (int)memVector[object.int_value].size();
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSum(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSum(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MEAN:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::MeanValue(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::MeanValue(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_VARIANCE:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::Variance(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::Variance(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MINIMUM:
		if (isComplex)
		{
			int position;
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMagnitudeMin(memVectorC[object.int_value], position);
		}
		else
		{
			int position;
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMinimum(memVector[object.int_value], position);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MAXIMUM:
		if (isComplex == true)
		{
			int position;
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetMagnitudeMax(memVectorC[object.int_value], position);
		}
		else
		{
			int position;
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetMaximum(memVector[object.int_value], position);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MIN_POS:
		if (isComplex == true)
		{
			returnValue.datatype = LEX_DATATYPE_INTEGER;
			Math::Statistics::GetMagnitudeMin(memVectorC[object.int_value], returnValue.int_value);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_INTEGER;
			Math::Statistics::GetMinimum(memVector[object.int_value], returnValue.int_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_MAX_POS:
		if (isComplex == true)
		{
			returnValue.datatype = LEX_DATATYPE_INTEGER;
			Math::Statistics::GetMagnitudeMax(memVectorC[object.int_value], returnValue.int_value);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_INTEGER;
			Math::Statistics::GetMaximum(memVector[object.int_value], returnValue.int_value);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_GET_SQUARED_SUM:
		if (isComplex)
		{
			returnValue.datatype = LEX_DATATYPE_COMPLEX;
			returnValue.complex_value = Math::Statistics::GetSumOfSquares(memVectorC[object.int_value]);
		}
		else
		{
			returnValue.datatype = LEX_DATATYPE_DOUBLE;
			returnValue.double_value = Math::Statistics::GetSumOfSquares(memVector[object.int_value]);
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_IMP_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::ImpulRespLowPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_LOW_PASS_FREQ_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::FreqRespLowPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_IMP_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::ImpulRespHighPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_HIGH_PASS_FREQ_RESP:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_DOUBLE, L"3") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[2], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double fc = param[0].double_value;
			const int length = param[1].int_value;
			const double beta = param[2].double_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::FreqRespHighPass(beta, length, fc, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_KAISER:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_DOUBLE, L"1") == false) return false;
			const double beta = param[1].double_value;
			const int length = param[0].int_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				Math::Dsp::KaiserWindow(beta, length, memVector[object.int_value]);
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_CREATE_RANDOM_SET:
		{
			returnValue.datatype = LEX_DATATYPE_BOOL;
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"2") == false) return false;
			if (Convert(param[1], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int length = param[1].int_value;
			const int maxValue = param[0].int_value;
			if (isComplex)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
				return false;
			}
			else
			{
				if (Math::Oper::CreateRandomSet(memVector[object.int_value], length, maxValue) ==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::CreateRandomSet invalid argument", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_WRAP:
		{
			returnValue.bool_value = true;
			if (Convert(param[0], LEX_DATATYPE_INTEGER, L"1") == false) return false;
			const int colCount = param[0].int_value;
			if (isComplex)
			{
				returnValue.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				if (Math::Oper::WrapVector(memVectorC[object.int_value], colCount, returnValue.matrixC_value) ==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector::Wrap no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				returnValue.datatype = LEX_DATATYPE_MATRIX;
				if (Math::Oper::WrapVector(memVector[object.int_value], colCount, returnValue.matrix_value) ==false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::Wrap no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
		}
		stack.push(returnValue);
		return true;
	case LEX_FUNC_VECTOR_LINE_FIT:
		if (isComplex)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
			return false;
		}
		else
		{
			try
			{
				valarray<double> x;
				const int len = (int)memVector[object.int_value].size();
				x.resize(len);
				for(int i = 0; i<len; i++)
				{
					x[i] = i;
				}
				returnValue.datatype = LEX_DATATYPE_VECTOR;
				returnValue.vector_value.resize(2);
				if (isComplex)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ComplexVector does not support this method", machineCode[instructionIndex].line_number);
					return false;
				}
				else
				{
					Math::Oper::LineFitting(x, memVector[object.int_value], returnValue.vector_value[0], returnValue.vector_value[1]);
				}
			}
			catch(const std::bad_alloc& )
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector::LineFit no enough memory", machineCode[instructionIndex].line_number);
					return false;
			}
		}
		stack.push(returnValue);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Vector does not support this method", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::FuncComplex(Compiler::Instruction& objectFunction, Cpl::VirtualMachine::Memory* param, int paramCount, Cpl::VirtualMachine::Memory& object)
{
	return true;
}

bool VirtualMachine::VmObjFunc(Compiler::Instruction& inst, Mt::BoolTs& running, Mt::DoubleTs& progress)
{
	if (inst.type != VM_OBJFUNC)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid virtual machine function", machineCode[instructionIndex].line_number);
		return false;
	}
	//____________________________________ pop object
	Cpl::VirtualMachine::Memory object = stack.top();
	stack.pop();
	const int datatype = (int)inst.double_value;
	if (object.datatype != datatype) 
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid object function", machineCode[instructionIndex].line_number);
		return false;
	}

	//____________________________________ pop parameters
	const int func_id = inst.subtype;
	const int paramCount = inst.int_value;
	if (paramCount>12)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d exceeded number of parameter", machineCode[instructionIndex].line_number);
		return false;
	}
	Cpl::VirtualMachine::Memory param[12];
	for(int i=0; i<paramCount; i++)
	{
		param[i] = stack.top();
		stack.pop();
	}

	//____________________________________ Execute function
	switch(object.datatype)
	{
	//case LEX_DATATYPE_BOOL 700
	//case LEX_DATATYPE_INTEGER 701
	//case LEX_DATATYPE_DOUBLE 702
	//case LEX_DATATYPE_VOID 703
	case LEX_DATATYPE_VECTOR: return FuncVector(inst, param, paramCount, object, false);
	case LEX_DATATYPE_MATRIX: return FuncMatrix(inst, param, paramCount, object, false);
	case LEX_DATATYPE_COMPLEX: return FuncComplex(inst, param, paramCount, object);
	case LEX_DATATYPE_COMPLEX_VECTOR: return FuncVector(inst, param, paramCount, object, true);
	case LEX_DATATYPE_COMPLEX_MATRIX: return FuncMatrix(inst, param, paramCount, object, true);
	case LEX_DATATYPE_LAYERNET: return FuncLayerNet(inst, param, paramCount, object, running, progress);
	case LEX_DATATYPE_LAYERNETC: return FuncLayerNetC(inst, param, paramCount, object, running, progress);
	case LEX_DATATYPE_KOHONET: return FuncKohoNet(inst, param, paramCount, object, running, progress);
	case LEX_DATATYPE_PROBNET: return FuncProbNet(inst, param, paramCount, object, running, progress);
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid object function", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmFunc(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory result, operator1;
	operator1 = stack.top();
	stack.pop();
	wchar_t * error = NULL;

	int rows = 0;
	int cols = 0;
	int i = 0, j = 0;

	//__________________________________________ THREE ARGUMENT FUNCTIONS
	if (inst.subtype == LEX_FUNC_CONFUSION_MATRIX)
	{	
		//____________________________________________________ 3: threshold
		Cpl::VirtualMachine::Memory operator3 = operator1;//  The first operator is now the third operator
		if (Convert(operator3, LEX_DATATYPE_DOUBLE, L"3") == false) return false; // 3, threshold
		//____________________________________________________2: target
		Cpl::VirtualMachine::Memory operator2 = stack.top(); // 2. target
		stack.pop();
		//____________________________________________________1: output
		operator1= stack.top(); // 1. output
		stack.pop();
		
		if (operator1.datatype == LEX_DATATYPE_MATRIX && operator2.datatype == LEX_DATATYPE_MATRIX)
		{
			result.datatype = LEX_DATATYPE_MATRIX;
			wchar_t * error = Math::Oper::ConfusionMatrix(operator1.matrix_value, operator2.matrix_value, result.matrix_value, operator3.double_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ConfussionMatrix %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
		else if (operator1.datatype == LEX_DATATYPE_COMPLEX_MATRIX && operator2.datatype == LEX_DATATYPE_COMPLEX_MATRIX)
		{
			result.datatype = LEX_DATATYPE_MATRIX;
			wchar_t * error = Math::Oper::ConfusionMatrix(operator1.matrixC_value, operator2.matrixC_value, result.matrix_value, operator3.double_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ConfussionMatrix %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ConfusionMatrix param 1 and 2 must be both Matrix or both MatrixC", machineCode[instructionIndex].line_number);
			return false;
		}
	}
	//__________________________________________ TWO ARGUMENT FUNCTIONS
	else if (inst.subtype == LEX_FUNC_CONVOLUTION || 
		inst.subtype == LEX_FUNC_SHORT_CONVOLUTION || 
		inst.subtype == LEX_FUNC_COMPUTE_MSE || 
		inst.subtype == LEX_FUNC_MAKE_COMPLEX ||
		inst.subtype == LEX_FUNC_POW)
	{
		Cpl::VirtualMachine::Memory operator2 = operator1; //  The first operator is now the second operator
		operator1 = stack.top();
		stack.pop();
		if (inst.subtype == LEX_FUNC_COMPUTE_MSE)
		{
			if (operator1.datatype != LEX_DATATYPE_MATRIX)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse cannot convert parameter 1 to Matrix", machineCode[instructionIndex].line_number);
				return false;
			}
			if (operator2.datatype != LEX_DATATYPE_MATRIX)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse cannot convert parameter 2 to Matrix", machineCode[instructionIndex].line_number);
				return false;
			}
			result.datatype = LEX_DATATYPE_DOUBLE;
			result.double_value = Math::Oper::ComputeMse(operator1.matrix_value, operator2.matrix_value);
			if (result.double_value < 0)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse both matrices must have the same size", machineCode[instructionIndex].line_number);
				return false;
			}
			stack.push(result);
			return true;
		}
		if (inst.subtype == LEX_FUNC_POW)
		{
			if (Convert(operator2, LEX_DATATYPE_DOUBLE, L"2") == false) return false; // 2, Exponent

			if (operator1.datatype == LEX_DATATYPE_DOUBLE)
			{
				result.datatype = LEX_DATATYPE_DOUBLE;
				result.double_value = pow(operator1.double_value, operator2.double_value);
			}
			else if (operator1.datatype == LEX_DATATYPE_INTEGER)
			{
				result.datatype = LEX_DATATYPE_DOUBLE;
				result.double_value = pow(operator1.int_value, operator2.double_value);
			}
			else if (operator1.datatype == LEX_DATATYPE_VECTOR)
			{
				result.datatype = LEX_DATATYPE_VECTOR;
				result.vector_value = pow(operator1.vector_value, operator2.double_value);
			}
			else if (operator1.datatype == LEX_DATATYPE_MATRIX)
			{
				result.datatype = LEX_DATATYPE_MATRIX;
				const int rows = (int)operator1.matrix_value.size();
				try
				{
					result.matrix_value.resize(rows);
					for(int i = 0; i<rows; i++)
					{
						result.matrix_value[i] = pow(operator1.matrix_value[i], operator2.double_value);
					}
				}
				catch(const std::bad_alloc&)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
			}
			else
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d mse cannot convert parameter 1 to double", machineCode[instructionIndex].line_number);
				return false;
			}
			stack.push(result);
			return true;
		}
		else if (inst.subtype == LEX_FUNC_MAKE_COMPLEX)
		{
			if (Convert(operator2, LEX_DATATYPE_DOUBLE, L"2") == false) return false; // 2, imag
			if (Convert(operator1, LEX_DATATYPE_DOUBLE, L"1") == false) return false; // 1, real
			result.datatype = LEX_DATATYPE_COMPLEX;
			result.complex_value.real(operator1.double_value);
			result.complex_value.imag(operator2.double_value);
			stack.push(result);
			return true;
		}
		else if (inst.subtype == LEX_FUNC_CONVOLUTION)//__________________________________________________ CONVOLUTION
		{
			if (operator1.datatype == LEX_DATATYPE_VECTOR)
			{
				if (operator2.datatype != LEX_DATATYPE_VECTOR)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution cannot convert parameter 2 to Vector", machineCode[instructionIndex].line_number);
					return false;
				}
				result.datatype = LEX_DATATYPE_VECTOR;
				if (Math::Dsp::Convolution(operator1.vector_value, operator2.vector_value, result.vector_value) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				stack.push(result);
				return true;
			}
			else if (operator1.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
			{
				if (operator2.datatype != LEX_DATATYPE_COMPLEX_VECTOR)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution cannot convert parameter 2 to ComplexVector", machineCode[instructionIndex].line_number);
					return false;
				}
				result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				if (Math::Dsp::Convolution(operator1.vectorC_value, operator2.vectorC_value, result.vectorC_value) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				stack.push(result);
				return true;
			}
			else
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution cannot convert parameter 1 to Vector", machineCode[instructionIndex].line_number);
				return false;
			}
		}
		else if (inst.subtype == LEX_FUNC_SHORT_CONVOLUTION)//__________________________________________________ SHORT CONVOLUTION
		{
			if (operator1.datatype == LEX_DATATYPE_VECTOR)
			{
				if (operator2.datatype != LEX_DATATYPE_VECTOR)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ShortConvolution cannot convert parameter 2 to Vector", machineCode[instructionIndex].line_number);
					return false;
				}
				result.datatype = LEX_DATATYPE_VECTOR;
				if (Math::Dsp::ShortConvolution(operator1.vector_value, operator2.vector_value, result.vector_value) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				stack.push(result);
				return true;
			}
			else if (operator1.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
			{
				if (operator2.datatype != LEX_DATATYPE_COMPLEX_VECTOR)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ShortConvolution cannot convert parameter 2 to ComplexVector", machineCode[instructionIndex].line_number);
					return false;
				}
				result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				if (Math::Dsp::ShortConvolution(operator1.vectorC_value, operator2.vectorC_value, result.vectorC_value) == false)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d Convolution no enough memory", machineCode[instructionIndex].line_number);
					return false;
				}
				stack.push(result);
				return true;
			}
			else
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d ShortConvolution cannot convert parameter 1 to Vector", machineCode[instructionIndex].line_number);
				return false;
			}
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_INTEGER)
	{
		result.datatype = LEX_DATATYPE_DOUBLE;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			result.double_value = sin((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			result.double_value = cos((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			result.double_value = tan((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			result.double_value = asin((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			result.double_value = acos((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			result.double_value = atan((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			result.double_value = sinh((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			result.double_value = cosh((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			result.double_value = tanh((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			result.double_value = sqrt((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			result.double_value = log10((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			result.double_value = log((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			result.double_value = exp((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			result.double_value = abs((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			result.double_value = Math::Dsp::Sinc((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			result.double_value = Math::Dsp::Triangular((double)operator1.int_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			result.double_value = Math::Dsp::Sawtooth((double)operator1.int_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			result.double_value = Math::Dsp::Rectangular((double)operator1.int_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_CEIL:
			result.double_value = ceil((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			result.double_value = floor((double)operator1.int_value);
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
			{
				std::tr1::uniform_real<double> ur (0, operator1.int_value);
				result.double_value = ur(Math::Statistics::random_generator);
				result.datatype = LEX_DATATYPE_DOUBLE;
				stack.push(result);
				return true;
			}
		case LEX_FUNC_RANDI:
			{
				std::tr1::uniform_int<int> ui (0, operator1.int_value);
				result.int_value = ui(Math::Statistics::random_generator);
				result.datatype = LEX_DATATYPE_INTEGER;
				stack.push(result);
				return true;
			}
		case LEX_FUNC_ISPRIME:
			result.datatype = LEX_DATATYPE_BOOL;
			result.bool_value = Math::Oper::IsPrime(operator1.int_value);
			stack.push(result);
			return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_DOUBLE)
	{
		result.datatype = LEX_DATATYPE_DOUBLE;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			result.double_value = sin((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			result.double_value = cos((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			result.double_value = tan((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			result.double_value = asin((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			result.double_value = acos((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			result.double_value = atan((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			result.double_value = sinh((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			result.double_value = cosh((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			result.double_value = tanh((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			result.double_value = sqrt((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			result.double_value = log10((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			result.double_value = log((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			result.double_value = exp((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			result.double_value = abs((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			result.double_value = Math::Dsp::Sinc((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			result.double_value = Math::Dsp::Triangular((double)operator1.double_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			result.double_value = Math::Dsp::Sawtooth((double)operator1.double_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			result.double_value = Math::Dsp::Rectangular((double)operator1.double_value, 2*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_CEIL:
			result.double_value = ceil((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			result.double_value = floor((double)operator1.double_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TOINT:
			result.datatype = LEX_DATATYPE_INTEGER;
			result.int_value = (int)operator1.double_value;
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
			{
				std::tr1::uniform_real<double> ur (0.0, operator1.double_value);
				result.double_value = ur(Math::Statistics::random_generator);
				result.datatype = LEX_DATATYPE_DOUBLE;
				stack.push(result);
				return true;
			}
		//case LEX_FUNC_RANDI:
		//	result.double_value = sin((double)operator1.double_value);
		//	stack.push(result);
		//	return true;
		//case LEX_FUNC_ISPRIME:
		//	result.double_value = sin((double)operator1.double_value);
		//	stack.push(result);
		//	return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_VECTOR)
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			result.vector_value = sin(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			result.vector_value = cos(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			result.vector_value = tan(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			result.vector_value = asin(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			result.vector_value = acos(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			result.vector_value = atan(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			result.vector_value = sinh(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			result.vector_value = cosh(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			result.vector_value = tanh(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			result.vector_value = sqrt(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			result.vector_value = log10(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			result.vector_value = log(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			result.vector_value = exp(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			result.vector_value = abs(operator1.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			cols = (int)operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Sinc(operator1.vector_value[i]);
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			cols = (int)operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Triangular(operator1.vector_value[i], 2.0*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			cols = (int)operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Sawtooth(operator1.vector_value[i], 2.0*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			cols = (int)operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = Math::Dsp::Rectangular(operator1.vector_value[i], 2.0*M_PI);
			stack.push(result);
			return true;
		case LEX_FUNC_CEIL:
			cols = (int)operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = ceil(operator1.vector_value[i]);
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			cols = (int)operator1.vector_value.size();
			result.vector_value.resize(cols);
			for(i=0; i<cols; i++) result.vector_value[i] = floor(operator1.vector_value[i]);
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			if (Math::Dsp::IsPowerOfTwo((int)operator1.vector_value.size()) == true)
			{
				error = (wchar_t*)Math::Dsp::Fft(operator1.vector_value, result.vectorC_value, false);
				if (error != NULL)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
					return false;
				}
			}
			else
			{
				Math::Dsp::FourierTransformRe(operator1.vector_value, result.vectorC_value);
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFTNORM:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = (wchar_t*)Math::Dsp::Fft(operator1.vector_value, result.vectorC_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			Math::Dsp::PhaseNormalization(result.vectorC_value);
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = (wchar_t*)Math::Dsp::Fft(operator1.vector_value, result.vectorC_value, true);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_REALFFT:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = (wchar_t*)Math::Dsp::RealFft(operator1.vector_value, result.vector_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_REALFFTNORM:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = (wchar_t*)Math::Dsp::RealFft(operator1.vector_value, result.vector_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			Math::Dsp::PhaseNormalization(result.vector_value);
			stack.push(result);
			return true;
		case LEX_FUNC_IREALFFT:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = (wchar_t*)Math::Dsp::RealFft(operator1.vector_value, result.vector_value, true);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = (wchar_t*)Math::Dsp::Spectrum(operator1.vector_value, result.vector_value);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
			{
				std::tr1::uniform_real<double> ur (0.0, operator1.vector_value[0]);
				cols = (int)operator1.vector_value.size();
				result.vector_value.resize(cols);
				for(i=0; i<cols; i++) result.vector_value[i] = ur(Math::Statistics::random_generator);
				stack.push(result);
				return true;
			}
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_COMPLEX_VECTOR)
	{
		result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
		switch(inst.subtype)
		{
		case LEX_FUNC_ABS:
			result.datatype = LEX_DATATYPE_VECTOR;
			{
				const int len = (int)operator1.vectorC_value.size();
				try
				{
					result.vector_value.resize(len);
				}
				catch(std::bad_alloc& )
				{
					if (error != NULL)
					{
						_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
						return false;
					}
				}
				double re, im;
				for(int i = 0; i < len; i++)
				{
					re = operator1.vectorC_value[i].real();
					im = operator1.vectorC_value[i].imag();
					result.vector_value[i] = sqrt(re*re + im*im);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			if (Math::Dsp::IsPowerOfTwo((int)operator1.vectorC_value.size()) == true)
			{
				error = (wchar_t*)Math::Dsp::Fft(operator1.vectorC_value, result.vectorC_value, false);
				if (error != NULL)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
					return false;
				}
			}
			else
			{
				Math::Dsp::FourierTransform(operator1.vectorC_value, result.vectorC_value, false);
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFTNORM:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = (wchar_t*)Math::Dsp::Fft(operator1.vectorC_value, result.vectorC_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			Math::Dsp::PhaseNormalization(result.vectorC_value);
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
			error = (wchar_t*)Math::Dsp::Fft(operator1.vectorC_value, result.vectorC_value, true);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_VECTOR;
			error = (wchar_t*)Math::Dsp::Spectrum(operator1.vectorC_value, result.vector_value);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_MATRIX)
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		switch(inst.subtype)
		{
		case LEX_FUNC_SIN:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = sin(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_COS:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = cos(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_TAN:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = tan(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ASIN:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = asin(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ACOS:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = acos(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ATAN:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = atan(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SINH :
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = sinh(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_COSH:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = cosh(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_TANH:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = tanh(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SQRT:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = sqrt(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_LOG10:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = log10(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_LOG:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = log(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_EXP:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = exp(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_ABS:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = abs(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SINC:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Sinc(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_TRIANG:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Triangular(operator1.matrix_value[i][j], 2.0*M_PI);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SAW:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Sawtooth(operator1.matrix_value[i][j], 2.0*M_PI);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RECT:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = Math::Dsp::Rectangular(operator1.matrix_value[i][j], 2.0*M_PI);
				}
			}
			stack.push(result);
		case LEX_FUNC_CEIL:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value[i].resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = ceil(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FLOOR:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrix_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value[i].resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = floor(operator1.matrix_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = (wchar_t*)Math::Dsp::Fft(operator1.matrix_value, result.matrixC_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFTNORM:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = (wchar_t*)Math::Dsp::Fft(operator1.matrix_value, result.matrixC_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			Math::Dsp::PhaseNormalization(result.matrixC_value);
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = (wchar_t*)Math::Dsp::Fft(operator1.matrix_value, result.matrixC_value, true);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_REALFFT:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = (wchar_t*)Math::Dsp::RealFft(operator1.matrix_value, result.matrix_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_REALFFTNORM:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = (wchar_t*)Math::Dsp::RealFft(operator1.matrix_value, result.matrix_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			Math::Dsp::PhaseNormalization(result.matrix_value);
			stack.push(result);
			return true;
		case LEX_FUNC_IREALFFT:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = (wchar_t*)Math::Dsp::RealFft(operator1.matrix_value, result.matrix_value, true);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = (wchar_t*)Math::Dsp::Spectrum(operator1.matrix_value, result.matrix_value);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
			{
				std::tr1::uniform_real<double> ur (0.0, operator1.matrix_value[0][0]);
				rows = (int)operator1.matrix_value.size();
				result.matrix_value.resize(rows);
				if (rows>0) cols = (int)operator1.matrix_value[0].size();
				for(i = 0; i<rows; i++)
				{
					result.matrix_value.resize(cols);
					for(j = 0; j<cols; j++)
					{
						result.matrix_value[i][j] = ur(Math::Statistics::random_generator);
					}
				}
				stack.push(result);	
			}
			return true;
		case LEX_FUNC_COVARIANCE_MATRIX:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = (wchar_t*)Math::Statistics::CovarianceMatrix(operator1.matrix_value, result.matrix_value);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_CORRELATION_MATRIX:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = (wchar_t*)Math::Statistics::CorrelationMatrix(operator1.matrix_value, result.matrix_value);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_EIGENSYSTEM:
			{
				result.datatype = LEX_DATATYPE_MATRIX;
				valarray<double> eigen_value;
				error = (wchar_t*)Math::EigenSystem::Jacobi(operator1.matrix_value, eigen_value, result.matrix_value);
				if (error != NULL)
				{
					_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
					return false;
				}
				result.matrix_value.push_back(eigen_value);
				stack.push(result);
			}
			return true;
		}
	}
	else if (operator1.datatype == LEX_DATATYPE_COMPLEX_MATRIX)
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		switch(inst.subtype)
		{
		case LEX_FUNC_ABS:
			rows = (int)operator1.matrix_value.size();
			result.matrix_value.resize(rows);
			if (rows>0) cols = (int)operator1.matrixC_value[0].size();
			for(i = 0; i<rows; i++)
			{
				result.matrix_value.resize(cols);
				for(j = 0; j<cols; j++)
				{
					result.matrix_value[i][j] = abs(operator1.matrixC_value[i][j]);
				}
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = (wchar_t*)Math::Dsp::Fft(operator1.matrixC_value, result.matrixC_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_FFTNORM:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = (wchar_t*)Math::Dsp::Fft(operator1.matrixC_value, result.matrixC_value, false);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			Math::Dsp::PhaseNormalization(result.matrixC_value);
			stack.push(result);
			return true;
		case LEX_FUNC_IFFT:
			result.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			error = (wchar_t*)Math::Dsp::Fft(operator1.matrixC_value, result.matrixC_value, true);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_SPECTRUM:
			result.datatype = LEX_DATATYPE_MATRIX;
			error = (wchar_t*)Math::Dsp::Spectrum(operator1.matrixC_value, result.matrix_value);
			if (error != NULL)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		case LEX_FUNC_RAND:
		{
				std::tr1::uniform_real<double> ur (0.0, operator1.matrix_value[0][0]);
				rows = (int)operator1.matrix_value.size();
				result.matrix_value.resize(rows);
				if (rows>0) cols = (int)operator1.matrix_value[0].size();
				for(i = 0; i<rows; i++)
				{
					result.matrix_value.resize(cols);
					for(j = 0; j<cols; j++)
					{
						result.matrix_value[i][j] = ur(Math::Statistics::random_generator);
					}
				}
				stack.push(result);
				return true;
			}
		}
	}

	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid function call", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmOper(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory operator1;
	Cpl::VirtualMachine::Memory operator2;

	operator1 = stack.top();
	stack.pop();
	operator2 = stack.top();
	stack.pop();

	switch(inst.subtype)
	{
	case LEX_PLUS:
	case LEX_MINUS:
	case LEX_ASTERISK:
	case LEX_DIVISION:
	case LEX_PERCENT_SIGN:
		return OperBinary(inst, operator2, operator1);
	case LEX_IS_BIGGER:
	case LEX_IS_BIGGER_EQ:
	case LEX_IS_LESS:
	case LEX_IS_LESS_EQ:
	case LEX_IS_EQUAL:
	case LEX_IS_DIFFERENT: 
		return OperRelational(inst, operator2, operator1);
	case LEX_OR:
	case LEX_AND:
		return OperBool(inst, operator1, operator2);
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operation", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmOperMono(Compiler::Instruction& inst)
{
	int operation = (int)inst.double_value;
	if (inst.subtype == LEX_DATATYPE_INTEGER)
	{
		switch(operation)
		{
		case LEX_PLUS_PLUS:
			memInteger[inst.int_value]++;
			return true;
		case LEX_MINUS_MINUS:
			memInteger[inst.int_value]--;
			return true;
		}
	}
	else if (inst.subtype == LEX_DATATYPE_DOUBLE)
	{
		switch(operation)
		{
		case LEX_PLUS_PLUS:
			memDouble[inst.int_value]++;
			return true;
		case LEX_MINUS_MINUS:
			memDouble[inst.int_value]--;
			return true;
		}
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmOperBina(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory operator1;

	operator1 = stack.top();
	stack.pop();

	if (Convert(operator1, inst.subtype, NULL) == false) return false;

	int operation = (int)inst.double_value;
	if (inst.subtype == LEX_DATATYPE_INTEGER)
	{
		switch(operation)
		{
		case LEX_PLUS_EQUAL:
			memInteger[inst.int_value]+=operator1.int_value;
			return true;
		case LEX_MINUS_EQUAL:
			memInteger[inst.int_value]-=operator1.int_value;
			return true;
		case LEX_PRODUCT_EQUAL:
			memInteger[inst.int_value]*=operator1.int_value;
			return true;
		case LEX_DIVISION_EQUAL:
			memInteger[inst.int_value]/=operator1.int_value;
			return true;
		}
	}
	else if (inst.subtype == LEX_DATATYPE_DOUBLE)
	{
		switch(operation)
		{
		case LEX_PLUS_EQUAL:
			memDouble[inst.int_value]+=operator1.double_value;
			return true;
		case LEX_MINUS_EQUAL:
			memDouble[inst.int_value]-=operator1.double_value;
			return true;
		case LEX_PRODUCT_EQUAL:
			memDouble[inst.int_value]*=operator1.double_value;
			return true;
		case LEX_DIVISION_EQUAL:
			memDouble[inst.int_value]/=operator1.double_value;
			return true;
		}
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::OperBinary(Compiler::Instruction& inst, VirtualMachine::Memory& operator1, VirtualMachine::Memory& operator2)
{
	Cpl::VirtualMachine::Memory result;
	int original_operator1_datatype = operator1.datatype;
	int original_operator2_datatype = operator2.datatype;
	double dtmp = 0.0;
	result.datatype = GetResultingDatatype(operator1.datatype, operator2.datatype, inst.subtype);
	int i, j, rows1, rows2, cols1, cols2;
	wchar_t* error = NULL;

	//_____________________________________________________ Vector + double
	if (operator1.datatype == LEX_DATATYPE_VECTOR && operator2.datatype == LEX_DATATYPE_DOUBLE) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = operator1.vector_value + operator2.double_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = operator1.vector_value - operator2.double_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = operator1.vector_value * operator2.double_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = operator1.vector_value / operator2.double_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ Vector + integer
	if (operator1.datatype == LEX_DATATYPE_VECTOR && operator2.datatype == LEX_DATATYPE_INTEGER) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = operator1.vector_value + (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = operator1.vector_value - (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = operator1.vector_value * (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = operator1.vector_value / (double)operator2.int_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ double + Vector
	if (operator1.datatype == LEX_DATATYPE_DOUBLE && operator2.datatype == LEX_DATATYPE_VECTOR) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = operator1.double_value + operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = operator1.double_value- operator2.vector_value ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = operator1.double_value * operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = operator1.double_value / operator2.vector_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ integer + Vector
	if (operator1.datatype == LEX_DATATYPE_INTEGER && operator2.datatype == LEX_DATATYPE_VECTOR) 
	{
		result.datatype = LEX_DATATYPE_VECTOR;
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.vector_value = (double)operator1.int_value + operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.vector_value = (double)operator1.int_value - operator2.vector_value ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.vector_value = (double)operator1.int_value * operator2.vector_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.vector_value = (double)operator1.int_value / operator2.vector_value;
			stack.push(result);
			return true;
		}
	}

	//_____________________________________________________ Matrix + double
	if (operator1.datatype == LEX_DATATYPE_MATRIX && operator2.datatype == LEX_DATATYPE_DOUBLE) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = (int)operator1.matrix_value.size();
		const int cols = (rows == 0) ? 0 : (int)operator1.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] + operator2.double_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] - operator2.double_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] * operator2.double_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] / operator2.double_value;
			stack.push(result);
			return true;
		}
	}

	//_____________________________________________________ Matrix + integer
	if (operator1.datatype == LEX_DATATYPE_MATRIX && operator2.datatype == LEX_DATATYPE_INTEGER) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = (int)operator1.matrix_value.size();
		const int cols = (rows == 0) ? 0 : (int)operator1.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] + (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] - (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] * (double)operator2.int_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.matrix_value[i] / (double)operator2.int_value;
			stack.push(result);
			return true;
		}
	}
	//_____________________________________________________ double + Matrix
	if (operator1.datatype == LEX_DATATYPE_DOUBLE && operator2.datatype == LEX_DATATYPE_MATRIX) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = (int)operator2.matrix_value.size();
		const int cols = (rows == 0) ? 0 : (int)operator2.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = operator1.double_value + operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = operator1.double_value- operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = operator1.double_value * operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = operator1.double_value / operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		}
	}

	//_____________________________________________________ integer + Matrix
	if (operator1.datatype == LEX_DATATYPE_INTEGER && operator2.datatype == LEX_DATATYPE_MATRIX) 
	{
		result.datatype = LEX_DATATYPE_MATRIX;
		const int rows = (int)operator2.matrix_value.size();
		const int cols = (rows == 0) ? 0 : (int)operator2.matrix_value[0].size();
		int i;
		try
		{
			result.matrix_value.resize(rows);
			for (i=0; i<rows; i++) result.matrix_value[i].resize(cols);
		}
		catch (const std::bad_alloc& )
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d no enough memory", machineCode[instructionIndex].line_number);
			return false;
		}
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i = 0; i<rows; i++) result.matrix_value[i] = (double)operator1.int_value + operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = (double)operator1.int_value- operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = (double)operator1.int_value * operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i = 0; i<rows; i++) result.matrix_value[i]  = (double)operator1.int_value / operator2.matrix_value[i] ;
			stack.push(result);
			return true;
		}
	}
		
	if (result.datatype == ERROR_INVALID_VALUE)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d conversion error", machineCode[instructionIndex].line_number);
		return false;
	}

	//______________________________________________________ Product:  Matrix and vectors
	switch(result.datatype)
	{
	case LEX_DATATYPE_VECTOR://_____________________________ matrix * vector
		if  (original_operator1_datatype  == LEX_DATATYPE_MATRIX && original_operator2_datatype == LEX_DATATYPE_VECTOR &&
			inst.subtype == LEX_ASTERISK)
		{
			// the number of columns of the matrix is equal to the number of rows of the vector
			error = Math::Oper::Product(operator1.matrix_value, operator2.vector_value, result.vector_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
		break;
	case LEX_DATATYPE_MATRIX://_____________________________ vector * matrix
		if  (original_operator1_datatype  == LEX_DATATYPE_VECTOR && original_operator2_datatype == LEX_DATATYPE_MATRIX &&
			inst.subtype == LEX_ASTERISK)
		{
			// the matrix must have only one row
			if (operator2.matrix_value.size() != 1)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the number of rows in the matrix must be one", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.vector_value, operator2.matrix_value, 0, result.matrix_value);
			stack.push(result);
			return true;
		}
		break;
	case LEX_DATATYPE_COMPLEX_VECTOR://_____________________________ matrixC * vectorC
		if  (original_operator1_datatype  == LEX_DATATYPE_COMPLEX_MATRIX && original_operator2_datatype == LEX_DATATYPE_COMPLEX_VECTOR &&
			inst.subtype == LEX_ASTERISK)
		{
			// the number of columns of the matrix is equal to the number of rows of the vector
			error = Math::Oper::Product(operator1.matrixC_value, operator2.vectorC_value, result.vectorC_value);
			if (error)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s", machineCode[instructionIndex].line_number, error);
				return false;
			}
			stack.push(result);
			return true;
		}
		break;
	case LEX_DATATYPE_COMPLEX_MATRIX://_____________________________ vectorC * matrixC
		if  (original_operator1_datatype  == LEX_DATATYPE_COMPLEX_VECTOR && original_operator2_datatype == LEX_DATATYPE_COMPLEX_MATRIX &&
			inst.subtype == LEX_ASTERISK)
		{
			// the matrix must have only one row
			if (operator2.matrixC_value.size() != 1)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the number of rows in the matrix must be one", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.vectorC_value, operator2.matrixC_value, 0, result.matrixC_value);
			stack.push(result);
			return true;
		}
		break;
	}
	if (Convert(operator1, result.datatype, NULL)== false) return false;
	if (Convert(operator2,result.datatype, NULL)== false) return false;

	switch(result.datatype)
	{
	//______________________________________________________________________________
	case LEX_DATATYPE_INTEGER:
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.int_value = operator1.int_value + operator2.int_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.int_value = operator1.int_value - operator2.int_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.int_value = operator1.int_value * operator2.int_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.int_value = operator1.int_value / operator2.int_value;
			stack.push(result);
			return true;
		case LEX_PERCENT_SIGN:
			result.int_value = operator1.int_value % operator2.int_value;
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_DOUBLE:
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.double_value = operator1.double_value + operator2.double_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.double_value = operator1.double_value - operator2.double_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.double_value = operator1.double_value * operator2.double_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.double_value = operator1.double_value / operator2.double_value;
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_VECTOR:
		////_____________________________ double * vector          or                double * vector
		//if  ((original_operator1_datatype  == LEX_DATATYPE_DOUBLE && original_operator2_datatype == LEX_DATATYPE_VECTOR)
		//	|| (original_operator1_datatype  == LEX_DATATYPE_INTEGER && original_operator2_datatype == LEX_DATATYPE_VECTOR))
		//{
		//	cols1 = operator1.vector_value.size();
		//	cols2 = operator2.vector_value.size();
		//	//
		//	dtmp = operator1.vector_value[0];
		//	operator1.vector_value.resize(cols2);
		//	cols1 = operator1.vector_value.size();
		//	for(i = 0; i<cols1; i++) operator1.vector_value[i] = dtmp; 
		//}
		////_____________________________ vector * double          or                interger * vector
		//else if ((original_operator2_datatype  == LEX_DATATYPE_DOUBLE && original_operator1_datatype == LEX_DATATYPE_VECTOR)
		//	|| (original_operator2_datatype  == LEX_DATATYPE_INTEGER && original_operator1_datatype == LEX_DATATYPE_VECTOR))
		//{
		//	cols1 = operator1.vector_value.size();
		//	cols2 = operator2.vector_value.size();
		//	//
		//	dtmp = operator2.vector_value[0];
		//	operator2.vector_value.resize(cols2);
		//	cols2 = operator2.vector_value.size();
		//	for(i = 0; i<cols1; i++) operator2.vector_value[i] = dtmp; 
		//}
		
		cols1 = (int)operator1.vector_value.size();
		cols2 = (int)operator2.vector_value.size();
		if (cols1 != cols2)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the vectors have different sizes", machineCode[instructionIndex].line_number);
			return false;
		}
		result.vector_value.resize(cols1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]+operator2.vector_value[i];
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]-operator2.vector_value[i];
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]*operator2.vector_value[i];
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i=0; i<cols1; i++) result.vector_value[i] = operator1.vector_value[i]/operator2.vector_value[i];
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_MATRIX:
		rows1 = (int)operator1.matrix_value.size();
		rows2 = (int)operator2.matrix_value.size();
		if (rows1>0) cols1 = (int)operator1.matrix_value[0].size();
		if (rows2>0) cols2 = (int)operator2.matrix_value[0].size();

		result.vector_value.resize(rows1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrix_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrix_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrix_value[i][j] = operator1.matrix_value[i][j]+operator2.matrix_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_MINUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrix_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrix_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrix_value[i][j] = operator1.matrix_value[i][j]-operator2.matrix_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			if (rows1 == 1 && cols1 ==1) //____________ first element is a scalar
			{
				result.matrix_value.resize(rows2);
				for(i=0; i<rows2; i++) 
				{
					result.matrix_value[i].resize(cols2);
					for(j=0; j<cols2; j++) 
					{
						result.matrix_value[i][j] = operator1.matrix_value[0][0]*operator2.matrix_value[i][j];
					}
				}
				stack.push(result);
				return true;
			}
			if (rows2 ==1 && cols2 ==1) //____________ second element is a scalar
			{
				result.matrix_value.resize(rows1);
				for(i=0; i<rows1; i++) 
				{
					result.matrix_value[i].resize(cols1);
					for(j=0; j<cols1; j++) 
					{
						result.matrix_value[i][j] = operator1.matrix_value[i][j]*operator2.matrix_value[0][0];
					}
				}
				stack.push(result);
				return true;
			}
			if (cols1 != rows2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices are not compatible", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.matrix_value, operator2.matrix_value, result.matrix_value);
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_COMPLEX:
		switch(inst.subtype)
		{
		case LEX_PLUS:
			result.complex_value = operator1.complex_value + operator2.complex_value;
			stack.push(result);
			return true;
		case LEX_MINUS:
			result.complex_value = operator1.complex_value - operator2.complex_value;
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			result.complex_value = operator1.complex_value * operator2.complex_value;
			stack.push(result);
			return true;
		case LEX_DIVISION:
			result.complex_value = operator1.complex_value / operator2.complex_value;
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_COMPLEX_VECTOR:
		cols1 = (int)operator1.vectorC_value.size();
		cols2 = (int)operator2.vectorC_value.size();
		if (cols1 != cols2)
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the vectors have different sizes", machineCode[instructionIndex].line_number);
			return false;
		}
		result.vectorC_value.resize(cols1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]+operator2.vectorC_value[i];
			stack.push(result);
			return true;
		case LEX_MINUS:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]-operator2.vectorC_value[i];
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]*operator2.vectorC_value[i];
			stack.push(result);
			return true;
		case LEX_DIVISION:
			for(i=0; i<cols1; i++) result.vectorC_value[i] = operator1.vectorC_value[i]/operator2.vectorC_value[i];
			stack.push(result);
			return true;
		}
		break;
	//______________________________________________________________________________
	case LEX_DATATYPE_COMPLEX_MATRIX:
		rows1 = (int)operator1.matrixC_value.size();
		rows2 = (int)operator2.matrixC_value.size();
		if (rows1>0) cols1 = (int)operator1.matrixC_value[0].size();
		if (rows2>0) cols2 = (int)operator1.matrixC_value[0].size();

		result.matrixC_value.resize(rows1);
		switch(inst.subtype)
		{
		case LEX_PLUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrixC_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrixC_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrixC_value[i][j] = operator1.matrixC_value[i][j]+operator2.matrixC_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_MINUS:
			if (rows1 != rows2 || cols1 != cols2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices have different sizes", machineCode[instructionIndex].line_number);
				return false;
			}
			result.matrixC_value.resize(rows1);
			for(i=0; i<rows1; i++) 
			{
				result.matrixC_value[i].resize(cols1);
				for(j=0; j<cols1; j++) 
					result.matrixC_value[i][j] = operator1.matrixC_value[i][j]-operator2.matrixC_value[i][j];
			}
			stack.push(result);
			return true;
		case LEX_ASTERISK:
			if (cols1 != rows2)
			{
				_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d the matrices are not compatible", machineCode[instructionIndex].line_number);
				return false;
			}
			Math::Oper::Product(operator1.matrixC_value, operator2.matrixC_value, result.matrixC_value);
			stack.push(result);
			return true;
		}
		break;
	}

	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::OperBool(Compiler::Instruction& inst, VirtualMachine::Memory& operator1, VirtualMachine::Memory& operator2)
{
	if (operator1.datatype != LEX_DATATYPE_BOOL || operator2.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d a bool type is expected", machineCode[instructionIndex].line_number);
		return false;
	}
	Cpl::VirtualMachine::Memory result;
	result.datatype = LEX_DATATYPE_BOOL;
	switch(inst.subtype)
	{
	case LEX_OR:
		result.bool_value = operator1.bool_value || operator2.bool_value;
		stack.push(result);
		return true;
	case LEX_AND:
		result.bool_value = operator1.bool_value && operator2.bool_value;
		stack.push(result);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::OperRelational(Compiler::Instruction& inst, VirtualMachine::Memory& operator1, VirtualMachine::Memory& operator2)
{
	Cpl::VirtualMachine::Memory result;
	result.datatype = GetResultingDatatype(operator1.datatype, operator2.datatype, inst.subtype);
	if (result.datatype != LEX_DATATYPE_INTEGER && result.datatype != LEX_DATATYPE_DOUBLE && result.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype", machineCode[instructionIndex].line_number);
		return false;
	}
	if (Convert(operator1, result.datatype, NULL) == false) return false;
	if (Convert(operator2, result.datatype, NULL) == false) return false;

	switch(inst.subtype)
	{
	case LEX_IS_BIGGER:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value > operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value > operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_BIGGER_EQ:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value >= operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value >= operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_LESS:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value < operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value < operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_LESS_EQ:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value <= operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value <= operator2.double_value;
		}
		else
		{
			_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype for the operator", machineCode[instructionIndex].line_number);
			return false;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_EQUAL:
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value == operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value == operator2.double_value;
		}
		else if (result.datatype == LEX_DATATYPE_BOOL)
		{
			result.bool_value = operator1.bool_value == operator2.bool_value;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	case LEX_IS_DIFFERENT: 
		if (result.datatype == LEX_DATATYPE_INTEGER)
		{
			result.bool_value = operator1.int_value != operator2.int_value;
		}
		else if (result.datatype == LEX_DATATYPE_DOUBLE)
		{
			result.bool_value = operator1.double_value != operator2.double_value;
		}
		else if (result.datatype == LEX_DATATYPE_BOOL)
		{
			result.bool_value = operator1.bool_value != operator2.bool_value;
		}
		result.datatype = LEX_DATATYPE_BOOL;
		stack.push(result);
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid operator", machineCode[instructionIndex].line_number);
	return false;
}

bool VirtualMachine::VmGoto(Compiler::Instruction& inst)
{
	if (inst.int_value == -1)
	{
		instructionIndex = (int)machineCode.size();
		return true;
	}
	instructionIndex = inst.int_value-1;
	return true;
}

bool VirtualMachine::VmGoFalse(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory value = stack.top();
	stack.pop();
	if (value.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d bool value expected", machineCode[instructionIndex].line_number);
		return false;
	}
	if (value.bool_value == false)
	{
		if (inst.int_value == -1)
		{
			instructionIndex = (int)machineCode.size();
			return true;
		}
		instructionIndex = inst.int_value-1;
	}
	return true;
}

bool VirtualMachine::VmGoTrue(Compiler::Instruction& inst)
{
	Cpl::VirtualMachine::Memory value = stack.top();
	stack.pop();
	if (value.datatype != LEX_DATATYPE_BOOL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d bool value expected", machineCode[instructionIndex].line_number);
		return false;
	}
	if (value.bool_value == true)
	{
		if (inst.int_value == -1)
		{
			instructionIndex = (int)machineCode.size();
			return true;
		}
		instructionIndex = inst.int_value-1;
	}
	return true;
}

bool VirtualMachine::VmCreate(Compiler::Instruction& inst)
{
	//prevent a variable from being created more than once at run time
	pair<set<wstring>::iterator, bool> returnValue = variableName.insert(inst.name);
	if (returnValue.second == false)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d %s must be declared outside: for, if, else, do-while or while", 
			machineCode[instructionIndex].line_number, inst.name);
		return false;
	}

	switch(inst.subtype)
	{
	case LEX_DATATYPE_BOOL:
		{
			bool x = false;
			memBool.push_back(x);
		}
		return true;
	case LEX_DATATYPE_DOUBLE:
		{
			double x = 0.0;
			memDouble.push_back(x);
		}
		return true;
	case LEX_DATATYPE_INTEGER:
		{
			int x = 0;
			memInteger.push_back(x);
		}
		return true;
	case LEX_DATATYPE_MATRIX: 
		{
			MATRIX x;
			memMatrix.push_back(x);
		}
		return true;
	case LEX_DATATYPE_VECTOR: 
		{
			valarray<double> x;
			memVector.push_back(x);
		}
		return true;
	case LEX_DATATYPE_COMPLEX: 
		{
			complex<double> x;
			memComplex.push_back(x);
		}
		return true;
	case LEX_DATATYPE_COMPLEX_VECTOR: 
		{
			valarray<complex<double> > x;
			memVectorC.push_back(x);
		}
		return true;
	case LEX_DATATYPE_COMPLEX_MATRIX: 
		{
			MATRIXC x;
			memMatrixC.push_back(x);
		}
		return true;
	case LEX_DATATYPE_LAYERNET:
		{
			Nn::LayerNet x;
			memLayerNet.push_back(x);
		}
		return true;
	case LEX_DATATYPE_LAYERNETC:
		{
			Nn::LayerNetC x;
			memLayerNetC.push_back(x);
		}
		return true;
	case LEX_DATATYPE_KOHONET:
		{
			Nn::KohoNet x;
			memKohoNet.push_back(x);
		}
		return true;
	case LEX_DATATYPE_PROBNET:
		{
			Nn::ProbNet x;
			memProbNet.push_back(x);
		}
		return true;
	}
	_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d invalid datatype", machineCode[instructionIndex].line_number);
	return false;
}

// It converts in place the data to the specify datatype in datatypeTarget
bool VirtualMachine::Convert(VirtualMachine::Memory& input_output, int datatypeTarget, wchar_t* caption)
{
	if (input_output.datatype == datatypeTarget) return true;


	if (datatypeTarget == LEX_DATATYPE_DOUBLE) //___________________________ double
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			input_output.double_value =  input_output.int_value;
			input_output.datatype = LEX_DATATYPE_DOUBLE;
			//_____________ clean up
			input_output.int_value = 0;
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_MATRIX) //___________________________ MATRIX
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				valarray<double> x(1);
				x[0] = input_output.int_value;
				input_output.matrix_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_MATRIX;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				valarray<double> x(1);
				x[0] = input_output.double_value;
				input_output.matrix_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_MATRIX;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_VECTOR:
			Sys::Convert::ToMatrix(input_output.vector_value, input_output.matrix_value);
			input_output.datatype = LEX_DATATYPE_MATRIX;
			//_____________ clean up
			input_output.vector_value.resize(0);
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_VECTOR) //___________________________ VECTOR
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				input_output.vector_value.resize(1);
				input_output.vector_value[0] = input_output.int_value;
				input_output.datatype = LEX_DATATYPE_VECTOR;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				input_output.vector_value.resize(1);
				input_output.vector_value[0] = input_output.double_value;
				input_output.datatype = LEX_DATATYPE_VECTOR;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX) //____________________________ COMPLEX
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				input_output.complex_value = input_output.int_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				input_output.complex_value = input_output.double_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_VECTOR) //___________________________ COMPLEX_VECTOR
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				input_output.vectorC_value.resize(1);
				input_output.vectorC_value[0] = input_output.int_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				input_output.vectorC_value.resize(1);
				input_output.vectorC_value[0] = input_output.double_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_COMPLEX:
			{
				input_output.vectorC_value.resize(1);
				input_output.vectorC_value[0] = input_output.complex_value;
				input_output.datatype = LEX_DATATYPE_COMPLEX_VECTOR;
				//_____________ clean up
				input_output.complex_value = 0.0;
			}
			return true;
		}
	}
	else if (datatypeTarget == LEX_DATATYPE_COMPLEX_MATRIX) //___________________________ COMPLEX_MATRIX
	{
		switch(input_output.datatype)
		{
		case LEX_DATATYPE_INTEGER:
			{
				valarray<complex <double> > x(1);
				x[0] = input_output.int_value;
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.int_value = 0;
			}
			return true;
		case LEX_DATATYPE_DOUBLE:
			{
				valarray<complex <double> > x(1);
				x[0] = input_output.double_value;
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.double_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_COMPLEX:
			{
				valarray<complex <double> > x(1);
				x[0] = input_output.complex_value;
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.complex_value = 0.0;
			}
			return true;
		case LEX_DATATYPE_VECTOR:
			{
				const int size = (int)input_output.vector_value.size();
				valarray<complex <double> > x(size);
				if (size>0)
				{
					for(int i=0; i< size; i++)
						x = input_output.vector_value[i];
				}
				input_output.matrixC_value.push_back(x);
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.vector_value.resize(0);
			}
			return true;
		case LEX_DATATYPE_COMPLEX_VECTOR:
			input_output.matrixC_value.push_back(input_output.vectorC_value);
			input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
			//_____________ clean up
			input_output.vectorC_value.resize(0);
			return true;
		case LEX_DATATYPE_MATRIX:
			{
				const int rows = (int)input_output.matrix_value.size();
				const int cols = (rows == 0) ? 0 : (int)input_output.matrix_value[0].size();
				int i, j;
				input_output.matrixC_value.resize(rows);
				for(i = 0; i < rows; i++)
				{
					input_output.matrixC_value[i].resize(cols);
					for(j = 0; j < cols; j++)
					{
						input_output.matrixC_value[i][j] = input_output.matrix_value[i][j];
					}
				}
				input_output.datatype = LEX_DATATYPE_COMPLEX_MATRIX;
				//_____________ clean up
				input_output.matrix_value.clear();
			}
			return true;
		}
	}

	ReportConversionError(input_output.datatype, datatypeTarget, caption);
	input_output.datatype = ERROR_INVALID_VALUE;
	return false;
}

void VirtualMachine::ReportConversionError(int datatypeFrom, int datatypeTo, wchar_t* caption)
{
	wchar_t * descrFrom = Cpl::LexicalAnalyzer::GetTokenText(datatypeFrom);
	wchar_t * descrTo = Cpl::LexicalAnalyzer::GetTokenText(datatypeTo);
	if (caption == NULL)
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d cannot convert from %s to %s", 
			machineCode[instructionIndex].line_number, descrFrom, descrTo);
	}
	else
	{
		_snwprintf_s(errorDescr, STERRORMAX, _TRUNCATE, L"Line %d parameter %s cannot be converted from %s to %s", 
			machineCode[instructionIndex].line_number, caption, descrFrom, descrTo);
	}
}

int VirtualMachine::GetResultingDatatype(int datatype1, int datatype2, int operation)
{
	if (datatype1 == datatype2) return datatype1;

	//___________________________________ Matrix * vector  (the number of columns of the matrix is equal to the number of rows of the vector)
	if (datatype1 == LEX_DATATYPE_MATRIX && datatype2 == LEX_DATATYPE_VECTOR && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_VECTOR;
	}

	//___________________________________ vector * Matrix  (the matrix must have only one row)
	if (datatype1 == LEX_DATATYPE_VECTOR && datatype2 == LEX_DATATYPE_MATRIX && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_MATRIX;
	}

	//___________________________________ MatrixC * vectorC  (the number of columns of the matrix is equal to the number of rows of the vector)
	if (datatype1 == LEX_DATATYPE_COMPLEX_MATRIX && datatype2 == LEX_DATATYPE_COMPLEX_VECTOR && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_COMPLEX_VECTOR;
	}

	//___________________________________ vectorC * MatrixC  (the matrix must have only one row)
	if (datatype1 == LEX_DATATYPE_COMPLEX_VECTOR && datatype2 == LEX_DATATYPE_COMPLEX_MATRIX && operation==LEX_ASTERISK)
	{
		return LEX_DATATYPE_COMPLEX_MATRIX;
	}

	//_________________________________ be sure "a" is the smaller data type
	int a, b;
	if (datatype1<datatype2)
	{
		a = datatype1;
		b = datatype2;
	}
	else
	{
		a = datatype2;
		b = datatype1;
	}

	switch(b)
	{
	case LEX_DATATYPE_BOOL:
		return LEX_DATATYPE_BOOL;
	case LEX_DATATYPE_INTEGER:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
			return LEX_DATATYPE_INTEGER;
		}
		break;
	case LEX_DATATYPE_DOUBLE:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
			return LEX_DATATYPE_DOUBLE;
		}
		break;
	case LEX_DATATYPE_VECTOR:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
			return LEX_DATATYPE_VECTOR;
		}
		break;
	case LEX_DATATYPE_MATRIX:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
		case LEX_DATATYPE_MATRIX:
			return LEX_DATATYPE_MATRIX;
		}
		break;
	case LEX_DATATYPE_COMPLEX:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
			return LEX_DATATYPE_COMPLEX;
		case LEX_DATATYPE_DOUBLE:
			return LEX_DATATYPE_COMPLEX;
		case LEX_DATATYPE_VECTOR:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		case LEX_DATATYPE_MATRIX:
			return LEX_DATATYPE_COMPLEX_MATRIX;
		case LEX_DATATYPE_COMPLEX:
			return LEX_DATATYPE_COMPLEX;
		}
		break;
	case LEX_DATATYPE_COMPLEX_VECTOR:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		case LEX_DATATYPE_MATRIX:
			return LEX_DATATYPE_COMPLEX_MATRIX;
		case LEX_DATATYPE_COMPLEX:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		case LEX_DATATYPE_COMPLEX_VECTOR:
			return LEX_DATATYPE_COMPLEX_VECTOR;
		}
		break;
	case LEX_DATATYPE_COMPLEX_MATRIX:
		switch(a)
		{
		case LEX_DATATYPE_BOOL:
			return ERROR_INVALID_VALUE;
		case LEX_DATATYPE_INTEGER:
		case LEX_DATATYPE_DOUBLE:
		case LEX_DATATYPE_VECTOR:
		case LEX_DATATYPE_MATRIX:
		case LEX_DATATYPE_COMPLEX:
		case LEX_DATATYPE_COMPLEX_VECTOR:
			return LEX_DATATYPE_COMPLEX_MATRIX;
		}
		break;
	}
	return ERROR_INVALID_VALUE;
}

//_____________________________________________________________________ VariableInfo
//VariableInfo::VariableInfo()
//{
//}
//
//VariableInfo::~VariableInfo()
//{
//}
//
//void VariableInfo::Clear()
//{
//	datatype.clear();
//	name.clear();
//}

//_____________________________________________________________________ PropertyInfo
//PropertyInfo::PropertyInfo()
//{
//	line = -1;
//}
//
//PropertyInfo::~PropertyInfo()
//{
//}
//	
//void PropertyInfo::Clear()
//{
//	datatype.clear();
//	name.clear();
//	line = -1;
//}
//
//bool PropertyInfo::operator<(const Cpl::PropertyInfo& init)
//{
//	return name < init.name;
//}

//_____________________________________________________________________ FunctionInfo
FunctionInfo::FunctionInfo()
{
	//isStatic = false;
	line = -1;
}

FunctionInfo::~FunctionInfo()
{
}

void FunctionInfo::Clear()
{
	name.clear();
	//returnDatatype.clear();
	//param.clear();
	//isStatic = false;
	line = -1;
	helpString.clear();
}

bool FunctionInfo::operator<(const Cpl::FunctionInfo& init)
{
	return name < init.name;
}

//_____________________________________________________________________ ClassInfo
ClassInfo::ClassInfo()
{
	line = -1;
}

ClassInfo::~ClassInfo()
{
}

void ClassInfo::Clear()
{
	name.clear();
	baseClass.clear();
	prop.clear();
	func.clear();
	line = -1;
	helpString.clear();
}
bool ClassInfo::operator<(const Cpl::ClassInfo& init)
{
	return name < init.name;
}

//_____________________________________________________________________ NamespaceInfo
NamespaceInfo::NamespaceInfo()
{
	line = -1;
}

NamespaceInfo::~NamespaceInfo()
{
}

void NamespaceInfo::Clear()
{
	name.clear();
	func.clear();
	classi.clear();
	line = -1;
	helpString.clear();
}

bool NamespaceInfo::operator<(const Cpl::NamespaceInfo& init)
{
	return name < init.name;
}

//_____________________________________________________________________ HeaderFileCompiler
HeaderFileCompiler::HeaderFileCompiler()
{
}

HeaderFileCompiler::~HeaderFileCompiler()
{
}

void HeaderFileCompiler::GelClassHelpString(vector<wstring>& lines, vector<Cpl::ClassInfo>& classi)
{
	const size_t classCount = classi.size();
	size_t i, j;
	size_t funcCount;
	for (i = 0; i < classCount; i++)
	{
		GelHelpString(lines, classi[i].line - 1, classi[i].helpString);
		funcCount = classi[i].func.size();
		for (j = 0; j < funcCount; j++)
		{
			GelHelpString(lines, classi[i].func[j].line - 1, classi[i].func[j].helpString);
		}
	}
}

void HeaderFileCompiler::GelHelpString(vector<wstring>& lines, int line_number, wstring& out_helpString)
{
	//_____________________________________ Find first comment line
	int i;
	int line;
	for (i = 1; i < 10; i++) // Go backwards trying to find the help string
	{
		line = line_number - i;
		if (IsComment(lines[line]) == false) break;
	}
	if (line + 1 == line_number) return; // Help string does not exist
	//___________________________________ Extract help string
	for (i = line+1; i < line_number; i++)
	{
		out_helpString += lines[i];
		out_helpString += L" ";
	}
	Sys::TextAssistant::Replace(out_helpString, L"//", L" ", false);
	Sys::TextAssistant::Replace(out_helpString, L"  ", L" ", false);
	Sys::TextAssistant::RemoveTrailingSpaces(out_helpString);
}

bool HeaderFileCompiler::IsComment(wstring text)
{
	Sys::TextAssistant::RemoveTrailingSpaces(text);
	const size_t len = text.size();
	if (len <= 3) return false;
	//________________ len is at least four
	if (text[0] != '/') return false;
	if (text[1] != '/') return false;
	if (text[2] == '_') return false;
	if (text[3] == '_') return false;
	return true; 
}

bool HeaderFileCompiler::GetClassList(const wchar_t* headerFilename, vector<Cpl::NamespaceInfo>& output)
{
	output.clear();
	//_____________________________________________________________ Read the File
	string content;
	wstring wcontent;
	if (Sys::FileAssistant::TextLoad(headerFilename, content) == false)
	{
		errorString = L"Cpl::Assistant::GetClassList: The file could not be open";
		return false;
	}
	Sys::Convert::StringToWstring(content, wcontent);
	vector<wstring> lines;
	Sys::Convert::ToVectorOfStrings(wcontent, lines);
	//_____________________________________________________________ Lexical Analysis
	if (lexer.Create(wcontent.c_str()) == false)
	{
		errorString = L"Cpl::Assistant::GetClassList: the lexical analyzer was not able to read the information";
		return false;
	}
	//lexer.Debug(debugString);
	//return NULL;
	bool stay = false;
	while (true)
	{
		if (stay == false) lexer.GetNextToken(lookahead);
		if (lookahead.type == LEX_END_OF_FILE) break;
		if (Cpl::LexicalAnalyzer::IsError(lookahead) == true)
		{
			Cpl::LexicalAnalyzer::GetErrorText(lookahead, errorString);
			return false;
		}
		if (lookahead.type == LEX_NAMESPACE)
		{
			stay = Namespace(output);
		}
		else
		{
			stay = false;
		}
	}
	//_______________________________________________________________ Sort Classes
	const size_t namespaceCount = output.size();
	size_t i, j;
	for (i = 0; i < namespaceCount; i++)
	{
		sort(output[i].classi.begin(), output[i].classi.end());
		GelClassHelpString(lines, output[i].classi);
	}
	//______________________________________________________________ Sort Functions
	size_t classCount;
	for (i = 0; i < namespaceCount; i++)
	{
		classCount = output[i].classi.size();
		for (j = 0; j < classCount; j++)
		{
			if (output[i].classi[j].name == L"PointF") continue; // Skip this class as we will move the functions
			sort(output[i].classi[j].func.begin(), output[i].classi[j].func.end());
		}
	}
	return true;
}

// This function returns true when there is another namespace ready to be processed
bool HeaderFileCompiler::Namespace(vector<Cpl::NamespaceInfo>& output)
{
	if (lookahead.type != LEX_NAMESPACE) return false; // Imposible to get here
	lexer.GetNextToken(lookahead);
	if (lookahead.type != LEX_ID) return false;
	wstring id = lookahead.string_value;
	lexer.GetNextToken(lookahead);
	if (lookahead.type == LEX_LEFT_CURLY_BRACKET)
	{
		lexer.GetNextToken(lookahead);
		Cpl::NamespaceInfo ni;
		ni.name = id;
		output.push_back(ni);
		return NamespaceContent(output.back());
	}
	else if (lookahead.type == LEX_SEMICOLON)
	{
		// this might be a: using namespace ..., just ignore it
		lexer.GetNextToken(lookahead);
		return false;
	}
	return false;
}

// This function returns true when there is another namespace ready to be processed
bool HeaderFileCompiler::NamespaceContent(Cpl::NamespaceInfo& output)
{
	bool stay = false;
	while (true)
	{
		if (lookahead.type == LEX_NAMESPACE)
		{
			return true;
		}
		else if (lookahead.type == LEX_CLASS)
		{
			stay = Class(output.classi);
		}
		else if (lookahead.type == LEX_STRUCT)
		{
			stay = Struct();
		}
		//else if (lookahead.type == LEX_STATIC)
		//{
		//	Cpl::FunctionInfo fi;
		//	output.func.push_back(fi);
		//	stay = StaticFunction(output.func.back());
		//}
		else
		{
			stay = false;
		}
		if (lookahead.type == LEX_END_OF_FILE) return true;
		if (stay == false) lexer.GetNextToken(lookahead);
	}
	return false;
}

bool HeaderFileCompiler::Struct()
{
	if (lookahead.type != LEX_STRUCT) return false; // Imposible to get here
	lexer.GetNextToken(lookahead);
	if (lookahead.type != LEX_ID) return false;
	int count = 0;
	while (lookahead.type != LEX_END_OF_FILE)
	{
		if (lookahead.type == LEX_NAMESPACE) return true;
		if (lookahead.type == LEX_CLASS) return true;
		if (lookahead.type == LEX_STRUCT) return true;
		if (lookahead.type == LEX_LEFT_CURLY_BRACKET)
		{
			count++;
		}
		else if (lookahead.type == LEX_RIGHT_CURLY_BRACKET)
		{
			count--;
			if (count == 0)
			{
				return false;
			}
		}
		lexer.GetNextToken(lookahead);
	}
	return false;
}

// This function returns true when there is another object ready to be processed
bool HeaderFileCompiler::Class(vector<Cpl::ClassInfo>& classi)
{
	//_______________________________________________________________________ class
	if (lookahead.type != LEX_CLASS) return false; // Imposible to get here
	Cpl::ClassInfo ci;
	ci.line = lookahead.line_number;
	lexer.GetNextToken(lookahead);
	//________________________________________________________________________ class ID
	if (lookahead.type != LEX_ID)
	{
		if (lookahead.type == LEX_FUNC_EIGENSYSTEM)
		{
		}
		else if (lookahead.type == LEX_DATATYPE_LAYERNET)
		{
		}
		else if (lookahead.type == LEX_DATATYPE_KOHONET)
		{
		}
		else if (lookahead.type == LEX_DATATYPE_PROBNET)
		{
		}
		else
		{
			return false;
		}
	}
	ci.name = lookahead.string_value;
	lexer.GetNextToken(lookahead);
	//________________________________________________________________________ class ID : public ID
	while (lookahead.type != LEX_LEFT_CURLY_BRACKET)
	{
		if (lookahead.type == LEX_END_OF_FILE) return true;
		if (lookahead.type == LEX_CLASS) return true;
		if (lookahead.type == LEX_NAMESPACE) return true;
		ci.baseClass += lookahead.string_value;
		ci.baseClass += L" ";
		lexer.GetNextToken(lookahead);
	}
	//________________________________________________________________________ class ID : public ID {
	if (lookahead.type != LEX_LEFT_CURLY_BRACKET) return false;
	lexer.GetNextToken(lookahead);
	
	//________________________________________________________________________ Move until find public:
	while (lookahead.type != LEX_PUBLIC)
	{
		if (lookahead.type == LEX_END_OF_FILE) return true;
		if (lookahead.type == LEX_CLASS) return true;
		if (lookahead.type == LEX_NAMESPACE) return true;
		if (lookahead.type == LEX_STRUCT) return true;
		lexer.GetNextToken(lookahead);
	}
	lexer.GetNextToken(lookahead);
	if (lookahead.type != LEX_COLON) return false;
	classi.push_back(ci);
	return ClassContent(classi.back());
}

// This function returns true when there is another object ready to be processed
bool HeaderFileCompiler::ClassContent(Cpl::ClassInfo& ci)
{
	if (lookahead.type != LEX_COLON) return false;
	lexer.GetNextToken(lookahead); // Move after colon
	wstring tmp;
	int count = 1;
	while (true)
	{
		if (lookahead.type == LEX_END_OF_FILE) return true;
		if (lookahead.type == LEX_CLASS) return true;
		if (lookahead.type == LEX_NAMESPACE) return true;
		//if (lookahead.type == LEX_STRUCT) return true;
		if (lookahead.type == LEX_PRIVATE)
		{
			return false;
		}
		if (lookahead.type == LEX_PROTECTED) return false;
		if (lookahead.type == LEX_LEFT_CURLY_BRACKET) count++;
		if (lookahead.type == LEX_RIGHT_CURLY_BRACKET)
		{
			count--;
			if (count == 0) return false;
		}
		if (lookahead.type == LEX_LEFT_CURLY_BRACKET) // Inline Function
		{
			GetFunctionOrProperty(lookahead.line_number-1, tmp, ci); // The function is the line before at the left curly bracket
			tmp.clear();
			// Move to the end of the function
			int funcCount = 1;
			lexer.GetNextToken(lookahead);
			while (true)
			{
				if (lookahead.type == LEX_END_OF_FILE) return true;
				if (lookahead.type == LEX_CLASS) return true;
				if (lookahead.type == LEX_NAMESPACE) return true;
				//if (lookahead.type == LEX_STRUCT) return true;
				if (lookahead.type == LEX_PRIVATE) return false;
				if (lookahead.type == LEX_PROTECTED) return false;
				if (lookahead.type == LEX_LEFT_CURLY_BRACKET) funcCount++;
				if (lookahead.type == LEX_RIGHT_CURLY_BRACKET)
				{
					funcCount--;
					if (funcCount == 0) break;
				}
				lexer.GetNextToken(lookahead);
			}
		}
		else if (lookahead.type == LEX_SEMICOLON) // Variables, Functions and Properties
		{
			GetFunctionOrProperty(lookahead.line_number, tmp, ci);
			tmp.clear();
		}
		else
		{
			tmp += lookahead.string_value;
			tmp += L" ";
		}
		lexer.GetNextToken(lookahead);
	}
	return false;
}

bool HeaderFileCompiler::StaticFunction(Cpl::FunctionInfo& output)
{
	if (lookahead.type != LEX_STATIC) return false; // Imposible to get here
	lexer.GetNextToken(lookahead);
	if (lookahead.type != LEX_ID) return false;
	int count = 0;
	while (lookahead.type != LEX_END_OF_FILE)
	{
		if (lookahead.type == LEX_NAMESPACE) return true;
		if (lookahead.type == LEX_CLASS) return true;
		if (lookahead.type == LEX_STRUCT) return true;
		if (lookahead.type == LEX_LEFT_CURLY_BRACKET)
		{
			count++;
		}
		else if (lookahead.type == LEX_RIGHT_CURLY_BRACKET)
		{
			count--;
			if (count == 0)
			{
				return false;
			}
		}
		lexer.GetNextToken(lookahead);
	}
	return false;
}

bool HeaderFileCompiler::IsProperty(const wstring& text)
{
	int left = 0;
	int right = 0;
	const size_t len = text.length();
	for (size_t i = 0; i < len; i++)
	{
		if (text[i] == '(') left++;
		if (text[i] == ')') right++;
	}
	if (text.find(L"__declspec") == std::wstring::npos) return false;
	if (text.find(L"property") == std::wstring::npos) return false;
	return (left == 2 && right == 2);
}

bool HeaderFileCompiler::IsFunction(const wstring& text)
{
	int left = 0;
	int right = 0;
	const size_t len = text.length();
	for (size_t i = 0; i < len; i++)
	{
		if (text[i] == '(') left++;
		if (text[i] == ')') right++;
	}
	if (text.find(L"__declspec") != std::wstring::npos) return false;
	if (text.find(L"(property(") != std::wstring::npos) return false;
	return (left == 1 && right == 1);
}

bool HeaderFileCompiler::GetFunction(const wstring& text, Cpl::FunctionInfo& fi)
{
	fi.name = text;
	Sys::TextAssistant::Replace(fi.name, L"  ", L" ", false);
	Sys::TextAssistant::Replace(fi.name, L" , ", L", ", false);
	Sys::TextAssistant::Replace(fi.name, L" & ", L"& ", false);
	Sys::TextAssistant::Replace(fi.name, L" * ", L"* ", false);
	Sys::TextAssistant::Replace(fi.name, L" ( ", L"(", false);
	Sys::TextAssistant::Replace(fi.name, L" (", L"(", false);
	Sys::TextAssistant::Replace(fi.name, L"( ", L"(", false);
	Sys::TextAssistant::Replace(fi.name, L" ) ", L")", false);
	Sys::TextAssistant::Replace(fi.name, L" )", L")", false);
	Sys::TextAssistant::Replace(fi.name, L" : : ", L"::", false);
	Sys::TextAssistant::Replace(fi.name, L" < ", L"<", false);
	Sys::TextAssistant::Replace(fi.name, L" > ", L">", false);
	Sys::TextAssistant::RemoveTrailingSpaces(fi.name);
	return true;
}

bool HeaderFileCompiler::GetProperty(const wstring& text, wstring& out_property)
{
	int count = 0;
	const size_t len = text.size();
	for (size_t i = 0; i < len; i++)
	{
		if (text[i] == '(') count++;
		if (text[i] == ')')
		{
			count--;
			if (count == 0)
			{
				for (size_t j = i + 1; j < len; j++)
				{
					out_property.push_back(text[j]);
				}
				Sys::TextAssistant::Replace(out_property, L"  ", L" ", false);
				Sys::TextAssistant::Replace(out_property, L" : : ", L"::", false);
				Sys::TextAssistant::Replace(out_property, L" & ", L"& ", false);
				//Sys::TextAssistant::Replace(out_property, L" < ", L"<", false);
				//Sys::TextAssistant::Replace(out_property, L" > ", L">", false);
				Sys::TextAssistant::RemoveTrailingSpaces(out_property);
				return true;
			}
		}
	}
	//__declspec(property (get = IsFirstTime)) bool FirstTime;
	return false;
}

bool HeaderFileCompiler::GetFunctionOrProperty(int line_number, const wstring& text, Cpl::ClassInfo& ci)
{
	if (IsProperty(text) == true)
	{
		wstring pro;
		if (GetProperty(text, pro) == true)
		{
			ci.prop.push_back(pro);
			return true;
		}
		return false;
	}
	else if (IsFunction(text) == true)
	{
		Cpl::FunctionInfo fi;
		fi.line = line_number;
		if (GetFunction(text, fi) == true)
		{
			ci.func.push_back(fi);
			return true;
		}
		return false;
	}
	return false;
}

} //____________________________________________________ namespace Cpl::End

namespace Pdf //________________________________________ namespace Pdf::Ini
{

//_____________________________________________________________________ Value
Value::Value()
{
	data = NULL;
	Delete();
}

Value::~Value()
{
	if (data != NULL) delete[] data;
}


Value::Value(const Pdf::Value& init)
{
	data = NULL;
	Copy(init);
}

void Value::Delete()
{
	if (data != NULL) delete [] data;
	type = PDF_VALUE_NULL;
	data = NULL;
	length = 0;
	ref_id = 0;
	ref_generation_number = 0;
	value.clear();
	dictionary.clear();
}

Pdf::Value& Value::operator=(const Pdf::Value& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Value::Copy(const Pdf::Value& init)
{
	if (init.data != NULL)
	{
		data = new unsigned char[init.length];
		::memcpy(data, init.data, init.length);
	}
	//
	value = init.value;
	type = init.type;
	length = init.length;
	ref_id = init.ref_id;
	ref_generation_number = init.ref_generation_number;
	dictionary = init.dictionary;
}

bool Value::GetInteger(int &output)
{
	output = 0;
	if (this->data == NULL) return false;
	return Sys::TextAssistant::GetInteger(this->data, output);
}

void Value::SetInteger(int value)
{
	type = PDF_VALUE_DATA;
	if (data != NULL) delete[] data;
	char text[32];
	_snprintf_s(text, 32, "%d", value);
	length = strlen(text)+1;
	data = new unsigned char[length];
	::memcpy(data, text, length);
}

bool Value::GetDouble(double & output)
{
	output = 0;
	if (this->data == NULL) return false;
	return Sys::TextAssistant::GetDouble(this->data, output);
}

void Value::SetDouble(double value)
{
	type = PDF_VALUE_DATA;
	if (data != NULL) delete[] data;
	char text[32];
	_snprintf_s(text, 32, "%f", value);
	length = strlen(text)+1;
	data = new unsigned char[length];
	::memcpy(data, text, length);
}

bool Value::GetBoolean(bool & output)
{
	output = false;
	if (this->data == NULL) return false;
	if (strcmp((char*)data, "true") == 0)
	{
		output = true;
		return true;
	}
	if (strcmp((char*)data, "false") == 0)
	{
		output = false;
		return true;
	}
	return false;
}

void Value::SetBoolean(bool value)
{
	type = PDF_VALUE_DATA;
	if (data != NULL) delete[] data;
	char text[32];
	if (value)
	{
		_snprintf_s(text, 32, "true");
	}
	else
	{
		_snprintf_s(text, 32, "false");
	}
	length = strlen(text)+1;
	data = new unsigned char[length];
	::memcpy(data, text, length);
}

bool Value::SetData(const unsigned char* input, size_t input_length)
{
	if (data != NULL) delete[] data;
	data = NULL;
	if (input_length == 0)
	{
		length = 0;
		return true;
	}
	if (input == NULL) return true;
	//_________________________ Copy
	data = new unsigned char[input_length];
	if (data == NULL) return false;
	length = input_length;
	for(size_t i = 0; i < input_length; i++)
	{
		data[i] = input[i];
	}
	return true;
}

const wchar_t* Value::GetText()
{
	if (type == PDF_VALUE_NULL) return L"PDF_VALUE_NULL";
	else if (type == PDF_VALUE_DATA) return L"PDF_VALUE_DATA";
	else if (type == PDF_VALUE_NAME) return L"PDF_VALUE_NAME";
	else if (type == PDF_VALUE_LITERALSTRING) return L"PDF_VALUE_LITERALSTRING";
	else if (type == PDF_VALUE_HEXSTRING) return L"PDF_VALUE_HEXSTRING";
	else if (type == PDF_VALUE_ARRAY) return L"PDF_VALUE_ARRAY";
	else if (type == PDF_VALUE_REFERENCE) return L"PDF_VALUE_REFERENCE";
	else if (type == PDF_VALUE_DICTIONARY) return L"PDF_VALUE_DICTIONARY";
	return L"Error";
}

void Value::GetWchar(wstring& output)
{
	if (data == NULL) return;
	if (length == 0) return;
	for(size_t i = 0; i < length-1; i++)
	{
		output += (wchar_t)data[i];
	}
}

void Value::PrivateGetText(wstring& output, size_t& indentationLevel)
{
	size_t i;
	size_t k;
	if (type == PDF_VALUE_NULL)
	{
		//output += L"NULL";
	}
	else if (type == PDF_VALUE_DATA || type == PDF_VALUE_NAME)
	{
		GetWchar(output);
	}
	else if (type == PDF_VALUE_LITERALSTRING)
	{
		output += L"(";
		GetWchar(output);
		output += L")";
	}
	else if (type == PDF_VALUE_HEXSTRING)
	{
		output += L"<";
		GetWchar(output);
		output += L">";
	}
	else if (type == PDF_VALUE_ARRAY)
	{
		output += L"[";
		const size_t len = value.size();
		for (i = 0; i < len; i++)
		{
			value[i].PrivateGetText(output, indentationLevel);
			if (i != len-1) output += L" ";
		}
		output += L"]";
	}
	else if (type == PDF_VALUE_REFERENCE)
	{
		wchar_t text[32];
		_snwprintf_s(text, 32, _TRUNCATE, L"%d %d R", ref_id, ref_generation_number);
		output += text;
	}
	else if (type == PDF_VALUE_DICTIONARY)
	{
		if (IsLineReturn(output) == false) output += L"\r\n";
		for (k = 0; k < indentationLevel; k++) output +=L"   ";
		output += L"<<\r\n";
		indentationLevel++;
		const size_t len = dictionary.size();
		wstring wname;
		for (i = 0; i < len; i++)
		{
			for (k = 0; k < indentationLevel; k++) output +=L"   ";
			Sys::Convert::StringToWstring(dictionary[i].name, wname);
			output += wname;
			output += L" ";
			//____________________________
			dictionary[i].value.PrivateGetText(output, indentationLevel);
			if (IsLineReturn(output) == false) output += L"\r\n";
		}
		indentationLevel--;
		for (k = 0; k < indentationLevel; k++) output +=L"   ";
		output += L">>\r\n";
	}
}

void Value::GetText(wstring& output)
{
	output.clear();
	size_t indentationLevel = 0;
	PrivateGetText(output, indentationLevel);
}

bool Value::IsLineReturn(wstring& text)
{
	if (text.empty()) return true;
	return (text[text.size()-1] == '\n');
}

//_____________________________________________________________________ DictionaryItem
DictionaryItem::DictionaryItem()
{
}

DictionaryItem::~DictionaryItem()
{
}

void DictionaryItem::Delete()
{
	name.clear();
	value.Delete();
}

//_____________________________________________________________________ Object	
Object::Object()
{
	stream = NULL;
	Delete();
}

Object::~Object()
{
	if (stream != NULL) delete[] stream;
}

Object::Object(const Pdf::Object& init)
{
	stream = NULL;
	Copy(init);
}

Pdf::Object& Object::operator=(const Pdf::Object& init)
{
	Delete();
	Copy(init);
	return *this;
}

void Object::Delete()
{
	id = 0;
	generation_number = 0;
	stream_length = 0;
	if (stream != NULL) delete[] stream;
	stream = NULL;
	value.Delete();
}

void Object::Copy(const Pdf::Object& init)
{
	id = init.id;
	generation_number = init.generation_number;
	stream_length = init.stream_length;
	value = init.value;
	if (init.stream != NULL)
	{
		stream = new char[stream_length];
		if (stream == NULL) stream_length = 0;
		::memcpy(stream, init.stream, init.stream_length);
	}
}

//_____________________________________________________________________ Pdf::Token
Token::Token()
{
	Constructor();
}

Token::Token(const Pdf::Token& init)
{
	Constructor();
	Copy(init);
}

Token::~Token()
{
	if (data != NULL) delete [] data;
}

bool Token::IsID()
{
	if (type != LEX_PDF_DATA) return false;
	if (data == NULL) return false;
	const size_t len = length-1;
	for(size_t i = 0; i < len; i++)
	{
		if (data[i] < '0') return false;
		if ('9' < data[i]) return false;
	}
	return true;
}

void Token::Delete()
{
	if (data != NULL) delete [] data;
	Constructor();
}

void Token::Copy(const Pdf::Token& init)
{
	type = init.type;
	//______________________________________________ Copy stream data
	data = NULL;
	if (init.data != NULL)
	{
		data = new unsigned char[init.length];
		if (data == NULL)
		{
			length = 0;
			return;
		}
		::memcpy(data, init.data, init.length);
	}
	line_number = init.line_number;
	length = init.length;
}

Pdf::Token& Token::operator=(const Pdf::Token& init)
{
	if (data != NULL) delete [] data;
	Copy(init);
	return *this;
}

void Token::Constructor()
{
	type = LEX_END_OF_FILE;
	data = NULL;
	line_number = -1;
	length = 0;
}

bool Token::SetText(const char* text)
{
	if (data != NULL) delete[] data;
	length = 0;
	const size_t len = strlen(text)+1;
	data = new unsigned char[len];
	if (data == NULL) return false;
	::memcpy(data, text, len);
	length = len;
	return true;
}

const wchar_t* Token::GetTypeText()
{
	if (type == ERROR_SYNTAX) return L"ERROR_SYNTAX";
	else if (type == ERROR_VARIABLE_ALREADY_DEFINED) return L"ERROR_VARIABLE_ALREADY_DEFINED";
	else if (type == ERROR_VARIABLE_NOEXISTS) return L"ERROR_VARIABLE_NOEXISTS";
	else if (type == ERROR_INVALID_OBJECT_FUNC) return L"ERROR_INVALID_OBJECT_FUNC";
	else if (type == ERROR_VARIABLE_UNINIT) return L"ERROR_VARIABLE_UNINIT";
	else if (type == ERROR_INVALID_PARAM) return L"ERROR_INVALID_PARAM";
	else if (type == ERROR_MISSING_TOKEN) return L"ERROR_MISSING_TOKEN";
	else if (type == ERROR_INCOMPLETE_COMMAND) return L"ERROR_INCOMPLETE_COMMAND";
	else if (type == ERROR_MISSING_VARIABLE) return L"ERROR_MISSING_VARIABLE";
	else if (type == ERROR_LEX) return L"ERROR_LEX";
	else if (type == ERROR_INVALID_VALUE) return L"ERROR_INVALID_VALUE";
	return L"Unknown Error";
}

void Token::GetText(wstring& output)
{
	output.clear();
	if (data == NULL) return;
	size_t i;
	const size_t len = length - 1;
	output.resize(len);
	for (i = 0; i < len; i++)
	{
		output[i] = data[i];
	}
}

//_____________________________________________________________________ LexicalAnalyzer
LexicalAnalyzer::LexicalAnalyzer(void)
{
	Delete();
}

LexicalAnalyzer::~LexicalAnalyzer(void)
{
	Close();
}

void LexicalAnalyzer::Delete()
{
	majorVersion = 0;
	minorVersion = 0;
	line_number = 1;
	isTokenANext= true;
	keyword.clear();
}

void LexicalAnalyzer::Peek1Token(Pdf::Token& token)
{
	if (isTokenANext)
	{
		token = tokenA;
	}
	else
	{
		token = tokenB;
	}
}

void LexicalAnalyzer::Peek2Token(Pdf::Token& token)
{
	if (isTokenANext)
	{
		token = tokenB;
	}
	else
	{
		token = tokenA;
	}
}

bool LexicalAnalyzer::Create(const wchar_t* filename)
{
	Delete();
	FillKeywords(keyword);
	const bool ok = Open(filename);
	PrivateGetNextToken(tokenA);
	PrivateGetNextToken(tokenB);
	return ok;
}

void LexicalAnalyzer::FillKeywords(unordered_map<wstring, int>& keyword)
{
	int type;
	wchar_t * text = NULL;
	//_____________________________________________________________________ Data type
	for (type = LEX_PDF_OBJ; type <= LEX_PDF_STARTXREF; type++)
	{
		text = Cpl::LexicalAnalyzer::GetTokenText(type);
		if (text == NULL) break;
		keyword[text] = type;
	}
}

void LexicalAnalyzer::GetNextToken(Pdf::Token& token)
{
	if (isTokenANext)
	{
		token = tokenA;
		isTokenANext = false;
		PrivateGetNextToken(tokenA);
	}
	else
	{
		token = tokenB;
		isTokenANext = true;
		PrivateGetNextToken(tokenB);
	}
}

void LexicalAnalyzer::PrivateGetNextToken(Pdf::Token& token)
{
	int i=0;
	char* text = NULL;
	char c;
	token.Delete();
	token.line_number = line_number;

	//_________________________ Have we reached the end of the file?
	if (Peek(c) == false)
	{
		token.type = LEX_END_OF_FILE;
		return;
	}
	//_________________________ find the token
	while(Peek(c))
	{
		if (ProcessComments(c, token) == true)
		{
			continue;
		}
		else if (c == ' ' || c == '\t' || c == '\r') //________________ skip
		{
			if (Advance() == false) return;
			continue;
		}
		else if (c == '\n') //_________________ update line number
		{
			line_number++;
			if (Advance() == false) return;
		}
		else if (ProcessSeparator(token) == true)
		{
			return;
		}
		else if (c == '/') //_________________ it is a Name
		{
			ProcessName(c, token);
			return;
		}
		else
		{
			ProcessData(token);
			return;
		}
	}
}

bool LexicalAnalyzer::ProcessKeywords(Pdf::Token& token)
{
	if (token.type != LEX_PDF_DATA) return false;
	wstring text;
	token.GetText(text);
	unordered_map<wstring, int>::iterator p = keyword.find(text);
	if (p != keyword.end())
	{
		token.type = p->second;
		token.line_number = line_number;
		return true;
	}
	return false;
}

void LexicalAnalyzer::ProcessName(char c, Pdf::Token& token)
{
	if (c != '/') return;
	if (Advance() == false) return;
	string name;
	name = "/";
	while (Peek(c))
	{
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '(' || c == ')' || c == '/' || c == '\\' || c == '[' || c == ']' || c == '[' || c == ']' || c == '<' || c == '>')
		{
			const size_t len = name.size();
			token.data = new unsigned char[len+1];
			for (size_t i = 0; i < len; i++)
			{
				token.data[i] = name[i];
			}
			token.data[len] = '\0';
			token.length = len+1;
			token.type = LEX_PDF_NAME;
			token.line_number = line_number;
			return;
		}
		else
		{
			name += c;
			if (Advance() == false) return; //Imposible to get here
		}
	}
}

void LexicalAnalyzer::ProcessData(Pdf::Token& token)
{
	char c;
	string name;
	while (Peek(c))
	{
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '(' || c == ')' || c == '/' || c == '\\' || c == '[' || c == ']' || c == '[' || c == ']' || c == '<' || c == '>')
		{
			const size_t len = name.size();
			token.data = new unsigned char[len+1];
			for (size_t i = 0; i < len; i++)
			{
				token.data[i] = name[i];
			}
			token.data[len] = '\0';
			token.length = len+1;
			token.type = LEX_PDF_DATA;
			token.line_number = line_number;
			break;
		}
		else
		{
			name += c;
			if (Advance() == false) return; //Imposible to get here
		}
	}
	if (ProcessKeywords(token) == true)
	{
		if (token.type == LEX_PDF_STREAM)
		{
			//____________________ Read Stream data
			Stream(token);
		}
		return;
	}
	token.type = LEX_PDF_DATA;
	token.line_number = line_number;
}


// it returns 0, if streamEndText is the end of the stream
// it returns 1, if streamEndText is incorrect
// it returns -1, if streamEndText is incomplete
int LexicalAnalyzer::IsStreamEnd(const char* streamEndText, size_t len)
{
	const char* p = streamEndText;
	if (len == 0) return 1;
	//______________________________________ \n
	if (*p != '\n') return 1;
	if (len == 1) return -1;
	p++;
	//______________________________________ e
	if (*p != 'e') return 1;
	if (len == 2) return -1;
	p++;
	//______________________________________ n
	if (*p != 'n') return 1;
	if (len == 3) return -1;
	p++;
	//______________________________________ d
	if (*p != 'd') return 1;
	if (len == 4) return -1;
	p++;
	//______________________________________ s
	if (*p != 's') return 1;
	if (len == 5) return -1;
	p++;
	//______________________________________ t
	if (*p != 't') return 1;
	if (len == 6) return -1;
	p++;
	//______________________________________ r
	if (*p != 'r') return 1;
	if (len == 7) return -1;
	p++;
	//______________________________________ e
	if (*p != 'e') return 1;
	if (len == 8) return -1;
	p++;
	//______________________________________ a
	if (*p != 'a') return 1;
	if (len == 9) return -1;
	p++;
	//______________________________________ m
	if (*p != 'm') return 1;
	if (len == 10) return -1;
	p++;
	//______________________________________ \n, \r, or ' '
	if (*p != '\n' && *p != '\r' && *p != ' ') return 1;
	if (len == 11) return -1;
	//p++;
	//______________________________________
	return 0;
}

bool LexicalAnalyzer::Stream(Pdf::Token& token)
{
	char c;
	if (Read(c) == false) return false;
	if (c == '\r')
	{
		if (Read(c) == false) return false;
	}
	if (c != '\n') return false; // Error
	if (Advance() == false) return false; // Move after \new line
	//________________________________________________________________ Compute stream data length
	char buffer[32];
	string data;
	size_t i = 0;
	int result;
	while (Peek(c))
	{
		data += c;
		buffer[i] = c;
		result = IsStreamEnd(buffer, i+1);
		if (result == 0) //end of the stream
		{
			break;
		}
		else if (result == -1) //incomplete
		{
			Advance();
			i++;
			if (i >= 31) break; // error
		}
		else if (result == 1) // incorrect
		{
			Advance();
			i = 0;
		}
		else // error
		{
			Advance();
		}
	}
	//________________________________________________________________ Memory Allocation
	const size_t extra = strlen("endstream") + 2; // character before endstream and character after endstream
	const size_t actual_len = data.size()-extra;
	if (token.data != NULL) delete [] token.data;
	token.data = new unsigned char[actual_len];
	token.length = actual_len;
	if (token.data == NULL)
	{
		token.length = 0;
		return false; // Memory error
	}
	//________________________________________________________________ Copy
	for (i = 0; i < actual_len; i++)
	{
		token.data[i] = data[i];
	}
	return true;
}

bool LexicalAnalyzer::CheckToken(Pdf::Token& token, const char c, const char match, int lex_type)
{
	if (c != match) return false;
	token.type = lex_type;
	char text[2];
	text[0] = c;
	text[1] = '\0';
	token.SetText(text);
	token.line_number = line_number;
	return Advance();
}

bool LexicalAnalyzer::CheckToken(Pdf::Token& token, const char c, const char match1, const char match2, int lex_type1, int lex_type2)
{
	if (c != match1) return false;
	if (Advance() == false) return false;
	char c2;
	char text[3];
	text[0] = match1;
	text[1] = '\0';
	if (Peek(c2) == false)
	{
		token.SetText(text);
		token.type = lex_type1;
		token.line_number = line_number;
	}
	if (c2 == match2)
	{
		token.type = lex_type2;
		text[1] = match2;
		text[2] = '\0';
		token.SetText(text);
		token.line_number = line_number;
		if (Advance() == false) return false;
	}
	else
	{
		token.SetText(text);
		token.type = lex_type1;
		token.line_number = line_number;
	}
	return true;
}

bool LexicalAnalyzer::ProcessSeparator(Pdf::Token& token)
{
	char c;
	if (Peek(c) == false) return false;
	if (c == '\\')
	{
		if (Advance() == false) return false;
		if (CheckToken(token, c, '\\', LEX_PDF_BSLASH_BSLASH)) return true;
		else if (CheckToken(token, c, '(', LEX_PDF_BSLASH_LPARENTHESIS)) return true;
		else if (CheckToken(token, c, ')', LEX_PDF_BSLASH_RPARENTHESIS)) return true;
		else if (CheckToken(token, c, '[', LEX_PDF_BSLASH_LBRACKET)) return true;
		else if (CheckToken(token, c, ']', LEX_PDF_BSLASH_RBRACKET)) return true;
		else if (CheckToken(token, c, '<', LEX_PDF_BSLASH_LESS)) return true;
		else if (CheckToken(token, c, '>', LEX_PDF_BSLASH_BIGGER)) return true; 
		else if (CheckToken(token, c, '>', LEX_PDF_BSLASH_DIAGONAL)) return true;
		//____________________________________________ Error
		token.type = LEX_ERROR_UNRECOGNIZED_CHAR;
		token.data = new unsigned char[3];
		token.data[0] = '\\';
		token.data[1] = 'c';
		token.length = 3;
		token.line_number = line_number;
	}
	else
	{
		if (CheckToken(token, c, '(', LEX_LEFT_PARENTHESIS)) return true;
		else if (CheckToken(token, c, ')', LEX_RIGHT_PARENTHESIS)) return true;
		else if (CheckToken(token, c, '[', LEX_LEFT_BRACKET)) return true;
		else if (CheckToken(token, c, ']', LEX_RIGHT_BRACKET)) return true;
		else if (CheckToken(token, c, '<', '<', LEX_IS_LESS, LEX_INSERTION_OPERATOR)) return true;
		else if (CheckToken(token, c, '>', '>', LEX_IS_BIGGER, LEX_EXTRACTION_OPERATOR)) return true;
	}
	return false;
}

bool LexicalAnalyzer::ProcessComments(char c, Pdf::Token& token)
{
	if (c != '%') return false;
	Advance(); // Mover after '%'
	if (majorVersion == 0 && minorVersion == 0)
	{
		if (Read(c) == false) return true;
		if (c != 'P') return true;
		//
		if (Read(c) == false) return true;
		if (c != 'D') return true;
		//
		if (Read(c) == false) return true;
		if (c != 'F') return true;
		//
		if (Read(c) == false) return true;
		if (c != '-') return true;
		//
		int status = -1;
		majorVersion = ReadNumber(status);
		if (status != 0) return true;
		//
		if (Read(c) == false) return true;
		if (c != '.') return true;
		//
		minorVersion = ReadNumber(status);
		if (status != 0) return true;
		return true;
	}
	else
	{
		while (Read(c))
		{
			if (c == '\n') return true;
			if (c == '\r') return true;
			if (c == '\0') return true;
		}
	}
	return true;
}

//______________________________________________________________________ Pdf::Reader
Reader::Reader()
{
	Delete();
}

Reader::~Reader()
{
}

void Reader::Delete()
{
	majorVersion = 0;
	minorVersion = 0;
	offsetToXref = 0;
	readingXref = false;
	object.clear();
}

bool Reader::Load(const wchar_t* filename)
{
	Delete();
	Pdf::LexicalAnalyzer lex;
	if (lex.Create(filename) == false) return false;
	//
	Pdf::Token token;
	wstring text;
	bool result = true;
	lex.GetNextToken(token);
	while(true)
	{
		if (token.type == LEX_END_OF_FILE) break;
		if (token.type == LEX_PDF_STARTXREF)
		{
			LoadStartxref(lex, token);
			readingXref = false;
			continue;
		}
		if (token.type == LEX_PDF_XREF && readingXref == false)
		{
			readingXref = true;
			continue;
		}
		if (readingXref)
		{
			break; //result = LoadXref(lex, token);
		}
		else
		{
			if (LoadObject(lex, token) == false)
			{
				//________________________________________________ Try to recover from an error
				while (token.type != LEX_PDF_ENDOBJ)
				{
					if (token.type == LEX_END_OF_FILE)
					{
						majorVersion = lex.majorVersion;
						minorVersion = lex.minorVersion;
						return result;
					}
					lex.GetNextToken(token);
				}
				if (token.type == LEX_PDF_ENDOBJ)
				{
					lex.GetNextToken(token);
				}
			}
		}
	}
	majorVersion = lex.majorVersion;
	minorVersion = lex.minorVersion;
	return result;
}

bool Reader::LoadObject(Pdf::LexicalAnalyzer& lex, Pdf::Token& token)
{
	if (token.type != LEX_PDF_DATA) return false;
	Pdf::Object new_object;
	//__________________________________________________________________________ ID
	if (Sys::TextAssistant::GetInteger(token.data, new_object.id) == false) return false;
	//__________________________________________________________________________ generation number
	lex.GetNextToken(token);
	if (token.type != LEX_PDF_DATA) return false;
	if (Sys::TextAssistant::GetInteger(token.data, new_object.generation_number) == false) return false;
	//__________________________________________________________________________ obj
	lex.GetNextToken(token);
	if (token.type != LEX_PDF_OBJ) return false;
	//__________________________________________________________________________ value
	lex.GetNextToken(token);
	if (LoadValue(lex, token, new_object.value) == false) return false;
	//__________________________________________________________________________ stream?
	if (token.type == LEX_PDF_STREAM)
	{
		if (token.data != NULL)
		{
			if (new_object.stream != NULL) delete [] new_object.stream;
			new_object.stream = new char[token.length];
			if (new_object.stream != NULL)
			{
				::memcpy(new_object.stream, token.data, token.length);
				new_object.stream_length = token.length;
			}
		}
		else
		{
			if (new_object.stream != NULL) delete[] new_object.stream;
			new_object.stream = NULL;
			new_object.stream_length = 0;
		}
		lex.GetNextToken(token); // Move after stream
	}
	//__________________________________________________________________________ endobj
	if (token.type != LEX_PDF_ENDOBJ) return false;
	lex.GetNextToken(token);
	object.push_back(new_object);
	return true;
}

bool Reader::LoadValue(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	if (token.type == LEX_INSERTION_OPERATOR) return ValueDictionary(lex, token, value); // <<    >>
	if (token.type == LEX_LEFT_BRACKET)  return ValueArray(lex, token, value); // [        ]
	if (token.type == LEX_LEFT_PARENTHESIS) return ValueLiteralString(lex, token, value); // (     )
	if (token.type == LEX_IS_LESS) return ValueHexadecimalString(lex, token, value); // <    >
	if (token.type == LEX_PDF_NAME) return ValueName(lex, token, value); //    /Type
	if (token.type == LEX_PDF_DATA) return ValueDataOrReference(lex, token, value);// 1 0 R  or Data
	return false;
}

bool Reader::ValueDataOrReference(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	if (token.type != LEX_PDF_DATA) return false;
	//_____________________________________________________________ ID?
	if (token.IsID() == false) return ValueData(lex, token, value);
	//_____________________________________________________________ ID?
	Pdf::Token token1;
	lex.Peek1Token(token1);
	if (token1.IsID() == false) return ValueData(lex, token, value);
	//_____________________________________________________________ R?
	Pdf::Token token2;
	lex.Peek2Token(token2);
	if (token2.type != LEX_PDF_DATA) return ValueData(lex, token, value);
	if (token2.length != 2) return ValueData(lex, token, value);
	if (token2.data[0] != 'R') return ValueData(lex, token, value);
	//_____________________________________________________________ Indirect Reference
	return ValueReference(lex, token, value);
}

//Data (An integer or a double)
bool Reader::ValueData(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	if (token.type != LEX_PDF_DATA) return false;
	value.type = PDF_VALUE_DATA;
	const bool ok = value.SetData(token.data, token.length);
	lex.GetNextToken(token);
	return ok;
}

// 1 0 R
bool Reader::ValueReference(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	//__________________________________________________________________ 1
	if (token.type != LEX_PDF_DATA) return false;
	value.type = PDF_VALUE_REFERENCE;
	if (Sys::TextAssistant::GetInteger(token.data, value.ref_id) == false) return false;
	//__________________________________________________________________ 0
	lex.GetNextToken(token);
	if (token.type != LEX_PDF_DATA) return false;
	if (Sys::TextAssistant::GetInteger(token.data, value.ref_generation_number) == false) return false;
	//__________________________________________________________________ R
	lex.GetNextToken(token);
	if (token.type != LEX_PDF_DATA) return false;
	if (token.length != 2) return false;
	if (token.data[0] != 'R') return false;
	//__________________________________________________________________ Move after R
	lex.GetNextToken(token);
	return true;
}

//    /Type
bool Reader::ValueName(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	if (token.type != LEX_PDF_NAME) return false;
	value.type = PDF_VALUE_NAME;
	const bool ok = value.SetData(token.data, token.length);
	lex.GetNextToken(token);
	return ok;
}

// (     )
bool Reader::ValueLiteralString(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	//_______________________________________________________________ (
	if (token.type != LEX_LEFT_PARENTHESIS) return false;
	lex.GetNextToken(token);
	//_____________________
	if (token.type != LEX_PDF_DATA) return false;
	value.type = PDF_VALUE_LITERALSTRING;
	const bool ok = value.SetData(token.data, token.length);
	lex.GetNextToken(token);
	//_______________________________________________________________ )
	if (token.type != LEX_RIGHT_PARENTHESIS) return false;
	lex.GetNextToken(token);
	return ok;
}

// <    >
bool Reader::ValueHexadecimalString(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	//_______________________________________________________________ <
	if (token.type != LEX_IS_LESS) return false;
	lex.GetNextToken(token);
	//_____________________
	if (token.type != LEX_PDF_DATA) return false;
	value.type = PDF_VALUE_HEXSTRING;
	const bool ok = value.SetData(token.data, token.length);
	lex.GetNextToken(token);
	//_______________________________________________________________ >
	if (token.type != LEX_IS_BIGGER) return false;
	lex.GetNextToken(token);
	return ok;
}

// [        ]
bool Reader::ValueArray(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	//________________________________________________________________ [
	if (token.type != LEX_LEFT_BRACKET) return false;
	lex.GetNextToken(token);
	value.type = PDF_VALUE_ARRAY;
	if (token.type == LEX_RIGHT_BRACKET)//empty array
	{
		lex.GetNextToken(token);
		return true;
	}
	//_____________________
	Pdf::Value tmp;
	while (true)
	{
		tmp.Delete();
		if (LoadValue(lex, token, tmp) == false) break;
		value.value.push_back(tmp);
		//_______________________________________________________________ ]
		if (token.type == LEX_RIGHT_BRACKET) break;
	}
	if (token.type != LEX_RIGHT_BRACKET) return false;
	lex.GetNextToken(token);
	return true;
}

// <<    >>
bool Reader::ValueDictionary(Pdf::LexicalAnalyzer& lex, Pdf::Token& token, Pdf::Value& value)
{
	//_______________________________________________________________ <<
	if (token.type != LEX_INSERTION_OPERATOR) return false;
	lex.GetNextToken(token);
	value.type = PDF_VALUE_DICTIONARY;
	//_____________________
	Pdf::DictionaryItem di;
	Pdf::Value tmp;
	map<string, int>::iterator hint;
	//bool isReferenceHint = false;
	while (true)
	{
		//___________________________________ /Type
		tmp.Delete();
		di.Delete();
		if (token.type != LEX_PDF_NAME) return false;
		//isReferenceHint = IsReference(token.data);
		if (ValueName(lex, token, tmp) == false) break;
		di.name = (char*)tmp.data;
		//___________________________________ Value
		if (LoadValue(lex, token, di.value) == false) break;
		value.dictionary.push_back(di);
		if (token.type == LEX_EXTRACTION_OPERATOR) break;
	}
	//_______________________________________________________________ >>
	if (token.type != LEX_EXTRACTION_OPERATOR) return false;
	lex.GetNextToken(token);
	return true;
}

// startxref
bool Reader::LoadStartxref(Pdf::LexicalAnalyzer& lex, Pdf::Token& token)
{
	//_______________________________________________________________ startxref
	if (token.type != LEX_PDF_STARTXREF) return false;
	lex.GetNextToken(token);
	//
	if (token.type != LEX_PDF_DATA) return false;
	if (Sys::TextAssistant::GetInteger(token.data, offsetToXref) == false) return false;
	lex.GetNextToken(token);
	return true;
}

// xref  ...    startxref
bool Reader::LoadXref(Pdf::LexicalAnalyzer& lex, Pdf::Token& token)
{
	//_______________________________________________________________ xref
	if (token.type != LEX_PDF_XREF) return false;
	lex.GetNextToken(token);

	//____ Implementation pending
	
	//_______________________________________________________________ startxref
	if (token.type != LEX_PDF_STARTXREF) return false;
	lex.GetNextToken(token);
	return true;
}

//_____________________________________________________________________ Pdf::Font
Font::Font()
{
	Clear();
	ClearPdfObject();
}

Font::~Font()
{
}

int Font::GetPdfFont()
{
	return _pdfFont;
}

const wchar_t *Font::GetFontName()
{
	if (_pdfFont == PDF_FONT_ARIAL) return L"Arial";
	if (_pdfFont == PDF_FONT_COURIER_NEW) return L"Courier New";
	if (_pdfFont == PDF_FONT_TIMES_NEW_ROMAN) return L"Times New Roman";
	if (_pdfFont == PDF_FONT_SYMBOL) return L"Symbol";
	return L"None";
}

const wchar_t *Font::PdfFontName(int pdfFont)
{
	if (pdfFont == PDF_FONT_ARIAL) return L"F1";
	if (pdfFont == PDF_FONT_COURIER_NEW) return L"F2";
	if (pdfFont == PDF_FONT_TIMES_NEW_ROMAN) return L"F3";
	if (pdfFont == PDF_FONT_SYMBOL) return L"F4";
	return L"None";
}

const char *Font::GetBaseFont()
{
	if (_pdfFont == PDF_FONT_ARIAL) return "ArialMT";
	if (_pdfFont == PDF_FONT_COURIER_NEW) return "Courier CourierNewPSMT";
	if (_pdfFont == PDF_FONT_TIMES_NEW_ROMAN) return "TimesNewRomanPSMT";
	if (_pdfFont == PDF_FONT_SYMBOL) return "SymbolMT"; //return L"FNPZIV+SymbolMT";
	return "NoneMT";
}

void Font::Create(HWND hWnd, int pdfFont)
{
		Clear();
	_pdfFont = pdfFont;

	//ABC abc[PDF_CHAR_COUNT];
	int i;

	//_____________________________________________ logfont
	LOGFONT logfont;
	logfont.lfHeight = -1000;
	logfont.lfWidth = 0;
	logfont.lfEscapement = 0;
	logfont.lfOrientation = 0;
	logfont.lfWeight = FW_NORMAL;
	logfont.lfItalic = FALSE;
	logfont.lfUnderline = FALSE;
	logfont.lfStrikeOut = FALSE;
	logfont.lfCharSet = DEFAULT_CHARSET;
	logfont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	logfont.lfQuality = DEFAULT_QUALITY;
	logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE;
	logfont.lfFaceName[0] = '\0';
	char *outlineTextMetric = NULL;
	int bufferOutlineSize = 0;
	//
	//_______________________________________  Create Font
	_snwprintf_s(logfont.lfFaceName, 32, _TRUNCATE, L"%s", GetFontName()); 
	HFONT current = ::CreateFontIndirect(&logfont);
	//_______________________________________ Get Metrics
	const HDC hdc = ::GetDC(hWnd);
	const HFONT original = (HFONT)::SelectObject(hdc, current);
	if (::GetCharABCWidths(hdc, PDF_FIRST_CHAR, PDF_LAST_CHAR, abc) != 0)
	{
		//for (i = 0; i < PDF_CHAR_COUNT; i++)
		//{
		//	width[i] = abc[i].abcA + abc[i].abcB + abc[i].abcC;
		//}
	}
	else
	{
		int width[PDF_CHAR_COUNT];
		::GetCharWidth(hdc, PDF_FIRST_CHAR, PDF_LAST_CHAR, width);
		for (i = 0; i < PDF_CHAR_COUNT; i++)
		{
			abc[i].abcA = 0;
			abc[i].abcB = width[i];
			abc[i].abcC = 0;
		}
	}
	bufferOutlineSize = ::GetOutlineTextMetrics(hdc, 0, NULL);
	outlineTextMetric = new char[bufferOutlineSize];
	::GetOutlineTextMetrics(hdc, bufferOutlineSize, (OUTLINETEXTMETRIC*)outlineTextMetric);
	::SelectObject(hdc, original);
	::ReleaseDC(hWnd, hdc);

	ascent = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmAscent;
	capEmHeight = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmsCapEmHeight;
	descent =	((OUTLINETEXTMETRIC*)outlineTextMetric)->otmDescent;
	fontBox.left = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmrcFontBox.left;
	fontBox.bottom =((OUTLINETEXTMETRIC*)outlineTextMetric)->otmrcFontBox.bottom;
	fontBox.right =((OUTLINETEXTMETRIC*)outlineTextMetric)->otmrcFontBox.right;
	fontBox.top =((OUTLINETEXTMETRIC*)outlineTextMetric)->otmrcFontBox.top;
	italicAngle = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmItalicAngle;
	aveCharWidth = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmTextMetrics.tmAveCharWidth;
	height = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmTextMetrics.tmHeight;
	leading = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmTextMetrics.tmExternalLeading + ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmTextMetrics.tmInternalLeading;
	maxCharWidth = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmTextMetrics.tmMaxCharWidth;
	xHeight = ((OUTLINETEXTMETRIC*)outlineTextMetric)->otmsXHeight;

	if (outlineTextMetric != NULL) delete [] outlineTextMetric;
}

void Font::Create(int fontType)
{
	Create(::GetDesktopWindow(), fontType);
}

void Font::ClearPdfObject()
{
	objFont = -1;
	objFontWidths = -1;
	objFontDescriptor = -1;
	nFont = 0;
	nFontWidth = 0;
	nFontDescriptor = 0;
}

void Font::Clear()
{
	_pdfFont= PDF_FONT_NONE;

	for(int i = 0; i < PDF_CHAR_COUNT; i++)
	{
		abc[i].abcA = 0;
		abc[i].abcB = 0;
		abc[i].abcC = 0;
	}
	ascent = 0;
	capEmHeight = 0;
	descent = 0;
	flags = 32;
	fontBox.left = 0;
	fontBox.top = 0;
	fontBox.right = 0;
	fontBox.bottom = 0;
	italicAngle = 0;
	aveCharWidth = 0;
	height = 0;
	maxCharWidth = 0;
	leading = 0;
	xHeight = 0;
}

double Font::GetAscent(double fontSize)
{
	return (fontSize*ascent)/1000.0;
}

double Font::GetCapEmHeight(double fontSize)
{
	return (fontSize*capEmHeight)/1000.0;
}

double Font::GetDescent(double fontSize)
{
	return (fontSize*descent)/1000.0;
}

void Font::GetFontBox(Sys::Rectangle& out_rect, double fontSize)
{
	out_rect.left = (float)((fontBox.left*fontSize)/1000.0);
	out_rect.top = (float)((fontBox.top*fontSize)/1000.0);
	out_rect.right = (float)((fontBox.right*fontSize)/1000.0);
	out_rect.bottom =(float)( (fontBox.bottom*fontSize)/1000.0);
}

double Font::GetItalicAngle(double fontSize)
{
	return (fontSize*italicAngle)/1000.0;
}

double Font::GetAveCharWidth(double fontSize)
{
	return (fontSize*aveCharWidth)/1000.0;
}

double Font::GetHeight(double fontSize)
{
	return (fontSize*height)/1000.0;
}

double Font::GetMaxCharWidth(double fontSize)
{
	return (fontSize*maxCharWidth)/1000.0;
}

double Font::GetLeading(double fontSize)
{
	return (fontSize*leading)/1000.0;
}

double Font::GetXHeight(double fontSize)
{
	return (fontSize*xHeight)/1000.0;
}

int Font::GetWidth(int index)
{
	if (index < 0) return -1;
	if (index >= PDF_CHAR_COUNT) return -1;
	return abc[index].abcA + abc[index].abcB + abc[index].abcC;
}

double Font::GetCharWidth(wchar_t character, double fontSize)
{
	const int index = character - PDF_FIRST_CHAR;
	if (index < 0) return -1;
	if (index >= PDF_CHAR_COUNT) return -1;
	return fontSize*(abc[index].abcA + abc[index].abcB + abc[index].abcC)/100.0;
}

double Font::GetTextWidth(const wchar_t* text, double fontSize)
{
	if (text == NULL) return 0;
	const int len = (int)wcslen(text);
	int sum = 0;
	int index;
	for(int i = 0; i < len; i++)
	{
		index = text[i] - PDF_FIRST_CHAR;
		sum += (abc[index].abcA + abc[index].abcB + abc[index].abcC);
	}
	return fontSize*sum/1000.0;
}

double Font::GetTextWidth(const wstring& text, double fontSize)
{
	return GetTextWidth(text.c_str(), fontSize);
}

//_____________________________________________________________________ Pdf::Page
Page::Page()
{
	objID = 0;
	paperSize = PDF_PAPER_SIZE_LETTER;
	pageOrientation = PDF_PAGE_ORIENTATION_PORTRAIT;
}

Page::~Page()
{
}

void Page::BeginText()
{
	stream.push_back(L"BT");
}

void Page::EndText()
{
	stream.push_back(L"ET");
}

void Page::MoveText(double x, double y)
{
	wchar_t text[64];
	_snwprintf_s(text, 64, _TRUNCATE, L"%.4f %.4f TD", x, y);
	stream.push_back(text);
}

void Page::ShowText(const wchar_t* text)
{
	const int len = (int)wcslen(text);
	wstring tmp;
	tmp = L"(";
	wchar_t c;
	for(int i=0 ; i < len; i++)
	{
		c = text[i];
		if (c== '(')
		{
			tmp += L"\\(";
		}
		else if (c == ')')
		{
			tmp += L"\\)";
		}
		else if (c == '\\')
		{
			tmp += L"\\\\";
		}
		else
		{
			tmp += c;
		}
	}
	tmp += L") Tj";
	stream.push_back(tmp);
}

void Page::ShowText(const wstring& text)
{
	ShowText(text.c_str());
}

void Page::Font(int pdfFont, double fontSize)
{
	pdfFontSet.insert(pdfFont);
	wchar_t text[64];
	_snwprintf_s(text, 64, _TRUNCATE, L"/%s %.4f Tf", Pdf::Font::PdfFontName(pdfFont), fontSize);
	stream.push_back(text);
}

void Page::Concat(double a, double b, double c, double d, double e, double f)
{
	wchar_t text[64];
	_snwprintf_s(text, 64, _TRUNCATE, L"%.5f %.5f %.5f %.5f %.5f %.5f cm", a, b, c, d, e, f);
	stream.push_back(text);
}

void Page::LineJoinStyleMiter()
{
	stream.push_back(L"0 j");
}

void Page::LineCapStyle(int capStyle)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%d J", capStyle);
	stream.push_back(text);
}

void Page::LineWidth(double lineWidth)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.5f w", lineWidth);
	stream.push_back(text);
}

void Page::MiterLimit(double value)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.15f M", value);
	stream.push_back(text);
}

void Page::LineDashPattern(const wchar_t * pattern)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%s d", pattern);
	stream.push_back(text);
}

void Page::StrokeColor(COLORREF color)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.2f %.2f %.2f RG", GetRValue(color)/255.0, GetGValue(color)/255.0,  GetBValue(color)/255.0);
	stream.push_back(text);
}

void Page::FillColor(COLORREF color)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.2f %.2f %.2f rg", GetRValue(color)/255.0, GetGValue(color)/255.0,  GetBValue(color)/255.0);
	stream.push_back(text);
}

void Page::MoveTo(double x, double y)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f m", x, y);
	stream.push_back(text);
}

void Page::LineTo(double x, double y)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f l", x, y);
	stream.push_back(text);
}

void Page::Rectangle(const RECT& rect)
{
	wchar_t text[32];
	//________________________________________________________ Top Line
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f m", (double)rect.left, (double)rect.top);
	stream.push_back(text);
	//
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f l", (double)rect.right, (double)rect.top);
	stream.push_back(text);
	//________________________________________________________ Right Line
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f m", (double)rect.right, (double)rect.top);
	stream.push_back(text);
	//
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f l", (double)rect.right, (double)rect.bottom);
	stream.push_back(text);
	//________________________________________________________ Bottom Line
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f m", (double)rect.right, (double)rect.bottom);
	stream.push_back(text);
	//
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f l", (double)rect.left, (double)rect.bottom);
	stream.push_back(text);
	//________________________________________________________ Left Line
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f m", (double)rect.left, (double)rect.bottom);
	stream.push_back(text);
	//
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f l", (double)rect.left, (double)rect.top);
	stream.push_back(text);
}

void Page::PolyLine(const POINT* point, const int numPoints)
{
	if (numPoints == 0) return;
	int i;
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f m", (double)point[0].x, (double)point[0].y);
	stream.push_back(text);
	for (i = 1; i < numPoints; i++)
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f l", (double)point[i].x, (double)point[i].y);
		stream.push_back(text);
	}
}

void Page::Line(double x1, double y1, double x2, double y2)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f m", x1, y1);
	stream.push_back(text);
	//
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f %.4f l", x2, y2);
	stream.push_back(text);
}

void Page::CurveTo(double x1, double y1, double x2, double y2, double x3, double y3)
{
	wchar_t text[128];
	_snwprintf_s(text, 128, _TRUNCATE, L"%.4f %.4f %.4f %.4f %.4f %.4f c", x1, y1, x2, y2, x3, y3);
	stream.push_back(text);
}

void Page::Ellipse(double x, double y, double width, double height)
{
	const double kappa = 4.0 * (sqrt(2.0) - 1.0) / 3.0;
	const double ox = (kappa*width) / 2.0;// control point offset horizontal
	const double oy = (kappa*height) / 2;// control point offset vertical
	const double xend = x + width;
	const double yend = y + height;
	const double xmiddle =x + width / 2.0;
	const double ymiddle = y + height / 2.0;

	MoveTo(x, ymiddle);
	CurveTo(x, ymiddle - oy, xmiddle - ox, y, xmiddle, y);
	CurveTo(xmiddle + ox, y, xend, ymiddle - oy, xend, ymiddle);
	CurveTo(xend, ymiddle + oy, xmiddle + ox, yend, xmiddle, yend);
	CurveTo(xmiddle - ox, yend, x, ymiddle + oy, x, ymiddle);
}

void Page::Circle(double centerX, double centerY, double radius)
{
	Ellipse(centerX-radius, centerY-radius, 2.0*radius, 2.0*radius);
}

void Page::StrokePath()
{
	stream.push_back(L"s");
}

void Page::CloseAndStrokePath()
{
	stream.push_back(L"S");
}

void Page::CloseFillAndStrokePath()
{
	stream.push_back(L"b");
}

void Page::FillAndStrokePath()
{
	stream.push_back(L"B");
}

void Page::CloseEvenOddFillAndStrokePath()
{
	stream.push_back(L"b*");
}

void Page::EvenOddFillAndStrokePath()
{
	stream.push_back(L"B*");
}

void Page::FillPath()
{
	stream.push_back(L"f");
}

void Page::FillGray(double value)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f g", value);
	stream.push_back(text);
}

void Page::StrokeGray(double value)
{
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%.4f G", value);
	stream.push_back(text);
}

void Page::ClosePath()
{
	stream.push_back(L"h");
}

void Page::EndPathWithoutFillOrStroke()
{
	stream.push_back(L"n");
}

void Page::SaveGraphicsState()
{
	stream.push_back(L"q");
}

void Page::RestoreGraphicsState()
{
	stream.push_back(L"Q");
}

double Page::GetWidth()
{
	if (paperSize == PDF_PAPER_SIZE_LETTER)
	{
		if (pageOrientation == PDF_PAGE_ORIENTATION_PORTRAIT)
		{
			return 612.0000;
		}
		else
		{
			return 792.0000;
		}
	}
	else if (paperSize == PDF_PAPER_SIZE_LEGAL)
	{
		if (pageOrientation == PDF_PAGE_ORIENTATION_PORTRAIT)
		{
			return 612.0000;
		}
		else
		{
			return 1008.0000;
		}
	}
	return 1000.0000;
}

double Page::GetHeight()
{
	if (paperSize == PDF_PAPER_SIZE_LETTER)
	{
		if (pageOrientation == PDF_PAGE_ORIENTATION_PORTRAIT)
		{
			return 792.0000;
		}
		else
		{
			return 612.0000;
		}
	}
	else if (paperSize == PDF_PAPER_SIZE_LEGAL)
	{
		if (pageOrientation == PDF_PAGE_ORIENTATION_PORTRAIT)
		{
			return 1008.0000;
		}
		else
		{
			return 612.0000;
		}
	}
	return 1000.0000;
}

//_____________________________________________________________________ Pdf::Document
Document::Document()
{
	Sys::Information::getUserName(author);
}

Document::~Document()
{
}

//pdfFont: PDF_FONT_ARIAL, PDF_FONT_COURIER_NEW, PDF_FONT_TIMES_NEW_ROMAN, PDF_FONT_SYMBOL
void Document::AddFont(HWND hWnd, int pdfFont)
{
	Pdf::Font tmpFont;
	font.push_back(tmpFont);
	font[font.size() -1].Create(hWnd, pdfFont);
}

bool Document::Save(const wchar_t* filename)
{
	//_________________________________ Create the file
	HANDLE hFile = ::CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	//_________________________________ Get file content
	string content;
	if (GetPdf(filename, content) == false)
	{
		::CloseHandle(hFile);
		return false;
	}
	//________________________________ Write file content
	const int bytes = (int)(content.length()*sizeof(char));
	if (bytes <= 0)
	{
		::CloseHandle(hFile);
		return false;
	}
	DWORD written;
	::WriteFile(hFile, (void*)content.data(), bytes, &written, NULL);
	if (bytes != written)
	{
		::CloseHandle(hFile);
		return false;
	}
	return true;
}

void Document::RenderVersion(string& text, string& out)
{
	Sys::Format(text, "%%PDF-1.4%c%c%%%c%c%c%c%c%c", 0x0D, 0x0A, 0xE2, 0xE3, 0xCF, 0xD3, 0x0D, 0x0A);
	out += text;
}

void Document::RenderInfo(const wchar_t* filename, string& text, string& out)
{
	offset.push_back((int)out.size());
	Sys::Time time;
	char year[8];
	_snprintf_s(year, 8, _TRUNCATE, "%d", time.wYear);
	char month[8];
	_snprintf_s(month, 8, _TRUNCATE, "%02d", time.wMonth);
	char day[8];
	_snprintf_s(day, 8, _TRUNCATE, "%02d", time.wDay);
	char hour[8];
	_snprintf_s(hour, 8, _TRUNCATE, "%02d", time.wHour);
	char min[8];
	_snprintf_s(min, 8, _TRUNCATE, "%02d", time.wMinute);
	char sec[8];
	_snprintf_s(sec, 8, _TRUNCATE, "%02d", time.wSecond);
	//(D:YYYYMMDDHHmmSSOHH'mm)
	//where:
	//YYYY shall be the year
	//MM shall be the month (0112)
	//DD shall be the day (0131)
	//HH shall be the hour (0023)
	//mm shall be the minute (0059)
	//SS shall be the second (0059)
	//O shall be the relationship of local time to Universal Time (UT), and shall be denoted by one of the characters PLUS SIGN (U+002B) (+), HYPHEN-MINUS (U+002D) (-), or LATIN CAPITAL LETTER Z (U+005A) (Z) (see below)
	//HH followed by APOSTROPHE (U+0027) (') shall be the absolute value of the offset from UT in hours (0023)
	//mm shall be the absolute value of the offset from UT in minutes (0059)
	//___________________________________________________________ Encode Author
	string hexAuthor;
	if (author.empty() == true)
	{
		ToHex(L"Wintempla", hexAuthor);
	}
	else
	{
		ToHex(author, hexAuthor);
	}
	//___________________________________________________________ Encode Title
	string hexTitle;
	wchar_t tmp[128];
	Sys::TextAssistant::ExtractFileName(filename, false, tmp, 128);
	ToHex(tmp, hexTitle);

	Sys::Format(text,  
		"1 0 obj%c%c<<%c%c/CreationDate <feff00%x00%x00%x00%x00%x00%x00%x00%x00%x00%x00%x00%x00%x00%x00%x00%x>%c%c" \
		"/Creator <feff00%x00%x00%x00%x00%x00%x00%x00%x00%x>%c%c" \
		"/Producer <feff00%x00%x00%x00%x00%x00%x00%x00%x00%x>%c%c" \
		"/Author <feff%s>%c%c/Title <feff%s>%c%c>>%c%cendobj%c%c", 
		0x0D,  0x0A, 0x0D,  0x0A, 'D', ':', year[0],  year[1],  year[2],  year[3],  month[0],  month[1], day[0], day[1],
		hour[0], hour[1], min[0], min[1] , sec[0], sec[1], 0x0D,  0x0A, 
		'W', 'i', 'n', 't', 'e', 'm', 'p', 'l', 'a', 0x0D,  0x0A,
		'W', 'i', 'n', 't', 'e', 'm', 'p', 'l', 'a', 0x0D,  0x0A,
		hexAuthor.c_str(), 0x0D, 0x0A,
		hexTitle.c_str(), 0x0D, 0x0A,
		0x0D, 0x0A, 0x0D, 0x0A);
	out += text;
}

void Document::RenderCatalog(string& text, string& out)
{
	offset.push_back((int)out.size());
	const int objCatalog = (int)offset.size();
	//____________________________________________________ Estimate objPages
	const int fontCount = (int)font.size();
	int trueFontCount = 0;
	for(int i = 0; i < fontCount; i++)
	{
		if (font[i].GetPdfFont() == PDF_FONT_NONE) continue;
		trueFontCount++;
	}
	const int objPages = (int)(offset.size() + trueFontCount*3 + 1);
	Sys::Format(text,
		"%d 0 obj%c%c<<%c%c/Type /Catalog%c%c/Pages %d 0 R%c%c>>%c%cendobj%c%c",
		objCatalog, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A, 
		objPages, 0x0D, 0x0A, 
		0x0D, 0x0A, 0x0D, 0x0A);
	out += text;
}

void Document::RenderFont(Pdf::Font& pdfFont, string& text, string& out)
{
	int i;
	char tmp[64];

	pdfFont.ClearPdfObject();
	if (pdfFont.GetPdfFont() == PDF_FONT_NONE) return;
	//________________________________________________________ Create a Font Name
	string strFontName;
	Sys::Convert::WstringToString(pdfFont.PdfFontName(pdfFont.GetPdfFont()), strFontName);
	//
	offset.push_back((int)out.size());
	pdfFont.objFont = (int)offset.size();
	pdfFont.objFontWidths = pdfFont.objFont + 1;
	pdfFont.objFontDescriptor = pdfFont.objFont +2;
	//_______________________________________ /Font
	Sys::Format(text, 
		"%d 0 obj%c%c<<%c%c/Type /Font%c%c/Subtype /TrueType%c%c/Name /%s%c%c/BaseFont /%s%c%c/FirstChar %d%c%c/LastChar %d%c%c/Widths %d 0 R%c%c/Encoding /WinAnsiEncoding%c%c/FontDescriptor %d 0 R%c%c>>%c%cendobj%c%c", 
		pdfFont.objFont, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A, 
		strFontName.c_str(), 0x0D, 0x0A, 
		pdfFont.GetBaseFont(), 0x0D, 0x0A,
		PDF_FIRST_CHAR, 0x0D, 0x0A,
		PDF_LAST_CHAR, 0x0D, 0x0A,
		pdfFont.objFontWidths, 0x0D, 0x0A, 0x0D, 0x0A, pdfFont.objFontDescriptor, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A);
	pdfFont.nFont = (int)text.size();
	out += text;
	//_______________________________________ /Font: Widths
	offset.push_back((int)out.size());
	Sys::Format(text, "%d 0 obj%c%c[", pdfFont.objFontWidths, 0x0D, 0x0A);
	pdfFont.nFontWidth = (int)text.size();
	out += text;
	//_____________________________________ Print Widths
	for (i = 0; i < PDF_CHAR_COUNT; i++)
	{
		if ((i+1)%19 == 0)
		{
			pdfFont.nFont +=  _snprintf_s(tmp, 64, _TRUNCATE, "%d%c%c", pdfFont.GetWidth(i), 0x0D, 0x0A);
		}
		else
		{
			pdfFont.nFont +=  _snprintf_s(tmp, 64, _TRUNCATE, "%d ", pdfFont.GetWidth(i));
		}
		out += tmp;
	}
	pdfFont.nFont +=  _snprintf_s(tmp, 64, _TRUNCATE, "]%c%cendobj%c%c", 0x0D, 0x0A, 0x0D, 0x0A);
	out += tmp;
	//_______________________________________ /FontDescriptor
	offset.push_back((int)out.size());
	Sys::Format(text, 
		"%d 0 obj%c%c<<%c%c/Type /FontDescriptor%c%c/FontName /%s%c%c/Ascent %d%c%c/CapHeight %d%c%c/Descent %d%c%c/Flags %d%c%c" \
		"/FontBBox [%d %d %d %d]%c%c/ItalicAngle %d%c%c/StemV %d%c%c/AvgWidth %d%c%c/Leading %d%c%c/MaxWidth %d%c%c/xHeight %d%c%c" \
		">>%c%cendobj%c%c",
		pdfFont.objFontDescriptor, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A,
		pdfFont.GetBaseFont(), 0x0D, 0x0A,
		pdfFont.ascent, 0x0D, 0x0A,
		pdfFont.capEmHeight, 0x0D, 0x0A,
		pdfFont.descent, 0x0D, 0x0A,
		pdfFont.flags, 0x0D, 0x0A,
		pdfFont.fontBox.left,
		pdfFont.fontBox.bottom,
		pdfFont.fontBox.right,
		pdfFont.fontBox.top, 0x0D, 0x0A,
		pdfFont.italicAngle, 0x0D, 0x0A,
		0, 0x0D, 0x0A,
		pdfFont.aveCharWidth, 0x0D, 0x0A,
		pdfFont.leading, 0x0D, 0x0A,
		pdfFont.maxCharWidth, 0x0D, 0x0A,
		pdfFont.xHeight, 0x0D, 0x0A,
		0x0D, 0x0A, 0x0D, 0x0A);
	pdfFont.nFontDescriptor = (int)text.size();
	out += text;
}

void Document::RenderPages(string& text, string& out)
{
	const int numPages = (int)page.size();
	char tmp[32];
	offset.push_back((int)out.size());
	Sys::Format(text, "%d 0 obj%c%c<<%c%c/Type /Pages%c%c/Kids [", offset.size(), 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A);
	int size = (int)text.size();
	out += text;
	for(int i = 0; i < numPages; i++)
	{
		size += _snprintf_s(tmp, 32, _TRUNCATE, "%d 0 R", 2*i+(int)offset.size()+1);
		out += tmp;
		if (i != numPages -1)
		{
			out += " ";
			size++;
		}
	}
	Sys::Format(text, "]%c%c/Count %d%c%c>>%c%cendobj%c%c", 0x0D, 0x0A, numPages, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A);
	size += (int)text.size();
	out += text;
}

void Document::RenderPage(int parentObjId, int pageIndex, string& text, string& out)
{
	const double paperWidth = page[pageIndex].GetWidth();
	const double paperHeight = page[pageIndex].GetHeight();
	offset.push_back((int)out.size());
	page[pageIndex].objID = (int)offset.size();
	//page[pageIndex].size = 0;
	Sys::Format(text, "%d 0 obj%c%c<<%c%c/Type /Page%c%c/Parent %d 0 R%c%c/Contents %d 0 R%c%c" \
		"/MediaBox [0.0000 0.0000 %.4f %.4f]%c%c" \
		"/TrimBox [0.0000 0.0000 %.4f %.4f]%c%c" \
		"/CropBox [0.0000 0.0000 %.4f %.4f]%c%c" \
		"/Resources <<%c%c/ProcSet [/PDF /Text]%c%c",
		offset.size(), 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A,
		parentObjId, 0x0D, 0x0A,
		offset.size()+1, 0x0D, 0x0A,
		paperWidth, paperHeight, 0x0D, 0x0A,
		paperWidth, paperHeight, 0x0D, 0x0A,
		paperWidth, paperHeight, 0x0D, 0x0A,
		0x0D, 0x0A, 0x0D, 0x0A);
	//page[pageIndex].size = text.size();
	out += text;
	//_______________________________________ Has Font?
	const int fontCount = (int)font.size();
	int trueFontCount = 0;
	int i;
	int pdfFont = PDF_FONT_NONE;
	for(i = 0; i < fontCount; i++)
	{
		pdfFont = font[i].GetPdfFont();
		if (pdfFont == PDF_FONT_NONE) continue;
		if (page[pageIndex].pdfFontSet.find(pdfFont) == page[pageIndex].pdfFontSet.end()) continue;
		trueFontCount ++;
	}

	if (trueFontCount > 0)
	{
		string pdfName;
		Sys::Format(text, "/Font <<%c%c", 0x0D, 0x0A);
		out += text;
		for(i = 0; i < fontCount; i++)
		{
			pdfFont = font[i].GetPdfFont();
			if (pdfFont == PDF_FONT_NONE) continue;
			if (page[pageIndex].pdfFontSet.find(pdfFont) == page[pageIndex].pdfFontSet.end()) continue;
			Sys::Convert::WstringToString(Pdf::Font::PdfFontName(pdfFont), pdfName);
			Sys::Format(text, "/%s %d 0 R%c%c", pdfName.c_str(), font[i].objFont, 0x0D, 0x0A);
			out += text;
		}
	}
	Sys::Format(text, ">>%c%c>>%c%c>>%c%cendobj%c%c", 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A);
	out += text;
	//__________________________________________________________________________ Stream
	offset.push_back((int)out.size());
	string tmp;
	const int streamCount = (int)page[pageIndex].stream.size();
	int streamSize = 0;
	for(i = 0; i < streamCount; i++)
	{
		streamSize += ((int)page[pageIndex].stream[i].size() + 2);  // plust: 0x0D and 0x0A
	}
	Sys::Format(text, "%d 0 obj%c%c<<%c%c/Length %d%c%c>>%c%cstream%c%c",
		offset.size(), 0x0D, 0x0A, 0x0D, 0x0A,
		streamSize, 0x0D, 0x0A, 0x0D, 0x0A, 0x0D, 0x0A);
	out += text;
	//___ Each stream
	for(i = 0; i < streamCount; i++)
	{
		Sys::Convert::WstringToString(page[pageIndex].stream[i], tmp);
		Sys::Format(text, "%s%c%c", tmp.c_str(), 0x0D, 0x0A);
		out += text;
	}
	Sys::Format(text, "endstream%c%cendobj%c%c", 0x0D, 0x0A, 0x0D, 0x0A);
	out += text;
}

void Document::RenderXref(string& text, string& out)
{
	const int numObj = (int)offset.size();
	offset.push_back((int)out.size());
	Sys::Format(text, "xref%c%c0 %d%c%c0000000000 65535 f%c%c", 0x0D, 0x0A, offset.size(), 0x0D, 0x0A, 0x0D, 0x0A);
	out += text;
	for(int i = 0; i < numObj; i++)
	{
		Sys::Format(text, "%010d 00000 n%c%c", offset[i], 0x0D, 0x0A);
		out += text;
	}
}

void Document::RenderTrailer(string& text, string& out)
{
	Sys::Format(text, "trailer%c%c<<%c%c/Size %d%c%c/Root 2 0 R%c%c/Info 1 0 R%c%c>>%c%cstartxref%c%c%d%c%c%%%%EOF", 
		0x0D, 0x0A, //trailer
		0x0D, 0x0A, // <<
		offset.size(), 0x0D, 0x0A, 
		0x0D, 0x0A, //Root
		0x0D, 0x0A, //Info
		0x0D, 0x0A, // >>
		0x0D, 0x0A, //startxref
		offset[offset.size()-1], 0x0D, 0x0A);
	out += text;
}

// The file name is passed to set the document title
bool Document::GetPdf(const wchar_t* filename, string& out_pdf)
{
	int i;
	const int numPages = (int)page.size();
	offset.clear();
	if (numPages == 0) return false;
	string text;
	RenderVersion(text, out_pdf);
	RenderInfo(filename, text, out_pdf);
	RenderCatalog(text, out_pdf);
	const int fontCount = (int)font.size();
	for(i = 0; i < fontCount; i ++)
	{
		RenderFont(font[i], text, out_pdf);
	}
	const int objPages = (int)offset.size() + 1;
	RenderPages(text, out_pdf);
	//_________________________________________________________ \Page

	for(i = 0; i < numPages; i++)
	{
		RenderPage(objPages, i, text, out_pdf);
	}
	RenderXref(text, out_pdf);
	RenderTrailer(text, out_pdf);

	return true;
}

///* btoa: version 4.0
// * stream filter to change 8 bit bytes into printable ascii
// * computes the number of bytes, and three kinds of simple checksums
// * incoming bytes are collected into 32-bit words, then printed in base 85
// * exp(85,5) > exp(2,32)
// * the ASCII characters used are between '!' and 'u'
// * 'z' encodes 32-bit zero; 'x' is used to mark the end of encoded data.
// *
// * Paul Rutter Joe Orost
// *
// * 7/29/90: added input and output file handling so to run on VMS, DOS, etc
//            --kang sun (sun@robios.eng.yale.edu)
// */
//
//#include <stdio.h>
//
//#define reg register
//
//#define MAXPERLINE 78
//
//long int Ceor = 0;
//long int Csum = 0;
//long int Crot = 0;
//
//long int ccount = 0;
//long int bcount = 0;
//long int word;
//
//FILE *fip, *fop; /* pointer to input and output file */
//
//#define EN(c)	(int) ((c) + '!')
//
//encode(c) reg c;
//{
//  Ceor ^= c;
//  Csum += c;
//  Csum += 1;
//  if ((Crot & 0x80000000)) {
//    Crot <<= 1;
//    Crot += 1;
//  } 
//  else {
//    Crot <<= 1;
//  }
//  Crot += c;
//
//  word <<= 8;
//  word |= c;
//  if (bcount == 3) {
//    wordout(word);
//    bcount = 0;
//  } 
//  else {
//    bcount += 1;
//  }
//}
//
//wordout(word) reg long int word;
//{
//  if (word == 0) {
//    charout('z');
//  } 
//  else {
//    reg int tmp = 0;
//
//    if (word < 0)
//    { /* Because some don't support unsigned long */
//      tmp = 32;
//      word = word - (long)(85L * 85 * 85 * 85 * 32);
//    }
//    if (word < 0) {
//      tmp = 64;
//      word = word - (long)(85L * 85 * 85 * 85 * 32);
//    }
//    charout(EN((word / (long)(85L * 85 * 85 * 85)) + tmp));
//    word %= (long)(85L * 85 * 85 * 85);
//    charout(EN(word / (85L * 85 * 85)));
//    word %= (85L * 85 * 85);
//    charout(EN(word / (85L * 85)));
//    word %= (85L * 85);
//    charout(EN(word / 85));
//    word %= 85;
//    charout(EN(word));
//  }
//}
//
//charout(c) {
//  putc(c,fop);
//  ccount += 1;
//  if (ccount == MAXPERLINE) {
//    putc('\n',fop);
//    ccount = 0;
//  }
//}
//
//main(argc,argv)
//int argc;
//char **argv;
//{
//  reg c;
//  reg long int n;
//  fip = stdin;
//  fop = stdout;
//
//  switch(argc) {
//  case 3: /* both in and out file names are given */
//    if ((fop=fopen(argv[2],"w"))==NULL) {
//      printf("\tCan't open output file - %s\n",argv[2]);
//      exit (1);
//    }
//  case 2: /* only in file name is given */
//    if ((fip=fopen(argv[1],"r"))==NULL) {
//      printf("\tCan't open input file - %s\n",argv[1]);
//      exit (1);
//    }
//  case 1: /* neither file name is given */
//    break;
//  default:
//    printf("\tUsage: %s [file1 [file2]]\n",argv[0]);
//    exit(0);
//    break;
//  }
//    
//  fprintf(fop,"xbtoa Begin\n");
//  n = 0;
//  while ((c = getc(fip)) != EOF) {
//    encode(c);
//    n += 1;
//  }
//
//  while (bcount != 0) {
//    encode(0);
//  } /* n is written twice as crude cross check*/
//
//  if (ccount == 0);
//  /* ccount == 0 means '\n' just written in charout() */
//  /* this avoids bug in BITNET, which changes blank line to spaces */
//  else putc('\n',fop);
//
//  fprintf(fop,"xbtoa End N %ld %lx E %lx S %lx R %lx\n", n, n, Ceor, Csum, Crot);
//
//  switch(argc) { /* close all the open files */
//  case 3: fclose(fop);
//  case 2: fclose(fip);
//  default: break;
//  }
//
//  exit(0);
//}

void Document::ToHex(const wstring& input, string& out_buffer)
{
	const int len = (int)input.size();
	int i;
	char tmp[8];
	for(i = 0; i < len; i++)
	{
		_snprintf_s(tmp, 8, _TRUNCATE, "00%x", input[i]);
		out_buffer += tmp;
	}
}

} //____________________________________________________ namespace Pdf::End



namespace Sql //________________________________________ namespace Sql::Ini
{

//_____________________________________________________________________ LexicalAnalyzer
LexicalAnalyzer::LexicalAnalyzer(void)
{
	constTextDeliminator = '\'';
}

LexicalAnalyzer::~LexicalAnalyzer(void)
{
}

void LexicalAnalyzer::FillKeywords(unordered_map<wstring, int>& keyword)
{
	// As SQL is not case sensitive, we create an empty map
	// Instead we use the function CheckTokenNoCase from ProcessKeywords to identify SQL keywords
}

bool LexicalAnalyzer::ProcessComments(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	if (c != '-') return false;

	c = inputString[index++];
	if (c=='-')  //_______________________ single line comments
	{
		while(c!='\n' && c!='\0')
		{
			c = inputString[index++];
		}
		return true;
	}
	else
	{
		//_____________________________________ It is not a comment
		index-=2;
		c = inputString[index++];
	}
	return false;
}

bool LexicalAnalyzer::ProcessKeywords(Cpl::LexicalAnalyzer::Token& token)
{
	if (CheckTokenNoCase(token, LEX_SQLTYPE_BIT, LEX_SQLTYPE_TIMESTAMP)) return true; //SQL DATATYPE
	if (CheckTokenNoCase(token, LEX_SQL_CREATE, LEX_SQL_ALTER)) return true; //SQL MAIN
	if (CheckTokenNoCase(token, LEX_SQL_TABLE, LEX_SQL_CURSOR)) return true; //SQL OBJECTS
	if (CheckTokenNoCase(token, LEX_SQL_WHERE, LEX_SQL_NULL)) return true; //SQL KEYWORDS
	if (CheckTokenNoCase(token, LEX_SQL_ABS, LEX_SQL_DB_NAME)) return true; //SQL FUNCTIONS
	return false;
}

bool LexicalAnalyzer::GetTokens(const wchar_t* inputString, vector<Cpl::LexicalAnalyzer::Token>& output)
{
	Sql::LexicalAnalyzer lex;
	Cpl::LexicalAnalyzer::Token token;
	if (lex.Create(inputString) == false) return false;
	do
	{
		lex.GetNextToken(token);
		output.push_back(token);
	}
	while (token.type != LEX_END_OF_FILE);// && token.type != LEX_ERROR);
	return true;
}


//_____________________________________________________________________ Column
Column::Column()
{
	name[0] = '\0';
	isPK = false;
	allowsNull = false;
	check[0]  = '\0';
	type = LEX_SQLTYPE_NVARCHAR;
	refTable[0]  = '\0';
	refPK[0]  = '\0';
	table_name[0] = '\0';
	size = 0;
}

Column::~Column()
{
}

//_____________________________________________________________________ Table
Table::Table()
{
	name[0] = '\0';
	selected = false;
}

Table::~Table()
{
}

//_____________________________________________________________________ Compiler
Compiler::Compiler()
{
}

Compiler::~Compiler()
{
}

bool Compiler::Compile(const wchar_t* inputString, vector<Sql::Table>& output)
{
	output.clear();
	if (lex.Create(inputString)==false) return false;
	//
	lex.GetNextToken(lookahead);
	if (lookahead.type == LEX_END_OF_FILE) return false;
	try
	{
		while(lookahead.type != LEX_END_OF_FILE)
		{
			Block_SingleLine(output);
		}
	}
	catch(int x)
	{
		x++;
		return false;
	}
	return true;
}

void Compiler::Next(vector<Sql::Table>& output)
{
	//lex.GetNextToken(lookahead);
	//if (lookahead.type == LEX_END_OF_FILE) return false;

	lex.GetNextToken(lookahead);
	if (lex.IsError(lookahead)) AddError(output, lookahead, ERROR_LEX, 0);
}

void Compiler::Match(vector<Sql::Table>& output, int type)
{
	if (lookahead.type != type ) AddError(output, lookahead, ERROR_SYNTAX, type);	
	Next(output);
}

void Compiler::Block_SingleLine(vector<Sql::Table>& output)
{
	switch(lookahead.type)
	{
	case LEX_SQL_CREATE:
		Create(output);
		break;
	case LEX_SQL_INSERT:
		Insert(output);
		break;
	case LEX_SQL_UPDATE:
		Update(output);
		break;
	case  LEX_SQL_SELECT:
		Select(output);
		break;
	case LEX_SQL_DELETE:
		Delete(output);
		break;
	case LEX_SQL_DROP:
		Drop(output);
		break;
	case LEX_SQL_GRANT:
		Grant(output);
		break;
	case LEX_SQL_REVOKE:
		Revoke(output);
		break;
	case LEX_SQL_ROLLBACK:
		Rollback(output);
		break;
	case LEX_SQL_SAVEPOINT:
		SavePoint(output);
		break;
	case LEX_SQL_USE:
		Use(output);
		break;
	case LEX_SQL_ALTER:
		Alter(output);
		break;
	default:
		Next(output);
		//AddError(output, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::Create(vector<Sql::Table>& output)
{
	Next(output); // CREATE
	switch(lookahead.type)
	{
	case LEX_SQL_TABLE:
		Table(output);
		break;
	case LEX_SQL_VIEW:
		View(output);
		break;
	case LEX_SQL_TRIGGER:
		Trigger(output);
		break;
	case LEX_SQL_INDEX:
		Index(output);
		break;
	case LEX_SQL_PROCEDURE:
		Procedure(output);
		break;
	case LEX_SQL_DATABASE:
		Database(output);
		break;
	case LEX_SQL_CURSOR:
		Cursor(output);
		break;
	default:
		Next(output);
		//AddError(output, lookahead, ERROR_SYNTAX, ERROR_INVALID_VALUE);
	}
}

void Compiler::Insert(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Update(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Select(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Delete(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Drop(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Grant(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Revoke(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Rollback(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::SavePoint(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Use(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Alter(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Table(vector<Sql::Table>& output)
{
	Next(output); // TABLE
	if (lookahead.type == LEX_SQL_DBO)
	{
		Next(output);
		Match(output, LEX_DOT);
	}
	if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
	//_________________________ TABLE NAME
	Sql::Table table;
	_snwprintf_s(table.name, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
	output.push_back(table);
	Next(output); // TABLE NAME
	Match(output, LEX_LEFT_PARENTHESIS);
	Columns(output);
}

void Compiler::Columns(vector<Sql::Table>& output)
{
	Column(output);
	while (lookahead.type == LEX_COMMA)
	{
		Next(output); // COMMA
		Column(output);
	}
	Match(output, LEX_RIGHT_PARENTHESIS);
}

void Compiler::Column(vector<Sql::Table>& output)
{
	if (lookahead.type == LEX_SQL_PRIMARY)
	{
		Next(output); //PRIMARY
		Match(output, LEX_SQL_KEY);
		Match(output, LEX_LEFT_PARENTHESIS);
		while(lookahead.type != LEX_RIGHT_PARENTHESIS)
		{
			if (lookahead.type == LEX_ID)
			{
				const int len = (int)output.back().column.size();
				for(int i = 0; i < len; i++)
				{
					if (wcscmp(lookahead.string_value, output.back().column[i].name) == 0)
					{
						output.back().column[i].isPK = true;
					}
				}
			}
			Next(output);
		}
		Next(output); // )
		return;
	}
	Sql::Column column;
	//___________________________________________________________ table_name
	_snwprintf_s(column.table_name, SQL_NAME_MAX, _TRUNCATE, L"%s", output.back().name);
	//___________________________________________________________ Column Name
	if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
	_snwprintf_s(column.name, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
	Next(output); // Column name
	//___________________________________________________________ Data type
	if (IsDataType(lookahead) == false) AddError(output, lookahead, 0, 0);
	column.type = lookahead.type;
	Next(output); //Data type
	if (RequiresSize(column.type) == true)
	{
		if (column.type == LEX_SQLTYPE_CHAR)
		{
			if (lookahead.type == LEX_LEFT_PARENTHESIS)
			{
				Match(output, LEX_LEFT_PARENTHESIS);
				if (lookahead.type == LEX_CONST_VALUE_INTEGER)
				{
					column.size = lookahead.int_value;
				}
				Match(output, LEX_CONST_VALUE_INTEGER);
				Match(output, LEX_RIGHT_PARENTHESIS);
			}
		}
		else
		{
			Match(output, LEX_LEFT_PARENTHESIS);
			if (lookahead.type == LEX_CONST_VALUE_INTEGER)
			{
				column.size = lookahead.int_value;
			}
			Match(output, LEX_CONST_VALUE_INTEGER);
			Match(output, LEX_RIGHT_PARENTHESIS);
		}
	}
	else if (RequiresDoubleSize(column.type) == true)
	{
		Match(output, LEX_LEFT_PARENTHESIS);
		Match(output, LEX_CONST_VALUE_INTEGER);
		Match(output, LEX_COMMA);
		Match(output, LEX_CONST_VALUE_INTEGER);
		Match(output, LEX_RIGHT_PARENTHESIS);
	}
	output.back().column.push_back(column);
	//___________________________________________________________  Column Param
	while(IsColumnParam(lookahead) == true)
	{
		switch(lookahead.type)
		{
		case LEX_SQL_CONSTRAINT:
			Constraint(output);
			break;
		case LEX_SQL_REFERENCES:
			References(output);
			break;
		case LEX_SQL_PRIMARY:
			Primary(output);
			break;
		case LEX_SQL_NOT:
			Not(output);
			break;
		case  LEX_SQL_NULL:
			Null(output);
			break;
		case LEX_SQL_CHECK:
			Check(output);
			break;
		case LEX_SQL_IDENTITY:
			Identity(output);
			break;
		case LEX_SQL_AUTO_INCREMENT:
			Auto_Increment(output);
			break;
		case  LEX_SQL_ON:
			On(output);
			break;
		case  LEX_SQL_UNIQUE:
			Unique(output);
			break;
		case  LEX_SQL_DEFAULT:
			Default(output);
			break;
		default:
			Next(output);
		}
	}
}

void Compiler::Constraint(vector<Sql::Table>& output)
{
	Next(output); // CONSTRAINT
	Match(output, LEX_ID);
}

void Compiler::References(vector<Sql::Table>& output)
{
	Next(output); // REFERENCES
	//_____________________________________________ REFERENCES table
	if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
	_snwprintf_s(output.back().column.back().refTable, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
	Match(output, LEX_ID);
	if (lookahead.type == LEX_LEFT_PARENTHESIS)
	{
		Match(output, LEX_LEFT_PARENTHESIS);
		//_____________________________________________ REFERENCES column
		if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
		_snwprintf_s(output.back().column.back().refPK, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
		Match(output, LEX_ID);
		Match(output, LEX_RIGHT_PARENTHESIS);
	}
	else if (lookahead.type == LEX_DOT)
	{
		Match(output, LEX_DOT);
		//_____________________________________________ REFERENCES column
		if (lookahead.type != LEX_ID) AddError(output, lookahead, 0, 0);
		_snwprintf_s(output.back().column.back().refPK, SQL_NAME_MAX, _TRUNCATE, L"%s", lookahead.string_value);
		Match(output, LEX_ID);
		//Match(output, LEX_RIGHT_PARENTHESIS);
	}
	else
	{
		AddError(output, lookahead, 0, 0);
	}
}

void Compiler::Primary(vector<Sql::Table>& output)
{
	Next(output); // PRIMARY
	Match(output, LEX_SQL_KEY);
	output.back().column.back().isPK = true;
}

void Compiler::Not(vector<Sql::Table>& output)
{
	Next(output); // NOT
	Match(output, LEX_SQL_NULL);
	output.back().column.back().allowsNull = false;
}

void Compiler::Null(vector<Sql::Table>& output)
{
	Next(output); // NULL
	output.back().column.back().allowsNull = true;
}

void Compiler::Default(vector<Sql::Table>& output)
{
	Next(output); // DEFAULT
	if (lookahead.type == LEX_CONST_VALUE_INTEGER)
	{
		Next(output); // INTEGER
	}
	else if (lookahead.type == LEX_CONST_VALUE_DOUBLE)
	{
		Next(output); // DOUBLE
	}
	else if (lookahead.type == LEX_CONST_VALUE_STRING)
	{
		Next(output); // STRING
	}
	else if (lookahead.type == LEX_SQL_GETDATE)
	{
		Next(output); // GETDATE
		Match(output, LEX_LEFT_PARENTHESIS);
		Match(output, LEX_RIGHT_PARENTHESIS);
	}
}

void Compiler::Check(vector<Sql::Table>& output)
{
	Next(output); // CHECK
	Match(output, LEX_LEFT_PARENTHESIS);
	while(lookahead.type != LEX_RIGHT_PARENTHESIS)
	{
		Next(output);
	}
	Next(output); // )
}

void Compiler::Identity(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Auto_Increment(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::On(vector<Sql::Table>& output)
{
	Next(output); // ON
	Match(output, LEX_SQL_DELETE);
	Match(output, LEX_SQL_CASCADE);
}

void Compiler::Unique(vector<Sql::Table>& output)
{
	Next(output); // Unique
}

bool Compiler::IsColumnParam(Cpl::LexicalAnalyzer::Token& token)
{
	if (token.type == LEX_SQL_CONSTRAINT) return true;
	if (token.type == LEX_SQL_REFERENCES) return true;
	if (token.type == LEX_SQL_PRIMARY) return true;
	if (token.type == LEX_SQL_NOT) return true;
	if (token.type == LEX_SQL_NULL) return true;
	if (token.type == LEX_SQL_CHECK) return true;
	if (token.type == LEX_SQL_IDENTITY) return true;
	if (token.type == LEX_SQL_AUTO_INCREMENT) return true;
	if (token.type == LEX_SQL_ON) return true;
	if (token.type == LEX_SQL_UNIQUE) return true;
	if (token.type == LEX_SQL_DEFAULT) return true;
	return false;
}

bool Compiler::RequiresSize(int datatype)
{
	if (datatype == LEX_SQLTYPE_VARCHAR2) return true;
	if (datatype == LEX_SQLTYPE_VARCHAR) return true;
	if (datatype == LEX_SQLTYPE_CHAR) return true;
	if (datatype == LEX_SQLTYPE_TEXT) return true;
	if (datatype == LEX_SQLTYPE_NVARCHAR) return true;
	if (datatype == LEX_SQLTYPE_NCHAR) return true;
	if (datatype == LEX_SQLTYPE_NTEXT) return true;
	return false;
}

bool Compiler::RequiresDoubleSize(int datatype)
{
	if (datatype == LEX_SQLTYPE_NUMERIC) return true;
	if (datatype == LEX_SQLTYPE_DECIMAL) return true;
	return false;
}

bool Compiler::IsDataType(Cpl::LexicalAnalyzer::Token& token)
{
	if (token.type < LEX_SQLTYPE_BIT) return false;
	if (LEX_SQLTYPE_TIMESTAMP < token.type) return false;
	return true;
}

void Compiler::View(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Trigger(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Index(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Procedure(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Database(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::Cursor(vector<Sql::Table>& output)
{
	Next(output);
}

void Compiler::AddError(vector<Sql::Table>& output, Cpl::LexicalAnalyzer::Token& token, int error_type, int correct_token_type)
{
	////___________________________  Create IntelliSense
	//IntelliSenseFuncInfo isfi;
	//while (sisfi.empty() == false)
	//{
	//	isfi = sisfi.top();
	//	sisfi.pop();
	//	ListMethods(isfi.func_id, isfi.datatype, NULL, isfi.parameterIndex);
	//}
	////
	//Instruction inst;
	//inst.type = VM_ERROR;
	//inst.subtype = error_type;
	//inst.line_number= token.line_number;
	//inst.int_value = 0;
	//inst.double_value = 0.0;
	//wchar_t * descr = NULL;
	//switch(error_type)
	//{
	//case ERROR_SYNTAX:
	//	descr = LexicalAnalyzer::GetTokenText(correct_token_type);
	//	if (descr)
	//	{			
	//		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing %s", inst.line_number, descr);
	//	}
	//	else
	//	{
	//		_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error", inst.line_number);
	//	}
	//	break;
	//case ERROR_VARIABLE_ALLREADY_DEFINED:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has already been defined", inst.line_number);
	//	break;
	//case ERROR_VARIABLE_NOEXISTS:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable does not exist", inst.line_number);
	//	break;
	//case ERROR_INVALID_OBJECT_FUNC:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the object does not support this method", inst.line_number);
	//	break;
	//case ERROR_VARIABLE_UNINIT:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the variable has not been initialized", inst.line_number);
	//	break;
	//case ERROR_INVALID_PARAM:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the function parameter is invalid", inst.line_number);
	//	break;
	//case ERROR_MISSING_TOKEN:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d syntax error, missing terminator", inst.line_number);
	//	break;
	//case ERROR_INCOMPLETE_COMMAND:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d the command is incomplete", inst.line_number);
	//	break;
	//case ERROR_MISSING_VARIABLE:
	//	_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d a variable is missing", inst.line_number);
	//	break;
	//case ERROR_LEX:
	//	{
	//		if (token.type == LEX_ERROR_UNRECOGNIZED_CHAR)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d unrecognized character %s", inst.line_number, token.string_value);
	//		}
	//		else if (token.type == LEX_ERROR_STRING_TOO_LONG)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d string too long %s", inst.line_number, token.string_value);
	//		}
	//		else if (token.type == LEX_ERROR_MISSING_COMMENT_TERMINATOR)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing comment terminator", inst.line_number);
	//		}
	//		else if (token.type == LEX_ERROR_MISSING_STRING_TERMINATOR)
	//		{
	//			_snwprintf_s(inst.name, LEX_STRINGMAX, _TRUNCATE, L"Line %d missing string terminator %s", inst.line_number, token.string_value);
	//		}
	//	}
	//	break;
	//}
	//machineCode.push_back(inst);
	Next(output);
	//throw 0;
}


//_____________________________________________________________________ Tools
Tools::Tools()
{
}

Tools::~Tools()
{
}

bool Tools::ImportFromText(const wchar_t* inputSqlText, vector<Sql::Table>& output)
{
	output.clear();
	Sql::Compiler compiler;
	if (compiler.Compile(inputSqlText, output) == false) return false;
	return true;
}

bool Tools::ImportFromFile(const wchar_t* fileName, vector<Sql::Table>& output)
{
	wstring text;
	if (Sys::FileAssistant::TextLoad(fileName, text) == false) return false;
	if (Sql::Tools::ImportFromText(text.c_str(), output) == false) return false;
	return true;
}

//_____________________________________________________________________ StringBuilder
StringBuilder::StringBuilder(const wchar_t * table_name, const wchar_t * primary_key_name, int primary_key_value)
{
	this->primary_key_name = primary_key_name;
	this->primary_key_value = primary_key_value;
	query.reserve(512);
	if (primary_key_value == -1)
	{
		sqlCommand.reserve(256);
		sqlValues.reserve(256);
		sqlCommand = L"INSERT INTO ";
		sqlCommand += table_name;
		sqlCommand += L" (";
		sqlValues = L" VALUES(";
	}
	else
	{
		sqlCommand.reserve(512);
		sqlCommand = L"UPDATE ";
		sqlCommand += table_name;
		sqlCommand += L" SET ";
	}
	isFirstTime = true;
}

StringBuilder::~StringBuilder()
{
}

const wchar_t* StringBuilder::GetString()
{
	query = sqlCommand;
	if (primary_key_value == -1)
	{
		query += L") ";
		query += sqlValues;
		query += L");";		
	}
	else
	{
		query += L" WHERE ";
		query += primary_key_name;
		wchar_t text[32];
		_snwprintf_s(text, 32, _TRUNCATE, L"='%d';", primary_key_value);
		query += text;
	}
	return query.c_str();
}

int StringBuilder::BindInt(const wchar_t* column_name, int value)
{
	wchar_t text[32];
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{
		if (isFirstTime == false)
		{
			_snwprintf_s(text, 32, _TRUNCATE, L", '%d'", value);
		}
		else
		{
			_snwprintf_s(text, 32, _TRUNCATE, L"'%d'", value);
		}
		sqlValues += text;
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"='%d'", value);
		sqlCommand += text;
	}
	isFirstTime = false;
	return value;
}

double StringBuilder::BindDouble(const wchar_t* column_name, double value)
{
	wchar_t text[32];
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			_snwprintf_s(text, 32, _TRUNCATE, L", '%g'", value);
		}
		else
		{
			_snwprintf_s(text, 32, _TRUNCATE, L"'%g'", value);
		}
		sqlValues += text;
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"='%g'", value);
		sqlCommand += text;
	}
	isFirstTime = false;
	return value;
}

bool StringBuilder::BindBool(const wchar_t* column_name, bool value)
{
	int nvalue = value == true ? 1 : 0;
	wchar_t text[32];
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{
		if (isFirstTime == false)
		{
			_snwprintf_s(text, 32, _TRUNCATE, L", '%d'", nvalue);
		}
		else
		{
			_snwprintf_s(text, 32, _TRUNCATE, L"'%d'", nvalue);
		}
		sqlValues += text;
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"='%d'", nvalue);
		sqlCommand += text;
	}
	isFirstTime = false;
	return value;
}

Sys::Time StringBuilder::BindDateTimeMicrosoft(const wchar_t* column_name, Sys::Time& value)
{
	wstring text;
	Sys::Format(text, L"CONVERT(DATETIME, '%4d-%02d-%02d %02d:%02d:%02d', 20)",
		value.wYear, value.wMonth, value.wDay, value.wHour, value.wMinute, value.wSecond);
	//Sys::Convert::DateToString(value, (wchar_t*)format, text);
	// 20 is ODVC canonical format: yyyy-mm-dd hh:mi:ss(24h)
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			sqlValues += L", ";
		}
		//else
		//{
		//	sqlValues += L"'";
		//}
		sqlValues += text;
		//sqlValues += L"'";
	}
	else
	{
		sqlCommand += L"=";
		sqlCommand += text;
		//sqlCommand += L"";
	}
	isFirstTime = false;
	return value;
}

Sys::Time StringBuilder::BindDateTimeOracle(const wchar_t* column_name, Sys::Time& value)
{
	wstring text;
	Sys::Format(text, L"TO_DATE('%02d-%02d-%04d %02d:%02d:%02d', 'DD-MM-YYYY HH24:MI:SS')",
		value.wDay, value.wMonth, value.wYear, value.wHour, value.wMinute, value.wSecond);
	//Sys::Convert::DateToString(value, (wchar_t*)format, text);
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			sqlValues += L", ";
		}
		//else
		//{
		//	sqlValues += L"'";
		//}
		sqlValues += text;
		//sqlValues += L"'";
	}
	else
	{
		sqlCommand += L"=";
		sqlCommand += text;
		//sqlCommand += L"";
	}
	isFirstTime = false;
	return value;
}

Sys::Time StringBuilder::BindDateTimeMySql(const wchar_t* column_name, Sys::Time& value)
{
	wstring text;
	Sys::Format(text, L"%04d-%02d-%02d", value.wYear, value.wMonth, value.wDay);
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			sqlValues += L", ";
		}
		else
		{
			sqlValues += L"'";
		}
		sqlValues += text;
		sqlValues += L"'";
	}
	else
	{
		sqlCommand += L"=";
		sqlCommand += text;
		sqlCommand += L"";
	}
	isFirstTime = false;
	return value;
}

const wchar_t* StringBuilder::BindString(const wchar_t* column_name, const wstring& value)
{
	return BindString(column_name, value.c_str());
}

const wchar_t* StringBuilder::BindString(const wchar_t* column_name, const wchar_t* value)
{
	if (isFirstTime == false) sqlCommand += L", ";
	sqlCommand += column_name;
	if (primary_key_value == -1)
	{	
		if (isFirstTime == false)
		{
			sqlValues += L", '";
		}
		else
		{
			sqlValues += L"'";
		}
		sqlValues += value;
		sqlValues += L"'";
	}
	else
	{
		sqlCommand += L"='";
		sqlCommand += value;
		sqlCommand += L"'";
	}
	isFirstTime = false;
	return value;
}

LPARAM StringBuilder::Bind(const wchar_t* column_name, Sys::ISelectInt& control)
{
	control.SqlUpdate(false);
	const LPARAM value = control.SqlGetInt();
	BindInt(column_name, (int)value);
	return value;
}

bool StringBuilder::Bind(const wchar_t* column_name, Sys::ISelectBool& control)
{
	control.SqlUpdate(false);
	const bool isChecked = control.SqlGetBool();
	BindBool(column_name, isChecked);
	return isChecked;
}

Sys::Time StringBuilder::BindMicrosoft(const wchar_t* column_name, Sys::ISelectTime& control)
{
	control.SqlUpdate(false);
	BindDateTimeMicrosoft(column_name, control.SqlGetSysTime());
	return control.SqlGetSysTime();
}

Sys::Time StringBuilder::BindOracle(const wchar_t* column_name, Sys::ISelectTime& control)
{
	control.SqlUpdate(false);
	BindDateTimeOracle(column_name, control.SqlGetSysTime());
	return control.SqlGetSysTime();
}

Sys::Time StringBuilder::BindMySql(const wchar_t* column_name, Sys::ISelectTime& control)
{
	control.SqlUpdate(false);
	BindDateTimeMySql(column_name, control.SqlGetSysTime());
	return control.SqlGetSysTime();
}

const wchar_t* StringBuilder::Bind(const wchar_t* column_name, Sys::ISelectString& control)
{
	control.SqlUpdate(false);
	BindString(column_name, control.SqlGetString());
	return control.SqlGetString().c_str();
}

//____________________________________________________ SqlException
SqlException::SqlException(Sql::SqlExceptInfo& exceptInfo, const wchar_t* statement, const wchar_t* funcName)
{
	description[0]='\0';
	const wchar_t * info = L"\r\n\r\nstatement: ";
	const wchar_t *temp = L"The provider did not send an error description";
	this->retcode = exceptInfo.retcode;
	if (retcode==SQL_SUCCESS) return;
	if (retcode==SQL_SUCCESS_WITH_INFO) return;
	if (retcode==SQL_NO_DATA)
	{
		if (statement==NULL) statement = L" ";
		_snwprintf_s(description, WINSQL_EXCEPT_MAX, _TRUNCATE, L"%s%s%s", temp, (wchar_t*)info, (wchar_t*)statement);
		return;
	}
	if (retcode!=SQL_ERROR) return;

	wchar_t szSqlState[10];
	SDWORD sdError=0;
	SWORD swSize;
	if (statement==NULL)
	{
		::SQLError(exceptInfo.henv, exceptInfo.hdbc, exceptInfo.hstmt, (SQLWCHAR*)szSqlState, &sdError,
			(SQLWCHAR*)description, SQL_MAX_MESSAGE_LENGTH, &swSize);
		description[SQL_MAX_MESSAGE_LENGTH-1]='\0';
	}
	else if (wcscmp(statement, L"SqlConnection::OpenSession") == 0 && retcode == -1)
	{
		_snwprintf_s(description, SQL_MAX_MESSAGE_LENGTH, _TRUNCATE, 
			L"SqlConnection::OpenSession: unable to connect, please check your CONNECTION STRING and verify that the SQL SERVER is running");
	}
	else
	{
		wchar_t errorDescr[SQL_MAX_MESSAGE_LENGTH];
		::SQLError(exceptInfo.henv, exceptInfo.hdbc, exceptInfo.hstmt, (SQLWCHAR*)szSqlState, &sdError,
			(SQLWCHAR*)errorDescr, SQL_MAX_MESSAGE_LENGTH, &swSize);
		errorDescr[SQL_MAX_MESSAGE_LENGTH-1]='\0';
		_snwprintf_s(description, WINSQL_EXCEPT_MAX, _TRUNCATE, L"%s%s%s", errorDescr, (wchar_t*)info, (wchar_t*)statement);
		description[WINSQL_EXCEPT_MAX-1]='\0';
	}
}

SqlException::SqlException(const SqlException& init)
{
	this->retcode = init.retcode;
	::memcpy(this->description, init.description, WINSQL_EXCEPT_MAX*sizeof(wchar_t));
}

SqlException::~SqlException(void)
{
}

wchar_t* SqlException::GetDescription(void)
{
	return description;
}

//_____________________________________________________________________ SqlConnection
SqlConnection::SqlConnection()
{
	henv=SQL_NULL_HENV;
	hdbc=SQL_NULL_HDBC;
	hstmt = SQL_NULL_HSTMT;
	bConnected = false;
	for(int i = 0; i<SQL_BINDCOL_MAX; i++) iselect[i] = NULL;
}

SqlConnection::~SqlConnection()
{
	CloseSession();
}

void SqlConnection::BindClear()
{
	for(int i = 0; i<SQL_BINDCOL_MAX; i++) iselect[i] = NULL;
}

void SqlConnection::CloseSession()
{
	DestroyStatement();

	if (bConnected && (hdbc!=SQL_NULL_HDBC))
	{
		SQLDisconnect(hdbc);
		bConnected = false;
	}

	if (hdbc!=SQL_NULL_HDBC)   //Free connection
	{
		SQLFreeConnect(hdbc);
		hdbc = SQL_NULL_HDBC;
	}

	if (henv!=SQL_NULL_HENV)  //Free environment
	{
		SQLFreeEnv(henv);
		henv=SQL_NULL_HENV;
	}
}

//RETCODE retcode;
//if (Win::SqlConnection::IsOk(retcode= sql.OpenSession(hWnd, (SQLWCHAR*)"DRIVER={SQL Server};SERVER=ACID;DATABASE=directory;Trusted_Connection=yes")==false)
//	sql.DisplayError(hWnd, NULL, L"Open Session", retcode);
RETCODE SqlConnection::OpenSession(HWND hWnd, const wchar_t* connectionString) // It does not required ODBC
{
	Sql::SqlExceptInfo ei;

	if (connectionString==NULL) connectionString = (SQLWCHAR*)"DRIVER={SQL Server};";
	RETCODE retcode= SQL_INVALID_HANDLE;
	CloseSession();
	if (IsOk(retcode= SQLAllocEnv(&henv))==false) 
	{
		henv=SQL_NULL_HENV;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocEnv");
	}
	if (IsOk(retcode= SQLAllocConnect(henv, &hdbc))==false)
	{
		hdbc = SQL_NULL_HDBC;
		if (henv!=SQL_NULL_HENV)  //Free environment
		{
			SQLFreeEnv(henv);
			henv=SQL_NULL_HENV;
		}
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocConnect");
	}
	wchar_t szOutConn[1024];
	SQLSMALLINT cbOutConn;
	retcode = ::SQLDriverConnect(hdbc, hWnd, (SQLWCHAR*)connectionString, SQL_NTS, (SQLWCHAR*)szOutConn,
		1024, &cbOutConn, SQL_DRIVER_COMPLETE);
	bConnected =IsOk(retcode);
	if (bConnected==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		if (hWnd == NULL)
		{
			throw Sql::SqlException(ei, L"SqlConnection::OpenSession", L"SqlConnection::OpenSession - SQLDriverConnect");
		}
		else
		{
			throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLDriverConnect");
		}
	}
	return retcode;
}

RETCODE SqlConnection::OpenSession(HWND hWnd, const wstring& connectionString) // It does not required ODBC
{
	return this->OpenSession(hWnd, connectionString.c_str());
}

RETCODE SqlConnection::OpenSession(Sys::IWindow& window, const wchar_t* connectionString)
{
	return OpenSession(window.GetHWND(), connectionString);
}

RETCODE SqlConnection::OpenSession(Sys::IWindow& window, const wstring& connectionString)
{
	return OpenSession(window.GetHWND(), connectionString.c_str());
}

//Win::SqlConnection sql;
//RETCODE retcode;
//
//if (Win::SqlConnection::IsOk(retcode=sql.OpenSession(L"directory", L"sa", L"123easy"))==false)
//	sql.DisplayError(hWnd, NULL, L"Open Session", retcode);
RETCODE SqlConnection::OpenSession(const wchar_t* dsn, const wchar_t* username, const wchar_t* password) //ODBC
{
	Sql::SqlExceptInfo ei;

	if (dsn==NULL) return SQL_INVALID_HANDLE;
	RETCODE retcode= SQL_INVALID_HANDLE;
	CloseSession();
	if (IsOk(retcode= SQLAllocEnv(&henv))==false) 
	{
		henv=SQL_NULL_HENV;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocEnv");
	}
	if (IsOk(retcode= SQLAllocConnect(henv, &hdbc))==false)
	{
		hdbc = SQL_NULL_HDBC;
		if (henv!=SQL_NULL_HENV)  //Free environment
		{
			SQLFreeEnv(henv);
			henv=SQL_NULL_HENV;
		}
		henv=SQL_NULL_HENV;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLAllocConnect");
	}

	if  (username!=NULL && password!=NULL)
	{
		retcode = SQLConnect(hdbc, (SQLWCHAR*)dsn, SQL_NTS, (SQLWCHAR*)username, SQL_NTS,
			(SQLWCHAR*)password, SQL_NTS);
	}
	else if  (username!=NULL && password==NULL)
	{
		retcode = SQLConnect(hdbc, (SQLWCHAR*)dsn, SQL_NTS, (SQLWCHAR*)username, SQL_NTS,
			NULL, 0);
	}
	else
	{
		retcode = SQLConnect(hdbc, (SQLWCHAR*)dsn, SQL_NTS, NULL, 0, NULL, 0);
	}
	bConnected =IsOk(retcode);
	if (bConnected==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = retcode;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::OpenSession - SQLConnect");
	}
	return retcode;
}



RETCODE SqlConnection::OpenSession(const wstring& dsn, const wstring& username, const wstring& password) //ODBC
{
	return this->OpenSession(dsn.c_str(), username.c_str(), password.c_str());
}


RETCODE SqlConnection::BindParameter(SQLUSMALLINT ipar, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType,
		SQLULEN cvColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLLEN cbValueMax, SQLLEN* pcvValue)
{
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, fParamType, fCType, fSqlType, cvColDef, ibScale, rgbValue, cbValueMax, pcvValue);
	if (this->IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindParameter - SQLBindParameter");
	}
	return rt;
}

//wchar_t* SqlConnection::GetErrorInformation(RETCODE retcode)
//{
//	if (retcode==SQL_SUCCESS) return NULL;
//	if (retcode==SQL_SUCCESS_WITH_INFO) return NULL;
//	if (retcode==SQL_NO_DATA) return NULL;
//	if (retcode!=SQL_ERROR) return NULL;
//	wchar_t szSqlState[10];
//	SDWORD sdError=0;
//	SWORD swSize;
//	SQLError(henv, hdbc, hstmt, (SQLWCHAR*)szSqlState, &sdError,
//			(SQLWCHAR*)errorDescr, SQL_MAX_MESSAGE_LENGTH-1, &swSize);
//	return errorDescr;
//}

int SqlConnection::GetColumCount(const wchar_t* statement)
{
	RETCODE rt = SQL_SUCCESS;
	Sql::SqlExceptInfo ei;
	if (statement ==NULL) return SQL_INVALID_HANDLE;
	CreateStatement();
	SQLSMALLINT cols = 0;
	if (IsOk(rt = ::SQLExecDirect(hstmt, (SQLWCHAR*)statement, SQL_NTS))==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumCount - SQLExecDirect");
	}
	if (IsOk(rt = ::SQLNumResultCols(hstmt, &cols))==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumCount - SQLNumResultCols");
	}
	return (int)cols;
}

RETCODE SqlConnection::BindColumn(int columnNumber, bool& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	//if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &value, 1, &bindColStr[columnNumber-1]))==false)
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_BIT, &value, 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, int& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &value, 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, double& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_DOUBLE, &value, 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sys::SqlTime& value)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_TIMESTAMP, &value, sizeof(Sys::SqlTime), &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sys::ISelectString& control, int bufferLength)
{
	if (columnNumber <=1) BindClear();
	control.SqlGetString().resize(bufferLength);
	this->iselect[columnNumber-1] = &control;

	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_WCHAR, (wchar_t*)control.SqlGetString().data(), bufferLength, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sys::ISelectTime& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_TIMESTAMP, &control.SqlGetTime(), sizeof(Sys::SqlTime), &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sys::ISelectInt& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &control.SqlGetInt(), 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sys::ISelectDouble& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_DOUBLE, &control.SqlGetDouble(), 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, Sys::ISelectBool& control)
{
	if (columnNumber <=1) BindClear();
	this->iselect[columnNumber-1] = &control;
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	//if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_LONG, &iselect.SqlGetBool(), 1, &bindColStr[columnNumber-1]))==false)
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_BIT, &control.SqlGetBool(), 1, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

RETCODE SqlConnection::BindColumn(int columnNumber, wchar_t* value, int bufferLength)
{
	RETCODE rt = SQL_SUCCESS;
	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_WCHAR, value, sizeof(wchar_t)*bufferLength, &bindColStr[columnNumber-1]))==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
	}
	return rt;
}

//RETCODE SqlConnection::BindColumn(int columnNumber, wstring& value, int columnLength)
//{
//	value.resize(columnLength+1);
//	RETCODE rt = SQL_SUCCESS;
//	SQLUSMALLINT col = (SQLUSMALLINT)columnNumber;
//	if (IsOk(rt = ::SQLBindCol(hstmt, col, SQL_C_WCHAR, (wchar_t*)value.c_str(), sizeof(wchar_t)*columnLength, &bindColStr[columnNumber-1]))==false)
//	{
//		Sql::SqlExceptInfo ei;
//		ei.hdbc = this->hdbc;
//		ei.henv = this->henv;
//		ei.hstmt = this->hstmt;
//		ei.retcode = rt;
//		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindColumn - SQLBindCol");
//	}
//	return rt;
//}

bool SqlConnection::Fetch(void)
{
	RETCODE rt = SQL_INVALID_HANDLE;

	if (IsOk(rt=SQLFetch(hstmt))==false)
	{
		this->CloseCursor();
		//Sql::SqlExceptInfo ei;
		//ei.hdbc = this->hdbc;
		//ei.henv = this->henv;
		//ei.hstmt = this->hstmt;
		//ei.retcode = rt;
		//throw Sql::SqlException(ei, NULL, L"SqlConnection::Fetch - SQLFetch");
		return false;
	}
	for(int i = 0; i<SQL_BINDCOL_MAX; i++)
	{
		if (iselect[i] != NULL)
		{
			iselect[i]->SqlUpdate(true);
		}
		else
		{
			break;
		}
	}
	return true;
}

int SqlConnection::GetInt(const wchar_t* statement)
{
	int value = 0;
	this->GetColumn(statement, 1, SQL_C_LONG, &value, 1);
	return value;
}

int SqlConnection::GetInt(const wstring& statement)
{
	return GetInt(statement.c_str());
}

bool SqlConnection::GetBool(const wchar_t* statement)
{
	bool value = 0;
	this->GetColumn(statement, 1, SQL_C_BIT, &value, 1);
	return value;
}

bool SqlConnection::GetBool(const wstring& statement)
{
	return GetBool(statement.c_str());
}

double SqlConnection::GetDouble(const wchar_t* statement)
{
	double value = 0.0;
	this->GetColumn(statement, 1, SQL_C_DOUBLE, &value, 1);
	return value;
}

double SqlConnection::GetDouble(const wstring& statement)
{
	return this->GetDouble(statement.c_str());
}

Sys::Time SqlConnection::GetDate(const wchar_t* statement)
{
	Sys::SqlTime value;
	Sys::Time output;
	this->GetColumn(statement, 1, SQL_C_TIMESTAMP, &value, sizeof(Sys::SqlTime));
	Sys::Convert::SqlTimeToSysTime(value, output);
	return output;
}

Sys::Time SqlConnection::GetDate(const wstring& statement)
{
	return this->GetDate(statement.c_str());
}

RETCODE SqlConnection::GetString(const wchar_t* statement, wchar_t* buffer, int bufferLength)
{
	return this->GetColumn(statement, 1, SQL_C_WCHAR, buffer, bufferLength*sizeof(wchar_t));
}

RETCODE SqlConnection::GetString(const wstring& statement, wchar_t* buffer, int bufferLength)
{
	return this->GetColumn(statement.c_str(), 1, SQL_C_WCHAR, buffer, bufferLength*sizeof(wchar_t));
}

RETCODE SqlConnection::GetString(const wstring& statement, wstring& buffer, int bufferLength)
{
	buffer.resize(bufferLength);
	RETCODE result =  this->GetColumn(statement.c_str(), 1, SQL_C_WCHAR, (wchar_t*)buffer.data(), bufferLength*sizeof(wchar_t));
	const int len = (int)wcslen(buffer.c_str());
	buffer.resize(len);
	return result;
}

// columnIndex starts at one
// targetType: SQL_C_TCHAR
//SQL_C_LONG
//SQL_C_SHORT
//SQL_C_FLOAT
//SQL_C_DOUBLE
//SQL_C_NUMERIC
//SQL_C_DATE
//SQL_C_TIME
//SQL_C_TIMESTAMP
RETCODE SqlConnection::GetColumn(const wchar_t* statement, int columnIndex, SQLSMALLINT targetType,
		SQLPOINTER targetValue, SQLINTEGER bufferLength)
{
	RETCODE rt = SQL_SUCCESS;
	SQLLEN len = 0;
	if (statement ==NULL) return SQL_INVALID_HANDLE;
	int cols = GetColumCount(statement);
	if (cols!=1) return SQL_NO_DATA;
	if (IsOk(rt = ::SQLBindCol(hstmt, columnIndex, targetType, targetValue, bufferLength, &len))==false) 
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumn - SQLBindCol");
	}
	rt = ::SQLFetch(hstmt);
	::SQLCloseCursor(hstmt);
	DestroyStatement();
	//
	if (IsOk(rt)==false) 
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::GetColumn - SQLFetch");
	}

	return rt;
}


// You may pass an objet that implements Win::ISqlNumerator
//	conn.OpenSession(L"directory", L"sa", L"123easy");
//	conn.ExecuteSelect(L"SELECT * FROM department", 100, *this);
//
//void Prueba::Enumerate(wchar_t** data, int colCount, int rowIndex)
//{
//	wchar_t texto[256];
//	for(int j=0; j<colCount; j++)
//	{
//		_snwprintf_s(texto, 256, L"row = %d, col = %d, data = %s", rowIndex, j, data[j]);
//		this->MessageBox(texto);
//	}
//}
RETCODE SqlConnection::ExecuteSelect(const wchar_t *statement, unsigned int maxTextLength, Sys::IEnumerator& num)
{
	int row = 0;
	Sql::SqlExceptInfo ei;
	RETCODE rt = SQL_SUCCESS;
	const int cols = this->GetColumCount(statement);
	int i = 0;

	wchar_t** pData=new wchar_t* [cols];
	if (pData==NULL)
	{
		DestroyStatement();
		return SQL_INVALID_HANDLE;
	}
	for(i=0; i<cols; i++)
	{
		pData[i]=new wchar_t [maxTextLength];
		pData[i][0]='\0';
	}

	//*********************************************************** BindCol
	for (i=0; i<cols; i++)
	{
		if (IsOk(rt = ::SQLBindCol(hstmt, i+1, SQL_C_TCHAR, pData[i], maxTextLength, &bindColStr[i]))==false)
		{
			if (pData)
			{
				for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
				delete [] pData;
			}
			this->DestroyStatement();
			ei.hdbc = this->hdbc;
			ei.henv = this->henv;
			ei.hstmt = this->hstmt;
			ei.retcode = rt;
			throw Sql::SqlException(ei, NULL, L"SqlConnection::ExecuteSelect - SQLBindCol");
		}
	}

	//************************************************************ Fetch
	while (IsOk(::SQLFetch(hstmt)))
	{
		num.Enumerate(pData, cols, row);
		for(i=0; i<cols; i++) pData[i][0]='\0';
		row++;
	}
	::SQLCloseCursor(hstmt);

	if (pData)
	{
		for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
		delete [] pData;
	}
	this->DestroyStatement();

	return rt;
}

RETCODE SqlConnection::ExecuteSelect(const wstring& statement, unsigned int maxTextLength, Sys::IEnumerator& num)
{
	return this->ExecuteSelect(statement.c_str(), maxTextLength, num);
}

RETCODE SqlConnection::ExecuteSelect(const wchar_t *statement, unsigned int maxTextLength, vector<vector<wstring> >& output)
{
	Sql::SqlExceptInfo ei;
	RETCODE rt = SQL_SUCCESS;
	const int cols = this->GetColumCount(statement);
	int i = 0;

	wchar_t** pData=new wchar_t* [cols];
	if (pData==NULL)
	{
		DestroyStatement();
		return SQL_INVALID_HANDLE;
	}
	for(i=0; i<cols; i++)
	{
		pData[i]=new wchar_t [maxTextLength];
		pData[i][0]='\0';
	}

	//*********************************************************** BindCol
	for (i=0; i<cols; i++)
	{
		if (IsOk(rt = ::SQLBindCol(hstmt, i+1, SQL_C_TCHAR, pData[i], maxTextLength, &bindColStr[i]))==false)
		{
			if (pData)
			{
				for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
				delete [] pData;
			}
			this->DestroyStatement();
			ei.hdbc = this->hdbc;
			ei.henv = this->henv;
			ei.hstmt = this->hstmt;
			ei.retcode = rt;
			throw Sql::SqlException(ei, NULL, L"SqlConnection::ExecuteSelect - SQLBindCol");
		}
	}

	//************************************************************ Fetch
	vector<wstring> row;
	row.resize(cols);
	while (IsOk(::SQLFetch(hstmt)))
	{
		for(i = 0; i <cols; i++)
		{
			row[i] = pData[i];
			pData[i][0]='\0';
		}
		output.push_back(row);
	}
	::SQLCloseCursor(hstmt);

	if (pData)
	{
		for (i=0; i<cols; i++) if (pData[i]) delete [] pData[i];
		delete [] pData;
	}
	this->DestroyStatement();

	return rt;
}

RETCODE SqlConnection::ExecuteSelect(const wstring& statement, unsigned int maxTextLength, vector<vector<wstring> >& output)
{
	return ExecuteSelect(statement.c_str(), maxTextLength, output);
}

RETCODE SqlConnection::CloseCursor()
{
	RETCODE rt = ::SQLCloseCursor(hstmt);
	this->DestroyStatement();
	return rt;
}

// Use this for UPDATE, DELETE and INSERT
// Returns the number of rows affected
int SqlConnection::ExecuteNonQuery(const wchar_t* statement)
{
	RETCODE rc = SQL_SUCCESS;

	this->CreateStatement();
	int rows = ExecDirect(statement);
	this->DestroyStatement();
	return rows;
}

// Use this for UPDATE, DELETE and INSERT
// Returns the number of rows affected
int SqlConnection::ExecuteNonQuery(const wstring& statement)
{
	return this->ExecuteNonQuery(statement.c_str());
}

RETCODE SqlConnection::CreateStatement()
{
	DestroyStatement();
	if (bConnected==true && hdbc!=SQL_NULL_HDBC) 
	{
		RETCODE rt = SQLAllocStmt(hdbc, &hstmt);
		if (IsOk(rt)==false)
		{
			Sql::SqlExceptInfo ei;
			ei.hdbc = this->hdbc;
			ei.henv = this->henv;
			ei.hstmt = this->hstmt;
			ei.retcode = rt;
			throw Sql::SqlException(ei, NULL, L"SqlConnection::CreateStatement - SQLAllocStmt");
			return rt;
		}
		return rt;
	}
	return SQL_INVALID_HANDLE;
}

int SqlConnection::ExecuteSelect(const wchar_t *statement)
{
	for(int i = 0; i<SQL_BINDCOL_MAX; i++) iselect[i] = NULL;
	return this->GetColumCount(statement);
}

int SqlConnection::ExecuteSelect(const wstring& statement)
{
	return this->ExecuteSelect(statement.c_str());
}

void SqlConnection::DestroyStatement()
{
	if (hstmt!=SQL_NULL_HSTMT)
	{
		SQLFreeStmt(hstmt, SQL_DROP);
		hstmt = SQL_NULL_HSTMT;
	}
}

// You can use this function to call stored procedures
int SqlConnection::ExecDirect(const wchar_t* statement)
{
	Sql::SqlExceptInfo ei;
	RETCODE rt = SQL_SUCCESS;
	if (statement ==NULL) return SQL_INVALID_HANDLE;
	if (bConnected == false) return SQL_INVALID_HANDLE;
	SQLLEN rows = -1;

	if (IsOk(rt = ::SQLExecDirect(hstmt, (SQLWCHAR*)statement, SQL_NTS))==false) 
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::ExecDirect - SQLExecDirect");
	}
	if (IsOk(rt = ::SQLRowCount(hstmt, &rows))==false)
	{
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, statement, L"SqlConnection::ExecDirect - SQLExecDirect");
	}
	return (int)rows;
}

// You can use this function to call stored procedures
int SqlConnection::ExecDirect(const wstring& statement)
{
	return this->ExecDirect(statement.c_str());
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, double& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_DOUBLE, SQL_DOUBLE, sizeof(double), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, double& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_DOUBLE, SQL_DOUBLE, sizeof(double), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, int& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_LONG, SQL_INTEGER, sizeof(int), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, int& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_LONG, SQL_INTEGER, sizeof(int), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, Sys::SqlTime& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_TIMESTAMP, SQL_TIMESTAMP, sizeof(Sys::SqlTime), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, Sys::SqlTime& parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = 0;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_TIMESTAMP, SQL_TIMESTAMP, sizeof(Sys::SqlTime), 0, &parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindInputParameter(int parameterNumber, const wchar_t* parameter)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = SQL_NTS;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_INPUT, 
		SQL_C_WCHAR, 
		SQL_WVARCHAR, //SQL_WCHAR, SQL_WVARCHAR, SQL_WLONGVARCHAR
		(wcslen(parameter)+1)*sizeof(wchar_t), 0, (wchar_t*)parameter, 0, &bindColStr[ipar-1]); 

	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindInputParameter - SQLBindParameter");
	}
	return rt;
}

RETCODE SqlConnection::BindOutputParameter(int parameterNumber, wchar_t* parameter, int maxNumberOfChar)
{
	SQLUSMALLINT ipar = (SQLUSMALLINT)parameterNumber;
	bindColStr[ipar-1] = SQL_NTS;
	RETCODE rt = ::SQLBindParameter(hstmt, ipar, SQL_PARAM_OUTPUT, 
		SQL_C_WCHAR, 
		SQL_WCHAR, //SQL_WCHAR, SQL_WVARCHAR, SQL_WLONGVARCHAR
		maxNumberOfChar*sizeof(wchar_t), 0, parameter, 0, &bindColStr[ipar-1]); 
	if (IsOk(rt)==false)
	{
		Sql::SqlExceptInfo ei;
		ei.hdbc = this->hdbc;
		ei.henv = this->henv;
		ei.hstmt = this->hstmt;
		ei.retcode = rt;
		throw Sql::SqlException(ei, NULL, L"SqlConnection::BindOutputParameter - SQLBindParameter");
	}
	return rt;
}

// Returns the number of attributes on a SQL statement without a connection
// If you have a Connection, use GetColCount();
int SqlConnection::GetAttributeCount(const wchar_t* statement)
{
	int iCount=0;
	int iParenthesis=0;
	
	if (statement ==NULL) return 0;
	const int len = (int)wcslen(statement);
	if (len == 0) return 0;

	// ___________________________________________We search for FROM
	const wchar_t* pFrom = wcsstr(statement, L"FROM");
	if (pFrom==NULL) pFrom = wcsstr (statement, L"from");
	if (pFrom != NULL)
	{
		pFrom--;
		iCount=1;
		for(const wchar_t* p=statement; p != pFrom; p++)
		{
			switch(*p)
			{
			case ',':
				if (iParenthesis==0)
					iCount++;
				break;
			case '(':
				iParenthesis++;
				break;
			case ')':
				iParenthesis--;
				break;
			}
		}
	}

	//_________________________________________ We search for DESCRIBE
	if (iCount==0)
	{
		pFrom=wcsstr (statement, L"DESCRIBE");
		if (pFrom==NULL) pFrom=wcsstr (statement, L"describe");
		if (pFrom) iCount =1;
	}

	return iCount;
}

//Returns the number of attributes on a SQL statement and the attribute names without an SQL connection
int SqlConnection::GetAttributeNames(const wchar_t* statement, vector<wstring>& output)
{
	output.clear();
	const int len = (int)wcslen(statement);
	if (len == 0) return 0;
	const int count = Sql::SqlConnection::GetAttributeCount(statement);
	if (count==0) return 0;
	int iParenthesis=0;
	bool bComma=false;
	wstring columnName;
	

	//********************************** We search for SELECT
	const wchar_t* pSelect = wcsstr(statement, L"SELECT");
	if (pSelect==NULL) pSelect=wcsstr (statement, L"select");

	if (pSelect)
	{
		pSelect+=6;
		const int lenSelect = (int)wcslen(pSelect) + 1;
		wchar_t* pData=new wchar_t[lenSelect];
		wcscpy_s(pData, lenSelect, pSelect);
		//________________________________________ We search for FROM
		wchar_t * pFrom=wcsstr (pData, L"FROM");
		if (pFrom==NULL) pFrom=wcsstr (pData, L"from");
		if (pFrom==NULL) return 0;
		pFrom--;
		*pFrom=','; // We add an extra comma to easy the column reading
		pFrom++;
		*pFrom='\0';
		int i=0;
		wchar_t* pBegin = NULL;
		wchar_t* pEnd = NULL;
		
		for(pEnd = pData; *pEnd!=NULL; pEnd++)
		{
			if (i>=count) break;
			switch(*pEnd)
			{
			case ',':
				if (iParenthesis==0) bComma=true;
				break;
			case '(':
				iParenthesis++;
				break;
			case ')':
				iParenthesis--;
				break;
			}
			if (bComma == true)
			{
				bComma=false;
				pBegin = pEnd;
				*pEnd='\0';
				pBegin--;
				if (*pBegin == '\'') //______________________________ AS 'column description'
				{
					pBegin--;
					while(*pBegin!='\'' && *pBegin!='\n' && *pBegin!='\r')
					{
						pBegin--;
					}
					pBegin++;
					columnName.assign(pBegin, pEnd-pBegin-1);					
				}
				else
				{
					while(*pBegin!=' ' && *pBegin!='\n' && *pBegin!='\r')
					{
						pBegin--;
					}
					pBegin++;
					columnName.assign(pBegin, pEnd-pBegin+1);
				}
				output.push_back(columnName);
			}
		}
		if (pData) delete [] pData;
	}
	else
	{
		//********************************** We search for DESCRIBE
		pSelect = wcsstr(statement, L"DESCRIBE");
		if (pSelect==NULL) pSelect=wcsstr(statement, L"describe");
		if (pSelect==NULL) return 0;
		pSelect += wcslen(L"DESCRIBE ");
		columnName.assign(pSelect, len-wcslen(L"DESCRIBE"));
		if (columnName.back() == ';') columnName.resize(columnName.length()-1); // Remove semicolon
		output.push_back(columnName);
	}

	return (int)output.size();
}

} //____________________________________________________ namespace Sql::End

namespace Web //________________________________________ namespace Web::Ini
{

//_______________________________________________________________________ ServiceVariable
ServiceVariable::ServiceVariable()
{
	type = WEBSERVICE_VARIABLE_INT;
}

ServiceVariable::~ServiceVariable()
{
}

const wchar_t* ServiceVariable::GetTypeText()
{
	switch(type)
	{
	case WEBSERVICE_VARIABLE_INT: return L"int";
	case WEBSERVICE_VARIABLE_DOUBLE: return L"double";
	case WEBSERVICE_VARIABLE_BOOL: return L"bool";
	case WEBSERVICE_VARIABLE_TEXT: return L"string";
	case WEBSERVICE_VARIABLE_OTHER: return L"other";
	}
	return L"other";
}

//_____________________________________________________________________ LexicalAnalyzer
LexicalAnalyzer::LexicalAnalyzer(void)
{
	isInsideTag = false;
}

LexicalAnalyzer::~LexicalAnalyzer(void)
{
}

bool LexicalAnalyzer::ContinueString(wchar_t c)
{
	if (isInsideTag == true)
	{
		 if (c == '=') return false;
		 if (c == '>') return false;
		 if (c == '/') return false;
		 if (c == ' ') return false;
		 if (c == '\t') return false;
	}
	else
	{
		if (c == ' ') return false;
		 if (c == '<') return false;
		 if (c == '&') return false;
		 if (c == '\t') return false;
		 if (c == '\r') return false;
		 if (c == '\n') return false;
	}
	return true;
}


void LexicalAnalyzer::ProcessString(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	int b = 0;
	int i = 0;
	const bool isTag = isInsideTag; // We store, so that we know it is a tag or not
	do
	{
		token.string_value[i] = c;
		i++;
		c = inputString[index++];
		b++;
		if (b >= LEX_STRINGMAX)
		{
			token.type = LEX_ERROR_STRING_TOO_LONG;
			token.line_number = line_number;
			token.string_value[b] = '\0';
			//_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"String too long in line %d", line_number);
			return;
		}
	}
	while (ContinueString(c) == true);
	if (c == '<') isInsideTag = true;
	//while (iswalnum(c) || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' || c == '_');
	token.string_value[i] = '\0';
	index--;
	token.type = (isTag == true) ? LEX_ID : LEX_HTML_TEXT;
	token.line_number = line_number;
}

void LexicalAnalyzer::GetNextToken(Cpl::LexicalAnalyzer::Token& token)
{
	int i=0;
	wchar_t* text = NULL;
	wchar_t c;
	bool isSequenceEscape = false;
	//___________________ clear token
	token.type = LEX_ERROR_UNRECOGNIZED_CHAR ;
	token.int_value = 0;
	token.double_value = 0.0;
	token.string_value[0]='\0';
	token.line_number = line_number;

	//_________________________ Have we reached the end of the file?
	if (index >= (int)length)
	{
		token.type = LEX_END_OF_FILE;
		token.line_number = line_number;
		token.string_value[i] = '\0';
		return;
	}
	//_________________________ find the token
	while(true)
	{
		c = inputString[index++];
		if (ProcessComments(c, token) == true)
		{
			continue;
		}
		else if (c==' ' || c=='\t') //________________strip out white space
		{
			continue;
		}
		else if (c=='\n') //_________________ update line number
		{
			line_number++;
		}
		else if (ProcessCharSequence(c, token) == true)
		{
			return;
		}
		else if (ProcessQuotedString(c, token) == true) //_________________ const string
		{
			return;
		}
		else if (ProcessSeparator(c, token) == true)
		{
			return;
		}
		else if (c == '\0')
		{
			token.type = LEX_END_OF_FILE;
			token.line_number = line_number;
			token.string_value[i] = '\0';
			return;
		}
		else
		{
			ProcessString(c, token);
			return;
		}
		//else
		//{
		//	token.type = LEX_ERROR_UNRECOGNIZED_CHAR;
		//	_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"Unrecognized character %c", c);
		//	token.line_number = line_number;
		//	return;
		//}
	}
}

bool LexicalAnalyzer::GetTokens(const wchar_t* inputString, vector<Cpl::LexicalAnalyzer::Token>& output)
{
	Web::LexicalAnalyzer lex;
	Cpl::LexicalAnalyzer::Token token;
	if (lex.Create(inputString) == false) return false;
	do
	{
		lex.GetNextToken(token);
		output.push_back(token);
	} while (token.type != LEX_END_OF_FILE);// && token.type != LEX_ERROR);
	return true;
}

void LexicalAnalyzer::FillKeywords(unordered_map<wstring, int>& keyword)
{
}

bool LexicalAnalyzer::ProcessCharSequence(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	if (c != '&') return false;
	int i = 0;
	token.string_value[i] = '&';
	for (i = 1; index < (int)length && i < LEX_STRINGMAX-1; index++, i++)
	{
		c = inputString[index];
		if (c == ';')
		{
			token.type = LEX_HTML_SPECIAL_SYMBOL;
			token.string_value[i] = c;
			token.string_value[i+1] = '\0';
			//
			index++;
			if (index <= (int)length) return true;
			c = inputString[index++];
			return true;
		}
		else
		{
			token.string_value[i] = c;
		}
	}
	return false;
}

// When it finds a comment, it returns true
bool LexicalAnalyzer::ProcessComments(wchar_t& c, Web::LexicalAnalyzer::Token& token)
{
	wchar_t prev;
	//__________________________________________________________ <
	if (c != '<') return false;
	if (index >= (int)length) return false;
	c = inputString[index++];
	//__________________________________________________________ <!
	if (c != '!') // It is not a comment
	{
		index--;
		c = '<';
		return false;
	}
	if (index >= (int)length) return false;
	c = inputString[index++];
	//__________________________________________________________ <!-
	if (c != '-') // It is not a comment
	{
		index -= 2;
		c = '<';
		return false;
	}
	if (index >= (int)length) return false;
	c = inputString[index++];
	//__________________________________________________________ <!--
	if (c != '-') // It is not a comment
	{
		index -= 3;
		c = '<';
		return false;
	}
	if (index >= (int)length) return false;
	c = inputString[index++];
	do
	{
		if (index >= (int)length) return false;
		c = inputString[index++];
		prev = c;
		if (c == '\0') break;
		if (c == '\n') line_number++; //update line number
		if (c == '-')
		{
			if (index >= (int)length) return false;
			c = inputString[index++];
			if (c == '\0')
			{
				token.type = LEX_ERROR_MISSING_COMMENT_TERMINATOR ;
				token.line_number = line_number;
				_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"Missing comment terminator in line %d", line_number);
				index--;
				return true;
			}
			if (c == '\n') line_number++; //update line number			
		}
	}
	while(prev != '-' || c != '-'); 	if (index >= (int)length) return true;
	//
	if (index >= (int)length) return true;
	c = inputString[index++]; // Advance -
	if (c != '>')
	{
		token.type = LEX_ERROR_MISSING_COMMENT_TERMINATOR;
		token.line_number = line_number;
		_snwprintf_s(token.string_value, LEX_STRINGMAX, _TRUNCATE, L"Missing comment terminator in line %d", line_number);
	}
	//
	//if (index >= (int)length) return false;
	//c = inputString[index++]; // Advance >
	return true;
}

bool LexicalAnalyzer::ProcessSeparator(wchar_t& c, Cpl::LexicalAnalyzer::Token& token)
{
	if (CheckToken(token, c, '<', '/', LEX_TAG_CLOSING))
	{
		isInsideTag = true;
		return true;
	}
	else if (CheckToken(token, c, '/', '>', LEX_MONO_TAG_CLOSING))
	{
		isInsideTag = false;
		return true;
	}
	else if (CheckToken(token, c, '<', LEX_IS_LESS))
	{
		isInsideTag = true;
		return true;
	}
	else if (CheckToken(token, c, '>', LEX_IS_BIGGER))
	{
		isInsideTag = false;
		return true;
	}
	if (isInsideTag == true)
	{
		if (CheckToken(token, c, '=', LEX_EQUAL)) return true;
	}
	return false;
}

//_____________________________________________________________________ HtmlToColorText
// It convert HTML text to a list of Sys::ColorText
HtmlToColorText::HtmlToColorText()
{
	colorText = RGB(0, 0, 0);
	colorTagName = RGB(40, 60, 225);
	colorTagProperty = RGB(40, 100, 155);
	colorTag = RGB(110, 110, 110);
	colorEqualSign = RGB(10, 150, 0);
	colorError = RGB(255, 0, 0);
	colorID = RGB(0, 0, 255);
	colorSpecialSymbol = RGB(10, 100, 10);
	colorQuotedText = RGB(114, 0, 64);
}

HtmlToColorText::~HtmlToColorText()
{
}

void HtmlToColorText::Convert(const wstring& input, list<Sys::ColorText>& output)
{
	Convert(input.c_str(), output);
}

void HtmlToColorText::Convert(const wchar_t* input, list<Sys::ColorText>& output)
{
	//output.clear();
	vector<Cpl::LexicalAnalyzer::Token> token;
	Web::LexicalAnalyzer::GetTokens(input, token);
	const size_t count = token.size();
	if (count <= 0) return;
	size_t i;
	Sys::ColorText ct;
	bool firstLexID = false;
	bool firstHtmlText = true;
	for (i = 0; i < count; i++)
	{
		if (token[i].type == LEX_IS_LESS) // <
		{
			ct.text = L"<";
			ct.color = colorTag;
			output.push_back(ct);
			firstLexID = true;
			firstHtmlText = true;
		}
		else if (token[i].type == LEX_TAG_CLOSING) // </
		{
			ct.text = L"</";
			ct.color = colorTag;
			output.push_back(ct);
			firstLexID = true;
			firstHtmlText = true;
		}
		else if (token[i].type == LEX_HTML_SPECIAL_SYMBOL)
		{
			ct.text = token[i].string_value;
			ct.text += L" ";
			ct.color = colorSpecialSymbol;
			output.push_back(ct);
		}
		else if (token[i].type == LEX_IS_BIGGER) // >
		{
			ct.text = L">";
			ct.color = colorTag;
			output.push_back(ct);
			firstHtmlText = true;
		}
		else if (token[i].type == LEX_MONO_TAG_CLOSING) // />
		{
			ct.text = L"/>";
			ct.color = colorTag;
			output.push_back(ct);
			firstHtmlText = true;
		}
		else if (token[i].type == LEX_EQUAL) // =
		{
			ct.text = L"=";
			ct.color = colorEqualSign;
			output.push_back(ct);
		}
		else if (token[i].type == LEX_EXCLAMATION_MARK) // !
		{
			ct.text = L"!";
			ct.color = colorTag;
			output.push_back(ct);
		}
		else if (token[i].type == LEX_ID) // ID
		{
			if (firstLexID == true)
			{
				firstLexID = false;
				ct.color = colorTagName;
				ct.text = token[i].string_value;
			}
			else
			{
				ct.color = colorTagProperty;
				ct.text = L" ";
				ct.text += token[i].string_value;
			}
			output.push_back(ct);
		}
		else if (token[i].type == LEX_HTML_TEXT)
		{
			ct.color = colorText;
			if (firstHtmlText == true)
			{
				ct.text = token[i].string_value;
				firstHtmlText = false;
			}
			else
			{
				ct.text = L" ";
				ct.text += token[i].string_value;
			}
			output.push_back(ct);
		}
		else if (token[i].type == LEX_CONST_VALUE_STRING) // "text"
		{
			ct.text = L"\"";
			ct.text += token[i].string_value;
			ct.text += L"\" ";
			ct.color = colorQuotedText;
			output.push_back(ct);
		}
		else
		{
			ct.text = token[i].string_value;
			ct.color = RGB(0, 0, 0);
			output.push_back(ct);
		}
	}
}
//__________________________________________________  CssType
CssType::CssType()
{
}

CssType::~CssType()
{
}

//__________________________________________________ Helper
Helper::Helper()
{
}

 Helper::~Helper()
 {
 }

wchar_t* Helper::GetTagDesc(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"<span>text</span>";
	case HTML_TND_P: return L"<p>text</p>";
	case HTML_TND_SMALL: return L"<small>text</small>";
	case HTML_TND_PRE: return L"<pre>text</pre>";
	case HTML_TND_TT: return L"<tt>text</tt>";
	case HTML_TND_B: return L"<b>text</b>";
	case HTML_TND_I: return L"<i>text</i>";
	case HTML_TND_U: return L"<u>text</u>";
	case HTML_TND_STRIKE: return L"<strike>text</strike>";
	case HTML_TND_Q: return L"<q>text</q>";
	case HTML_TND_H1: return L"<h1>text</h1>";
	case HTML_TND_H2: return L"<h2>text</h2>";
	case HTML_TND_H3: return L"<h3>text</h3>";
	case HTML_TND_H4: return L"<h4>text</h4>";
	case HTML_TND_H5: return L"<h5>text</h5>";
	case HTML_TND_H6: return L"<h6>text</h6>";
	case HTML_TND_NONE: return L"text";
	//
	case HTML_PND_TABLE: return L"<table>child</table>";
	case HTML_PND_SPAN: return L"<span>child</span>";
	case HTML_PND_UL: return L"<ul>child</ul>";
	case HTML_PND_OL: return L"<ol>child</ol>";
	case HTML_PND_DL: return L"<dl>child</dl>";
	case HTML_PND_NONE: return L"child";
	}
	return NULL;
}

wchar_t* Helper::GetTag(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"span";
	case HTML_TND_P: return L"p";
	case HTML_TND_SMALL: return L"small";
	case HTML_TND_PRE: return L"pre";
	case HTML_TND_TT: return L"tt";
	case HTML_TND_B: return L"b";
	case HTML_TND_I: return L"i";
	case HTML_TND_U: return L"u";
	case HTML_TND_STRIKE: return L"strike";
	case HTML_TND_Q: return L"q";
	case HTML_TND_H1: return L"h1";
	case HTML_TND_H2: return L"h2";
	case HTML_TND_H3: return L"h3";
	case HTML_TND_H4: return L"h4";
	case HTML_TND_H5: return L"h5";
	case HTML_TND_H6: return L"h6";
	//
	case HTML_PND_TABLE: return L"table";
	case HTML_PND_SPAN: return L"span";
	case HTML_PND_UL: return L"ul";
	case HTML_PND_OL: return L"ol";
	case HTML_PND_DL: return L"dl";
	//
	case HTML_TD: return L"td";
	case HTML_TR: return L"tr";
	case HTML_TH: return L"th";
	case HTML_DIV: return L"div";
	case HTML_LI: return L"li";
	case HTML_DD: return L"dd";
	case HTML_FORM: return L"form";
	case HTML_BODY: return L"body";
	case HTML_HEAD: return L"head";
	case HTML_INPUT: return L"input";
	case HTML_BR: return L"br";
	case HTML_HR: return L"hr";
	case HTML_SELECTX: return L"select";
	case HTML_TEXTAREA: return L"textarea";
	case HTML_META: return L"meta";
	case HTML_HTML: return L"html";
	case HTML_DOCTYPE: return L"!DOCTYPE";
	case HTML_TITLE: return L"title";
	case HTML_LINK: return L"link";
	case HTML_SCRIPT: return L"script";
	case HTML_IMG: return L"img";
	case HTML_A: return L"a";
	case HTML_OPTION: return L"option";
	case HTML_OBJECT: return L"object";
	case HTML_COMMENT: return L"!--";
	}
	return NULL;
}

bool Helper::RequiresClosingTag(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return true;
	case HTML_TND_P: return true;
	case HTML_TND_SMALL: return true;
	case HTML_TND_PRE: return true;
	case HTML_TND_TT: return true;
	case HTML_TND_B: return true;
	case HTML_TND_I: return true;
	case HTML_TND_U: return true;
	case HTML_TND_STRIKE: return true;
	case HTML_TND_Q: return true;
	case HTML_TND_H1: return true;
	case HTML_TND_H2: return true;
	case HTML_TND_H3: return true;
	case HTML_TND_H4: return true;
	case HTML_TND_H5: return true;
	case HTML_TND_H6: return true;
	//
	case HTML_PND_TABLE: return true;
	case HTML_PND_SPAN: return true;
	case HTML_PND_UL: return true;
	case HTML_PND_OL: return true;
	case HTML_PND_DL: return true;
	//
	case HTML_TD: return true;
	case HTML_TR: return true;
	case HTML_TH: return true;
	case HTML_DIV: return true;
	case HTML_LI: return true;
	case HTML_DD: return true;
	case HTML_FORM: return true;
	case HTML_BODY: return true;
	case HTML_HEAD: return true;
	case HTML_INPUT: return false;
	case HTML_BR: return false;
	case HTML_HR: return false;
	case HTML_SELECTX: return true;
	case HTML_TEXTAREA: return true;
	case HTML_META: return false;
	case HTML_HTML: return true;
	case HTML_DOCTYPE: return false;
	case HTML_TITLE: return true;
	case HTML_LINK: return false;
	case HTML_SCRIPT: return true;
	case HTML_IMG: return false;
	case HTML_A: return true;
	case HTML_OPTION: return true;
	case HTML_OBJECT: return true;
	case HTML_COMMENT: return false;
	}
	return NULL;
}

wchar_t* Helper::GetTagName(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"Text Section";
	case HTML_TND_P: return L"Paragraph";
	case HTML_TND_SMALL: return L"Small Text";
	case HTML_TND_PRE: return L"Monospaced Text";
	case HTML_TND_TT: return L"Monospaced Text";
	case HTML_TND_B: return L"Bold Text";
	case HTML_TND_I: return L"Italics Text";
	case HTML_TND_U: return L"Underline Text";
	case HTML_TND_STRIKE: return L"Strike Text";
	case HTML_TND_Q: return L"Quotation";
	case HTML_TND_H1: return L"Heading 1";
	case HTML_TND_H2: return L"Heading 2";
	case HTML_TND_H3: return L"Heading 3";
	case HTML_TND_H4: return L"Heading 4";
	case HTML_TND_H5: return L"Heading 5";
	case HTML_TND_H6: return L"Heading 6";
	case HTML_TND_NONE: return L"None";
	//
	case HTML_PND_TABLE: return L"table";
	case HTML_PND_SPAN: return L"span";
	case HTML_PND_UL: return L"unordered list";
	case HTML_PND_OL: return L"ordered list";
	case HTML_PND_DL: return L"definition list";
	case HTML_PND_NONE: return L"none";
	}
	return NULL;
}

wchar_t* Helper::GetNodeTypeText(int type)
{
	switch(type)
	{
	case HTML_TND_SPAN: return L"HTML_TND_SPAN";
	case HTML_TND_P: return L"HTML_TND_P";
	case HTML_TND_SMALL: return L"HTML_TND_SMALL";
	case HTML_TND_PRE: return L"HTML_TND_PRE";
	case HTML_TND_TT: return L"HTML_TND_TT";
	case HTML_TND_B: return L"HTML_TND_B";
	case HTML_TND_I: return L"HTML_TND_I";
	case HTML_TND_U: return L"HTML_TND_U";
	case HTML_TND_STRIKE: return L"HTML_TND_STRIKE";
	case HTML_TND_Q: return L"HTML_TND_Q";
	case HTML_TND_H1: return L"HTML_TND_H1";
	case HTML_TND_H2: return L"HTML_TND_H2";
	case HTML_TND_H3: return L"HTML_TND_H3";
	case HTML_TND_H4: return L"HTML_TND_H4";
	case HTML_TND_H5: return L"HTML_TND_H5";
	case HTML_TND_H6: return L"HTML_TND_H6";
	case HTML_TND_NONE: return L"HTML_TND_NONE";
	//
	case HTML_PND_TABLE: return L"HTML_PND_ONE_ROW_TABLE";
	case HTML_PND_SPAN: return L"HTML_PND_SPAN";
	case HTML_PND_UL: return L"HTML_PND_UL";
	case HTML_PND_OL: return L"HTML_PND_OL";
	case HTML_PND_DL: return L"HTML_PND_DL";
	case HTML_PND_NONE: return L"HTML_PND_NONE";
	}
	return NULL;
}

wchar_t* Helper::GetControlClass(int type_id)
{
	switch(type_id)
	{
	case HTML_BARCHART: return L"Web::BarChart";
	case HTML_BUTTON: return L"Web::Button";
	case HTML_CHECKBOX: return L"Web::CheckBox";
	case HTML_CHECKBOXLIST: return L"Web::CheckBoxList";
	//case HTML_CUSTOMCONTROL: return L"Web::CustomControl";
	case HTML_DATETIMEBOX: return L"Web::DateTimeBox";
	case HTML_DATEVIEW: return L"Web::DateView";
	case HTML_DROPDOWNLIST: return L"Web::DropDownList";
	case HTML_HIDDENVALUE: return L"Web::HiddenValue";
	case HTML_HISTOGRAM: return L"Web::Histogram";
	case HTML_IMAGE: return L"Web::Image";
	case HTML_IMAGELINK: return L"Web::ImageLink";
	case HTML_LABEL: return L"Web::Label";
	case HTML_LISTBOX: return L"Web::ListBox";
	case HTML_LISTVIEW: return L"Web::ListView";
	case HTML_PARENTNODE: return L"Web::ParentNode";
	case HTML_PIECHART: return L"Web::PieChart";
	case HTML_PLUGIN: return L"Web::PlugIn";
	case HTML_POLARCHART: return L"Web::PolarChart";
	case HTML_RADIOBUTTON: return L"Web::RadioButton";
	case HTML_WEBSERVICE: return L"Web::Service";
	case HTML_TEXTBOX: return L"Web::Textbox";
	case HTML_TEXTLINK: return L"Web::TextLink";
	case HTML_XYCHART: return L"Web::XyChart";
	case HTML_PAGE: return L"Web::Page";
	}
	return NULL;
}

wchar_t* Helper::GetControlDescr(int type_id)
{
	switch(type_id)
	{
	case HTML_BARCHART: return L"Bar Chart";
	case HTML_BUTTON: return L"Button";
	case HTML_CHECKBOX: return L"Check Box";
	case HTML_CHECKBOXLIST: return L"Check Box List";
	case HTML_CUSTOMCONTROL: return L"Custom Control";
	case HTML_DATETIMEBOX: return L"Date Time Box";
	case HTML_DATEVIEW: return L"Date View";
	case HTML_DROPDOWNLIST: return L"Drop Down List";
	case HTML_HIDDENVALUE: return L"Hidden Value";
	case HTML_HISTOGRAM: return L"Histogram";
	case HTML_IMAGE: return L"Image";
	case HTML_IMAGELINK: return L"Image Link";
	case HTML_LABEL: return L"Label";
	case HTML_LISTBOX: return L"List Box";
	case HTML_LISTVIEW: return L"List View";
	case HTML_PARENTNODE: return L"Parent Node";
	case HTML_PIECHART: return L"Pie Chart";
	case HTML_PLUGIN: return L"Plug In";
	case HTML_POLARCHART: return L"Polar Chart";
	case HTML_RADIOBUTTON: return L"Radio Button";
	case HTML_WEBSERVICE: return L"Web Service (SOAP)";
	case HTML_TEXTBOX: return L"Text Box";
	case HTML_TEXTLINK: return L"Text Link";
	case HTML_XYCHART: return L"XY Chart";
	case HTML_PAGE: return L"Page";
	}
	return NULL;
}

wchar_t * Helper::GetControlCaption(int type_id)
{
	switch(type_id)
	{
	case HTML_BARCHART: return L"bchart";
	case HTML_BUTTON: return L"bt";
	case HTML_CHECKBOX: return L"ck";
	case HTML_CHECKBOXLIST: return L"cl";
	case HTML_CUSTOMCONTROL: return L"customControl";
	case HTML_DATETIMEBOX: return L"dtbox";
	case HTML_DATEVIEW: return L"dv";
	case HTML_DROPDOWNLIST: return L"dd";
	case HTML_HIDDENVALUE: return L"hd";
	case HTML_HISTOGRAM: return L"hist";
	case HTML_IMAGE: return L"img";
	case HTML_IMAGELINK: return L"imk";
	case HTML_LABEL: return L"lb";
	case HTML_LISTBOX: return L"lbx";
	case HTML_LISTVIEW: return L"lv";
	case HTML_PARENTNODE: return L"pnd";
	case HTML_PIECHART: return L"pie";
	case HTML_PLUGIN: return L"pgi";
	case HTML_POLARCHART: return L"polar";
	case HTML_RADIOBUTTON: return L"radio";
	case HTML_WEBSERVICE: return L"service";
	case HTML_TEXTBOX: return L"tbx";
	case HTML_TEXTLINK: return L"txk";
	case HTML_XYCHART: return L"xy";
	case HTML_PAGE: return L"this->";
	}
	return NULL;
}

wchar_t* Helper::GetPositionDescr(Web::CssType::Position position)
{
	switch(position)
	{
	case Web::CssType::PositionAuto: return L"Automatic"; 
	case Web::CssType::PositionAbsolute: return L"Absolute"; 
	case Web::CssType::PositionRelative: return L"Relative";
	}
	return NULL;
}

wchar_t* Helper::GetPositionValue(Web::CssType::Position position)
{
	switch(position)
	{
	//case Web::CssType::PositionAuto: return L"auto"; 
	case Web::CssType::PositionAbsolute: return L"absolute"; 
	case Web::CssType::PositionRelative: return L"relative";
	}
	return NULL;
}

wchar_t* Helper::GetPositionEnum(Web::CssType::Position position)
{
	switch(position)
	{
	case Web::CssType::PositionAuto: return L"Web::CssType::PositionAuto"; 
	case Web::CssType::PositionAbsolute: return L"Web::CssType::PositionAbsolute"; 
	case Web::CssType::PositionRelative: return L"Web::CssType::PositionRelative";
	}
	return NULL;
}

wchar_t* Helper::GetFontFamilyDescr(Web::CssType::FontFamily font_family)
{
	switch(font_family)
	{
	case Web::CssType::FontFamilyAuto: return L"Automatic"; 
	case Web::CssType::FontFamilyArial: return L"Arial"; 
	case Web::CssType::FontFamilyCourier: return L"Courier"; 
	case Web::CssType::FontFamilyTimesNewRoman: return L"Times New Roman";  
	}
	return NULL;
}

wchar_t* Helper::GetFontFamilyValue(Web::CssType::FontFamily font_family)
{
	switch(font_family)
	{
	//case Web::CssType::FontFamilyAuto: return L"auto"; 
	case Web::CssType::FontFamilyArial: return L"'Arial', 'Helvetica', 'sans-serif'"; 
	case Web::CssType::FontFamilyCourier: return L"'Courier New', 'Courier', 'monospace', 'Lucida Console', 'Monaco'"; 
	case Web::CssType::FontFamilyTimesNewRoman: return L"'Times New Roman', 'Times', 'serif'";  
	}
	return NULL;
}

wchar_t* Helper::GetFontFamilyEnum(Web::CssType::FontFamily font_family)
{
	switch(font_family)
	{
	case Web::CssType::FontFamilyAuto: return L"Web::CssType::FontFamilyAuto"; 
	case Web::CssType::FontFamilyArial: return L"Web::CssType::FontFamilyArial"; 
	case Web::CssType::FontFamilyCourier: return L"Web::CssType::FontFamilyCourier"; 
	case Web::CssType::FontFamilyTimesNewRoman: return L"Web::CssType::FontFamilyTimesNewRoman";  
	}
	return NULL;
}

wchar_t* Helper::GetTextAlignDescr(Web::CssType::TextAlign text_align)
{
	switch(text_align)
	{
	case Web::CssType::TextAlignAuto: return L"Automatic"; 
	case Web::CssType::TextAlignCenter: return L"Center"; 
	case Web::CssType::TextAlignJustify: return L"Justify"; 
	case Web::CssType::TextAlignLeft: return L"Left"; 
	case Web::CssType::TextAlignRight: return L"Right";
	}
	return NULL;
}

wchar_t* Helper::GetTextAlignValue(Web::CssType::TextAlign text_align)
{
	switch(text_align)
	{
	//case Web::CssType::TextAlignAuto: return L"auto"; 
	case Web::CssType::TextAlignCenter: return L"center"; 
	case Web::CssType::TextAlignJustify: return L"justify"; 
	case Web::CssType::TextAlignLeft: return L"left"; 
	case Web::CssType::TextAlignRight: return L"right";
	}
	return NULL;
}

wchar_t* Helper::GetTextAlignEnum(Web::CssType::TextAlign text_align)
{
	switch(text_align)
	{
	case Web::CssType::TextAlignAuto: return L"Web::CssType::TextAlignAuto"; 
	case Web::CssType::TextAlignCenter: return L"Web::CssType::TextAlignCenter"; 
	case Web::CssType::TextAlignJustify: return L"Web::CssType::TextAlignJustify"; 
	case Web::CssType::TextAlignLeft: return L"Web::CssType::TextAlignLeft"; 
	case Web::CssType::TextAlignRight: return L"Web::CssType::TextAlignRight";
	}
	return NULL;
}

wchar_t* Helper::GetVerticalAlignDescr(Web::CssType::VerticalAlign vertical_align)
{
	switch(vertical_align)
	{
	case Web::CssType::VerticalAlignAuto: return L"Automatic"; 
	case Web::CssType::VerticalAlignBaseline: return L"Baseline";  
	case Web::CssType::VerticalAlignBottom: return L"Bottom"; 
	case Web::CssType::VerticalAlignMiddle: return L"Middle"; 
	case Web::CssType::VerticalAlignSub: return L"Sub-index"; 
	case Web::CssType::VerticalAlignSuper: return L"Superscript"; 
	case Web::CssType::VerticalAlignTextBottom: return L"Text-bottom"; 
	case Web::CssType::VerticalAlignTextTop: return L"Text-top"; 
	case Web::CssType::VerticalAlignTop: return L"Top";
	}
	return NULL;
}

wchar_t* Helper::GetVerticalAlignValue(Web::CssType::VerticalAlign vertical_align)
{
	switch(vertical_align)
	{
	//case Web::CssType::VerticalAlignAuto: return L"auto"; 
	case Web::CssType::VerticalAlignBaseline: return L"baseline";  
	case Web::CssType::VerticalAlignBottom: return L"bottom"; 
	case Web::CssType::VerticalAlignMiddle: return L"middle"; 
	case Web::CssType::VerticalAlignSub: return L"sub"; 
	case Web::CssType::VerticalAlignSuper: return L"super"; 
	case Web::CssType::VerticalAlignTextBottom: return L"text-bottom"; 
	case Web::CssType::VerticalAlignTextTop: return L"text-top"; 
	case Web::CssType::VerticalAlignTop: return L"top";
	}
	return NULL;
}

wchar_t* Helper::GetVerticalAlignEnum(Web::CssType::VerticalAlign vertical_align)
{
	switch(vertical_align)
	{
	case Web::CssType::VerticalAlignAuto: return L"Web::CssType::VerticalAlignAuto"; 
	case Web::CssType::VerticalAlignBaseline: return L"Web::CssType::VerticalAlignBaseline";  
	case Web::CssType::VerticalAlignBottom: return L"Web::CssType::VerticalAlignBottom"; 
	case Web::CssType::VerticalAlignMiddle: return L"Web::CssType::VerticalAlignMiddle"; 
	case Web::CssType::VerticalAlignSub: return L"Web::CssType::VerticalAlignSub"; 
	case Web::CssType::VerticalAlignSuper: return L"Web::CssType::VerticalAlignSuper"; 
	case Web::CssType::VerticalAlignTextBottom: return L"Web::CssType::VerticalAlignTextBottom"; 
	case Web::CssType::VerticalAlignTextTop: return L"Web::CssType::VerticalAlignTextTop"; 
	case Web::CssType::VerticalAlignTop: return L"Web::CssType::VerticalAlignTop";
	}
	return NULL;
}


wchar_t* Helper::GetTextDecorationDescr(Web::CssType::TextDecoration text_decoration)
{
	switch(text_decoration)
	{
	case Web::CssType::TextDecorationAuto: return L"Automatic"; 
	case Web::CssType::TextDecorationBlink: return L"Blink"; 
	case Web::CssType::TextDecorationLineThrough: return L"Line-through"; 
	case Web::CssType::TextDecorationNone: return L"None";
	case Web::CssType::TextDecorationOverline: return L"Overline"; 
	case Web::CssType::TextDecorationUnderline: return L"Underline"; 
	}
	return NULL;
}

wchar_t* Helper::GetTextDecorationValue(Web::CssType::TextDecoration text_decoration)
{
	switch(text_decoration)
	{
	//case Web::CssType::TextDecorationAuto: return L"auto"; 
	case Web::CssType::TextDecorationBlink: return L"blink"; 
	case Web::CssType::TextDecorationLineThrough: return L"line-through"; 
	case Web::CssType::TextDecorationNone: return L"none";
	case Web::CssType::TextDecorationOverline: return L"overline"; 
	case Web::CssType::TextDecorationUnderline: return L"underline"; 
	}
	return NULL;
}

wchar_t* Helper::GetTextDecorationEnum(Web::CssType::TextDecoration text_decoration)
{
	switch(text_decoration)
	{
	case Web::CssType::TextDecorationAuto: return L"Web::CssType::TextDecorationAuto"; 
	case Web::CssType::TextDecorationBlink: return L"Web::CssType::TextDecorationBlink"; 
	case Web::CssType::TextDecorationLineThrough: return L"Web::CssType::TextDecorationLineThrough"; 
	case Web::CssType::TextDecorationNone: return L"Web::CssType::TextDecorationNone";
	case Web::CssType::TextDecorationOverline: return L"Web::CssType::TextDecorationOverline"; 
	case Web::CssType::TextDecorationUnderline: return L"Web::CssType::TextDecorationUnderline"; 
	}
	return NULL;
}

wchar_t* Helper::GetVisibilityDescr(Web::CssType::Visibility visibility)
{
	switch(visibility)
	{
	case Web::CssType::VisibilityAuto: return L"Automatic"; 
	case Web::CssType::VisibilityHidden: return L"Hidden"; 
	case Web::CssType::VisibilityVisible: return L"Visible";
	}
	return NULL;
}

wchar_t* Helper::GetVisibilityValue(Web::CssType::Visibility visibility)
{
	switch(visibility)
	{
	//case Web::CssType::VisibilityAuto: return L"auto"; 
	case Web::CssType::VisibilityHidden: return L"hidden"; 
	case Web::CssType::VisibilityVisible: return L"visible";
	}
	return NULL;
}

wchar_t* Helper::GetVisibilityEnum(Web::CssType::Visibility visibility)
{
	switch(visibility)
	{
	case Web::CssType::VisibilityAuto: return L"Web::CssType::VisibilityAuto"; 
	case Web::CssType::VisibilityHidden: return L"Web::CssType::VisibilityHidden"; 
	case Web::CssType::VisibilityVisible: return L"Web::CssType::VisibilityVisible";
	}
	return NULL;
}

wchar_t* Helper::GetBorderStyleDescr(Web::CssType::BorderStyle border_style)
{
	switch(border_style)
	{
	case Web::CssType::BorderStyleAuto: return L"Automatic"; 
	case Web::CssType::BorderStyleDotted: return L"Dotted"; 
	case Web::CssType::BorderStyleGroove: return L"Groove"; 
	case Web::CssType::BorderStyleInset: return L"Inset"; 
	case Web::CssType::BorderStyleNone: return L"None"; 
	case Web::CssType::BorderStyleOutset: return L"Outset"; 
	case Web::CssType::BorderStyleRidge: return L"Ridge"; 
	case Web::CssType::BorderStyleSolid: return L"Solid"; 
	}
	return NULL;
}

wchar_t* Helper::GetBorderStyleValue(Web::CssType::BorderStyle border_style)
{
	switch(border_style)
	{
	//case Web::CssType::BorderStyleAuto: return L"auto"; 
	case Web::CssType::BorderStyleDotted: return L"dotted"; 
	case Web::CssType::BorderStyleGroove: return L"groove"; 
	case Web::CssType::BorderStyleInset: return L"inset"; 
	case Web::CssType::BorderStyleNone: return L"none"; 
	case Web::CssType::BorderStyleOutset: return L"outset"; 
	case Web::CssType::BorderStyleRidge: return L"ridge"; 
	case Web::CssType::BorderStyleSolid: return L"solid"; 
	}
	return NULL;
}

wchar_t* Helper::GetBorderStyleEnum(Web::CssType::BorderStyle border_style)
{
	switch(border_style)
	{
	case Web::CssType::BorderStyleAuto: return L"Web::CssType::BorderStyleAuto"; 
	case Web::CssType::BorderStyleDotted: return L"Web::CssType::BorderStyleDotted"; 
	case Web::CssType::BorderStyleGroove: return L"Web::CssType::BorderStyleGroove"; 
	case Web::CssType::BorderStyleInset: return L"Web::CssType::BorderStyleInset"; 
	case Web::CssType::BorderStyleNone: return L"Web::CssType::BorderStyleNone"; 
	case Web::CssType::BorderStyleOutset: return L"Web::CssType::BorderStyleOutset"; 
	case Web::CssType::BorderStyleRidge: return L"Web::CssType::BorderStyleRidge"; 
	case Web::CssType::BorderStyleSolid: return L"Web::CssType::BorderStyleSolid"; 
	}
	return NULL;
}

wchar_t* Helper::GetDisplayDescr(Web::CssType::Display display)
{
	switch(display)
	{
	case Web::CssType::DisplayAuto: return L"Automatic"; 
	case Web::CssType::DisplayBlock: return L"Block"; 	
	case Web::CssType::DisplayInline: return L"Inline"; 
	case Web::CssType::DisplayListItem: return L"List-item";
	case Web::CssType::DisplayNone: return L"None"; 
	}
	return NULL;
}

wchar_t* Helper::GetDisplayValue(Web::CssType::Display display)
{
	switch(display)
	{
	//case Web::CssType::DisplayAuto: return L"auto"; 	
	case Web::CssType::DisplayBlock: return L"block"; 
	case Web::CssType::DisplayInline: return L"inline"; 
	case Web::CssType::DisplayListItem: return L"list-item";
	case Web::CssType::DisplayNone: return L"none"; 
	}
	return NULL;
}

wchar_t* Helper::GetDisplayEnum(Web::CssType::Display display)
{
	switch(display)
	{
	case Web::CssType::DisplayAuto: return L"Web::CssType::DisplayAuto"; 	
	case Web::CssType::DisplayBlock: return L"Web::CssType::DisplayBlock"; 
	case Web::CssType::DisplayInline: return L"Web::CssType::DisplayInline"; 
	case Web::CssType::DisplayListItem: return L"Web::CssType::DisplayListItem";
	case Web::CssType::DisplayNone: return L"Web::CssType::DisplayNone"; 
	}
	return NULL;
}

wchar_t* Helper::GetCursorDescr(Web::CssType::Cursor cursor)
{
	switch(cursor)
	{
	case Web::CssType::CursorAuto: return L"Automatic"; 
	case Web::CssType::CursorCrosshair: return L"Crosshair"; 
	case Web::CssType::CursorDefault: return L"Default"; 
	case Web::CssType::CursorEResize: return L"East resize"; 
	case Web::CssType::CursorHelp: return L"Help"; 
	case Web::CssType::CursorMove: return L"Move"; 
	case Web::CssType::CursorNeResize: return L"NE resize"; 
	case Web::CssType::CursorNResize: return L"North resize"; 
	case Web::CssType::CursorNwResize: return L"NW resize"; 
	case Web::CssType::CursorPointer: return L"Pointer"; 
	case Web::CssType::CursorSeResize: return L"SE resize"; 
	case Web::CssType::CursorSResize: return L"South resize"; 
	case Web::CssType::CursorSwResize: return L"SW resize"; 
	case Web::CssType::CursorText: return L"Text";  
	case Web::CssType::CursorWait: return L"Wait";  
	case Web::CssType::CursorWResize: return L"West resize";
	}
	return NULL;
}

wchar_t* Helper::GetCursorValue(Web::CssType::Cursor cursor)
{
	switch(cursor)
	{
	//case Web::CssType::CursorAuto: return L"auto"; 
	case Web::CssType::CursorCrosshair: return L"crosshair"; 
	case Web::CssType::CursorDefault: return L"default"; 
	case Web::CssType::CursorEResize: return L"e-resize"; 
	case Web::CssType::CursorHelp: return L"help"; 
	case Web::CssType::CursorMove: return L"move"; 
	case Web::CssType::CursorNeResize: return L"ne-resize"; 
	case Web::CssType::CursorNResize: return L"n-resize"; 
	case Web::CssType::CursorNwResize: return L"nw-resize"; 
	case Web::CssType::CursorPointer: return L"pointer"; 
	case Web::CssType::CursorSeResize: return L"se-resize"; 
	case Web::CssType::CursorSResize: return L"s-resize"; 
	case Web::CssType::CursorSwResize: return L"sw_resize"; 
	case Web::CssType::CursorText: return L"text";  
	case Web::CssType::CursorWait: return L"wait";  
	case Web::CssType::CursorWResize: return L"w-resize";
	}
	return NULL;
}

wchar_t* Helper::GetCursorEnum(Web::CssType::Cursor cursor)
{
	switch(cursor)
	{
	case Web::CssType::CursorAuto: return L"Web::CssType::CursorAuto"; 
	case Web::CssType::CursorCrosshair: return L"Web::CssType::CursorCrosshair"; 
	case Web::CssType::CursorDefault: return L"Web::CssType::CursorDefault"; 
	case Web::CssType::CursorEResize: return L"Web::CssType::CursorEResize"; 
	case Web::CssType::CursorHelp: return L"Web::CssType::CursorHelp"; 
	case Web::CssType::CursorMove: return L"Web::CssType::CursorMove"; 
	case Web::CssType::CursorNeResize: return L"Web::CssType::CursorNeResize"; 
	case Web::CssType::CursorNResize: return L"Web::CssType::CursorNResize"; 
	case Web::CssType::CursorNwResize: return L"Web::CssType::CursorNwResize"; 
	case Web::CssType::CursorPointer: return L"Web::CssType::CursorPointer"; 
	case Web::CssType::CursorSeResize: return L"Web::CssType::CursorSeResize"; 
	case Web::CssType::CursorSResize: return L"Web::CssType::CursorSResize"; 
	case Web::CssType::CursorSwResize: return L"Web::CssType::CursorSwResize"; 
	case Web::CssType::CursorText: return L"Web::CssType::CursorText";  
	case Web::CssType::CursorWait: return L"Web::CssType::CursorWait";  
	case Web::CssType::CursorWResize: return L"Web::CssType::CursorWResize";
	}
	return NULL;
}

Web::CssType::Position Helper::GetPositionType(const wchar_t* text)
{
	//if (wcscmp(text, L"PositionAuto") == 0) return Web::CssType::PositionAuto; 
	if (wcscmp(text, L"PositionAbsolute")==0) return Web::CssType::PositionAbsolute;
	if (wcscmp(text, L"PositionRelative") == 0) return Web::CssType::PositionRelative;
	return Web::CssType::PositionAuto;
}

//Web::CssType::Position Helper::ReadPositionValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"PositionAuto") == 0) return Web::CssType::PositionAuto; 
//	if (tmp== L"absolute") return Web::CssType::PositionAbsolute;
//	if (tmp == L"relative") return Web::CssType::PositionRelative;
//	return Web::CssType::PositionAuto;
//}

Web::CssType::FontFamily Helper::GetFontFamilyType(const wchar_t* text)
{
	//if (wcscmp(text, L"FontFamilyAuto") == 0) return Web::CssType::FontFamilyAuto, 
	if (wcscmp(text, L"FontFamilyArial") == 0) return Web::CssType::FontFamilyArial;
	if (wcscmp(text, L"FontFamilyCourier") == 0) return Web::CssType::FontFamilyCourier;
	if (wcscmp(text, L"FontFamilyTimesNewRoman") == 0) return Web::CssType::FontFamilyTimesNewRoman;  
	return Web::CssType::FontFamilyAuto;
}

//Web::CssType::FontFamily Helper::ReadFontFamilyValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"FontFamilyAuto") == 0) return Web::CssType::FontFamilyAuto, 
//	if (tmp == L"arial") return Web::CssType::FontFamilyArial;
//	if (tmp == L"courier") return Web::CssType::FontFamilyCourier;
//	if (tmp == L"times new roman") return Web::CssType::FontFamilyTimesNewRoman;  
//	return Web::CssType::FontFamilyAuto;
//}

Web::CssType::TextAlign Helper::GetTextAlignType(const wchar_t* text)
{
	//if (wcscmp(text, L"TextAlignAuto") == 0) return Web::CssType::TextAlignAuto, 
	if (wcscmp(text, L"TextAlignCenter") == 0) return Web::CssType::TextAlignCenter; 
	if (wcscmp(text, L"TextAlignJustify") == 0) return Web::CssType::TextAlignJustify; 
	if (wcscmp(text, L"TextAlignLeft") == 0) return Web::CssType::TextAlignLeft;
	if (wcscmp(text, L"TextAlignRight") == 0) return Web::CssType::TextAlignRight;
	return Web::CssType::TextAlignAuto;
}

//Web::CssType::TextAlign Helper::ReadTextAlignValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"TextAlignAuto") == 0) return Web::CssType::TextAlignAuto, 
//	if (tmp == L"center") return Web::CssType::TextAlignCenter; 
//	if (tmp == L"justify")return Web::CssType::TextAlignJustify; 
//	if (tmp == L"left")return Web::CssType::TextAlignLeft;
//	if (tmp == L"right") return Web::CssType::TextAlignRight;
//	return Web::CssType::TextAlignAuto;
//}

Web::CssType::VerticalAlign Helper::GetVerticalAlignType(const wchar_t* text)
{
	//if (wcscmp(text, L"VerticalAlignAuto") == 0) return Web::CssType::VerticalAlignAuto, 
	if (wcscmp(text, L"VerticalAlignBaseline") == 0) return Web::CssType::VerticalAlignBaseline;
	if (wcscmp(text, L"VerticalAlignBottom") == 0) return Web::CssType::VerticalAlignBottom;
	if (wcscmp(text, L"VerticalAlignMiddle") == 0) return Web::CssType::VerticalAlignMiddle; 
	if (wcscmp(text, L"VerticalAlignSub") == 0) return Web::CssType::VerticalAlignSub;
	if (wcscmp(text, L"VerticalAlignSuper") == 0) return Web::CssType::VerticalAlignSuper; 
	if (wcscmp(text, L"VerticalAlignTextBottom") == 0) return Web::CssType::VerticalAlignTextBottom; 
	if (wcscmp(text, L"VerticalAlignTextTop") == 0) return Web::CssType::VerticalAlignTextTop;
	if (wcscmp(text, L"VerticalAlignTop") == 0) return Web::CssType::VerticalAlignTop;
	return Web::CssType::VerticalAlignAuto;
}

//Web::CssType::VerticalAlign Helper::ReadVerticalAlignValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"VerticalAlignAuto") == 0) return Web::CssType::VerticalAlignAuto, 
//	if (tmp == L"baseline") return Web::CssType::VerticalAlignBaseline;
//	if (tmp == L"bottom") return Web::CssType::VerticalAlignBottom;
//	if (tmp == L"middle") return Web::CssType::VerticalAlignMiddle; 
//	if (tmp == L"sub") return Web::CssType::VerticalAlignSub;
//	if (tmp == L"super") return Web::CssType::VerticalAlignSuper; 
//	if (tmp == L"text-bottom") return Web::CssType::VerticalAlignTextBottom; 
//	if (tmp == L"text-top") return Web::CssType::VerticalAlignTextTop;
//	if (tmp ==  L"top") return Web::CssType::VerticalAlignTop;
//	return Web::CssType::VerticalAlignAuto;
//}

Web::CssType::TextDecoration Helper::GetTextDecorationType(const wchar_t* text)
{
	//if (wcscmp(text, L"TextDecorationAuto") == 0) return Web::CssType::TextDecorationAuto, 
	if (wcscmp(text, L"TextDecorationBlink") == 0) return Web::CssType::TextDecorationBlink;
	if (wcscmp(text, L"TextDecorationLineThrough") == 0) return Web::CssType::TextDecorationLineThrough; 
	if (wcscmp(text, L"TextDecorationNone") == 0) return Web::CssType::TextDecorationNone;
	if (wcscmp(text, L"TextDecorationOverline") == 0) return Web::CssType::TextDecorationOverline; 
	if (wcscmp(text, L"TextDecorationUnderline") == 0) return Web::CssType::TextDecorationUnderline;
	return Web::CssType::TextDecorationAuto;
}

//Web::CssType::TextDecoration Helper::ReadTextDecorationValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"TextDecorationAuto") == 0) return Web::CssType::TextDecorationAuto, 
//	if (tmp ==  L"blink") return Web::CssType::TextDecorationBlink;
//	if (tmp ==  L"line-through") return Web::CssType::TextDecorationLineThrough; 
//	if (tmp ==  L"none") return Web::CssType::TextDecorationNone;
//	if (tmp ==  L"overline") return Web::CssType::TextDecorationOverline; 
//	if (tmp ==  L"underline") return Web::CssType::TextDecorationUnderline;
//	return Web::CssType::TextDecorationAuto;
//}

Web::CssType::Visibility Helper::GetVisibilityType(const wchar_t* text)
{
	//if (wcscmp(text, L"VisibilityAuto") == 0) return Web::CssType::VisibilityAuto, 
	if (wcscmp(text, L"VisibilityHidden") == 0) return Web::CssType::VisibilityHidden;
	if (wcscmp(text, L"VisibilityVisible") == 0) return Web::CssType::VisibilityVisible;
	return Web::CssType::VisibilityAuto;
}

Web::CssType::Visibility Helper::ReadVisibilityValue(const wchar_t* text)
{
	wstring tmp(text);
	Sys::TextAssistant::ToLower(tmp);
	//if (wcscmp(text, L"VisibilityAuto") == 0) return Web::CssType::VisibilityAuto, 
	if (tmp ==  L"hidden") return Web::CssType::VisibilityHidden;
	if (tmp ==  L"visible") return Web::CssType::VisibilityVisible;
	return Web::CssType::VisibilityAuto;
}

Web::CssType::BorderStyle Helper::GetBorderStyleType(const wchar_t* text)
{
	//if (wcscmp(text, L"BorderStyleAuto") == 0) return Web::CssType::BorderStyleAuto, 
	if (wcscmp(text, L"BorderStyleDotted") == 0) return Web::CssType::BorderStyleDotted;
	if (wcscmp(text, L"BorderStyleGroove") == 0) return Web::CssType::BorderStyleGroove; 
	if (wcscmp(text, L"BorderStyleInset") == 0) return Web::CssType::BorderStyleInset;
	if (wcscmp(text, L"BorderStyleNone") == 0) return Web::CssType::BorderStyleNone; 
	if (wcscmp(text, L"BorderStyleOutset") == 0) return Web::CssType::BorderStyleOutset; 
	if (wcscmp(text, L"BorderStyleRidge") == 0) return Web::CssType::BorderStyleRidge;
	if (wcscmp(text, L"BorderStyleSolid") == 0) return Web::CssType::BorderStyleSolid;
	return Web::CssType::BorderStyleAuto;
}

//Web::CssType::BorderStyle Helper::ReadBorderStyleValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"BorderStyleAuto") == 0) return Web::CssType::BorderStyleAuto, 
//	if (tmp ==  L"dotted") return Web::CssType::BorderStyleDotted;
//	if (tmp ==  L"groove") return Web::CssType::BorderStyleGroove; 
//	if (tmp ==  L"inset") return Web::CssType::BorderStyleInset;
//	if (tmp ==  L"none") return Web::CssType::BorderStyleNone; 
//	if (tmp ==  L"outset") return Web::CssType::BorderStyleOutset; 
//	if (tmp ==  L"ridge") return Web::CssType::BorderStyleRidge;
//	if (tmp ==  L"solid") return Web::CssType::BorderStyleSolid;
//	return Web::CssType::BorderStyleAuto;
//}

Web::CssType::Display Helper::GetDisplayType(const wchar_t* text)
{
	//if (wcscmp(text, L"DisplayAuto") == 0) return Web::CssType::DisplayAuto, 
	if (wcscmp(text, L"DisplayBlock") == 0) return Web::CssType::DisplayBlock;
	if (wcscmp(text, L"DisplayInline") == 0) return Web::CssType::DisplayInline; 
	if (wcscmp(text, L"DisplayListItem") == 0) return Web::CssType::DisplayListItem;
	if (wcscmp(text, L"DisplayNone") == 0) return Web::CssType::DisplayNone;
	return Web::CssType::DisplayAuto;
}

//Web::CssType::Display Helper::ReadDisplayValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"DisplayAuto") == 0) return Web::CssType::DisplayAuto, 
//	if (tmp ==  L"block") return Web::CssType::DisplayBlock;
//	if (tmp ==  L"inline")return Web::CssType::DisplayInline; 
//	if (tmp ==  L"list-item") return Web::CssType::DisplayListItem;
//	if (tmp ==  L"none") return Web::CssType::DisplayNone;
//	return Web::CssType::DisplayAuto;
//}

Web::CssType::Cursor Helper::GetCursorType(const wchar_t* text)
{
	//if (wcscmp(text, L"CursorAuto") == 0) return Web::CssType::CursorAuto;
	if (wcscmp(text, L"CursorCrosshair") == 0) return Web::CssType::CursorCrosshair;
	if (wcscmp(text, L"CursorDefault") == 0) return Web::CssType::CursorDefault;
	if (wcscmp(text, L"CursorEResize") == 0) return Web::CssType::CursorEResize; 
	if (wcscmp(text, L"CursorHelp") == 0) return Web::CssType::CursorHelp;
	if (wcscmp(text, L"CursorMove") == 0) return Web::CssType::CursorMove;
	if (wcscmp(text, L"CursorNeResize") == 0) return Web::CssType::CursorNeResize; 
	if (wcscmp(text, L"CursorNResize") == 0) return Web::CssType::CursorNResize;
	if (wcscmp(text, L"CursorNwResize") == 0) return Web::CssType::CursorNwResize; 
	if (wcscmp(text, L"CursorPointer") == 0) return Web::CssType::CursorPointer;
	if (wcscmp(text, L"CursorSeResize") == 0) return Web::CssType::CursorSeResize; 
	if (wcscmp(text, L"CursorSResize") == 0) return Web::CssType::CursorSResize;
	if (wcscmp(text, L"CursorSwResize") == 0) return Web::CssType::CursorSwResize; 
	if (wcscmp(text, L"CursorText") == 0) return Web::CssType::CursorText;
	if (wcscmp(text, L"CursorWait") == 0) return Web::CssType::CursorWait;
	if (wcscmp(text, L"CursorWResize") == 0) return Web::CssType::CursorWResize;
	return Web::CssType::CursorAuto;
}

Web::CssType::Cursor Helper::ReadCursorValue(const wchar_t* text)
{
	wstring tmp(text);
	Sys::TextAssistant::ToLower(tmp);
	//if (wcscmp(text, L"CursorAuto") == 0) return Web::CssType::CursorAuto;
	if (tmp ==  L"crosshair") return Web::CssType::CursorCrosshair;
	if (tmp ==  L"default")return Web::CssType::CursorDefault;
	if (tmp ==  L"e-resize") return Web::CssType::CursorEResize; 
	if (tmp ==  L"help")return Web::CssType::CursorHelp;
	if (tmp ==  L"move") return Web::CssType::CursorMove;
	if (tmp ==  L"ne-resize") return Web::CssType::CursorNeResize; 
	if (tmp ==  L"n-resize") return Web::CssType::CursorNResize;
	if (tmp ==  L"nw-resize") return Web::CssType::CursorNwResize; 
	if (tmp ==  L"pointer") return Web::CssType::CursorPointer;
	if (tmp ==  L"se-resize") return Web::CssType::CursorSeResize; 
	if (tmp ==  L"s-resize") return Web::CssType::CursorSResize;
	if (tmp ==  L"sw-resize") return Web::CssType::CursorSwResize; 
	if (tmp ==  L"text") return Web::CssType::CursorText;
	if (tmp ==  L"wait") return Web::CssType::CursorWait;
	if (tmp ==  L"w-resize") return Web::CssType::CursorWResize;
	return Web::CssType::CursorAuto;
}

Web::CssType::OverflowX Helper::GetOverflowXType(const wchar_t* text)
{
	//if (wcscmp(text, L"OverflowXNone") == 0) 
	if (wcscmp(text, L"OverflowXVisible")==0) return Web::CssType::OverflowXVisible; 
	if (wcscmp(text, L"OverflowXHidden")==0) return Web::CssType::OverflowXHidden; 
	if (wcscmp(text, L"OverflowXScroll")==0)  return Web::CssType::OverflowXScroll; 
	if (wcscmp(text, L"OverflowXAuto")==0)  return Web::CssType::OverflowXAuto; 
	if (wcscmp(text, L"OverflowXInherit")==0)  return Web::CssType::OverflowXInherit; 
	return Web::CssType::OverflowXNone;
}

//Web::CssType::OverflowX Helper::ReadOverflowXValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"OverflowXNone") == 0) 
//	if (tmp ==  L"visible") return Web::CssType::OverflowXVisible; 
//	if (tmp ==  L"hidden") return Web::CssType::OverflowXHidden; 
//	if (tmp ==  L"scroll") return Web::CssType::OverflowXScroll; 
//	if (tmp ==  L"auto") return Web::CssType::OverflowXAuto; 
//	if (tmp ==  L"inherit") return Web::CssType::OverflowXInherit; 
//	return Web::CssType::OverflowXNone;
//}

Web::CssType::OverflowY Helper::GetOverflowYType(const wchar_t* text)
{
	//if (wcscmp(text, L"OverflowYNone") == 0) 
	if (wcscmp(text, L"OverflowYVisible")==0) return Web::CssType::OverflowYVisible; 
	if (wcscmp(text, L"OverflowYHidden")==0) return Web::CssType::OverflowYHidden; 
	if (wcscmp(text, L"OverflowYScroll")==0)  return Web::CssType::OverflowYScroll; 
	if (wcscmp(text, L"OverflowYAuto")==0)  return Web::CssType::OverflowYAuto; 
	if (wcscmp(text, L"OverflowYInherit")==0)  return Web::CssType::OverflowYInherit; 
	return Web::CssType::OverflowYNone;
}

//Web::CssType::OverflowY Helper::ReadOverflowYValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	if (wcscmp(text, L"OverflowYNone") == 0) 
//	if (tmp ==  L"visible") return Web::CssType::OverflowYVisible; 
//	if (tmp ==  L"hidden") return Web::CssType::OverflowYHidden; 
//	if (tmp ==  L"scroll") return Web::CssType::OverflowYScroll; 
//	if (tmp ==  L"auto") return Web::CssType::OverflowYAuto; 
//	if (tmp ==  L"inherit") return Web::CssType::OverflowYInherit; 
//	return Web::CssType::OverflowYNone;
//}

wchar_t* Helper::GetOverflowXValue(Web::CssType::OverflowX overflowX)
{
	switch(overflowX)
	{
	//case Web::CssType::OverflowXNone = 0x00000000, 
	case Web::CssType::OverflowXVisible: return L"visible"; 
	case Web::CssType::OverflowXHidden: return L"hidden"; 
	case Web::CssType::OverflowXScroll: return L"scroll"; 
	case Web::CssType::OverflowXAuto: return L"auto"; 
	case Web::CssType::OverflowXInherit: return L"inherit"; 
	}
	return NULL;
}

wchar_t* Helper::GetOverflowXEnum(Web::CssType::OverflowX overflowX)
{
	switch(overflowX)
	{
	case Web::CssType::OverflowXNone: return L"Web::CssType::OverflowXNone";
	case Web::CssType::OverflowXVisible: return L"Web::CssType::OverflowXVisible"; 
	case Web::CssType::OverflowXHidden: return L"Web::CssType::OverflowXHidden"; 
	case Web::CssType::OverflowXScroll: return L"Web::CssType::OverflowXScroll"; 
	case Web::CssType::OverflowXAuto: return L"Web::CssType::OverflowXAuto"; 
	case Web::CssType::OverflowXInherit: return L"Web::CssType::OverflowXInherit"; 
	}
	return NULL;
}

wchar_t* Helper::GetOverflowYValue(Web::CssType::OverflowY overflowY)
{
	switch(overflowY)
	{
	//case Web::CssType::OverflowYNone = 0x00000000, 
	case Web::CssType::OverflowYVisible: return L"visible"; 
	case Web::CssType::OverflowYHidden: return L"hidden"; 
	case Web::CssType::OverflowYScroll: return L"scroll"; 
	case Web::CssType::OverflowYAuto: return L"auto"; 
	case Web::CssType::OverflowYInherit: return L"inherit"; 
	}
	return NULL;
}

wchar_t* Helper::GetOverflowYEnum(Web::CssType::OverflowY overflowY)
{
	switch(overflowY)
	{
	case Web::CssType::OverflowYNone: return L"Web::CssType::OverflowYNone";
	case Web::CssType::OverflowYVisible: return L"Web::CssType::OverflowYVisible"; 
	case Web::CssType::OverflowYHidden: return L"Web::CssType::OverflowYHidden"; 
	case Web::CssType::OverflowYScroll: return L"Web::CssType::OverflowYScroll"; 
	case Web::CssType::OverflowYAuto: return L"Web::CssType::OverflowYAuto"; 
	case Web::CssType::OverflowYInherit: return L"Web::CssType::OverflowYInherit"; 
	}
	return NULL;
}

wchar_t* Helper::GetFontWeightValue(Web::CssType::FontWeight font_weight)
{
	switch (font_weight)
	{
	//case Web::CssType::FontWeightAuto: return L"visible";
	case Web::CssType::FontWeightNormal: return L"normal";
	case Web::CssType::FontWeightBold: return L"bold";
	case Web::CssType::FontWeightBolder: return L"bolder";
	case Web::CssType::FontWeightLighter: return L"lighter";
	case Web::CssType::FontWeight100: return L"100";
	case Web::CssType::FontWeight200: return L"200";
	case Web::CssType::FontWeight300: return L"300";
	case Web::CssType::FontWeight400: return L"400";
	case Web::CssType::FontWeight500: return L"500";
	case Web::CssType::FontWeight600: return L"600";
	case Web::CssType::FontWeight700: return L"700";
	case Web::CssType::FontWeight800: return L"800";
	case Web::CssType::FontWeight900: return L"900";
	case Web::CssType::FontWeightInitial: return L"initial";
	}
	return NULL;
}

wchar_t* Helper::GetFontWeightEnum(Web::CssType::FontWeight font_weight)
{
	switch (font_weight)
	{
	case Web::CssType::FontWeightAuto: return L"Web::CssType::FontWeightAuto";
	case Web::CssType::FontWeightNormal: return L"Web::CssType::FontWeightNormal";
	case Web::CssType::FontWeightBold: return L"Web::CssType::FontWeightBold";
	case Web::CssType::FontWeightBolder: return L"Web::CssType::FontWeightBolder";
	case Web::CssType::FontWeightLighter: return L"Web::CssType::FontWeightLighter";
	case Web::CssType::FontWeight100: return L"Web::CssType::FontWeight100";
	case Web::CssType::FontWeight200: return L"Web::CssType::FontWeight200";
	case Web::CssType::FontWeight300: return L"Web::CssType::FontWeight300";
	case Web::CssType::FontWeight400: return L"Web::CssType::FontWeight400";
	case Web::CssType::FontWeight500: return L"Web::CssType::FontWeight500";
	case Web::CssType::FontWeight600: return L"Web::CssType::FontWeight600";
	case Web::CssType::FontWeight700: return L"Web::CssType::FontWeight700";
	case Web::CssType::FontWeight800: return L"Web::CssType::FontWeight800";
	case Web::CssType::FontWeight900: return L"Web::CssType::FontWeight900";
	case Web::CssType::FontWeightInitial: return L"Web::CssType::FontWeightInitial";
	}
	return NULL;
}

Web::CssType::FontWeight Helper::GetFontWeightType(const wchar_t* text)
{
	//if (wcscmp(text, L"FontWeightAuto") == 0)
	if (wcscmp(text, L"FontWeightNormal") == 0) return Web::CssType::FontWeightNormal;
	if (wcscmp(text, L"FontWeightBold") == 0) return Web::CssType::FontWeightBold;
	if (wcscmp(text, L"FontWeightBolder") == 0) return Web::CssType::FontWeightBolder;
	if (wcscmp(text, L"FontWeightLighter") == 0) return Web::CssType::FontWeightLighter;
	if (wcscmp(text, L"FontWeight100") == 0) return Web::CssType::FontWeight100;
	if (wcscmp(text, L"FontWeight200") == 0) return Web::CssType::FontWeight200;
	if (wcscmp(text, L"FontWeight300") == 0) return Web::CssType::FontWeight300;
	if (wcscmp(text, L"FontWeight400") == 0) return Web::CssType::FontWeight400;
	if (wcscmp(text, L"FontWeight500") == 0) return Web::CssType::FontWeight500;
	if (wcscmp(text, L"FontWeight600") == 0) return Web::CssType::FontWeight600;
	if (wcscmp(text, L"FontWeight700") == 0) return Web::CssType::FontWeight700;
	if (wcscmp(text, L"FontWeight800") == 0) return Web::CssType::FontWeight800;
	if (wcscmp(text, L"FontWeight900") == 0) return Web::CssType::FontWeight900;
	if (wcscmp(text, L"FontWeightInitial") == 0) return Web::CssType::FontWeightInitial;
	return Web::CssType::FontWeightAuto;
}

//Web::CssType::FontWeight Helper::ReadFontWeightValue(const wchar_t* text)
//{
//	wstring tmp(text);
//	Sys::TextAssistant::ToLower(tmp);
//	//if (wcscmp(text, L"FontWeightAuto") == 0)
//	if (tmp == L"normal") return Web::CssType::FontWeightNormal;
//	if (tmp == L"bold") return Web::CssType::FontWeightBold;
//	if (tmp == L"bolder") return Web::CssType::FontWeightBolder;
//	if (tmp == L"lighter") return Web::CssType::FontWeightLighter;
//	if (tmp == L"100") return Web::CssType::FontWeight100;
//	if (tmp == L"200") return Web::CssType::FontWeight200;
//	if (tmp == L"300") return Web::CssType::FontWeight300;
//	if (tmp == L"400") return Web::CssType::FontWeight400;
//	if (tmp == L"500") return Web::CssType::FontWeight500;
//	if (tmp == L"600") return Web::CssType::FontWeight600;
//	if (tmp == L"700") return Web::CssType::FontWeight700;
//	if (tmp == L"800") return Web::CssType::FontWeight800;
//	if (tmp == L"900") return Web::CssType::FontWeight900;
//	if (tmp == L"initial") return Web::CssType::FontWeightInitial;
//	return Web::CssType::FontWeightAuto;
//}

//__________________________________________________ Http
Http::Http()
{
	majorVersion = 1;
	minorVersion = 0;
}

Http::~Http()
{
}

const wchar_t* Http::GetMimeContentType(const wchar_t* fileExtension)
{
	if (wcscmp(fileExtension, L"htm") == 0) return L"text/html";
	if (wcscmp(fileExtension, L"html") == 0) return L"text/html";
	if (wcscmp(fileExtension, L"txt") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"css") == 0) return L"text/css";
	if (wcscmp(fileExtension, L"csv") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"xml") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"svg") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"h") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"c") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"cpp") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"m") == 0) return L"text/plain";
	if (wcscmp(fileExtension, L"talk") == 0) return L"text/x-speech";
	if (wcscmp(fileExtension, L"css") == 0) return L"text/css";
	if (wcscmp(fileExtension, L"gif") == 0) return L"image/gif";
	if (wcscmp(fileExtension, L"xbm") == 0) return L"image/x-xbitmap";
	if (wcscmp(fileExtension, L"xpm") == 0) return L"image/x-xpixmap";
	if (wcscmp(fileExtension, L"png") == 0) return L"image/x-png";
	if (wcscmp(fileExtension, L"ief") == 0) return L"image/ief";
	if (wcscmp(fileExtension, L"jpg") == 0) return L"image/jpeg";
	if (wcscmp(fileExtension, L"tiff") == 0) return L"image/tiff";
	if (wcscmp(fileExtension, L"tif") == 0) return L"image/tiff";
	if (wcscmp(fileExtension, L"rgb") == 0) return L"image/rgb";
	if (wcscmp(fileExtension, L"g3f") == 0) return L"image/g3fax";
	if (wcscmp(fileExtension, L"xwd") == 0) return L"image/x-xwindowdump";
	if (wcscmp(fileExtension, L"pict") == 0) return L"image/x-pict";
	if (wcscmp(fileExtension, L"ppm") == 0) return L"image/x-portable-pixmap";
	if (wcscmp(fileExtension, L"pgm") == 0) return L"image/x-portable-graymap";
	if (wcscmp(fileExtension, L"pbm") == 0) return L"image/x-portable-bitmap";
	if (wcscmp(fileExtension, L"pnm") == 0) return L"image/x-portable-anymap";
	if (wcscmp(fileExtension, L"bmp") == 0) return L"image/x-ms-bmp";
	if (wcscmp(fileExtension, L"ras") == 0) return L"image/x-cmu-raster";
	if (wcscmp(fileExtension, L"pcd") == 0) return L"image/x-photo-cd";
	if (wcscmp(fileExtension, L"cgm") == 0) return L"image/cgm";
	if (wcscmp(fileExtension, L"cal") == 0) return L"image/x-cals";
	if (wcscmp(fileExtension, L"fif") == 0) return L"image/fif";
	if (wcscmp(fileExtension, L"dsf") == 0) return L"image/x-mgx-dsf";
	if (wcscmp(fileExtension, L"cmx") == 0) return L"image/x-cmx";
	if (wcscmp(fileExtension, L"wi") == 0) return L"image/wavelet";
	if (wcscmp(fileExtension, L"dwg") == 0) return L"image/vnd.dwg";
	if (wcscmp(fileExtension, L"dxf") == 0) return L"image/vnd.dxf";
	if (wcscmp(fileExtension, L"svf") == 0) return L"image/vnd.svf";
	if (wcscmp(fileExtension, L"aif") == 0) return L"audio/x-aiff";
	if (wcscmp(fileExtension, L"wav") == 0) return L"audio/x-wav";
	if (wcscmp(fileExtension, L"es") == 0) return L"audio/echospeech";
	if (wcscmp(fileExtension, L"vox") == 0) return L"audio/voxware";
	if (wcscmp(fileExtension, L"lcc") == 0) return L"application/fastman";
	if (wcscmp(fileExtension, L"mmid") == 0) return L"x-music/x-midi";
	if (wcscmp(fileExtension, L"skp") == 0) return L"application/vnd.koan";
	if (wcscmp(fileExtension, L"talk") == 0) return L"text/x-speech";
	if (wcscmp(fileExtension, L"mpeg") == 0) return L"video/mpeg";
	if (wcscmp(fileExtension, L"mov") == 0) return L"video/quicktime";
	if (wcscmp(fileExtension, L"avi") == 0) return L"video/x-msvideo";
	if (wcscmp(fileExtension, L"movie") == 0) return L"video/x-sgi-movie";
	if (wcscmp(fileExtension, L"vdo") == 0) return L"video/vdo";
	if (wcscmp(fileExtension, L"viv") == 0) return L"video/vnd.vivo";
	if (wcscmp(fileExtension, L"pac") == 0) return L"application/x-ns-proxy-autoconfig";
	if (wcscmp(fileExtension, L"ice") == 0) return L"x-conference/x-cooltalk";
	if (wcscmp(fileExtension, L"ps") == 0) return L"application/postscript";
	if (wcscmp(fileExtension, L"eps") == 0) return L"application/postscript";
	if (wcscmp(fileExtension, L"rtf") == 0) return L"application/rtf";
	if (wcscmp(fileExtension, L"pdf") == 0) return L"application/pdf";
	if (wcscmp(fileExtension, L"cdr") == 0) return L"application/cdr";
	if (wcscmp(fileExtension, L"mif") == 0) return L"application/vnd.mif";
	if (wcscmp(fileExtension, L"roff") == 0) return L"application/x-troff";
	if (wcscmp(fileExtension, L"man") == 0) return L"application/x-troff-man";
	if (wcscmp(fileExtension, L"me") == 0) return L"application/x-troff-me";
	if (wcscmp(fileExtension, L"ms") == 0) return L"application/x-troff-ms";
	if (wcscmp(fileExtension, L"latex") == 0) return L"application/x-latex";
	if (wcscmp(fileExtension, L"tex") == 0) return L"application/x-tex";
	if (wcscmp(fileExtension, L"texinfo") == 0) return L"application/x-texinfo";
	if (wcscmp(fileExtension, L"dvi") == 0) return L"application/x-dvi";
	if (wcscmp(fileExtension, L"oda") == 0) return L"application/oda";
	if (wcscmp(fileExtension, L"evy") == 0) return L"application/envoy";
	if (wcscmp(fileExtension, L"gtar") == 0) return L"application/x-gtar";
	if (wcscmp(fileExtension, L"tar") == 0) return L"application/x-tar";
	if (wcscmp(fileExtension, L"ustar") == 0) return L"application/x-ustar";
	if (wcscmp(fileExtension, L"bcpio") == 0) return L"application/x-bcpio";
	if (wcscmp(fileExtension, L"cpio") == 0) return L"application/x-cpio";
	if (wcscmp(fileExtension, L"shar") == 0) return L"application/x-shar";
	if (wcscmp(fileExtension, L"zip") == 0) return L"application/zip";
	if (wcscmp(fileExtension, L"hqx") == 0) return L"application/mac-binhex40";
	if (wcscmp(fileExtension, L"sit") == 0) return L"application/x-stuffit";
	if (wcscmp(fileExtension, L"fif") == 0) return L"application/fractals";
	if (wcscmp(fileExtension, L"bin") == 0) return L"application/octet-stream";
	if (wcscmp(fileExtension, L"lib") == 0) return L"application/octet-stream";
	if (wcscmp(fileExtension, L"dll") == 0) return L"application/octet-stream";
	if (wcscmp(fileExtension, L"exe") == 0) return L"application/octet-stream";
	if (wcscmp(fileExtension, L"hdf") == 0) return L"application/hdf";
	if (wcscmp(fileExtension, L"js") == 0) return L"text/javascript";
	if (wcscmp(fileExtension, L"sh") == 0) return L"application/x-sh";
	if (wcscmp(fileExtension, L"csh") == 0) return L"application/x-csh";
	if (wcscmp(fileExtension, L"pl") == 0) return L"application/x-perl";
	if (wcscmp(fileExtension, L"tcl") == 0) return L"application/x-tcl";
	if (wcscmp(fileExtension, L"spl") == 0) return L"application/futuresplash";
	if (wcscmp(fileExtension, L"mbd") == 0) return L"application/mbedlet";
	if (wcscmp(fileExtension, L"rad") == 0) return L"application/x-rad-powermedia";
	if (wcscmp(fileExtension, L"ppz") == 0) return L"application/mspowerpoint";
	if (wcscmp(fileExtension, L"asp") == 0) return L"application/x-asap";
	if (wcscmp(fileExtension, L"asn") == 0) return L"application/astound";
	if (wcscmp(fileExtension, L"axs") == 0) return L"application/x-olescript";
	if (wcscmp(fileExtension, L"ods") == 0) return L"application/x-oleobject";
	if (wcscmp(fileExtension, L"opp") == 0) return L"x-form/x-openscape";
	if (wcscmp(fileExtension, L"wba") == 0) return L"application/x-webbasic";
	if (wcscmp(fileExtension, L"frm") == 0) return L"application/x-alpha-form";
	if (wcscmp(fileExtension, L"wfx") == 0) return L"x-script/x-wfxclient";
	if (wcscmp(fileExtension, L"pcn") == 0) return L"application/x-pcn";
	if (wcscmp(fileExtension, L"xlsx") == 0) return L"application/x-msexcel";
	if (wcscmp(fileExtension, L"xls") == 0) return L"application/ms-excel";
	if (wcscmp(fileExtension, L"docx") == 0) return L"application/x-msword";
	if (wcscmp(fileExtension, L"doc") == 0) return L"application/ms-word";
	if (wcscmp(fileExtension, L"ppt") == 0) return L"application/ms-powerpoint";
	if (wcscmp(fileExtension, L"pptx") == 0) return L"application/x-mspowerpoint";
	if (wcscmp(fileExtension, L"svd") == 0) return L"application/vnd.svd";
	if (wcscmp(fileExtension, L"ins") == 0) return L"application/x-net-install";
	if (wcscmp(fileExtension, L"ccv") == 0) return L"application/ccv";
	if (wcscmp(fileExtension, L"vts") == 0) return L"workbook/formulaone";
	if (wcscmp(fileExtension, L"vrw") == 0) return L"x-world/x-vream";
	if (wcscmp(fileExtension, L"p3d") == 0) return L"application/x-p3d";
	if (wcscmp(fileExtension, L"svr") == 0) return L"x-world/x-svr";
	if (wcscmp(fileExtension, L"wvr") == 0) return L"x-world/x-wvr";
	if (wcscmp(fileExtension, L"3dmf") == 0) return L"x-world/x-3dmf";
	if (wcscmp(fileExtension, L"ma") == 0) return L"application/mathematica";
	if (wcscmp(fileExtension, L"v5d") == 0) return L"application/vis5d";
	if (wcscmp(fileExtension, L"dwf") == 0) return L"drawing/x-dwf";
	if (wcscmp(fileExtension, L"show") == 0) return L"application/x-showcase";
	if (wcscmp(fileExtension, L"ins") == 0) return L"application/x-insight";
	if (wcscmp(fileExtension, L"ano") == 0) return L"application/x-annotator";
	if (wcscmp(fileExtension, L"dir") == 0) return L"application/x-dirview";
	if (wcscmp(fileExtension, L"lic") == 0) return L"application/x-enterlicense";
	if (wcscmp(fileExtension, L"faxmgr") == 0) return L"application/x-fax-manager";
	if (wcscmp(fileExtension, L"faxmgrjob") == 0) return L"application/x-fax-manager-job";
	if (wcscmp(fileExtension, L"icnbk") == 0) return L"application/x-iconbook";
	if (wcscmp(fileExtension, L"wb") == 0) return L"application/x-inpview";
	if (wcscmp(fileExtension, L"inst") == 0) return L"application/x-install";
	if (wcscmp(fileExtension, L"mail") == 0) return L"application/x-mailfolder";
	if (wcscmp(fileExtension, L"pp") == 0) return L"application/x-ppages";
	if (wcscmp(fileExtension, L"sgi-lpr") == 0) return L"application/x-sgi-lpr";
	if (wcscmp(fileExtension, L"tardist") == 0) return L"application/x-tardist";
	if (wcscmp(fileExtension, L"ztardist") == 0) return L"application/x-ztardist";
	if (wcscmp(fileExtension, L"wkz") == 0) return L"application/x-wingz";
	if (wcscmp(fileExtension, L"iv") == 0) return L"graphics/x-inventor";
	return L"application/octet-stream";
}

bool Http::DoKeepConnectionAlive()
{
	map<wstring, wstring>::iterator p = head.find(L"connection");
	if (p == head.end()) return false;
	wstring lowerValue = p->second;
	Sys::TextAssistant::ToLower(lowerValue);
	return (lowerValue == L"keep-alive");
}

bool Http::IsUtf8()
{
	map<wstring, wstring>::iterator p;
	wstring value;
	//________________________________________ Accept-Charset: utf-8
	//p = head.find(L"Accept-Charset");
	//if (p != head.end())
	//{
	//	value = p->second;
	//	Sys::TextAssistant::ToUpper(value);
	//	if (value == L"UTF-8") return true;
	//}
	//________________________________________ Content-Type: application/vnd.bonfire+xml; charset=utf-8
	p = head.find(L"Content-Type");
	if (p != head.end())
	{
		value = p->second;
		Sys::TextAssistant::ToUpper(value);
		if (value.find(L"=UTF-8") != std::wstring::npos) return true;
	}
	return false;
}

bool Http::CreateHead(const char* in_buffer, const size_t bufferSize)
{
	Delete();
	size_t position = 0;
	if (ReadStatusLine(position, in_buffer, bufferSize) == false) return false;
	//____________________________________________________ Read Header
	wstring name;
	wstring value;
	while(position < bufferSize)
	{
		if (ReadHeadName(position, in_buffer, bufferSize, name) == false) return false;
		if (ReadHeadValue(position, in_buffer, bufferSize, value) == false) return false;
		//head.insert (make_pair<wstring, wstring>(name, value));
		head[name] = value;
		//
		if (IsBlankLine(position, in_buffer, bufferSize) == true) break;
	}
	return true;
}

int Http::GetContentLength()
{
	map<wstring, wstring>::iterator p = head.find(L"Content-Length");
	if (p == head.end()) return -1;
	return Sys::Convert::ToInt(p->second);
}

bool Http::GetHeaderValue(const wchar_t* in_name, wstring& out_value)
{
	out_value.clear();
	if (in_name == NULL) return false;
	map<wstring, wstring>::iterator p = head.find(in_name);
	if (p == head.end()) return false;
	out_value = p->second;
	return true;
}

bool Http::GetHeaderValue(const wstring& in_name, wstring& out_value)
{
	out_value.clear();
	map<wstring, wstring>::iterator p = head.find(in_name);
	if (p == head.end()) return false;
	out_value = p->second;
	return true;
}

bool Http::ReadHeadName(size_t& position, const char* in_buffer, const size_t bufferSize, wstring& out_name)
{
	out_name.clear();
	if (position >= bufferSize) return false;
	char c;
	do
	{
		c = in_buffer[position++];
		if (c ==':') return true;
		out_name += c;
	}
	while (position < bufferSize);
	return false;
}

bool Http::ReadHeadValue(size_t& position, const char* in_buffer, const size_t bufferSize, wstring& out_value)
{
	out_value.clear();
	if (position >= bufferSize) return false;
	char c;
	//_________________________________________ Move spaces, if any
	do
	{
		c = in_buffer[position++];
		if (c != ' ' && c != '\t')
		{
			position--;
			break;
		}
	}
	while (position < bufferSize);
	//_________________________________________ Read value
	do
	{
		c = in_buffer[position++];
		if (c =='\n') return true;
		if (c != '\r') out_value += c;
	}
	while (position < bufferSize);
	return false;
}

bool Http::IsBlankLine(size_t& position, const char* in_buffer, const size_t bufferSize)
{
	if (position >= bufferSize) return false;
	const size_t original_position = position;
	char c = in_buffer[position++];
	
	if (c == '\r')
	{
		if (position >= bufferSize)
		{
			position = original_position; // Restore position so that we can keep reading the header
			return false;
		}
		c = in_buffer[position++];
		if (c == '\n') return true;
	}
	else if (c == '\n')
	{
		return true;
	}
	position = original_position; // Restore position so that we can keep reading the header
	return false;
}

bool Http::ReadBody(size_t& position, const char* in_buffer, const size_t bufferSize)
{
	if (position >= bufferSize) return false;
	const size_t numBytes = bufferSize - position;
	if (body.Reserve(numBytes) == false) return false;
	int result = body.Send(in_buffer + position, (int)numBytes);
	if (result == -1) return false;
	if (numBytes != result) return false;
	return true;
}

void Http::Create(Sys::Xml& xml)
{
	Delete();
	const bool isUtf8 = xml.utf_8;
	
	if (isUtf8 == true)
	{
		head[L"Content-Type"] = L"text/xml; charset=utf-8";
		wstring data;
		xml.GetXmlText(data);
		Sys::Convert::WstringToUTF8(data, body);
	}
	else
	{
		head[L"Content-Type"] = L"text/xml";
		string data;
		xml.GetXmlText(data);
		body.CreateFromText(data);
	}
}

void Http::Create(Sys::SoapEnvelope& soapEnvelope)
{
	Delete();
	const bool isUtf8 = soapEnvelope.utf_8;
	//________________________________________________________________________ SOAPAction
	if (soapEnvelope.minorVersion == 1 && soapEnvelope.majorVersion == 1)
	{
		wstring soapAction = soapEnvelope.ActionXmlns;
		soapAction += soapEnvelope.GetActionName();
		head[L"SOAPAction"] = soapAction;
	}
	//________________________________________________________________________
	if (isUtf8 == true)
	{
		if (soapEnvelope.minorVersion == 1 && soapEnvelope.majorVersion == 1)
		{
				head[L"Content-Type"] = L"text/xml; charset=utf-8";
		}
		else
		{
				head[L"Content-Type"] = L"application/soap+xml; charset=utf-8";
		}
		wstring data;
		soapEnvelope.GetXmlText(data);
		Sys::Convert::WstringToUTF8(data, body);
	}
	else
	{
		if (soapEnvelope.minorVersion == 1 && soapEnvelope.majorVersion == 1)
		{
				head[L"Content-Type"] = L"text/xml";
		}
		else
		{
				head[L"Content-Type"] = L"application/soap+xml";
		}
		string data;
		soapEnvelope.GetXmlText(data);
		body.CreateFromText(data);
	}
}

#ifdef WIN_SOCKETS_SUPPORT
bool Http::Create(Sys::SocketStatus& out_socketStatus, Sys::Socket& socket)
{
	out_socketStatus.Delete();
	//____________________________________________________________ Receive Head (receive until we get \r\n\r\n)
	Sys::Buffer sysBuffer;
	char buffer[512];
	int result;
	int endPosition = -1;
	int total = 0;
	while(true)
	{
		result = socket.Receive(buffer, 512);
		if (result == SOCKET_ERROR)
		{
			out_socketStatus.isError = true;
			return false;
		}
		if (result == SOCKET_DISCONNECTED)
		{
			out_socketStatus.isConnected = false;
			break;
		}
		total += result;
		out_socketStatus.bytesTransferred = total;
		sysBuffer.Send(buffer, result);
		endPosition = sysBuffer.GetHttpHeadEndPosition();
		if (endPosition != -1) break;
	}
	if (endPosition == -1) return false;
	if (CreateHead(sysBuffer, endPosition+4) == false) return false;
	if (IsRequiredToReceiveBody() == false) return true;
	const int content_length = GetContentLength();
	const int totalAlreadyRead = (int)sysBuffer.GetSize();
	const int bodyBytesAlreadyRead = totalAlreadyRead - (endPosition + 4); // We subtract \r\n\r\n
	//____________________________________________________________ Receive Body
	if (bodyBytesAlreadyRead > 0)
	{
		if (body.Create(sysBuffer, endPosition+4, sysBuffer.GetSize()-1) == false)
		{
			out_socketStatus.bytesTransferred = total;
			return false;
		}
	}
	int bytesRemaining = content_length - bodyBytesAlreadyRead;
	int written = -1;

	if (content_length == -1) //___________________________ Content-Length is missing
	{
		if (out_socketStatus.isConnected == false) return false;
		out_socketStatus.Delete();
		while(written != 0)
		{
			result = socket.Receive(buffer, 512);
			if (result == SOCKET_ERROR)
			{
				out_socketStatus.isError = true;
				return false;
			}
			if (result == SOCKET_DISCONNECTED)
			{
				out_socketStatus.isConnected = false;
				break;
			}
			total += result;
			out_socketStatus.bytesTransferred = total;
			written = body.Send(buffer, result);
			if (written != result) return false;
		}
	}
	else
	{
		if (out_socketStatus.isConnected == false) return false;
		out_socketStatus.Delete();
		while(bytesRemaining > 0)
		{
			result = socket.Receive(buffer, 512);
			if (result == SOCKET_ERROR)
			{
				out_socketStatus.isError = true;
				return false;
			}
			if (result == SOCKET_DISCONNECTED)
			{
				out_socketStatus.isConnected = false;
				break;
			}
			total += result;
			out_socketStatus.bytesTransferred = total;
			written = body.Send(buffer, result);
			bytesRemaining -= result;
		}
	}
	return true;
}

bool Http::Send(Sys::SocketStatus& out_socketStatus, Sys::Socket& socket)
{
	out_socketStatus.Delete();
	//_________________________________________ Send Head;
	wstring headText;
	RenderHeadText(headText, body.GetSize());
	Sys::Buffer headBuffer;
	Sys::Convert::WstringToString(headText, headBuffer);
	socket.SendLargeBlock(out_socketStatus, (const char*)headBuffer, headBuffer.GetSize(), 512);
	if (out_socketStatus.isError == true) return false;
	if (out_socketStatus.isConnected == false) return false;
	const int headBytesSent = out_socketStatus.bytesTransferred;
	//_________________________________________ Send Body
	out_socketStatus.Delete();
	if (body.GetSize() == 0) return true;
	socket.SendLargeBlock(out_socketStatus, (const char*)body, body.GetSize(), 512);
	if (out_socketStatus.isError == true) return false;
	out_socketStatus.bytesTransferred += headBytesSent;
	return true;
}

bool Http::SendFile(Sys::SocketStatus& out_socketStatus, Sys::Socket& socket, const wstring& filename) 
{
	return SendFile(out_socketStatus, socket, filename.c_str());
}

bool Http::SendFile(Sys::SocketStatus& out_socketStatus, Sys::Socket& socket, const wchar_t* filename) 
{
	out_socketStatus.Delete();
	Delete();
	//__________________________________________________________________________ 
	int fileSize = 0;
	bool mustSend = false;
	if (PrepareSendFile(filename, fileSize, mustSend) == false)
	{
		if (mustSend == true)
		{
			return Send(out_socketStatus, socket);
		}
		return false;
	}
	const int bytestSent = out_socketStatus.bytesTransferred; 
	if (out_socketStatus.isError == true) return false;
	if (out_socketStatus.isConnected== false) return false;
	//________________________________________________________________________________ Method 1
	out_socketStatus.Delete();
	if (body.CreateFromFile(filename) == false) return false;
	const bool ok = Send(out_socketStatus, socket);
	out_socketStatus.bytesTransferred += bytestSent;
	return ok;
	//________________________________________________________________________________ Method 2
	////_________________________________________ Send Head;
	//wstring headText;
	//RenderHeadText(headText, fileSize);
	//Sys::Buffer headBuffer;
	//Sys::Convert::WstringToString(headText, headBuffer);
	//if (socket.SendLargeBlock((const char*)headBuffer, headBuffer.GetSize(), 512) == -1) return false;
	////_________________________________________ Send Body using file content
	//DWORD highSize;
	//char buffer[512];
	//DWORD dwRead = 1;
	//DWORD bytesToRead = 0;
	//int written;
	//HANDLE hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	//if  (hFile == INVALID_HANDLE_VALUE) return false; // Impossible to get here
	//const int responseLength = (int)::GetFileSize(hFile, &highSize);
	//if (responseLength < 512)
	//{
	//	bytesToRead = responseLength;
	//	::ReadFile(hFile, buffer, bytesToRead, &dwRead, NULL);
	//	if (dwRead != responseLength)
	//	{
	//		if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile); //500 Internal Server Error
	//		return false;
	//	}
	//	if (socket.Send(buffer, (int)responseLength, (int)0) == SOCKET_ERROR)
	//	{
	//		if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	//		return false;
	//	}
	//}
	//else
	//{
	//	bytesToRead = 512;
	//	while (dwRead != 0)
	//	{
	//		::ReadFile(hFile, buffer, bytesToRead, &dwRead, NULL);
	//		if (dwRead == 0) break;
	//		written = socket.Send(buffer, (int)dwRead, (int)0);
	//		if (written == SOCKET_ERROR)
	//		{
	//			if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	//			return false;
	//		}
	//		if (dwRead != written)
	//		{
	//			if (hFile!=INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	//			return false;
	//		}
	//	}
	//}
	//if  (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	//return true;
}

bool Http::ReceiveFile(Sys::SocketStatus& out_socketStatus, Sys::Socket& socket, const wstring& filename)
{
	return ReceiveFile(out_socketStatus, socket, filename.c_str());
}

bool Http::ReceiveFile(Sys::SocketStatus& out_socketStatus, Sys::Socket& socket, const wchar_t* filename)
{
	if (Create(out_socketStatus, socket) == false) return false;
	if (CanSaveFile() == false) return false;
	return body.SaveToFile(filename);
}

#endif

void Http::RenderHeadText(wstring& out_text, int content_length)
{
	//____________________________________________________________ Head
	WriteStatusLine(out_text);
	out_text += L"\r\n";
	map<wstring, wstring>::iterator param;
	map<wstring, wstring>::const_iterator param_end = head.end();
	wstring lowerContent;
	for (param = head.begin(); param != param_end; param++)
	{
		lowerContent = param->first;
		Sys::TextAssistant::ToLower(lowerContent);
		if (lowerContent == L"content-length") continue;
		out_text += param->first;
		out_text += L": ";
		out_text += param->second;
		out_text += L"\r\n";
	}
	//_____________________________________________________________ Date
	wchar_t tmp[256];
	Web::Http::GetDateHeader(tmp, 256);
	out_text += tmp;
	//_____________________________________________________________ Content-Length
	if (content_length > 0)
	{
		_snwprintf_s(tmp, 256, _TRUNCATE, L"Content-Length: %d\r\n", content_length);
		out_text += tmp;
	}
	RenderCustomHead(out_text);
	//____________________________________________________________ Blank Line
	out_text += L"\r\n";  
}

void Http::GetHeadHtml(bool includeDate, wstring& out_html)
{
	out_html.clear();
	out_html.reserve(head.size() * 96);
	WriteStatusLine(out_html);
	out_html += L"<br />";
	map<wstring, wstring>::iterator param;
	map<wstring, wstring>::const_iterator param_end = head.end();
	for (param = head.begin(); param != param_end; param++)
	{
		out_html += param->first;
		out_html += L": ";
		out_html += param->second;
		out_html += L"<br />";
	}
	wchar_t tmp[256];
	//_____________________________________________________________ Date
	if (includeDate == true)
	{
		Web::Http::GetDateHeader(tmp, 256);
		out_html += tmp;
		out_html += L"<br />";
	}
	//_____________________________________________________________ Content-Length
	const int content_length = (int)body.GetSize();
	if (content_length > 0)
	{
		_snwprintf_s(tmp, 256, _TRUNCATE, L"Content-Length: %d", content_length);
		out_html += tmp;
		out_html += L"<br />";
	}
	//RenderCustomHead(out_text);
	//____________________________________________________________ Blank Line
	out_html += L"<br />";  
}

void Http::GetHeadText(wstring& out_text)
{
	out_text.clear();
	out_text.reserve(head.size() * 64);
	WriteStatusLine(out_text);
	out_text += L"\r\n";
	map<wstring, wstring>::iterator param;
	map<wstring, wstring>::const_iterator param_end = head.end();
	for (param = head.begin(); param != param_end; param++)
	{
		out_text += param->first;
		out_text += L": ";
		out_text += param->second;
		out_text += L"\r\n";
	}
	//____________________________________________________________ Blank Line
	out_text += L"\r\n";  
}

void Http::GetBodyText(wstring& out_text)
{
	out_text.clear();
	if (body.GetSize() > 0)
	{
		bool isUtf8 = false;
		if (DoesBodyHaveText(isUtf8) == true)
		{
			wstring wdata;
			if (isUtf8 == true)
			{
				Sys::Convert::UTF8ToWstring(body, out_text);
			}
			else //_______________ ASCII
			{
				Sys::Convert::StringToWstring(body, out_text);
			}
		}
	}
}

void Http::GetTextToBeSent(wstring& out_text)
{
	RenderHeadText(out_text, (int)body.GetSize());
	wstring bodyText;
	GetBodyText(bodyText);
	if (bodyText.empty() == true) return;
	out_text += bodyText;
}

void Http::GetText(wstring& out_text)
{
	GetHeadText(out_text);
	wstring bodyText;
	GetBodyText(bodyText);
	if (bodyText.empty() == true) return;
	out_text += bodyText;
}

bool Http::DoesBodyHaveText(bool& isUtf8)
{
	bool isText = false;
	isUtf8 = false;
	//_________________________________________________
	map<wstring, wstring>::iterator p = head.find(L"Content-Type");
	if (p == head.end()) return false;
	if (p->second.find(L"text/") != std::wstring::npos) isText = true;
	if (p->second.find(L"xml") != std::wstring::npos) isText = true;
	if (p->second.find(L"urlencoded") != std::wstring::npos) isText = true;
	//______________________________________ Is utf-8?
	wstring lowercase;
	lowercase = p->second;
	Sys::TextAssistant::ToLower(lowercase);
	isUtf8 = (lowercase.find(L"utf-8") != std::wstring::npos);
	return isText;
}

void Http::Delete()
{
	majorVersion = 1;
	minorVersion = 0;
	head.clear();
	body.Delete();
	PrivateDelete();
}

void Http::GetDateHeader(char* buffer, int bufferSize)
{
	const char* days[]={"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	const char* months[]={"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
		//_______________________________ rfc1123-date
	SYSTEMTIME now;
	::GetSystemTime(&now); // UTC time
	_snprintf_s(buffer, bufferSize, _TRUNCATE, "Date: %s, %02d %s %04d %02d:%02d:%02d GMT\r\n", 
		days[now.wDayOfWeek], now.wDay, months[now.wMonth-1], now.wYear,
		now.wHour, now.wMinute, now.wSecond);
}

void Http::GetDateHeader(wchar_t* buffer, int bufferSize)
{
	const wchar_t* days[] = { L"Sun", L"Mon", L"Tue", L"Wed", L"Thu", L"Fri", L"Sat" };
	const wchar_t* months[] = { L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun", L"Jul", L"Aug", L"Sep", L"Oct", L"Nov", L"Dec" };
	//_______________________________ rfc1123-date
	SYSTEMTIME now;
	::GetSystemTime(&now); // UTC time
	_snwprintf_s(buffer, bufferSize, _TRUNCATE, L"Date: %s, %02d %s %04d %02d:%02d:%02d GMT\r\n",
		days[now.wDayOfWeek], now.wDay, months[now.wMonth - 1], now.wYear,
		now.wHour, now.wMinute, now.wSecond);
}

void Http::SetUsernameAndPassword(const wchar_t* username, const wchar_t* password)
{
	string asciiUsername;
	string asciiPassword;
	Sys::Convert::WstringToString(username, asciiUsername);
	Sys::Convert::WstringToString(password, asciiPassword);
	//_______________________________________________ Create Authorization value: Basic username:password
	string value;
	value += asciiUsername;
	value += ":";
	value += asciiPassword;
	//______________________________________________ Code Base 64
	string encoded;
	Sys::Convert::Base64BitEncode(value.c_str(), (int)value.size(), encoded);
	wstring wencoded;
	Sys::Convert::StringToWstring(encoded, wencoded);
	wstring tmp = L"Basic ";
	tmp += wencoded;
	head[L"Authorization"] = tmp;
}

void Http::SetUsernameAndPassword(const wstring& username, const wstring& password)
{
	SetUsernameAndPassword(username.c_str(), password.c_str());
}

bool Http::GetUsernameAndPassword(wstring& out_username, wstring& out_password)
{
	out_username.clear();
	out_password.clear();
	//_________________
	string username;
	string password;
	if (GetUsernameAndPassword(username, password) == false) return false;
	Sys::Convert::StringToWstring(username, out_username);
	Sys::Convert::StringToWstring(password, out_password);
	return true;
}

bool Http::GetUsernameAndPassword(string& out_username, string& out_password)
{
	out_username.clear();
	out_password.clear();
	//_____________________________________________________
	map<wstring, wstring>::iterator p = head.find(L"authorization");
	if (p == head.end()) return false;
	//
	string line;
	Sys::Convert::WstringToString(p->second, line);
	size_t pos = line.find_first_of("Basic ");
	if (pos == std::string::npos) return false;
	const int len = (int)line.length();
	//
	string encoded;
	string decoded;
	encoded.assign(line, pos+6, len-6);
	Sys::Convert::Base64BitDecode(encoded.c_str(), (int)encoded.length(), decoded);
	pos = decoded.find_first_of(":");
	if (pos == std::string::npos) return false;
	const int decoded_len = (int)decoded.size();
	out_username.assign(decoded, 0, pos);
	out_password.assign(decoded, pos+1, decoded_len-pos);
	return true;
}

//__________________________________________________ HttpRequest
HttpRequest::HttpRequest()
{
	method = L"GET";
	resource = L"/";
}

HttpRequest::~HttpRequest()
{
}

void HttpRequest::CreateFromCode(int code, const wchar_t* caption)
{
	// Nothing to do
}

bool HttpRequest::PrepareSendFile(const wchar_t* filename, int& out_fileSize, bool& mustSend)
{
	out_fileSize = 0;
	mustSend = false;
	//___________________________________________________
	HANDLE hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	//_____________________________________________________________ Get file size
	DWORD highSize;
	out_fileSize = (int)::GetFileSize(hFile, &highSize);
	if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	//______________________________________________________________ File Extension
	wchar_t ext[32];
	if (Sys::TextAssistant::ExtractFileExt(filename, ext, 32) == false) return false;
	//_____________________________________________________________ OK
	head[L"Content-type"] = GetMimeContentType(ext);	
	mustSend = true;
	return true;
}

bool HttpRequest::CanSaveFile()
{
	return true;
}

void HttpRequest::GetRequestedFileName(const wstring& wwwroot, wstring& out_filename)
{
	GetRequestedFileName(wwwroot.c_str(), out_filename);
}

void HttpRequest::GetRequestedFileName(const wchar_t* wwwroot, wstring& out_filename)
{
	if (resourceFileName.empty() == true)
	{
		if (resourcePath == L"\\")
		{
			Sys::Format(out_filename, L"%s\\index.htm", wwwroot);
		}
		else
		{	
			Sys::Format(out_filename, L"%s\\%s\\index.htm", wwwroot, resourcePath.c_str());
		}
	}
	else
	{
		if (resourcePath == L"\\")
		{
			Sys::Format(out_filename, L"%s\\%s.%s", wwwroot, resourceFileName.c_str(), resourceFileExtension.c_str());
		}
		else
		{	
			Sys::Format(out_filename, L"%s\\%s\\%s.%s", wwwroot, resourcePath.c_str(), resourceFileName.c_str(), resourceFileExtension.c_str());
		}
	}
}

bool HttpRequest::IsRequiredToReceiveBody()
{
	if (method.empty() == true) return false;
	const int content_length = GetContentLength();
	if (method == L"GET" && content_length == -1) return false;
	return (content_length > 0);
}

void HttpRequest::PrivateDelete()
{
	method = L"GET";
	resource = L"/";
	query_string.clear();
	query_wstring.clear();
	resourceFileName.clear();
	resourceFileExtension.clear();
	resourcePath.clear();
}

//GET /documents/program.dll?x=10&y=20 HTTP/1.0
bool HttpRequest::ReadStatusLine(size_t& position, const char* in_buffer, const size_t bufferSize)
{
	if (position >= bufferSize) return false;
	char c;
	//___________________________________________ Method: GET, PUT, POST, DELETE, CONNECT, TRACE, ...
	method.clear();
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c ==' ' || c=='\t') break;
		method += toupper(c);
		c = in_buffer[position++];
	}
	if (position >= bufferSize) return false;
	//___________________________________________ Move spaces or tabs
	while(position < bufferSize)
	{
		if (c !=' ' && c != '\t')
		{
			position--;
			break;
		}
		c = in_buffer[position++];
	}
	if (position >= bufferSize) return false;
	//__________________________________________ Resource
	resource.clear();
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c ==' ' || c=='\t') break;
		resource += c;
		c = in_buffer[position++];
	}
	if (position >= bufferSize) return false;
	ReadResourceComponents();
	//___________________________________________ Move spaces or tabs
	while(position < bufferSize)
	{
		if (c !=' ' && c != '\t')
		{
			position--;
			break;
		}
		c = in_buffer[position++];
	}
	if (position >= bufferSize) return false;
	//__________________________________________ HTTP/
	wstring text;
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c =='/') break;
		text += c;
		c = in_buffer[position++];
	}
	if (text != L"HTTP") return false;
	if (position >= bufferSize) return false;
	//_________________________________________ Major Version
	text.clear();
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c =='.') break;
		text += c;
		c = in_buffer[position++];
	}
	majorVersion = Sys::Convert::ToInt(text);
	if (position >= bufferSize) return false;
	//_________________________________________ Minor Version
	text.clear();
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c == '\n') break;
		if (c != '\r') text += c;
		c = in_buffer[position++];
	}
	minorVersion = Sys::Convert::ToInt(text);
	if (position >= bufferSize) return false;
	return true;
}

bool HttpRequest::ReadResourceComponents()
{
	//http://localhost:8080/selo/doc/hola.htm?datos=100&peso=50
	//GET /selodoc/hola.htm?datos=100&peso=50 HTTP/1.1
	const wchar_t* begin = resource.c_str();
	const size_t len = resource.length();
	if (len == 0) return false;
	//___________________________________________________________ Resource is only: /
	if (len == 1)
	{
		if (resource[0] == '/')
		{
			resourcePath = L"\\";
			return true;
		}
	}
	//________________________________________________________
	wchar_t* questionMark = wcschr((wchar_t*)begin, '?');
	const bool hasQueryString = (questionMark != NULL);
	wchar_t * dot = NULL;
	bool hasDot = false;
	//__________________________________________________________ Get file extension
	if (hasQueryString == true)
	{
		//____________________ Find dot
		for(dot= questionMark; dot != begin; dot--)
		{
			if (*dot == '.')
			{
				hasDot = true;
				break;
			}
		}	
		if (hasDot == true)
		{
			dot++;// Move one position after the dot
			if (dot < questionMark)
			{
				resourceFileExtension.assign(dot, questionMark);
				Sys::TextAssistant::ToLower(resourceFileExtension);
			}
		}
		//__________ Get Query String
		questionMark++;// Move one position after question mark
		if (questionMark < begin+len)
		{
			query_wstring.assign(questionMark, begin+len);
			Sys::TextAssistant::RemoveTrailingSpaces(query_wstring);
			Sys::Convert::WstringToString(query_wstring, query_string);
		}
	}
	else
	{
		//____________________ Find dot
		for(dot = (wchar_t*)begin+len; dot != begin; dot--)
		{
			if (*dot == '.')
			{
				hasDot = true;
				break;
			}
		}	
		if (hasDot == true && dot < begin+len)
		{
			dot++;// Move one position after the dot
			if (dot < begin+len)
			{
				resourceFileExtension.assign(dot, begin+len);
				Sys::TextAssistant::ToLower(resourceFileExtension);
			}
		}
	}
	//__________________________________________________________  Get filename
	wchar_t* fileBegin = NULL;
	bool hasFile = false;
	if (hasDot == true && dot < begin+len)
	{
		for(fileBegin= dot; begin <= fileBegin; fileBegin--)
		{
			if (*fileBegin == '/')
			{
				hasFile = true;
				break;
			}
		}
		if (hasFile == true)
		{
			if (fileBegin+1 < dot-1)
			{
				resourceFileName.assign(fileBegin+1, dot-1);
			}
		}
		else
		{
			if (begin < dot-1)
			{
				resourceFileName.assign(begin, dot-1);
				resourcePath.clear();
				return true;
			}
		}
	}

	//__________________________________________________________  Get path
	if (hasFile == true)
	{
		if (begin < fileBegin) // Remember that fileBegins points the backslash previous to the filename
		{
			resourcePath.assign(begin, fileBegin);
		}
	}
	else
	{
		if (hasQueryString == true)
		{
			if (begin < questionMark-1)
			{
				resourcePath.assign(begin, questionMark-1);
			}
		}
		else
		{
			resourcePath = resource;
		}
	}
	Sys::TextAssistant::ReplaceChar(resourcePath, '/', '\\');
	if (resourcePath.empty() == true) resourcePath = L"\\";
	return true;
}

void HttpRequest::WriteStatusLine(wstring& text)
{
	text.reserve(head.size()*64);
	text = method;
	text += L" ";
	text += resource;
	//_____________________________
	wchar_t tmp[32];
	_snwprintf_s(tmp, 32, _TRUNCATE, L" HTTP/%d.%d", majorVersion, minorVersion);
	text += tmp;
}

void HttpRequest::RenderCustomHead(wstring& text)
{
}

//const char* HttpRequest::GetMethodDescrChar(int method)
//{
//	switch (method)
//	{
//	case HTTP_METHOD_GET: return "GET";
//	case HTTP_METHOD_HEAD: return "HEAD";
//	case HTTP_METHOD_POST: return "POST";
//	case HTTP_METHOD_PUT: return "PUT";
//	case HTTP_METHOD_DELETE: return "DELETE";
//	case HTTP_METHOD_TRACE: return "TRACE";
//	case HTTP_METHOD_CONNECT: return "CONNECT";
//	}
//	return "ERROR";
//}

//const wchar_t* HttpRequest::GetMethodDescr(int method)
//{
//	switch (method)
//	{
//	case HTTP_METHOD_GET: return L"GET";
//	case HTTP_METHOD_HEAD: return L"HEAD";
//	case HTTP_METHOD_POST: return L"POST";
//	case HTTP_METHOD_PUT: return L"PUT";
//	case HTTP_METHOD_DELETE: return L"DELETE";
//	case HTTP_METHOD_TRACE: return L"TRACE";
//	case HTTP_METHOD_CONNECT: return L"CONNECT";
//	}
//	return L"ERROR";
//}

//__________________________________________________ HttpResponse
HttpResponse::HttpResponse()
{
	code = 200;
}

HttpResponse::~HttpResponse()
{
}

void HttpResponse::CreateFromCode(int code, const wchar_t* caption)
{
	Delete();
	this->code = code;
	head[L"Content-type"] = L"text/html; charset=UTF-8";
	const wchar_t* descr = GetCodeDescr(code);
	wstring wtext;
	Sys::Format(wtext, L"<html><h1>%s</h1><hr />%s</html>", descr, caption);
	string text;
	Sys::Convert::WstringToUTF8(wtext, text);
	body.CreateFromText(text);
}

bool HttpResponse::PrepareSendFile(const wchar_t* filename, int& out_fileSize, bool& mustSend)
{
	out_fileSize = 0;
	mustSend = false;
	//____________________________________________________________________
	HANDLE hFile = ::CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		CreateFromCode(404, filename); //Not Found
		mustSend = true;
		return false;
	}
	//_____________________________________________________________ Get file size
	DWORD highSize;
	out_fileSize = (int)::GetFileSize(hFile, &highSize);
	if (hFile != INVALID_HANDLE_VALUE) ::CloseHandle(hFile);
	//_____________________________________________________________ 200 OK
	code = 200; //OK
	wchar_t ext[32];
	if (Sys::TextAssistant::ExtractFileExt(filename, ext, 32) == true)
	{
		head[L"Content-type"] = GetMimeContentType(ext);
	}
	else
	{
		CreateFromCode(400, filename); //Bad request
		mustSend = true;
		return false;
	}
	return true;
}

bool HttpResponse::CanSaveFile()
{
	return (code == 200);
}

bool HttpResponse::IsRequiredToReceiveBody()
{
	return true;
}

void HttpResponse::PrivateDelete()
{
	code = 200;
}

//HTTP/1.1 200 OK\r\n
bool HttpResponse::ReadStatusLine(size_t& position, const char* in_buffer, const size_t bufferSize)
{
	if (position >= bufferSize) return false;
	char c;
	//__________________________________________ HTTP/
	wstring text;
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c =='/') break;
		text += c;
		c = in_buffer[position++];
	}
	if (text != L"HTTP") return false;
	if (position >= bufferSize) return false;
	//_________________________________________ Major Version
	text.clear();
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c =='.') break;
		text += c;
		c = in_buffer[position++];
	}
	majorVersion = Sys::Convert::ToInt(text);
	if (position >= bufferSize) return false;
	//_________________________________________ Minor Version
	text.clear();
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c == ' ' || c == '\t') break;
		text += c;
		c = in_buffer[position++];
	}
	minorVersion = Sys::Convert::ToInt(text);
	if (position >= bufferSize) return false;
	//___________________________________________ Move spaces or tabs
	while(position < bufferSize)
	{
		if (c !=' ' && c != '\t')
		{
			position--;
			break;
		}
		c = in_buffer[position++];
	}
	if (position >= bufferSize) return false;
	//____________________________________________ Code
	text.clear();
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c == ' ' || c == '\t') break;
		if (c == '\n') return true; // done
		if (c != '\r') text += c;
		c = in_buffer[position++];
	}
	code = Sys::Convert::ToInt(text);
	if (position >= bufferSize) return false;
	//____________________________________________ Move to end of line
	c = in_buffer[position++];
	while(position < bufferSize)
	{
		if (c == '\n') return true;
		c = in_buffer[position++];
	}
	return false;
}

void HttpResponse::WriteStatusLine(wstring& text)
{
	wchar_t tmp[32];
	_snwprintf_s(tmp, 32, _TRUNCATE, L"HTTP/%d.%d %s", majorVersion, minorVersion, GetCodeDescr(code));
	text.reserve(head.size()*64);
	text = tmp;
}

void HttpResponse::RenderCustomHead(wstring& text)
{
	map<wstring, wstring>::iterator p;
	//_______________________________________________________ Server: ComputerName
	 p= head.find(L"Server");
	if (p == head.end())
	{
		wstring servername;
		Sys::Information::getComputerName(servername);
		text += L"Server: ";
		text += servername;
		text+= L"\r\n";
	}

	//_____________________________________________________WWW-Authenticate: 
	if (code == 401)
	{
		p= head.find(L"WWW-Authenticate");
		if (p == head.end())
		{
			text += L"WWW-Authenticate: Basic Realm=\"private\"\r\n";
		}
	}
}

bool HttpResponse::SeparateLocation(const wchar_t* in_location, wstring& out_servername, wstring& out_resource)
{
	out_servername.clear();
	out_resource = L"/";
	//_______________________________________________
	if (in_location == NULL) return false;
	const size_t len = wcslen(in_location);
	if (len == 0) return false;
	//_______________________________________________ Find http
	const wchar_t* http = wcsstr(in_location, L"http://");
	if (http == NULL) return false;
	//_______________________________________________ Find resource beginning i.e. /
	const wchar_t* resource = wcschr(http+7, '/');
	if (resource == NULL)
	{
		out_servername.assign(http + 7, in_location+len);
		return true;
	}
	//______________________________________________ servername and resource
	out_servername.assign(http + 7, resource);
	out_resource.assign(resource, in_location+len);
	return true;
}

bool HttpResponse::SeparateLocation(const wstring& in_location, wstring& out_servername, wstring& out_resource)
{
	return SeparateLocation(in_location.c_str(), out_servername, out_resource);
}

const char* HttpResponse::GetCodeDescrChar(int code)
{
	switch (code)
	{
		//_______________________________________Informational - Request received, continuing process
	case 100: return "100 Continue";
	case 101: return "101 Switching Protocols";
		//_______________________________________Informational - Request received, continuing process
	case 200: return "200 OK";
	case 201: return "201 Created";
	case 202: return "202 Accepted";
	case 203: return "203 Non-Authoritative Information";
	case 204: return "204 No Content";
	case 205: return "205 Reset Content";
	case 206: return "206 Partial Content";
		//_______________________________________Redirection - Further action must be taken in order tocomplete the request
	case 300: return "300 Multiple Choices";
	case 301: return "301 Moved Permanently";
	case 302: return "302 Found";
	case 303: return "303 See Other";
	case 304: return "304 Not Modified";
	case 305: return "305 Use Proxy";
	case 307: return "307 Temporary Redirect";
		//_______________________________________Client Error - The request contains bad syntax or cannot be fulfilled
	case 400: return "400 Bad Request";
	case 401: return "401 Unauthorized";  //WWW-Authenticate: Basic realm="WallyWorld"
	case 402: return "402 Payment Required";
	case 403: return "403 Forbidden";
	case 404: return "404 Not Found";
	case 405: return "405 Method Not Allowed";
	case 406: return "406 Not Acceptable";
	case 407: return "407 Proxy Authentication Required";
	case 408: return "408 Request Time-out";
	case 409: return "409 Conflict";
	case 410: return "410 Gone";
	case 411: return "411 Length Required";
	case 412: return "412 Precondition Failed";
	case 413: return "413 Request Entity Too Large";
	case 414: return "414 Request-URI Too Large";
	case 415: return "415 Unsupported Media Type";
	case 416: return "416 Requested range not satisfiable";
	case 417: return "417 Expectation Failed";
		//_______________________________________Server Error - The server failed to fulfill an apparently valid request
	case 500: return "500 Internal Server Error";
	case 501: return "501 Not Implemented";
	case 502: return "502 Bad Gateway";
	case 503: return "503 Service Unavailable";
	case 504: return "504 Gateway Time-out";
	case 505: return "505 HTTP Version not supported";
	}
	return "500 Internal Server Error";
}

const wchar_t* HttpResponse::GetCodeDescr(int code)
{
	switch (code)
	{
		//_______________________________________Informational - Request received, continuing process
	case 100: return L"100 Continue";
	case 101: return L"101 Switching Protocols";
		//_______________________________________Informational - Request received, continuing process
	case 200: return L"200 OK";
	case 201: return L"201 Created";
	case 202: return L"202 Accepted";
	case 203: return L"203 Non-Authoritative Information";
	case 204: return L"204 No Content";
	case 205: return L"205 Reset Content";
	case 206: return L"206 Partial Content";
		//_______________________________________Redirection - Further action must be taken in order to complete the request
	case 300: return L"300 Multiple Choices";
	case 301: return L"301 Moved Permanently";
	case 302: return L"302 Found";
	case 303: return L"303 See Other";
	case 304: return L"304 Not Modified";
	case 305: return L"305 Use Proxy";
	case 307: return L"307 Temporary Redirect";
		//_______________________________________Client Error - The request contains bad syntax or cannot be fulfilled
	case 400: return L"400 Bad Request";
	case 401: return L"401 Unauthorized";  //WWW-Authenticate: Basic realm="WallyWorld"
	case 402: return L"402 Payment Required";
	case 403: return L"403 Forbidden";
	case 404: return L"404 Not Found";
	case 405: return L"405 Method Not Allowed";
	case 406: return L"406 Not Acceptable";
	case 407: return L"407 Proxy Authentication Required";
	case 408: return L"408 Request Time-out";
	case 409: return L"409 Conflict";
	case 410: return L"410 Gone";
	case 411: return L"411 Length Required";
	case 412: return L"412 Precondition Failed";
	case 413: return L"413 Request Entity Too Large";
	case 414: return L"414 Request-URI Too Large";
	case 415: return L"415 Unsupported Media Type";
	case 416: return L"416 Requested range not satisfiable";
	case 417: return L"417 Expectation Failed";
		//_______________________________________Server Error - The server failed to fulfill an apparently valid request
	case 500: return L"500 Internal Server Error";
	case 501: return L"501 Not Implemented";
	case 502: return L"502 Bad Gateway";
	case 503: return L"503 Service Unavailable";
	case 504: return L"504 Gateway Time-out";
	case 505: return L"505 HTTP Version not supported";
	}
	return L"500 Internal Server Error";
}

//__________________________________________________ HttpConnector
HttpConnector::HttpConnector(EXTENSION_CONTROL_BLOCK* pECB)
{
	multimap<wstring, wstring>::iterator p; 
	httpCode = 200; // 200 OK
	ContentType = HTML_CONTENT_TYPE_TEXT_HTML;
	//
	postData = NULL;
	postDataNumberBytes = 0;
	//
	_isAjax = false;
	isSoap = false;
	windowID[0] = '\0';
	this->pECB = NULL;
	if (pECB != NULL) this->pECB = pECB;
	_hasRequestBeenHandled = false;
	ReadQueryString();
	ReadPostData();
	UpdateUrl();
	//____________________________________ WindowID
	p = value.find(L"windowID");
	if (p == value.end()) return;
	//__________________________________  Is XML?
	if (IsAjax() == true)
	{
		ContentType = HTML_CONTENT_TYPE_TEXT_XML;
		_snwprintf_s(windowID, 64, _TRUNCATE, L"%s", p->second.c_str());
		return;
	}
	//__________________________________  Is ProgressBar?
	if (p->second == L"ProgressBar")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_GIF;
		_hasRequestBeenHandled = true;
		Web::ProgressBar chart;
		//chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is CalendarWindowX?
	else if (p->second == L"CalendarWindowX")
	{
		ContentType = HTML_CONTENT_TYPE_TEXT_HTML;
		_hasRequestBeenHandled = true;
		multimap<wstring, wstring>::iterator q; 
		//______________ destinationDateTimeBoxID
		wstring destinationDateTimeBoxID;
		q = value.find(L"destinationDateTimeBoxID");
		if (q != value.end()) destinationDateTimeBoxID = q->second;
		//______________ monthsText
		wstring monthsText;
		q = value.find(L"monthsText");
		if (q != value.end()) monthsText = q->second;
		//______________ daysText
		wstring daysText;
		q = value.find(L"daysText");
		if (q != value.end()) daysText = q->second;
		//______________ cssFile
		//wstring cssFile;
		//q = value.find(L"cssFile");
		//if (q != value.end()) cssFile = q->second;
		Web::DateTimeBox dtb;
		dtb.GetCalendarWindowHtml(destinationDateTimeBoxID, monthsText, daysText, responseData);
	}
#ifdef WIN_GDI_PLUS_ON
	//__________________________________  Is BarChart?
	else if (p->second == L"BarChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::BarChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is PolarChart?
	else if (p->second == L"PolarChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::PolarChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is PieChart?
	else if (p->second == L"PieChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::PieChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is XyChart?
	else if (p->second == L"XyChart")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::XyChart chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
	//__________________________________  Is Histogram?
	else if (p->second == L"Histogram")
	{
		ContentType = HTML_CONTENT_TYPE_IMAGE_PNG;
		_hasRequestBeenHandled = true;
		Web::Histogram chart;
		chart.Sync(*this);
		chart.RenderImage(responseData);
	}
#endif
	_snwprintf_s(windowID, 64, _TRUNCATE, L"%s", p->second.c_str());
}

HttpConnector::~HttpConnector()
{
	if (postData != NULL) delete [] postData;
}

bool HttpConnector::IsAjax()
{
	return _isAjax;
}

//list<Sys::Xml>::const_iterator HttpConnector::GetAjaxXmlChildIterator(list<Sys::Xml>::const_iterator control, const wchar_t* childTagName) const
//{
//	if (control == ajaxResponse.child.end()) return ajaxResponse.child.end();
//	list<Sys::Xml>::const_iterator element= control->child.begin();
//	const list<Sys::Xml>::const_iterator element_end = control->child.end();
//	for(; element != element_end; element++)
//	{
//		if (element->name == childTagName) return element;
//	}
//	return ajaxResponse.child.end();
//}

//bool HttpConnector::GetAjaxXmlChildValue(list<Sys::Xml>::const_iterator control, const wchar_t* childTagName, wstring& out_value) const
//{
//	out_value.clear();
//	if (control == ajaxResponse.child.end()) return false;
//	list<Sys::Xml>::const_iterator element = control->child.begin();
//	const list<Sys::Xml>::const_iterator element_end = control->child.end();
//	for(; element != element_end; element++)
//	{
//		if (element->name == childTagName)
//		{
//			out_value = element->value;
//			return true;
//		}
//	}
//	return false;
//}

bool HttpConnector::GetAjaxControlIterator(const wchar_t* ID, list<Sys::Xml>::const_iterator& control) const
{
	if (_isAjax == false) return false;
	control = ajaxHttpRequest.child.begin();
	const list<Sys::Xml>::const_iterator gui_end = ajaxHttpRequest.child.end();
	//__________________________________________________________________________ Find the control
	for(; control != gui_end; control++)
	{
		if (control->child.empty() == true) continue; // Impossible to get here
		if (control->child.front().value == ID) return true; // The first child is <id>ID</id>
	}
	return false;
}

bool HttpConnector::IsFirstTime()
{
	multimap<wstring, wstring>::iterator state;
	//____________________________________ ajax?
	state = value.find(L"ajax");
	if (state != value.end())
	{
		if (Sys::Convert::ToBool(state->second) == true) return false;
	}
	//____________________________________ onclickSrc ?
	state = value.find(L"onclickSrc");
	if (state == value.end()) return true;
	if (state->second == L"0") return true;
	return false;
}

const wchar_t* HttpConnector::GetServerVariableName(int index)
{
	switch(index)
	{
	case 0: return L"APPL_MD_PATH";
	case 1: return L"APPL_PHYSICAL_PATH";
	case 2: return L"AUTH_PASSWORD";
	case 3: return L"AUTH_TYPE";
	case 4: return L"AUTH_USER";
	case 5: return L"CACHE_URL";
	case 6: return L"CERT_COOKIE";
	case 7: return L"CERT_FLAGS";
	case 8: return L"CERT_ISSUER";
	case 9: return L"CERT_KEYSIZE";
	case 10: return L"CERT_SECRETKEYSIZE";
	case 11: return L"CERT_SERIALNUMBER";
	case 12: return L"CERT_SERVER_ISSUER";
	case 13: return L"CERT_SERVER_SUBJECT";
	case 14: return L"CERT_SUBJECT";
	case 15: return L"CONTENT_LENGTH";
	case 16: return L"CONTENT_TYPE";
	case 17: return L"GATEWAY_INTERFACE";
	case 18: return L"HTTP_ACCEPT";
	case 19: return L"HTTP_ACCEPT_ENCODING";
	case 20: return L"HTTP_ACCEPT_LANGUAGE";
	case 21: return L"HTTP_CONNECTION";
	case 22: return L"HTTP_COOKIE";
	case 23: return L"HTTP_HOST";
	case 24: return L"HTTP_METHOD";
	case 25: return L"HTTP_REFERER";
	case 26: return L"HTTP_URL";
	case 27: return L"HTTP_USER_AGENT";
	case 28: return L"HTTP_VERSION";
	case 29: return L"HTTPS";
	case 30: return L"HTTPS_KEYSIZE";
	case 31: return L"HTTPS_SECRETKEYSIZE";
	case 32: return L"HTTPS_SERVER_ISSUER";
	case 33: return L"HTTPS_SERVER_SUBJECT";
	case 34: return L"INSTANCE_ID";
	case 35: return L"INSTANCE_META_PATH";
	case 36: return L"LOCAL_ADDR";
	case 37: return L"LOGON_USER";
	case 38: return L"PATH_INFO";
	case 39: return L"PATH_TRANSLATED";
	case 40: return L"QUERY_STRING";
	case 41: return L"REMOTE_ADDR";
	case 42: return L"REMOTE_HOST";
	case 43: return L"REMOTE_PORT";
	case 44: return L"REMOTE_USER";
	case 45: return L"REQUEST_METHOD";
	case 46: return L"SCRIPT_NAME";
	case 47: return L"SCRIPT_TRANSLATED";
	case 48: return L"SERVER_NAME";
	case 49: return L"SERVER_PORT";
	case 50: return L"SERVER_PORT_SECURE";
	case 51: return L"SERVER_PROTOCOL";
	case 52: return L"SERVER_SOFTWARE";
	case 53: return L"SSI_EXEC_DISABLED";
	case 54: return L"UNENCODED_URL";
	case 55: return L"UNMAPPED_REMOTE_USER";
	case 56: return L"URL";
	case 57: return L"URL_PATH_INFO";
	}
	return NULL;
}

//returns any of:
//HTML_BROWSER_UNKNOWN
//HTML_BROWSER_IE
//HTML_BROWSER_SAFARI
//HTML_BROWSER_CHROME
//HTML_BROWSER_OPERA
//HTML_BROWSER_FIREFOX
int HttpConnector::GetExplorerID()
{
	if (pECB == NULL) return HTML_BROWSER_IE;
	wstring user_agent;
	if (this->GetServerVariable("HTTP_USER_AGENT", user_agent) == false) return HTML_BROWSER_UNKNOWN;

	std::transform(user_agent.begin(), user_agent.end(), user_agent.begin(), toupper);
	size_t pos = user_agent.find(L"MSIE");
	if (pos != std::wstring::npos) return HTML_BROWSER_IE;
	//
	pos = user_agent.find(L"SAFARI");
	if (pos != std::wstring::npos) return HTML_BROWSER_SAFARI;
	//
	pos = user_agent.find(L"CHROME");
	if (pos != std::wstring::npos) return HTML_BROWSER_CHROME;
	//
	pos = user_agent.find(L"OPERA");
	if (pos != std::wstring::npos) return HTML_BROWSER_OPERA;
	//
	pos = user_agent.find(L"FIREFOX");
	if (pos != std::wstring::npos) return HTML_BROWSER_FIREFOX;
	//
	return HTML_BROWSER_UNKNOWN;
}

void HttpConnector::UpdateUrl()
{
	wstring unencoded_url;
	if (this->GetServerVariable("HTTP_HOST", url) == false)
	{
		url.clear();
		return;
	}
	if (this->GetServerVariable("UNENCODED_URL", unencoded_url)==false)
	{
		url.clear();
		return;
	}
	//___________________________________ Remove after question mark
	size_t pos = unencoded_url.find('?');
	if (pos != std::wstring::npos)
	{
		unencoded_url.resize(pos);
	}
	url += unencoded_url;
}

void HttpConnector::SetRequestEvent()
{
	_hasRequestBeenHandled = true;
}

bool HttpConnector::ReadPostData()
{
	if (pECB == NULL) return false;
	const DWORD len = pECB->cbTotalBytes;
	postDataNumberBytes = len;
	if (len == 0) return true;
	if (postData != NULL) delete [] postData;
	postData = new char[len+1]; // add an extra char for the NULL terminator
	if (postData == NULL) return false;

	//____________________________________________________________________________ Method 1
	//::memcpy_s(postData, len, pECB->lpbData, pECB->cbAvailable);
	//DWORD remaining = pECB->cbTotalBytes - pECB->cbAvailable; 
	//if (remaining > 0)
	//{
	//	pECB->ReadClient(pECB->ConnID, (LPVOID)(postData+pECB->cbAvailable), &remaining);
	//}
	//postData[len] = '\0';
	//____________________________________________________________________________ Method 2
	::memcpy_s(postData, len, pECB->lpbData, pECB->cbAvailable);
	DWORD remaining = pECB->cbTotalBytes - pECB->cbAvailable;
	size_t copied = pECB->cbAvailable;
	while (remaining > 0)
	{
		pECB->ReadClient(pECB->ConnID, (LPVOID)(postData+copied), &remaining);
		copied += (size_t)remaining;
	}
	postData[len] = '\0';

	//___________________________________________________________ CONTENT_TYPE Read Variables via POST urlencoded
	wstring content_type;
	if (GetServerVariable("CONTENT_TYPE", content_type) == true)
	{
		Sys::TextAssistant::ToLower(content_type);
		//___________________________ URLENCODED
		if (content_type.find(L"form-urlencoded") != std::wstring::npos)
		{
			ReadVariables(postData, len);
			return true;
		}
		//___________________________ SOAP 1.2
		else if (content_type.find(L"soap") != std::wstring::npos)
		{
			ContentType = HTML_CONTENT_TYPE_SOAP1_2;
			if (Sys::Xml::IsXml(postData) == true)
			{
				ReadVariablesFromSoapXml(postData, len);
			}
			return true;
		}
		//__________________________________________ AJAX
		multimap<wstring, wstring>::iterator p = value.find(L"ajax");
		if (p != value.end())
		{
			if (Sys::Convert::ToBool(p->second) == true) _isAjax = true;
		}
		if (_isAjax == true)
		{
			if (content_type.find(L"xml") != std::wstring::npos)
			{
				ContentType = HTML_CONTENT_TYPE_TEXT_XML;
				if (Sys::Xml::IsXml(postData) == true)
				{
					ajaxHttpRequest.CreateFromUtf8String(postData);
					//_______________________________________ Try to get name = windowID, id = windowInfo
					list<Sys::Xml>::const_iterator ctrl;
					if (GetAjaxControlIterator(L"windowInfo", ctrl) == false) return false;
					if (ctrl->child.size() < 2) return false;
					list<Sys::Xml>::const_iterator param = ctrl->child.begin();
					param++; // First is <id>ID<id>. Second is <d>value</d>
					AddVariable(L"windowID", param->value.c_str());
				}
				return true;
			}
		}
	}
	//___________________________________________________________ SOAPAction (SOAP 1.1)
	wstring soapAction;
	if (GetServerVariable("HEADER_SOAPAction", soapAction) == true)
	{
		value.insert(pair<wstring, wstring>(L"SOAPAction", soapAction));
		ContentType = HTML_CONTENT_TYPE_SOAP1_1;
		if (Sys::Xml::IsXml(postData) == true)
		{
			ReadVariablesFromSoapXml(postData, len);
		}
		return true;
	}
	return true;
}

void HttpConnector::ReadQueryString()
{
	if (pECB == NULL) return;
	if (pECB->lpszQueryString == NULL) return;
	const int len = (int)strlen(pECB->lpszQueryString);
	ReadVariables(pECB->lpszQueryString, len);
}

void HttpConnector::ReadVariablesFromSoapXml(const char* data, DWORD len)
{
	isSoap = false;
	if (len == 0) return;
	Sys::SoapEnvelope soapEnvelope;
	if (soapEnvelope.CreateFromUtf8String(data) == false)
	{
		soapEnvelope.GetXmlText(soapXmlError);
	}
	wstring actionName = soapEnvelope.GetActionName();
	if (actionName.length() == 0) return;
	isSoap = true;
	value.insert(pair<wstring, wstring>(L"SoapActionName", actionName));
	//_________________________________________ replace windowID with the value of the SoapActionName
	multimap<wstring, wstring>::iterator state;
	state = value.find(L"windowID");
	if (state != value.end())
	{
		state->second = actionName;
	}
	else
	{
		value.insert(pair<wstring, wstring>(L"windowID", actionName));
	}
	//_____________________________________ Read Parameters
	list<Sys::Xml>::iterator body;
	if (soapEnvelope.GetChildByNoPrefixName(L"Body", body) == false) return;
	if (body->child.empty() == true) return; // No Action
	//
	list<Sys::Xml>::const_iterator action = body->child.begin();
	if (action->child.empty() == true) return; // Zero Parameters
	list<Sys::Xml>::const_iterator parameter = action->child.begin();
	const list<Sys::Xml>::const_iterator param_end =action->child.end();
	for (; parameter != param_end; parameter++)
	{
		value.insert(pair<wstring, wstring>(parameter->name, parameter->value));
	}
	wstring xmlns;
	if (soapEnvelope.Get_xmlns(soapEnvelope, xmlns) == false) return;
	if (xmlns.empty() == false)
	{
		value.insert(pair<wstring, wstring>(L"soapEvelopeXmlns", xmlns));
	}
}

void HttpConnector::ReadVariables(const char* data, DWORD len)
{
	if (len == 0) return;
	len++; // We add one to consider a last &
	string name;
	wstring wname;
	string utf8name;
	//
	string val;
	wstring wval;
	string utf8val;
	//
	size_t posIni = 0;
	size_t posEqual = 0;
	DWORD i;
	bool isName = true;
	char c;
	for(i = 0; i<len; i++)
	{
		if (i == len-1)
		{
			c = '&'; // We append a last & to separate the last data
		}
		else
		{
			c = data[i];
		}
		if (c == '&')
		{
			if (isName == true)
			{
			}
			else
			{
				Sys::Convert::HexToUTF8(name.c_str(), utf8name);
				Sys::Convert::HexToUTF8(val.c_str(), utf8val);
				//
				Sys::Convert::UTF8ToWstring(utf8name, wname);
				Sys::Convert::UTF8ToWstring(utf8val, wval);
				value.insert(pair<wstring, wstring>(wname, wval));
				isName = true;
				name.clear();
				val.clear();
			}
		}
		else if (c == '=')
		{
			if (isName == true)
			{
				isName = false;
			}
			else
			{
			}
		}
		else
		{
			if (isName == true)
			{
				name += c;
			}
			else
			{
				val += c;
			}
		}
	}	
}

void HttpConnector::AddVariable(const wchar_t* variableName, const wchar_t* variableValue)
{
	value.insert(pair<wstring, wstring>(variableName, variableValue));
}

bool HttpConnector::SetVariable(const wchar_t* variableName, const wchar_t* variableValue)
{
	multimap<wstring, wstring>::iterator p = value.find(variableName);
	if (p == value.end()) return false;
	p->second = variableValue;
	return true;
}

bool HttpConnector::GetVariable(const wchar_t* variableName, wstring& out_variableValue)
{
	multimap<wstring, wstring>::iterator p = value.find(variableName);
	if (p == value.end()) return false;
	out_variableValue = p->second;
	return true;
}

bool HttpConnector::GetVariable(const wstring& variableName, wstring& out_variableValue)
{
	return GetVariable(variableName.c_str(), out_variableValue);
}

bool HttpConnector::GetVariable(const wchar_t*  variableName, double& out_variableValue)
{
	wstring tmp;
	const bool ok = GetVariable(variableName, tmp);
	out_variableValue = Sys::Convert::ToDouble(tmp);
	return ok;
}

bool HttpConnector::GetVariable(const wstring& variableName, double& out_variableValue)
{
	return GetVariable(variableName.c_str(), out_variableValue);
}

bool HttpConnector::GetVariable(const wchar_t*  variableName, int& out_variableValue)
{
	wstring tmp;
	const bool ok = GetVariable(variableName, tmp);
	out_variableValue = Sys::Convert::ToInt(tmp);
	return ok;
}

bool HttpConnector::GetVariable(const wstring& variableName, int& out_variableValue)
{
	return GetVariable(variableName.c_str(), out_variableValue);
}

bool HttpConnector::GetVariable(const wchar_t*  variableName, bool& out_variableValue)
{
	wstring tmp;
	const bool ok = GetVariable(variableName, tmp);
	out_variableValue = Sys::Convert::ToBool(tmp);
	return ok;
}

bool HttpConnector::GetVariable(const wstring& variableName, bool& out_variableValue)
{
	return GetVariable(variableName.c_str(), out_variableValue);
}

bool HttpConnector::HasRequestBeenHandled()
{
	return _hasRequestBeenHandled;
}

void HttpConnector::NavigateTo(const wchar_t* windowID)
{
	if (windowID == NULL) return;
	if (wcslen(windowID) == 0) return;
	_hasRequestBeenHandled = false;
	_snwprintf_s(this->windowID, 64, _TRUNCATE, L"%s", windowID);

	multimap<wstring, wstring>::iterator state;
	//_________________________________________ remove onclickSrc
	state = value.find(L"onclickSrc");
	if (state == value.end()) return;
	value.erase(state);
	//_________________________________________ replace windowID in the values
	state = value.find(L"windowID");
	if (state == value.end()) return;
	state->second = windowID;
}

wchar_t* HttpConnector::GetWindowID()
{
	return windowID;
}

bool HttpConnector::CheckEvent(const wstring& ID, int notification)
{
	multimap<wstring, wstring>::iterator p;

	//______________________________________ Submit Buttons
	p = value.find(L"onclickSrc");
	if (p != value.end())
	{
		if (p->second == ID && notification == LEX_HTML_ONCLICK) return true;
	}

	//______________________________________ Check sourceID
	p = value.find(L"sourceID");
	if (p == value.end()) return false;
	if (p->second != ID) return false;
	//______________________________________ Check eventID
	p = value.find(L"eventID");
	if (p == value.end()) return false;
	wchar_t * eventShortName = Cpl::LexicalAnalyzer::GetTokenText(notification);
	if (eventShortName == NULL) return false;
	if (p->second != eventShortName) return false;
	return true;
}

// ALL_HTTP ALL_RAW APP_POOL_ID APPL_MD_PATH APPL_PHYSICAL_PATH AUTH_PASSWORD
// AUTH_TYPE AUTH_USER CACHE_URL CERT_COOKIE CERT_FLAGS CERT_ISSUER CERT_KEYSIZE
// CERT_SECRETKEYSIZE CERT_SERIALNUMBER CERT_SERVER_ISSUER CERT_SERVER_SUBJECT
// CERT_SUBJECT CONTENT_LENGTH CONTENT_TYPE GATEWAY_INTERFACE HTTP_ACCEPT HTTP_ACCEPT_ENCODING
// HTTP_ACCEPT_LANGUAGE HTTP_CONNECTION HTTP_COOKIE HTTP_HOST HTTP_METHOD HTTP_REFERER
// HTTP_URL HTTP_USER_AGENT HTTP_VERSION HTTPS HTTPS_KEYSIZE HTTPS_SECRETKEYSIZE HTTPS_SERVER_ISSUER
// HTTPS_SERVER_SUBJECT INSTANCE_ID INSTANCE_META_PATH LOCAL_ADDR LOGON_USER PATH_INFO
// PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST REMOTE_PORT REMOTE_USER REQUEST_METHOD
// SCRIPT_NAME SCRIPT_TRANSLATED SERVER_NAME SERVER_PORT SERVER_PORT_SECURE SERVER_PROTOCOL
// SERVER_SOFTWARE SSI_EXEC_DISABLED UNENCODED_URL UNMAPPED_REMOTE_USER URL URL_PATH_INFO
bool HttpConnector::GetServerVariable(const char* variableName, char* buffer, DWORD bufferLen)
{
	if (pECB == NULL)
	{
		buffer[0] = '\0';
		return false;
	}
	if (pECB->GetServerVariable(pECB->ConnID, (char*)variableName, buffer, &bufferLen)== TRUE) return true;
	return false;
}

// ALL_HTTP ALL_RAW APP_POOL_ID APPL_MD_PATH APPL_PHYSICAL_PATH AUTH_PASSWORD
// AUTH_TYPE AUTH_USER CACHE_URL CERT_COOKIE CERT_FLAGS CERT_ISSUER CERT_KEYSIZE
// CERT_SECRETKEYSIZE CERT_SERIALNUMBER CERT_SERVER_ISSUER CERT_SERVER_SUBJECT
// CERT_SUBJECT CONTENT_LENGTH CONTENT_TYPE GATEWAY_INTERFACE HTTP_ACCEPT HTTP_ACCEPT_ENCODING
// HTTP_ACCEPT_LANGUAGE HTTP_CONNECTION HTTP_COOKIE HTTP_HOST HTTP_METHOD HTTP_REFERER
// HTTP_URL HTTP_USER_AGENT HTTP_VERSION HTTPS HTTPS_KEYSIZE HTTPS_SECRETKEYSIZE HTTPS_SERVER_ISSUER
// HTTPS_SERVER_SUBJECT INSTANCE_ID INSTANCE_META_PATH LOCAL_ADDR LOGON_USER PATH_INFO
// PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST REMOTE_PORT REMOTE_USER REQUEST_METHOD
// SCRIPT_NAME SCRIPT_TRANSLATED SERVER_NAME SERVER_PORT SERVER_PORT_SECURE SERVER_PROTOCOL
// SERVER_SOFTWARE SSI_EXEC_DISABLED UNENCODED_URL UNMAPPED_REMOTE_USER URL URL_PATH_INFO
// EXTENSION_CONTROL_BLOCK.GetServerVariable
bool HttpConnector::GetServerVariable(const char* variableName, string& out_value)
{
	if (pECB == NULL)
	{
		out_value.clear();
		return false;
	}
	char *buffer = NULL;
	DWORD size = 128;
	DWORD dw;

	do
	{
		if (buffer != NULL) delete [] buffer;
		buffer = new char[size];
		dw = size;
		if (pECB->GetServerVariable(pECB->ConnID, (char*)variableName, buffer, &dw)== TRUE)
		{
			out_value = buffer;
			if (buffer != NULL) delete [] buffer;
			return true;
		}
		if (size >=2048) break;
		size *= 2;
	}
	while(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
	//
	out_value = buffer;
	if (buffer != NULL) delete [] buffer;
	return false;
}

// ALL_HTTP ALL_RAW APP_POOL_ID APPL_MD_PATH APPL_PHYSICAL_PATH AUTH_PASSWORD
// AUTH_TYPE AUTH_USER CACHE_URL CERT_COOKIE CERT_FLAGS CERT_ISSUER CERT_KEYSIZE
// CERT_SECRETKEYSIZE CERT_SERIALNUMBER CERT_SERVER_ISSUER CERT_SERVER_SUBJECT
// CERT_SUBJECT CONTENT_LENGTH CONTENT_TYPE GATEWAY_INTERFACE HTTP_ACCEPT HTTP_ACCEPT_ENCODING
// HTTP_ACCEPT_LANGUAGE HTTP_CONNECTION HTTP_COOKIE HTTP_HOST HTTP_METHOD HTTP_REFERER
// HTTP_URL HTTP_USER_AGENT HTTP_VERSION HTTPS HTTPS_KEYSIZE HTTPS_SECRETKEYSIZE HTTPS_SERVER_ISSUER
// HTTPS_SERVER_SUBJECT INSTANCE_ID INSTANCE_META_PATH LOCAL_ADDR LOGON_USER PATH_INFO
// PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST REMOTE_PORT REMOTE_USER REQUEST_METHOD
// SCRIPT_NAME SCRIPT_TRANSLATED SERVER_NAME SERVER_PORT SERVER_PORT_SECURE SERVER_PROTOCOL
// SERVER_SOFTWARE SSI_EXEC_DISABLED UNENCODED_URL UNMAPPED_REMOTE_USER URL URL_PATH_INFO
bool HttpConnector::GetServerVariable(const char* variableName, wstring& out_value)
{
	string value;
	if (GetServerVariable(variableName, value) == true)
	{
		Sys::Convert::StringToWstring(value, out_value);
		return true;
	}
	out_value.clear();
	return false;
}

// ALL_HTTP ALL_RAW APP_POOL_ID APPL_MD_PATH APPL_PHYSICAL_PATH AUTH_PASSWORD
// AUTH_TYPE AUTH_USER CACHE_URL CERT_COOKIE CERT_FLAGS CERT_ISSUER CERT_KEYSIZE
// CERT_SECRETKEYSIZE CERT_SERIALNUMBER CERT_SERVER_ISSUER CERT_SERVER_SUBJECT
// CERT_SUBJECT CONTENT_LENGTH CONTENT_TYPE GATEWAY_INTERFACE HTTP_ACCEPT HTTP_ACCEPT_ENCODING
// HTTP_ACCEPT_LANGUAGE HTTP_CONNECTION HTTP_COOKIE HTTP_HOST HTTP_METHOD HTTP_REFERER
// HTTP_URL HTTP_USER_AGENT HTTP_VERSION HTTPS HTTPS_KEYSIZE HTTPS_SECRETKEYSIZE HTTPS_SERVER_ISSUER
// HTTPS_SERVER_SUBJECT INSTANCE_ID INSTANCE_META_PATH LOCAL_ADDR LOGON_USER PATH_INFO
// PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST REMOTE_PORT REMOTE_USER REQUEST_METHOD
// SCRIPT_NAME SCRIPT_TRANSLATED SERVER_NAME SERVER_PORT SERVER_PORT_SECURE SERVER_PROTOCOL
// SERVER_SOFTWARE SSI_EXEC_DISABLED UNENCODED_URL UNMAPPED_REMOTE_USER URL URL_PATH_INFO
bool HttpConnector::GetServerVariable(const wchar_t* variableName, wstring& out_value)
{
	string name;
	string value;
	Sys::Convert::WstringToString(variableName, name);
	if (GetServerVariable(name.c_str(), value) == true)
	{
		Sys::Convert::StringToWstring(value, out_value);
		return true;
	}
	out_value.clear();
	return false;
}

// ALL_HTTP ALL_RAW APP_POOL_ID APPL_MD_PATH APPL_PHYSICAL_PATH AUTH_PASSWORD
// AUTH_TYPE AUTH_USER CACHE_URL CERT_COOKIE CERT_FLAGS CERT_ISSUER CERT_KEYSIZE
// CERT_SECRETKEYSIZE CERT_SERIALNUMBER CERT_SERVER_ISSUER CERT_SERVER_SUBJECT
// CERT_SUBJECT CONTENT_LENGTH CONTENT_TYPE GATEWAY_INTERFACE HTTP_ACCEPT HTTP_ACCEPT_ENCODING
// HTTP_ACCEPT_LANGUAGE HTTP_CONNECTION HTTP_COOKIE HTTP_HOST HTTP_METHOD HTTP_REFERER
// HTTP_URL HTTP_USER_AGENT HTTP_VERSION HTTPS HTTPS_KEYSIZE HTTPS_SECRETKEYSIZE HTTPS_SERVER_ISSUER
// HTTPS_SERVER_SUBJECT INSTANCE_ID INSTANCE_META_PATH LOCAL_ADDR LOGON_USER PATH_INFO
// PATH_TRANSLATED QUERY_STRING REMOTE_ADDR REMOTE_HOST REMOTE_PORT REMOTE_USER REQUEST_METHOD
// SCRIPT_NAME SCRIPT_TRANSLATED SERVER_NAME SERVER_PORT SERVER_PORT_SECURE SERVER_PROTOCOL
// SERVER_SOFTWARE SSI_EXEC_DISABLED UNENCODED_URL UNMAPPED_REMOTE_USER URL URL_PATH_INFO
bool HttpConnector::GetServerVariable(const wstring& variableName, wstring& out_value)
{
	return GetServerVariable(variableName.c_str(), out_value);
}

bool HttpConnector::GetClientIP_Address(wstring& out_clientIP)
{
	string value;
	//____________________________________________________ HTTP_CLIENT_IP
	if (GetServerVariable("HTTP_CLIENT_IP", value) == true)
	{
		if (value != "127.0.0.1")
		{
			Sys::Convert::StringToWstring(value, out_clientIP);
			return true;
		}
	}
	//____________________________________________________ HTTP_X_FORWARDED_FOR
	if (GetServerVariable("HTTP_X_FORWARDED_FOR", value) == true)
	{
		if (value != "127.0.0.1")
		{
			Sys::Convert::StringToWstring(value, out_clientIP);
			return true;
		}
	}
	//____________________________________________________ HTTP_X_FORWARDED
	if (GetServerVariable("HTTP_X_FORWARDED", value) == true)
	{
		if (value != "127.0.0.1")
		{
			Sys::Convert::StringToWstring(value, out_clientIP);
			return true;
		}
	}
	//____________________________________________________ HTTP_FORWARDED_FOR
	if (GetServerVariable("HTTP_FORWARDED_FOR", value) == true)
	{
		if (value != "127.0.0.1")
		{
			Sys::Convert::StringToWstring(value, out_clientIP);
			return true;
		}
	}
	//____________________________________________________ HTTP_FORWARDED
	if (GetServerVariable("HTTP_FORWARDED", value) == true)
	{
		if (value != "127.0.0.1")
		{
			Sys::Convert::StringToWstring(value, out_clientIP);
			return true;
		}
	}
	//____________________________________________________ REMOTE_ADDR
	if (GetServerVariable("REMOTE_ADDR", value) == true)
	{
		if (value != "127.0.0.1")
		{
			Sys::Convert::StringToWstring(value, out_clientIP);
			return true;
		}
	}
	out_clientIP.clear();
	return false;
}

const char * HttpConnector::GetContentTypeDescription(int content_type)
{
	switch(content_type)
	{
	case HTML_CONTENT_TYPE_TEXT_HTML: return "text/html; charset=utf-8";
	case HTML_CONTENT_TYPE_TEXT_XML: return "text/xml; charset=utf-8";
	case HTML_CONTENT_TYPE_APPLICATION_XML: return "application/xml; charset=utf-8";
	case HTML_CONTENT_TYPE_SOAP1_1: return "text/xml; charset=utf-8";
	case HTML_CONTENT_TYPE_SOAP1_2: return "application/soap+xml; charset=utf-8";
	case HTML_CONTENT_TYPE_IMAGE_GIF: return "image/gif";
	case HTML_CONTENT_TYPE_IMAGE_PNG: return "image/png";
	case HTML_CONTENT_TYPE_IMAGE_XPNG: return "image/x-png";
	case HTML_CONTENT_TYPE_IMAGE_JPG: return "image/jpg";
	}
	return "text/html;  charset=utf-8";
}

// To send a custom response manually set: ContentType and responseData
DWORD HttpConnector::SendResponse(EXTENSION_CONTROL_BLOCK* pECB)
{
	// You must set shei.cchHeader  with Content-Type and Content-Length at least follow of one empty line
	// You must set the lenght of shei.pszHeader
	// The status line is created by the Server
	const char * codeDescr = Web::HttpResponse::GetCodeDescrChar(httpCode);
	const char* content_type = GetContentTypeDescription(ContentType);
	//_____________________________________ Header
	char header[1024];

	HSE_SEND_HEADER_EX_INFO shei;
	::memset(&shei, 0, sizeof(HSE_SEND_HEADER_EX_INFO));
	shei.fKeepConn = TRUE;
	int content_length = (int)responseData.size();
	if (httpCode == 200)
	{
		shei.pszStatus = "200 OK";
		shei.cchStatus = (DWORD)strlen (shei.pszStatus);
		if (content_length == 0) // The web page is responsible of HTTP Response body
		{
			responseData.reserve(html.size());
			Sys::Convert::WstringToUTF8(html, responseData);
			content_length = (DWORD)responseData.size();
		}
		shei.cchHeader  = _snprintf_s(header, 1024, _TRUNCATE, "Content-Type: %s\r\nContent-Length: %d\r\n\r\n", content_type, content_length);
		shei.pszHeader = header;
	}
	else if (httpCode == 401)
	{
		char script_name[256];
		if (this->GetServerVariable("SCRIPT_NAME", script_name, 256) == true)
		{
			const int realm_len = (int)strlen(script_name);
			if (realm_len >= 5) script_name[realm_len-4] = '\0'; // Remove file extension from the script_name
			shei.cchHeader  = _snprintf_s(header, 1024, _TRUNCATE, 
				"Content-Type: %s\r\nContent-Length: %d\r\nWWW-Authenticate: Basic realm=\"%s\"\r\n\r\n", 
				content_type, content_length, script_name);
		}
		else
		{
			shei.cchHeader  = _snprintf_s(header, 1024, _TRUNCATE, 
				"Content-Type: %s\r\nContent-Length: %d\r\nWWW-Authenticate: Basic realm=\"private\"\r\n\r\n",
				content_type, content_length);
		}
		shei.pszStatus = Web::HttpResponse::GetCodeDescrChar(httpCode);
		shei.cchStatus = (DWORD)strlen(shei.pszStatus);
		shei.pszHeader = header;
	}
	else
	{
		shei.pszStatus = Web::HttpResponse::GetCodeDescrChar(httpCode);
		shei.cchStatus = (DWORD)strlen(shei.pszStatus);
		shei.cchHeader  = _snprintf_s(header, 1024, _TRUNCATE, "Content-Type: %s\r\nContent-Length: %d\r\n\r\n", content_type, content_length);
		shei.pszHeader = header;
	}

	if (pECB->ServerSupportFunction (pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER_EX, 
						&shei, NULL, NULL) == FALSE)
	{
		return HSE_STATUS_ERROR;
	}
	if (content_length == 0) return HSE_STATUS_SUCCESS; //HSE_STATUS_SUCCESS_AND_KEEP_CONN;
	DWORD dwContent_Length = content_length;
	if (pECB->WriteClient(pECB->ConnID, (LPVOID)responseData.c_str(), &dwContent_Length, 0) == FALSE)
	{
		return HSE_STATUS_ERROR;
	}
    return HSE_STATUS_SUCCESS; //HSE_STATUS_SUCCESS_AND_KEEP_CONN;
}

bool HttpConnector::WriteText(const wstring& source)
{
	if (source.length() == 0) return true;
	try
	{
		html += source;
	}
	catch(const std::bad_alloc& )
	{
		return false;
	}
	return true;
}

#ifdef WIN_SOCKETS_SUPPORT
//__________________________________________________ ConnectionHandle
ConnectionHandle::ConnectionHandle()
{
	httpDebug = HTTP_DEBUG_NONE;
	keepConnection = false;
}

ConnectionHandle::~ConnectionHandle()
{
}

bool ConnectionHandle::SendErrorCode(Sys::SocketStatus& out_socketStatus, int code, const wchar_t* details)
{
	Web::HttpResponse httpResponse;
	httpResponse.CreateFromCode(code, details);
	return httpResponse.Send(out_socketStatus, socket);
}

bool ConnectionHandle::ProcessRequest(Sys::SocketStatus& out_socketStatus)
{
	if (httpRequest.resourceFileExtension == L"dll") //_________________________ CGI BIN
	{
		if (ExecuteDll(out_socketStatus) == false) return false;
	}
	else //____________________________________________________________ Regular File
	{
		if (SendFile(out_socketStatus) == false) return false;
	}
	return true;
}

DWORD ConnectionHandle::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	Sys::SocketStatus socketStatus;
	keepConnection = false;

	while(true)
	{
		//_______________________________________________________ Receive HTTP Request
		if (httpRequest.Create(socketStatus, socket) == false) break;
		if (socketStatus.isError == true) break;
		if (socketStatus.isConnected == false) break;
		//_______________________________________________________ Process HTTP Request
		if (ProcessRequest(socketStatus) == false) break;
		if (socketStatus.isError == true) break;
		if (socketStatus.isConnected == false) break;
		//_______________________________________________________
		if (keepConnection == false) break;
		if (httpRequest.DoKeepConnectionAlive() == false) break;
	}
	socket.Disconnect();
	running.Set(false);
	return 0;
}

bool ConnectionHandle::SendFile(Sys::SocketStatus& out_socketStatus)
{
	wstring  filename;
	httpRequest.GetRequestedFileName(wwwroot, filename);
	//httpRequest.GetRequestedFileName(filename);
	//__________________________________ HTTP Response
	Web::HttpResponse httpResponse;
	return httpResponse.SendFile(out_socketStatus, socket, filename);
}

bool ConnectionHandle::LoadDLL(Sys::DLLibrary& dll)
{
	wstring filename;
	//__________________________________________________ Try at wwwroot
	Sys::Format(filename, L"%s\\%s.%s", wwwroot.c_str(), httpRequest.resourceFileName.c_str(), httpRequest.resourceFileExtension.c_str());
	if (dll.Load(filename) == true) return true;
	//__________________________________________________ Find one level down wwwroot
	wstring oneLevelDown = wwwroot;
	size_t pos = wwwroot.find_last_of(L"\\");
	if (pos == std::wstring::npos) return false;
	oneLevelDown.resize(pos);
	//__________________________________________________ Try at ..\\Debug
	Sys::Format(filename, L"%s\\Debug\\%s.%s", oneLevelDown.c_str(), httpRequest.resourceFileName.c_str(), httpRequest.resourceFileExtension.c_str());
	if (dll.Load(filename) == true) return true;
	//__________________________________________________ Try at ..\\Release
	Sys::Format(filename, L"%s\\Release\\%s.%s", oneLevelDown.c_str(), httpRequest.resourceFileName.c_str(), httpRequest.resourceFileExtension.c_str());
	if (dll.Load(filename) == true) return true;
	return false;
}

bool ConnectionHandle::ExecuteDll(Sys::SocketStatus& out_socketStatus)
{
	out_socketStatus.Delete();
	int content_length = httpRequest.GetContentLength();
	if (content_length < 0) content_length = 0;
	//__________________________________________________ Load Library
	wstring filename;
	Sys::DLLibrary dll;
	if (LoadDLL(dll) == false) return SendErrorCode(out_socketStatus, 404, filename.c_str());
	//___________________________________________________
	EXTENSION_CONTROL_BLOCK ecb;
	::memset(&ecb, 0, sizeof(EXTENSION_CONTROL_BLOCK));
	ecb.ConnID = this;
	ecb.cbAvailable = content_length;
	ecb.cbTotalBytes = content_length;
	ecb.lpbData = content_length > 0 ? (LPBYTE)(char*)httpRequest.body : NULL;
	ecb.lpszQueryString = (char*)httpRequest.query_string.c_str();
	ecb.WriteClient = WriteClient_;
	ecb.ReadClient = ReadClient_; // As ecb.cbAvailable is equal to ecb.cbTotalBytes, this function is never called
	ecb.ServerSupportFunction = ServerSupportFunction_;
	ecb.GetServerVariable = GetServerVariable_;
	//
	//________________________________________________ Call GetExtensionVersion (YOU MUST CALL THIS TO INITIALIZE GDIPLUS)
	GET_EXTENSION_VERSION funcGetExtensionVersion = (GET_EXTENSION_VERSION)dll.GetProcAddress("GetExtensionVersion");
	if (funcGetExtensionVersion == NULL) return SendErrorCode(out_socketStatus, 503, L"GetExtensionVersion"); // Service Unavailable
	HSE_VERSION_INFO hseVersionInfo;
	funcGetExtensionVersion(&hseVersionInfo);
	//________________________________________________ Call HttpExtensionProc
	HTTP_EXTENSION_PROC funcHttpExtensionProc = (HTTP_EXTENSION_PROC)dll.GetProcAddress("HttpExtensionProc");
	if (funcHttpExtensionProc == NULL) return SendErrorCode(out_socketStatus, 503, L"HttpExtensionProc"); // Service Unavailable
	const DWORD result = funcHttpExtensionProc(&ecb);
	const bool ok = ((result == HSE_STATUS_SUCCESS) || (result == HSE_STATUS_SUCCESS_AND_KEEP_CONN));
	keepConnection = (result == HSE_STATUS_SUCCESS_AND_KEEP_CONN);
	//________________________________________________ Call TerminateExtension
	TERMINATE_EXTENSION funcTerminateExtension = (TERMINATE_EXTENSION)dll.GetProcAddress("TerminateExtension");
	if (funcTerminateExtension == NULL) return SendErrorCode(out_socketStatus, 503, L"TerminateExtension"); // Service Unavailable
	DWORD dword = 0;
	funcTerminateExtension(dword);
   return ok;
}

BOOL WINAPI ConnectionHandle::ServerSupportFunction_(HCONN hConn, 
								   DWORD dwHSERequest, LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType)
{
	if (dwHSERequest == HSE_REQ_SEND_RESPONSE_HEADER_EX)
	{
		Web::ConnectionHandle* ch = (Web::ConnectionHandle*)hConn;
		if (ch == NULL) return FALSE;
		char buffer[256];
		//_____________________________________________________________ HTTP CODE
		HSE_SEND_HEADER_EX_INFO* shei = (HSE_SEND_HEADER_EX_INFO*) lpvBuffer;
		int len = _snprintf_s(buffer, 256, _TRUNCATE, "HTTP/1.1 %s\r\n", shei->pszStatus);
		if (ch->socket.Send(buffer, len, 0) == INVALID_SOCKET) return false;

		//____________________________________________________________ Server
		wstring wServerName;
		string serverName;
		Sys::Information::getComputerName(wServerName);
		Sys::Convert::WstringToString(wServerName, serverName);
		len = _snprintf_s(buffer, 256, _TRUNCATE, "Server: %s\r\n", serverName.c_str());
		if (ch->socket.Send(buffer, len, 0) == INVALID_SOCKET) return false;

		//_____________________________________________________________Date
		Web::Http::GetDateHeader(buffer, 256);
		if (ch->socket.Send(buffer, strlen(buffer), 0) == INVALID_SOCKET) return false;

		//____________________________________________________________ Remaining Header
		const char* header = shei->pszHeader;
		len = shei->cchHeader;
		if (ch->socket.Send(header, len, 0) == INVALID_SOCKET) return false;
		return TRUE;
	}
	return FALSE;
}

BOOL WINAPI ConnectionHandle::ReadClient_ (HCONN hConn, LPVOID lpvBuffer, LPDWORD lpdwSize)
{
	// Because we set ecb.cbAvailable equal to ecb.cbTotalBytes, this function is never called
	//Web::ConnectionHandle* ch = (Web::ConnectionHandle*)hConn;
	//if (ch == NULL) return FALSE;
	//const int bytes = *lpdwSize;
	//*lpdwSize = ch->httpRequest.body.Read(lpvBuffer, bytes);
	return TRUE;
}

BOOL WINAPI ConnectionHandle::WriteClient_(HCONN hConn, LPVOID lpvBuffer, LPDWORD lpdwBytes, DWORD dwReserved)
{
	Web::ConnectionHandle* ch = (Web::ConnectionHandle*)hConn;
	if (ch == NULL) return FALSE;
	const int len = (int)*lpdwBytes;
	Sys::SocketStatus socketStatus;
	ch->socket.SendLargeBlock(socketStatus, (const char*)lpvBuffer, len, 512);
	*lpdwBytes = socketStatus.bytesTransferred;
	//if (ch->socket.Send((const char*) lpvBuffer, len, 0) == INVALID_SOCKET) return FALSE;
	if (socketStatus.isError == true) return FALSE;
	return TRUE;
}

int ConnectionHandle::CopyFromHead(const wstring& name, char* buffer, int bufferSize)
{
	map<wstring, wstring>::iterator p = httpRequest.head.find(name);
	if (p == httpRequest.head.end())
	{
		if (bufferSize >= 1) buffer[0] = '\0';
		return 0;
	}
	//_____________________________________________ Copy
	const int input_len = (int)p->second.length();
	const int len = (bufferSize-1 < input_len) ? (bufferSize-1) : input_len;
	int i;
	for(i = 0; i < len; i++)
	{
		buffer[i] = (char)p->second[i];
	}
	buffer[i] ='\0';
	return i;
}

int ConnectionHandle::CopyValue(const wstring& input, char* buffer, int bufferSize)
{
	//______________________________________________ Empty input
	if (input.empty() == true)
	{
		if (bufferSize >= 1) buffer[0] = '\0';
		return 0;
	}
	//_____________________________________________ Copy
	const int input_len = (int)input.size();
	const int len = (bufferSize-1 < input_len) ? (bufferSize-1) : input_len;
	int i;
	for(i = 0; i < len; i++)
	{
		buffer[i] = (char)input[i];
	}
	buffer[i] ='\0';
	return i;
}

BOOL WINAPI ConnectionHandle::GetServerVariable_ ( HCONN hConn, LPSTR lpszVariableName, LPVOID lpvBuffer, LPDWORD lpdwSize)
{
	Web::ConnectionHandle* p = (Web::ConnectionHandle*)hConn;
	DWORD dwSize = *lpdwSize;
	char* buffer = (char*)lpvBuffer; 
	if (dwSize > 0) buffer[0] = '\0'; // Be sure to return a clean value
	*lpdwSize = 0;

	if (strcmp(lpszVariableName, "AUTH_PASSWORD")==0 
		|| strcmp(lpszVariableName, "AUTH_USER")==0
		|| strcmp(lpszVariableName, "LOGON_USER") == 0)
	{
		string password;
		string username;
		if (p->httpRequest.GetUsernameAndPassword(username, password) == true)
		{
			if (strcmp(lpszVariableName, "AUTH_USER") == 0 || strcmp(lpszVariableName, "LOGON_USER") == 0)
			{
				*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", username.c_str());
			}
			else
			{
				*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", password.c_str());
			}	
		}
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "QUERY_STRING")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", p->httpRequest.query_string.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "SCRIPT_NAME")==0)
	{
		wchar_t text[256];
		_snwprintf_s(text, 256, _TRUNCATE, L"%s.%s", p->httpRequest.resourceFileName.c_str(), p->httpRequest.resourceFileExtension.c_str());
		string tmp;
		Sys::Convert::WstringToString(text, tmp);
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%s", tmp.c_str());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "SERVER_NAME")==0)
	{
		wstring server_name;
		Sys::Information::getComputerName(server_name);
		if (server_name.empty() == true) server_name = L"localhost";
		*lpdwSize = CopyValue(server_name, (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "REQUEST_METHOD")==0)
	{
		*lpdwSize = CopyValue(p->httpRequest.method, (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "SERVER_PORT")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%d", p->socket.GetPortNumber());
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_ACCEPT")==0)
	{
		*lpdwSize = p->CopyFromHead(L"accept", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_ACCEPT_LANGUAGE")==0)
	{
		*lpdwSize = p->CopyFromHead(L"accept-language", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_CONNECTION")==0)
	{
		*lpdwSize = p->CopyFromHead(L"connection", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_HOST")==0)
	{
		*lpdwSize = p->CopyFromHead(L"host", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_USER_AGENT")==0)
	{
		*lpdwSize = p->CopyFromHead(L"user-agent", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_ACCEPT_ENCODING")==0)
	{
		*lpdwSize = p->CopyFromHead(L"accept-encoding", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "AUTH_TYPE")==0)
	{
		*lpdwSize = p->CopyFromHead(L"authorization", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "CONTENT_LENGTH")==0)
	{
		int content_length = p->httpRequest.GetContentLength();
		if (content_length < 0) content_length = 0;
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "%d", content_length);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "CONTENT_TYPE")==0)
	{
		*lpdwSize = p->CopyFromHead(L"content-type", (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "WIN_INDENT")==0)
	{
		*lpdwSize = _snprintf_s((char*)lpvBuffer, dwSize, _TRUNCATE, "true");
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "HTTP_URL")==0 || strcmp(lpszVariableName, "UNENCODED_URL")==0)
	{
		*lpdwSize = CopyValue(p->httpRequest.resource, (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "URL")==0)
	{
		*lpdwSize = CopyValue(p->httpRequest.resource, (char*)lpvBuffer, dwSize);
		return TRUE;
	}
	else if (strcmp(lpszVariableName, "SOAPAction")==0 || strcmp(lpszVariableName, "HEADER_SOAPAction")==0)
	{
		*lpdwSize = p->CopyFromHead(L"soapaction", (char*)lpvBuffer, dwSize);
		return TRUE;
	}

	/* ALL_HTTP
	ALL_RAW
	APPL_MD_PATH
	APPL_PHYSICAL_PATH
	CERT_COOKIE
	CERT_FLAGS
	CERT_ISSUER
	CERT_KEYSIZE
	CERT_SECRETKEYSIZE
	CERT_SERIALNUMBER
	CERT_SERVER_ISSUER
	CERT_SERVER_SUBJECT
	CERT_SUBJECT
	CONTENT_LENGTH
	CONTENT_TYPE
	GATEWAY_INTERFACE
	HTTPS
	HTTPS_KEYSIZE
	HTTPS_SECRETKEYSIZE
	HTTPS_SERVER_ISSUER
	HTTPS_SERVER_SUBJECT
	INSTANCE_ID
	INSTANCE_META_PATH
	LOCAL_ADDR
	LOGON_USER
	PATH_INFO
	PATH_TRANSLATED
	REMOTE_ADDR
	REMOTE_HOST
	REMOTE_USER
	SERVER_PORT_SECURE
	SERVER_PROTOCOL
	SERVER_SOFTWARE
	URL
	HTTP_COOKIE
	  */
	*lpdwSize = 0;
	return FALSE;
}

//__________________________________________________ Server
Server::Server()
{
	hWndNotify = NULL;
	_portNumber.Set(-1);
	minimumPortNumber = 80;
	maximumPortNumber = 80;
	numThreads = 32;
	//_____________________________________________ Current Directory
	Sys::Information::getCurrentDirectory(wwwroot);
	//________________ Remove last back slash
	const int len = (int)wwwroot.size();
	if (len > 1)
	{
		if (wwwroot[len-1] == '\\')
		{
			wwwroot.resize(len-1);
		}
	}
	////_________________Remove last folder
	//size_t pos = wwwroot.find_last_of(L"\\");
	//if (pos != std::wstring::npos)
	//{
	//	wwwroot.resize(pos);
	//}
	httpDebug = HTTP_DEBUG_NONE;
}

Server::~Server()
{
}

bool Server::Stop(Mt::ThreadObject& threadObject)
{
	threadObject.running.Set(false);
	const int portNumber = GetPortNumber();
	Sys::Socket socket;
	if (socket.Connect(L"localhost", portNumber) == SOCKET_ERROR) return false;
	socket.Send("SEND ANYTHING");
	socket.Disconnect();
	return true;
}

int Server::GetPortNumber()
{
	return _portNumber.Get();
}

wchar_t* Server::Run(Mt::BoolTs& running)
{
	int i;
	//______________________________________________ Create the thread objects
	Mt::ThreadObject * thread = new Mt::ThreadObject[numThreads];
	if (thread == NULL) return L"No enough memory";
	//______________________________________________ Create the connection handles
	Web::ConnectionHandle * connHandle = new Web::ConnectionHandle[numThreads];
	if (connHandle == NULL)
	{
		if (thread != NULL) delete [] thread;
		running.Set(false);
		return L"No enough memory";
	}
	for(i = 0; i < numThreads; i++)
	{
		connHandle[i].wwwroot = wwwroot;
		connHandle[i].httpDebug = httpDebug;
	}
	//____________________________________________________________ Socket Accept
	SOCKET socketAccept = INVALID_SOCKET;

	const int portNumber = _portNumber.Get();
	if (hWndNotify != NULL) ::PostMessage(hWndNotify, WM_USER, (WPARAM)1, MAKELPARAM(WEBSERVER_INDIVIDUAL_WORK_ID, WIN_THREAD_READY));
	while(true)
	{
		socketAccept = socketListen.Accept();
		if (socketAccept == INVALID_SOCKET) continue;
		if (running.Get() == false) break;
		//___________________________ Search for an available thread and connection handle
		for(i = 0; i < numThreads; i++)
		{
			if (thread[i].running.Get() == true) continue;
			connHandle[i].socket.Attach(socketAccept, portNumber);
			thread[i].StartThread(hWndNotify, WM_USER, WEBSERVER_INDIVIDUAL_WORK_ID, connHandle[i]);
			if (hWndNotify != NULL) ::PostMessage(hWndNotify, WM_USER, (WPARAM)1, MAKELPARAM(WEBSERVER_INDIVIDUAL_WORK_ID, WIN_THREAD_STARTED));
			break;
		}
	}

	if (thread != NULL) delete [] thread;
	if (connHandle != NULL) delete [] connHandle;
	running.Set(false);
	return NULL;
}

//____________________________________________________________ IThread
DWORD Server::ThreadFunc(Mt::BoolTs& running, Mt::DoubleTs& progress, Mt::BoolTs& resetTime)
{
	wchar_t * error =  NULL;
	int portNumber;
	for(portNumber = minimumPortNumber; portNumber <= maximumPortNumber; portNumber++)
	{
		error = socketListen.StartServer(portNumber, numThreads);
		if (error == NULL) break;
		//::MessageBox(NULL, error, L"Webserver 1", MB_OK | MB_ICONERROR);
	}
	_portNumber.Set(portNumber);
	error = Run(running);
	if (error != NULL)
	{
		::MessageBox(NULL, error, L"Webserver 2", MB_OK | MB_ICONERROR);
	}
	return 0;
}

#endif

//________________________________________________________ JavascriptEvent
JavascriptEvent::JavascriptEvent()
{
	_data = (__int32)0;
}

JavascriptEvent::~JavascriptEvent()
{
}

void JavascriptEvent::Set_onkeydown(bool fireEvent){ Set(fireEvent, 0x00000001); }
bool JavascriptEvent::Get_onkeydown(){ return ((_data & 0x00000001) != 0); }

void JavascriptEvent::Set_onkeypress(bool fireEvent){ Set(fireEvent, 0x00000002); }
bool JavascriptEvent::Get_onkeypress(){ return ((_data & 0x00000002) != 0); }

void JavascriptEvent::Set_onkeyup(bool fireEvent){ Set(fireEvent, 0x00000004); }
bool JavascriptEvent::Get_onkeyup(){ return ((_data & 0x00000004) != 0); }

void JavascriptEvent::Set_onclick(bool fireEvent){ Set(fireEvent, 0x00000008); }
bool JavascriptEvent::Get_onclick(){ return ((_data & 0x00000008) != 0); }

void JavascriptEvent::Set_ondblclick(bool fireEvent){ Set(fireEvent, 0x00000010); }
bool JavascriptEvent::Get_ondblclick(){ return ((_data & 0x00000010) != 0); }

void JavascriptEvent::Set_ondrag(bool fireEvent){ Set(fireEvent, 0x00000020); }
bool JavascriptEvent::Get_ondrag(){ return ((_data & 0x00000020) != 0); }

void JavascriptEvent::Set_ondragend(bool fireEvent){ Set(fireEvent, 0x00000040); }
bool JavascriptEvent::Get_ondragend(){ return ((_data & 0x00000040) != 0); }

void JavascriptEvent::Set_ondragenter(bool fireEvent){ Set(fireEvent, 0x00000080); }
bool JavascriptEvent::Get_ondragenter(){ return ((_data & 0x00000080) != 0); }

void JavascriptEvent::Set_ondragleave(bool fireEvent){ Set(fireEvent, 0x00000100); }
bool JavascriptEvent::Get_ondragleave(){ return ((_data & 0x00000100) != 0); }

void JavascriptEvent::Set_ondragover(bool fireEvent){ Set(fireEvent, 0x00000200); }
bool JavascriptEvent::Get_ondragover(){ return ((_data & 0x00000200) != 0); }

void JavascriptEvent::Set_ondragstart(bool fireEvent){ Set(fireEvent, 0x00000400); }
bool JavascriptEvent::Get_ondragstart(){ return ((_data & 0x00000400) != 0); }

void JavascriptEvent::Set_ondrop(bool fireEvent){ Set(fireEvent, 0x00000800); }
bool JavascriptEvent::Get_ondrop(){ return ((_data & 0x00000800) != 0); }

void JavascriptEvent::Set_onerror(bool fireEvent){ Set(fireEvent, 0x00001000); }
bool JavascriptEvent::Get_onerror(){ return ((_data & 0x00001000) != 0); }

void JavascriptEvent::Set_onload(bool fireEvent){ Set(fireEvent, 0x00002000); }
bool JavascriptEvent::Get_onload(){ return ((_data & 0x00002000) != 0); }

void JavascriptEvent::Set_onmousedown(bool fireEvent){ Set(fireEvent, 0x00004000); }
bool JavascriptEvent::Get_onmousedown(){ return ((_data & 0x00004000) != 0); }

void JavascriptEvent::Set_onmousemove(bool fireEvent){ Set(fireEvent, 0x00008000); }
bool JavascriptEvent::Get_onmousemove(){ return ((_data & 0x00008000) != 0); }

void JavascriptEvent::Set_onmouseout(bool fireEvent){ Set(fireEvent, 0x00010000); }
bool JavascriptEvent::Get_onmouseout(){ return ((_data & 0x00010000) != 0); }

void JavascriptEvent::Set_onmouseover(bool fireEvent){ Set(fireEvent, 0x00020000); }
bool JavascriptEvent::Get_onmouseover(){ return ((_data & 0x00020000) != 0); }

void JavascriptEvent::Set_onmouseup(bool fireEvent){ Set(fireEvent, 0x00040000); }
bool JavascriptEvent::Get_onmouseup(){ return ((_data & 0x00040000) != 0); }

void JavascriptEvent::Set_onmousewheel(bool fireEvent){ Set(fireEvent, 0x00080000); }
bool JavascriptEvent::Get_onmousewheel(){ return ((_data & 0x00080000) != 0); }

void JavascriptEvent::Set_onscroll(bool fireEvent){ Set(fireEvent, 0x00100000); }
bool JavascriptEvent::Get_onscroll(){ return ((_data & 0x00100000) != 0); }

void JavascriptEvent::Set_onblur(bool fireEvent){ Set(fireEvent, 0x00200000); }
bool JavascriptEvent::Get_onblur(){ return ((_data & 0x00200000) != 0); }

void JavascriptEvent::Set_onchange(bool fireEvent){ Set(fireEvent, 0x00400000); }
bool JavascriptEvent::Get_onchange(){ return ((_data & 0x00400000) != 0); }

void JavascriptEvent::Set_oncontextmenu(bool fireEvent){ Set(fireEvent, 0x00800000); }
bool JavascriptEvent::Get_oncontextmenu(){ return ((_data & 0x00800000) != 0); }

void JavascriptEvent::Set_onfocus(bool fireEvent){ Set(fireEvent, 0x01000000); }
bool JavascriptEvent::Get_onfocus() { return ((_data & 0x01000000) != 0); }

void JavascriptEvent::Set_oninput(bool fireEvent){ Set(fireEvent, 0x02000000); }
bool JavascriptEvent::Get_oninput(){ return ((_data & 0x02000000) != 0); }

void JavascriptEvent::Set_oninvalid(bool fireEvent){ Set(fireEvent, 0x04000000); }
bool JavascriptEvent::Get_oninvalid(){ return ((_data & 0x04000000) != 0); }

void JavascriptEvent::Set_onselect(bool fireEvent){ Set(fireEvent, 0x08000000); }
bool JavascriptEvent::Get_onselect(){ return ((_data & 0x08000000) != 0); }

const wchar_t* JavascriptEvent::GetHelp(int index)
{
	switch (index)
	{
	case LEX_HTML_ONKEYDOWN: return L"presses a key on the keyboard";
	case LEX_HTML_ONKEYPRESS: return L"presses and releases a key on the keyboard";
	case LEX_HTML_ONKEYUP: return L"releases a key on the keyboard";
	case LEX_HTML_ONCLICK: return L"clicks the element";
	case LEX_HTML_ONDBLCLICK: return L"double-clicks the element";
	case LEX_HTML_ONDRAG: return L"drags an element";
	case LEX_HTML_ONDRAGEND: return L"ends a drag operation";
	case LEX_HTML_ONDRAGENTER:  return L"has dragged an element to a valid drop target";
	case LEX_HTML_ONDRAGLEAVE: return L"moves a element away from a valid drop target"; 
	case LEX_HTML_ONDRAGOVER: return L"drags an eelement over a valid drop target";
	case LEX_HTML_ONDRAGSTART: return L"starts a drag operation";
	case LEX_HTML_ONDROP: return L"drops a dragged element";
	case LEX_HTML_ONERROR: return L"opens a page and there is an error (i.e., an external file is not found)";
	case LEX_HTML_ONLOAD: return L"opens a page and  the web page has completely loaded all content";
	case LEX_HTML_ONMOUSEDOWN: return L"presses the mouse button";
	case LEX_HTML_ONMOUSEMOVE: return L"moves the mouse whithin the element";
	case LEX_HTML_ONMOUSEOUT: return L"moves the mouse away from the element";
	case LEX_HTML_ONMOUSEOVER: return L"moves the mouse so that it enters an element";
	case LEX_HTML_ONMOUSEUP: return L"releases the mouse button";
	case LEX_HTML_ONMOUSEWHEEL: return L"rotates the mouse wheel";
	case LEX_HTML_ONSCROLL: return L"scrolls an element's scrollbar";
	case LEX_HTML_ONBLUR: return L"moves the focus away from the element";
	case LEX_HTML_ONCHANGE: return L"changes an element's value and then leaves the element";
	case LEX_HTML_ONCONTEXTMENU: return L"opens the context menu";
	case LEX_HTML_ONFOCUS: return L"sends the keyboard focus to the element";
	case LEX_HTML_ONINPUT: return L"provides input to an element";
	case LEX_HTML_ONINVALID: return L"makes an element invalid";
	case LEX_HTML_ONSELECT: return L"selects text";
	}
	return NULL;
}

const wchar_t* JavascriptEvent::GetID(int index)
{
	switch (index)
	{
	case LEX_HTML_ONKEYDOWN: return L"LEX_HTML_ONKEYDOWN";
	case LEX_HTML_ONKEYPRESS: return L"LEX_HTML_ONKEYPRESS";
	case LEX_HTML_ONKEYUP: return L"LEX_HTML_ONKEYUP";
	case LEX_HTML_ONCLICK: return L"LEX_HTML_ONCLICK";
	case LEX_HTML_ONDBLCLICK: return L"LEX_HTML_ONDBLCLICK";
	case LEX_HTML_ONDRAG: return L"LEX_HTML_ONDRAG";
	case LEX_HTML_ONDRAGEND: return L"LEX_HTML_ONDRAGEND";
	case LEX_HTML_ONDRAGENTER:  return L"LEX_HTML_ONDRAGENTER";
	case LEX_HTML_ONDRAGLEAVE: return L"LEX_HTML_ONDRAGLEAVE";
	case LEX_HTML_ONDRAGOVER: return L"LEX_HTML_ONDRAGOVER";
	case LEX_HTML_ONDRAGSTART: return L"LEX_HTML_ONDRAGSTART";
	case LEX_HTML_ONDROP: return L"LEX_HTML_ONDROP";
	case LEX_HTML_ONERROR: return L"LEX_HTML_ONERROR";
	case LEX_HTML_ONLOAD: return L"LEX_HTML_ONLOAD";
	case LEX_HTML_ONMOUSEDOWN: return L"LEX_HTML_ONMOUSEDOWN";
	case LEX_HTML_ONMOUSEMOVE: return L"LEX_HTML_ONMOUSEMOVE";
	case LEX_HTML_ONMOUSEOUT: return L"LEX_HTML_ONMOUSEOUT";
	case LEX_HTML_ONMOUSEOVER: return L"LEX_HTML_ONMOUSEOVER";
	case LEX_HTML_ONMOUSEUP: return L"LEX_HTML_ONMOUSEUP";
	case LEX_HTML_ONMOUSEWHEEL: return L"LEX_HTML_ONMOUSEWHEEL";
	case LEX_HTML_ONSCROLL: return L"LEX_HTML_ONSCROLL";
	case LEX_HTML_ONBLUR: return L"LEX_HTML_ONBLUR";
	case LEX_HTML_ONCHANGE: return L"LEX_HTML_ONCHANGE";
	case LEX_HTML_ONCONTEXTMENU: return L"LEX_HTML_ONCONTEXTMENU";
	case LEX_HTML_ONFOCUS: return L"LEX_HTML_ONFOCUS";
	case LEX_HTML_ONINPUT: return L"LEX_HTML_ONINPUT";
	case LEX_HTML_ONINVALID: return L"LEX_HTML_ONINVALID";
	case LEX_HTML_ONSELECT: return L"LEX_HTML_ONSELECT";
	}
	return NULL;
}

void JavascriptEvent::Render(const wchar_t* ctrlID, Sys::ITextWriterW& out_html, const wchar_t* url)
{
	if (url == NULL) return;
	const bool isUrlEmpty = (wcslen(url) == 0);
	int ievent = 0;
	const wchar_t* name;
	wchar_t text[256];
	__int32 index = 0x00000001;
	for (ievent = LEX_HTML_EVENT_FIRST; ievent <= LEX_HTML_EVENT_LAST; ievent++, index*=2)
	{
		if ((_data & index) == 0) continue;
		//
		name = Cpl::LexicalAnalyzer::GetTokenText(ievent);
		if (name == NULL) break;
		//
		if (isUrlEmpty == true)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L" %s=\"%s_%s(\'url\', \'%s\', \'%s\');\"", name, ctrlID, name, ctrlID, name);
			out_html.WriteText(text);
		}
		else
		{
			_snwprintf_s(text, 256, _TRUNCATE, L" %s=\"%s_%s(\'%s\', \'%s\', \'%s\');\"", name, ctrlID, name, url, ctrlID, name);
			out_html.WriteText(text);
		}		
	}

	//wchar_t *eventName = Web::Helper::GetEventName(eventID);
	//wchar_t *eventShortName = Web::Helper::GetEventShortName(eventID);
	////wchar_t *eventIdText = Web::Helper::GetEventID(eventID);
	//if (eventName == NULL) return;
	//if (eventShortName == NULL) return;
	//out_html.WriteText(L" ");
	//out_html.WriteText(eventName);
	////
	//wchar_t text[128];
	//_snwprintf_s(text, 128, _TRUNCATE, L"=\"%s_%s(\'%s\', \'%s\', \'%s\');\"", 
	//	ID.c_str(), eventShortName, url, ID.c_str(), eventShortName);
	//out_html.WriteText(text);
}

//________________________________________________________  JavascriptMediaEvent
JavascriptMediaEvent::JavascriptMediaEvent()
{
	_data = (__int32)0;
}

JavascriptMediaEvent::~JavascriptMediaEvent()
{
}

void JavascriptMediaEvent::Set_onabort(bool fireEvent) { Set(fireEvent, 0x00000001); }
bool JavascriptMediaEvent::Get_onabort(){ return ((_data & 0x00000001) != 0); }

void JavascriptMediaEvent::Set_oncanplay(bool fireEvent) { Set(fireEvent, 0x00000002); }
bool JavascriptMediaEvent::Get_oncanplay() { return ((_data & 0x00000002) != 0); }

void JavascriptMediaEvent::Set_oncanplaythrough(bool fireEvent) { Set(fireEvent, 0x00000004); }
bool JavascriptMediaEvent::Get_oncanplaythrough() { return ((_data & 0x00000004) != 0); }

void JavascriptMediaEvent::Set_ondurationchange(bool fireEvent) { Set(fireEvent, 0x00000008); }
bool JavascriptMediaEvent::Get_ondurationchange() { return ((_data & 0x00000008) != 0); }

void JavascriptMediaEvent::Set_onemptied(bool fireEvent) { Set(fireEvent, 0x00000010); }
bool JavascriptMediaEvent::Get_onemptied() { return ((_data & 0x00000010) != 0); }

void JavascriptMediaEvent::Set_onended(bool fireEvent) { Set(fireEvent, 0x00000020); }
bool JavascriptMediaEvent::Get_onended() { return ((_data & 0x00000020) != 0); }

void JavascriptMediaEvent::Set_onerror(bool fireEvent) { Set(fireEvent, 0x00000040); }
bool JavascriptMediaEvent::Get_onerror() { return ((_data & 0x00000040) != 0); }

void JavascriptMediaEvent::Set_onloadeddata(bool fireEvent) { Set(fireEvent, 0x00000080); }
bool JavascriptMediaEvent::Get_onloadeddata() { return ((_data & 0x00000080) != 0); }

void JavascriptMediaEvent::Set_onloadedmetadata(bool fireEvent) { Set(fireEvent, 0x00000100); }
bool JavascriptMediaEvent::Get_onloadedmetadata() { return ((_data & 0x00000100) != 0); }

void JavascriptMediaEvent::Set_onloadstart(bool fireEvent) { Set(fireEvent, 0x00000200); }
bool JavascriptMediaEvent::Get_onloadstart() { return ((_data & 0x00000200) != 0); }

void JavascriptMediaEvent::Set_onpause(bool fireEvent) { Set(fireEvent, 0x00000400); }
bool JavascriptMediaEvent::Get_onpause() { return ((_data & 0x00000400) != 0); }

void JavascriptMediaEvent::Set_onplay(bool fireEvent) { Set(fireEvent, 0x00000800); }
bool JavascriptMediaEvent::Get_onplay() { return ((_data & 0x00000800) != 0); }

void JavascriptMediaEvent::Set_onplaying(bool fireEvent) { Set(fireEvent, 0x00001000); }
bool JavascriptMediaEvent::Get_onplaying() { return ((_data & 0x00001000) != 0); }

void JavascriptMediaEvent::Set_onprogress(bool fireEvent) { Set(fireEvent, 0x00002000); }
bool JavascriptMediaEvent::Get_onprogress() { return ((_data & 0x00002000) != 0); }

void JavascriptMediaEvent::Set_onratechange(bool fireEvent) { Set(fireEvent, 0x00004000); }
bool JavascriptMediaEvent::Get_onratechange() { return ((_data & 0x00004000) != 0); }

void JavascriptMediaEvent::Set_onreadystatechange(bool fireEvent) { Set(fireEvent, 0x00008000); }
bool JavascriptMediaEvent::Get_onreadystatechange() { return ((_data & 0x00008000) != 0); }

void JavascriptMediaEvent::Set_onseeked(bool fireEvent) { Set(fireEvent, 0x00010000); }
bool JavascriptMediaEvent::Get_onseeked() { return ((_data & 0x00010000) != 0); }

void JavascriptMediaEvent::Set_onseeking(bool fireEvent) { Set(fireEvent, 0x00020000); }
bool JavascriptMediaEvent::Get_onseeking() { return ((_data & 0x00020000) != 0); }

void JavascriptMediaEvent::Set_onstalled(bool fireEvent) { Set(fireEvent, 0x00040000); }
bool JavascriptMediaEvent::Get_onstalled() { return ((_data & 0x00040000) != 0); }

void JavascriptMediaEvent::Set_onsuspend(bool fireEvent) { Set(fireEvent, 0x00080000); }
bool JavascriptMediaEvent::Get_onsuspend() { return ((_data & 0x00080000) != 0); }

void JavascriptMediaEvent::Set_ontimeupdate(bool fireEvent) { Set(fireEvent, 0x00100000); }
bool JavascriptMediaEvent::Get_ontimeupdate() { return ((_data & 0x00100000) != 0); }

void JavascriptMediaEvent::Set_onvolumechange(bool fireEvent) { Set(fireEvent, 0x00200000); }
bool JavascriptMediaEvent::Get_onvolumechange() { return ((_data & 0x00200000) != 0); }

void JavascriptMediaEvent::Set_onwaiting(bool fireEvent) { Set(fireEvent, 0x00400000); }
bool JavascriptMediaEvent::Get_onwaiting() { return ((_data & 0x00400000) != 0); }

const wchar_t* JavascriptMediaEvent::GetHelp(int index)
{
	switch (index)
	{
	case LEX_HTML_ONABORT: return L"On abort";
	case LEX_HTML_ONCANPLAY: return L"When a file is ready to start playing (when it has buffered enough to begin)";
	case LEX_HTML_ONCANPLAYTHROUGH: return L"When a file can be played all the way to the end without pausing for buffering";
	case LEX_HTML_ONDURATIONCHANGE: return L"When the length of the media changes";
	case LEX_HTML_ONEMPTIED: return L"When something bad happens and the file is suddenly unavailable (like unexpectedly disconnects)";
	case LEX_HTML_ONENDED: return L"When the media has reach the end";
	case LEX_HTML_ONERROR_MEDIA: return L"When an error occurs when the file is being loaded";
	case LEX_HTML_ONLOADEDDATA: return L"When media data is loaded";
	case LEX_HTML_ONLOADEDMETADATA: return L"When meta data(like dimensions and duration) are loaded";
	case LEX_HTML_ONLOADSTART: return L"Just as the file begins to load before anything is actually loaded";
	case LEX_HTML_ONPAUSE: return L"When the media is paused either by the user or programmatically";
	case LEX_HTML_ONPLAY: return L"When the media is ready to start playing";
	case LEX_HTML_ONPLAYING: return L"When the media actually has started playing";
	case LEX_HTML_ONPROGRESS: return L"When the browser is in the process of getting the media data";
	case LEX_HTML_ONRATECHANGE: return L"Each time the playback rate changes (like when a user switches to a slow motion or fast forward mode)";
	case LEX_HTML_ONREADYSTATECHANGE: return L"Each time the ready state changes(the ready state tracks the state of the media data)";
	case LEX_HTML_ONSEEKED: return L"When the seeking attribute is set to false indicating that seeking has ended";
	case LEX_HTML_ONSEEKING: return L"When the seeking attribute is set to true indicating that seeking is active";
	case LEX_HTML_ONSTALLED: return L"When the browser is unable to fetch the media data for whatever reason";
	case LEX_HTML_ONSUSPEND: return L"When fetching the media data is stopped before it is completely loaded for whatever reason";
	case LEX_HTML_ONTIMEUPDATE: return L"When the playing position has changed(like when the user fast forwards to a different point in the media)";
	case LEX_HTML_ONVOLUMECHANGE: return L"Each time the volume is changed which(includes setting the volume to \"mute\")";
	case LEX_HTML_ONWAITING: return L"When the media has paused but is expected to resume(like when the media pauses to buffer more data)";
	}
	return NULL;
}

const wchar_t* JavascriptMediaEvent::GetID(int index)
{
	switch (index)
	{
	case LEX_HTML_ONABORT: return L"LEX_HTML_ONABORT";
	case LEX_HTML_ONCANPLAY: return L"LEX_HTML_ONCANPLAY";
	case LEX_HTML_ONCANPLAYTHROUGH: return L"LEX_HTML_ONCANPLAYTHROUGH";
	case LEX_HTML_ONDURATIONCHANGE: return L"LEX_HTML_ONDURATIONCHANGE";
	case LEX_HTML_ONEMPTIED: return L"LEX_HTML_ONEMPTIED";
	case LEX_HTML_ONENDED: return L"LEX_HTML_ONENDED";
	case LEX_HTML_ONERROR: return L"LEX_HTML_ONERROR";
	case LEX_HTML_ONLOADEDDATA: return L"LEX_HTML_ONLOADEDDATA";
	case LEX_HTML_ONLOADEDMETADATA: return L"LEX_HTML_ONLOADEDMETADATA";
	case LEX_HTML_ONLOADSTART: return L"LEX_HTML_ONLOADSTART";
	case LEX_HTML_ONPAUSE: return L"LEX_HTML_ONPAUSE";
	case LEX_HTML_ONPLAY: return L"LEX_HTML_ONPLAY";
	case LEX_HTML_ONPLAYING: return L"LEX_HTML_ONPLAYING";
	case LEX_HTML_ONPROGRESS: return L"LEX_HTML_ONPROGRESS";
	case LEX_HTML_ONRATECHANGE: return L"LEX_HTML_ONRATECHANGE";
	case LEX_HTML_ONREADYSTATECHANGE: return L"LEX_HTML_ONREADYSTATECHANGE";
	case LEX_HTML_ONSEEKED: return L"LEX_HTML_ONSEEKED";
	case LEX_HTML_ONSEEKING: return L"LEX_HTML_ONSEEKING";
	case LEX_HTML_ONSTALLED: return L"LEX_HTML_ONSTALLED";
	case LEX_HTML_ONSUSPEND: return L"LEX_HTML_ONSUSPEND";
	case LEX_HTML_ONTIMEUPDATE: return L"LEX_HTML_ONTIMEUPDATE";
	case LEX_HTML_ONVOLUMECHANGE: return L"LEX_HTML_ONVOLUMECHANGE";
	case LEX_HTML_ONWAITING: return L"LEX_HTML_ONWAITING";
	}
	return NULL;
}

void JavascriptMediaEvent::Render(const wchar_t* ctrlID, Sys::ITextWriterW& out_html, const wchar_t* url)
{
	int index = 0;
	const wchar_t* name;
	wchar_t text[256];
	for (index = 0; index < LEX_HTML_MEDIA_EVENT_COUNT; index++)
	{
		name = GetHelp(index);
		if (name == NULL) break;
		//
		_snwprintf_s(text, 256, _TRUNCATE, L" %s=\"%s_%s(\'%s\', \'%s\', \'%s\');\"", name, ctrlID, name, url, ctrlID, name);
		out_html.WriteText(text);
	}
}

//________________________________________________________  JavascriptPageEvent
//JavascriptPageEvent::JavascriptPageEvent()
//{
//	_data = (__int32)0;
//}
//
//JavascriptPageEvent::~JavascriptPageEvent()
//{
//}
//
//void JavascriptPageEvent::Set_onafterprint(bool fireEvent) { Set(fireEvent, 0x00000001); }
//bool JavascriptPageEvent::Get_onafterprint() { return ((_data & 0x00000001) != 0); }
//
//void JavascriptPageEvent::Set_onbeforeprint(bool fireEvent) { Set(fireEvent, 0x00000002); }
//bool JavascriptPageEvent::Get_onbeforeprint() { return ((_data & 0x00000002) != 0); }
//
//void JavascriptPageEvent::Set_onbeforeunload(bool fireEvent) { Set(fireEvent, 0x00000004); }
//bool JavascriptPageEvent::Get_onbeforeunload() { return ((_data & 0x00000004) != 0); }
//
//void JavascriptPageEvent::Set_onerror(bool fireEvent) { Set(fireEvent, 0x00000008); }
//bool JavascriptPageEvent::Get_onerror() { return ((_data & 0x00000008) != 0); }
//
//void JavascriptPageEvent::Set_onhaschange(bool fireEvent) { Set(fireEvent, 0x00000010); }
//bool JavascriptPageEvent::Get_onhaschange() { return ((_data & 0x00000010) != 0); }
//
//void JavascriptPageEvent::Set_onload(bool fireEvent) { Set(fireEvent, 0x00000020); }
//bool JavascriptPageEvent::Get_onload() { return ((_data & 0x00000020) != 0); }
//
//void JavascriptPageEvent::Set_onmessage(bool fireEvent) { Set(fireEvent, 0x00000040); }
//bool JavascriptPageEvent::Get_onmessage() { return ((_data & 0x00000040) != 0); }
//
//void JavascriptPageEvent::Set_onoffline(bool fireEvent) { Set(fireEvent, 0x00000080); }
//bool JavascriptPageEvent::Get_onoffline() { return ((_data & 0x00000080) != 0); }
//
//void JavascriptPageEvent::Set_ononline(bool fireEvent) { Set(fireEvent, 0x00000100); }
//bool JavascriptPageEvent::Get_ononline() { return ((_data & 0x00000100) != 0); }
//
//void JavascriptPageEvent::Set_onpagehide(bool fireEvent) { Set(fireEvent, 0x00000200); }
//bool JavascriptPageEvent::Get_onpagehide() { return ((_data & 0x00000200) != 0); }
//
//void JavascriptPageEvent::Set_onpageshow(bool fireEvent) { Set(fireEvent, 0x00000400); }
//bool JavascriptPageEvent::Get_onpageshow() { return ((_data & 0x00000400) != 0); }
//
//void JavascriptPageEvent::Set_onpopstate(bool fireEvent) { Set(fireEvent, 0x00000800); }
//bool JavascriptPageEvent::Get_onpopstate() { return ((_data & 0x00000800) != 0); }
//
//void JavascriptPageEvent::Set_onredo(bool fireEvent) { Set(fireEvent, 0x00001000); }
//bool JavascriptPageEvent::Get_onredo() { return ((_data & 0x00001000) != 0); }
//
//void JavascriptPageEvent::Set_onresize(bool fireEvent) { Set(fireEvent, 0x00002000); }
//bool JavascriptPageEvent::Get_onresize() { return ((_data & 0x00002000) != 0); }
//
//void JavascriptPageEvent::Set_onstorage(bool fireEvent) { Set(fireEvent, 0x00004000); }
//bool JavascriptPageEvent::Get_onstorage() { return ((_data & 0x00004000) != 0); }
//
//void JavascriptPageEvent::Set_onundo(bool fireEvent) { Set(fireEvent, 0x00008000); }
//bool JavascriptPageEvent::Get_onundo() { return ((_data & 0x00008000) != 0); }
//
//void JavascriptPageEvent::Set_onunload(bool fireEvent) { Set(fireEvent, 0x00010000); }
//bool JavascriptPageEvent::Get_onunload() { return ((_data & 0x00010000) != 0); }
//
//void JavascriptPageEvent::Set_onformchange(bool fireEvent) { Set(fireEvent, 0x00020000); }
//bool JavascriptPageEvent::Get_onformchange() { return ((_data & 0x00020000) != 0); }
//
//void JavascriptPageEvent::Set_onforminput(bool fireEvent) { Set(fireEvent, 0x00040000); }
//bool JavascriptPageEvent::Get_onforminput() { return ((_data & 0x00040000) != 0); }
//
//void JavascriptPageEvent::Set_onsubmit(bool fireEvent) { Set(fireEvent, 0x00080000); }
//bool JavascriptPageEvent::Get_onsubmit() { return ((_data & 0x00080000) != 0); }
//
//void JavascriptPageEvent::Set_onreset(bool fireEvent) { Set(fireEvent, 0x00100000); }
//bool JavascriptPageEvent::Get_onreset() { return ((_data & 0x00100000) != 0); }
//
//const wchar_t* JavascriptPageEvent::GetHelp(int index)
//{
//	switch (index)
//	{
//	case LEX_HTML_ONAFTERPRINT: return L"after the document is printed";
//	case LEX_HTML_BEFOREPRINT: return L"before the document is printed";
//	case LEX_HTML_BEFOREUNLOAD: return L"before the document is unloaded";
//	case LEX_HTML_ERROR: return L"when an error occur";
//	case LEX_HTML_HASCHANGE: return L"when the document has changed";
//	case LEX_HTML_LOAD: return L"after the page is finished loading";
//	case LEX_HTML_MESSAGE: return L"when the message is triggered";
//	case LEX_HTML_OFFLINE: return L"when the document goes offline";
//	case LEX_HTML_ONLINE: return L"when the document comes online";
//	case LEX_HTML_PAGEHIDE: return L"when the window is hidden";
//	case LEX_HTML_PAGESHOW: return L"when the window becomes visible";
//	case LEX_HTML_POPSTATE: return L"when the window's history changes";
//	case LEX_HTML_REDO: return L"when the document performs a redo";
//	case LEX_HTML_RESIZE: return L"when the browser window is resized";
//	case LEX_HTML_STORAGE: return L"when a Web Storage area is updated";
//	case LEX_HTML_UNDO: return L"when the document performs an undo";
//	case LEX_HTML_UNLOAD: return L"once a page has unloaded (or the browser window has been closed)";
//	case LEX_HTML_FORMCHANGE: return L"when a form changes";
//	case LEX_HTML_FORMINPUT: return L"when a form gets user input";
//	case LEX_HTML_SUBMIT:  return L"when a form is submitted";
//	case LEX_HTML_RESET: return L"when a form is reset";
//	}
//	return NULL;
//}
//
//const wchar_t* JavascriptPageEvent::GetID(int index)
//{
//	switch (index)
//	{
//	case LEX_HTML_ONAFTERPRINT: return L"LEX_HTML_ONAFTERPRINT";
//	case LEX_HTML_BEFOREPRINT: return L"LEX_HTML_BEFOREPRINT";
//	case LEX_HTML_BEFOREUNLOAD: return L"LEX_HTML_BEFOREUNLOAD";
//	case LEX_HTML_ERROR: return L"LEX_HTML_ERROR";
//	case LEX_HTML_HASCHANGE: return L"LEX_HTML_HASCHANGE";
//	case LEX_HTML_LOAD: return L"LEX_HTML_LOAD";
//	case LEX_HTML_MESSAGE: return L"LEX_HTML_MESSAGE";
//	case LEX_HTML_OFFLINE: return L"LEX_HTML_OFFLINE";
//	case LEX_HTML_ONLINE: return L"LEX_HTML_ONLINE";
//	case LEX_HTML_PAGEHIDE: return L"LEX_HTML_PAGEHIDE";
//	case LEX_HTML_PAGESHOW: return L"LEX_HTML_PAGESHOW";
//	case LEX_HTML_POPSTATE: return L"LEX_HTML_POPSTATE";
//	case LEX_HTML_REDO: return L"LEX_HTML_REDO";
//	case LEX_HTML_RESIZE: return L"LEX_HTML_RESIZE";
//	case LEX_HTML_STORAGE: return L"LEX_HTML_STORAGE";
//	case LEX_HTML_UNDO: return L"LEX_HTML_UNDO";
//	case LEX_HTML_UNLOAD: return L"LEX_HTML_UNLOAD";
//	case LEX_HTML_FORMCHANGE: return L"LEX_HTML_FORMCHANGE";
//	case LEX_HTML_FORMINPUT: return L"LEX_HTML_FORMINPUT";
//	case LEX_HTML_SUBMIT:  return L"LEX_HTML_SUBMIT";
//	case LEX_HTML_RESET: return L"LEX_HTML_RESET";
//	}
//	return NULL;
//}
//
//void JavascriptPageEvent::Render(Sys::ITextWriterW& out_html, const wchar_t* url)
//{
//	int index = 0;
//	const wchar_t* name;
//	wchar_t text[256];
//	unsigned __int32 id = 1;
//	for (index = 0; index < LEX_HTML_PAGE_EVENT_COUNT; index++, id = id << 1)
//	{
//		if ((_data & id) == 0) continue;
//		name = Cpl::LexicalAnalyzer::GetTokenText(index + LEX_HTML_PAGE_EVENT_FIRST);
//		if (name == NULL) break;
//		//
//		_snwprintf_s(text, 256, _TRUNCATE, L" %s=\"Page_%s(\'%s\', \'%s\');\"", name, name, url, name);
//		out_html.WriteText(text);
//	}
//}

//________________________________________________________ Css
Css::Css(void)
{
	background_color = CSS_COLOR_AUTO; 
	border_color = CSS_COLOR_AUTO; 
	color = CSS_COLOR_AUTO; 
	//additionalStyles;
	font_size = HTML_SIZE_AUTO; 
	width = HTML_SIZE_AUTO; 
	height = HTML_SIZE_AUTO; 
	border_width = HTML_SIZE_AUTO; 
	padding_left = HTML_SIZE_AUTO; 
	padding_right = HTML_SIZE_AUTO; 
	padding_top = HTML_SIZE_AUTO; 
	padding_bottom = HTML_SIZE_AUTO;
	//
	margin_left = HTML_SIZE_AUTO;
	margin_top = HTML_SIZE_AUTO;
	margin_right = HTML_SIZE_AUTO;
	margin_bottom = HTML_SIZE_AUTO;
	//
	memoryBlock1 = 0;
	memoryBlock2 = 0;
	memoryBlock3 = 0;
}

Css::~Css(void)
{
}

void Css::WriteXmlColor(Web::HttpConnector& httpConnector, COLORREF original_color, COLORREF new_color, const wchar_t* name)
{
	if (original_color == new_color) return;
	if (new_color == CSS_COLOR_AUTO) return;
	//______________________________________ <name>
	httpConnector.WriteText(L"<");
	httpConnector.WriteText(name);
	httpConnector.WriteText(L">");
	//______________________________________ color
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"rgb(%d, %d, %d)", GetRValue(new_color), GetGValue(new_color), GetBValue(new_color));
	httpConnector.WriteText(text);
	//______________________________________ </name>
	httpConnector.WriteText(L"</");
	httpConnector.WriteText(name);
	httpConnector.WriteText(L">");
}

void Css::WriteXmlInteger(Web::HttpConnector& httpConnector, int original_value, int new_value, const wchar_t* name)
{
	if (original_value == new_value) return;
	if (new_value == HTML_SIZE_AUTO) return;
	//______________________________________ <name>
	httpConnector.WriteText(L"<");
	httpConnector.WriteText(name);
	httpConnector.WriteText(L">");
	//______________________________________ value
	wchar_t text[16];
	if (new_value > 0)
	{
		_snwprintf_s(text, 16, _TRUNCATE, L"%dpx", new_value);
	}
	else
	{
		_snwprintf_s(text, 16, _TRUNCATE, L"%d%%", new_value);
	}
	
	httpConnector.WriteText(text);
	//______________________________________ </name>
	httpConnector.WriteText(L"</");
	httpConnector.WriteText(name);
	httpConnector.WriteText(L">");
}

void Css::GetXml(Web::HttpConnector& httpConnector, Web::Css& cssInitial, bool visibilityOnly)
{
	//_________________________________________________________ visibility
	if (cssInitial.visibility != visibility && visibility != Web::CssType::VisibilityAuto)
	{
		httpConnector.WriteText(L"<vi>");
		httpConnector.WriteText(Web::Helper::GetVisibilityValue(visibility));
		httpConnector.WriteText(L"</vi>");
	}
	if (visibilityOnly == true) return;
	//__________________________________________________________________________________
	WriteXmlColor(httpConnector, cssInitial.background_color, background_color, L"bc");
	WriteXmlColor(httpConnector, cssInitial.border_color, border_color, L"bo");
	WriteXmlColor(httpConnector, cssInitial.color, color, L"co");
	WriteXmlInteger(httpConnector, cssInitial.border_width, border_width, L"bw");
	//_________________________________________________________ cursor
	if (cssInitial.cursor != cursor && cursor != Web::CssType::CursorAuto)
	{
		httpConnector.WriteText(L"<cu>");
		httpConnector.WriteText(Web::Helper::GetCursorValue(cursor));
		httpConnector.WriteText(L"</cu>");
	}
}

void Css::LoadState(bool visibilityOnly, list<Sys::Xml>::const_iterator control)
{
	list<Sys::Xml>::const_iterator element = control->child.begin();
	const list<Sys::Xml>::const_iterator element_end = control->child.end();
	if (visibilityOnly == true)
	{
		for(; element != element_end; element++)
		{
			if (element->name == L"vi")
			{
				visibility = Web::Helper::ReadVisibilityValue(element->value.c_str());
				break;
			}
		}
	}
	else
	{
		for(; element != element_end; element++)
		{
			if (element->name == L"bc") background_color = Sys::Convert::TextToColorRef(element->value);
			else if (element->name == L"bo") border_color = Sys::Convert::TextToColorRef(element->value);
			else if (element->name == L"co") color = Sys::Convert::TextToColorRef(element->value);
			else if (element->name == L"bw") border_width = ReadInteger(element->value);
			else if (element->name == L"cu") cursor = Web::Helper::ReadCursorValue(element->value.c_str());
			else if (element->name == L"vi") visibility = Web::Helper::ReadVisibilityValue(element->value.c_str());
		}
	}
}

int Css::ReadInteger(const wstring& input)
{
	if (input.find(L"%") == std::wstring::npos) return -Sys::Convert::ToInt(input); // It is in percent
	return Sys::Convert::ToInt(input); // It is in pixels
}

void Css::PrivateGetHtml(wstring& out_html)
{
	wchar_t* descr =  NULL;
	bool semicolon = false;
	//_____________________________________  Border Style (It must be rendered before border-color and border-width)
	if (this->border_style != Web::CssType::BorderStyleAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"border-style:";
		descr = Web::Helper::GetBorderStyleValue(border_style);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}

	semicolon |= RenderColor(semicolon, L"background-color", background_color, out_html);
	semicolon |= RenderColor(semicolon, L"border-color", border_color, out_html);
	semicolon |= RenderColor(semicolon, L"color", color, out_html);
	semicolon |= RenderInteger(semicolon, L"font-size", font_size, out_html);
	semicolon |= RenderInteger(semicolon, L"width", width, out_html);
	semicolon |= RenderInteger(semicolon, L"height", height, out_html);
	semicolon |= RenderInteger(semicolon, L"border-width", border_width, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-left", padding_left, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-top", padding_top, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-right", padding_right, out_html);
	semicolon |= RenderInteger(semicolon, L"padding-bottom", padding_bottom, out_html);
	semicolon |= RenderInteger(semicolon, L"margin-left", margin_left, out_html);
	semicolon |= RenderInteger(semicolon, L"margin-top", margin_top, out_html);
	semicolon |= RenderInteger(semicolon, L"margin-right", margin_right, out_html);
	semicolon |= RenderInteger(semicolon, L"margin-bottom", margin_bottom, out_html);
	//_____________________________________  Font Family
	if (this->font_family != Web::CssType::FontFamilyAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"font-family:";
		descr = Web::Helper::GetFontFamilyValue(font_family);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Vertical Align
	if (this->vertical_align != Web::CssType::VerticalAlignAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"vertical-align:";
		descr = Web::Helper::GetVerticalAlignValue(vertical_align);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Text Align
	if (this->text_align != Web::CssType::TextAlignAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"text-align:";
		descr = Web::Helper::GetTextAlignValue(text_align);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Text Decoration
	if (this->text_decoration != Web::CssType::TextDecorationAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"text-decoration:";
		descr = Web::Helper::GetTextDecorationValue(text_decoration);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Font Weight
	if (this->font_weight != Web::CssType::FontWeightAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"font-weight:";
		descr = Web::Helper::GetFontWeightValue(font_weight);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Display
	if (this->display != Web::CssType::DisplayAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"display:";
		descr = Web::Helper::GetDisplayValue(display);
		if (descr != NULL) out_html+= descr;
		semicolon = true;
	}
	//_____________________________________  Cursor
	if (this->cursor != Web::CssType::CursorAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"cursor:";
		descr = Web::Helper::GetCursorValue(cursor);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Position
	if (this->position != Web::CssType::PositionAuto)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"position:";
		descr = Web::Helper::GetPositionValue(position);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Visibility
	if (this->visibility == Web::CssType::VisibilityHidden)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"visibilitiy:";
		descr = Web::Helper::GetVisibilityValue(visibility);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Overflow X
	if (this->overflow_x != Web::CssType::OverflowXNone)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"overflow-x:";
		descr = Web::Helper::GetOverflowXValue(overflow_x);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________  Overflow Y
	if (this->overflow_y != Web::CssType::OverflowYNone)
	{
		if (semicolon == true) out_html += L";";
		out_html += L"overflow-y:";
		descr = Web::Helper::GetOverflowYValue(overflow_y);
		if (descr != NULL) out_html += descr;
		semicolon = true;
	}
	//_____________________________________ Additional Styles
	if (additionalStyles.empty() == false)
	{
		if (semicolon == true) out_html += L";";
		out_html += additionalStyles;
		semicolon = true;
	}
}

//__________________________________ IObject
void Css::GetHtml(Sys::ITextWriterW& out_html)
{
	wstring style;
	PrivateGetHtml(style);
	if (style.empty() == true) return;
	out_html.WriteText(L" style=\"");
	out_html.WriteText(style);
	out_html.WriteText(L"\"");
}

bool  Css::RenderColor(bool semicolon, const wchar_t* name, COLORREF color, wstring& out_html)
{
	if (color == CSS_COLOR_AUTO) return false;
	if (semicolon == true) out_html += L";";
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%s:#%02X%02X%02X", name, 
		GetRValue(color) ,GetGValue(color), GetBValue(color));
	out_html += text;
	return true;
}

bool Css::RenderInteger(bool semicolon, const wchar_t* name, int value, wstring& out_html)
{
	if (value == HTML_SIZE_AUTO) return false;
	if (semicolon == true) out_html += L";";
	
	wchar_t text[32];
	if (value >= 0)
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"%s:%dpx", name, value);
	}
	else
	{
		_snwprintf_s(text, 32, _TRUNCATE, L"%s:%d%%", name, -value);
	}
	out_html += text;
	return true;
}

void Css::SetPosition(Web::CssType::Position position)
{
	//memoryBlock1: X000 0000
	memoryBlock1 &= 0x0FFFFFFF;
	memoryBlock1 |= position;
}

Web::CssType::Position Css::GetPosition()
{
	//memoryBlock1: X000 0000
	return (Web::CssType::Position) (memoryBlock1 & 0xF0000000);
}

void Css::SetFontFamily(Web::CssType::FontFamily font)
{
	//memoryBlock1: 0XX0 0000
	memoryBlock1 &= 0xF00FFFFF;
	memoryBlock1 |= font;
}

Web::CssType::FontFamily Css::GetFontFamily()
{
	//memoryBlock1: 0XX0 0000
	return (Web::CssType::FontFamily) (memoryBlock1 & 0x0FF00000);
}

void Css::SetTextAlign(Web::CssType::TextAlign text_align)
{
	//memoryBlock1: 000X 0000
	memoryBlock1 &= 0xFFF0FFFF;
	memoryBlock1 |= text_align;
}

Web::CssType::TextAlign Css::GetTextAlign()
{
	//memoryBlock1: 000X 0000
	return (Web::CssType::TextAlign) (memoryBlock1 & 0x000F0000);
}

void Css::SetVerticalAlign(Web::CssType::VerticalAlign vertical_align)
{
	//memoryBlock1: 0000 XX00
	memoryBlock1 &= 0xFFFF00FF;
	memoryBlock1 |= vertical_align;
}

Web::CssType::VerticalAlign Css::GetVerticalAlign()
{
	//memoryBlock1: 0000 XX00
	return (Web::CssType::VerticalAlign) (memoryBlock1 & 0x0000FF00);
}

void Css::SetTextDecoration(Web::CssType::TextDecoration text_decoration)
{
	//memoryBlock1: 0000 00XX
	memoryBlock1 &= 0xFFFFFF00;
	memoryBlock1 |= text_decoration;
}

Web::CssType::TextDecoration Css::GetTextDecoration()
{
	//memoryBlock1: 0000 00XX
	return (Web::CssType::TextDecoration) (memoryBlock1 & 0x000000FF);
}

void Css::SetVisibility(Web::CssType::Visibility visibility)
{
	//memoryBlock2: X000 0000
	memoryBlock2 &= 0x0FFFFFFF;
	memoryBlock2 |= visibility;
}

Web::CssType::Visibility Css::GetVisibility()
{
	//memoryBlock2: X000 0000
	return (Web::CssType::Visibility) (memoryBlock2 & 0xF0000000);
}

void Css::SetBorderStyle(Web::CssType::BorderStyle border_style)
{
	//memoryBlock2: 0XX0 0000
	memoryBlock2 &= 0xF00FFFFF;
	memoryBlock2 |= border_style;
}

Web::CssType::BorderStyle Css::GetBorderStyle()
{
	//memoryBlock2: 0XX0 0000
	return (Web::CssType::BorderStyle) (memoryBlock2 & 0x0FF00000);
}

void Css::SetDisplay(Web::CssType::Display display)
{
	//memoryBlock2: 000X 0000
	memoryBlock2 &= 0xFFF0FFFF;
	memoryBlock2 |= display;
}

Web::CssType::Display Css::GetDisplay()
{
	//memoryBlock2: 000X 0000
	return (Web::CssType::Display) (memoryBlock2 & 0x000F0000);
}

void Css::SetCursor(Web::CssType::Cursor cursor)
{
	//memoryBlock2: 0000 XXXX
	memoryBlock2 &= 0xFFFF0000;
	memoryBlock2 |= cursor;
}

Web::CssType::Cursor Css::GetCursor()
{
	//memoryBlock2: 0000 XXXX
	return (Web::CssType::Cursor) (memoryBlock2 & 0x0000FFFF);
}

void Css::SetOverflowX(Web::CssType::OverflowX overflowX)
{
	//memoryBlock3: XX00 0000
	memoryBlock3 &= 0x00FFFFFF;
	memoryBlock3 |= overflowX;
}

Web::CssType::OverflowX Css::GetOverflowX()
{
	//memoryBlock3: XX00 0000
	return (Web::CssType::OverflowX) (memoryBlock3 & 0xFF000000);
}

void Css::SetOverflowY(Web::CssType::OverflowY overflowY)
{
	//memoryBlock3: 00FF 0000
	memoryBlock3 &= 0xFF00FFFF;
	memoryBlock3 |= overflowY;
}

Web::CssType::OverflowY Css::GetOverflowY()
{
	//memoryBlock3: 00XX 0000
	return (Web::CssType::OverflowY) (memoryBlock3 & 0x00FF0000);
}

void Css::SetFontWeight(Web::CssType::FontWeight font_weight)
{
	//memoryBlock3: 0000 FFFF
	memoryBlock3 &= 0xFFFF0000;
	memoryBlock3 |= font_weight;
}

Web::CssType::FontWeight Css::GetFontWeight()
{
	//memoryBlock3: 0000 XXXX
	return (Web::CssType::FontWeight) (memoryBlock3 & 0x0000FFFF);
}

//________________________________________________________ Object
Object::Object(void)
{
	isBrowserView = false;
}

Object::~Object(void)
{
}

void Object::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

bool Object::IsEvent(Web::HttpConnector& httpConnector, int notification)
{
	if (httpConnector.CheckEvent(ID, notification) == false) return false;
	return true;
}

wchar_t* Object::RenderTagAndId(Sys::ITextWriterW& out_html)
{
	//Indent(indentCount, out_html);
	if (BeginHtml.length() > 0) out_html.WriteText(BeginHtml);
	//______________________________________ tag
	wchar_t * tag = GetTag();
	if (tag == NULL) return NULL;
	out_html.WriteText(L"<");
	out_html.WriteText(GetTag());
	//______________________________________ id
	RenderPair(L"id", ID, out_html);
	return tag;
}

//void Object::RenderHiddenValue(bool increaseIndent, int& indentCount, const wchar_t* value, Sys::ITextWriterW& out_html)
//{
//	//Indent(indentCount, out_html);
//	out_html.WriteText(L"<input type=\"hidden\" name=\"");
//	out_html.WriteText(ID);
//	out_html.WriteText(L"\" Data=\"");
//	out_html.WriteText(value);
//	out_html.WriteText(L"\" />");
//}

void Object::RenderPair(const wchar_t* name, wstring& value, Sys::ITextWriterW& out_html)
{
	if (value.length() == 0) return;
	out_html.WriteText(L" ");
	out_html.WriteText(name);
	out_html.WriteText(L"=\"");
	out_html.WriteText(value);
	out_html.WriteText(L"\"");
}

void Object::RenderPair(const wchar_t* name, const wchar_t* value, Sys::ITextWriterW& out_html)
{
	if (wcslen(name) == 0) return;
	out_html.WriteText(L" ");
	out_html.WriteText(name);
	out_html.WriteText(L"=\"");
	out_html.WriteText(value);
	out_html.WriteText(L"\"");
}

void Object::RenderPair(const wchar_t* name, int value, Sys::ITextWriterW& out_html)
{
	out_html.WriteText(L" ");
	out_html.WriteText(name);
	//
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"=\"%d\"", value);
	out_html.WriteText(text);
}

//void Object::RenderFunction(int eventID, Sys::ITextWriterW& out_html, const wchar_t* url)
//{
//	//wchar_t *eventName = Web::Helper::GetEventName(eventID);
//	//wchar_t *eventShortName = Web::Helper::GetEventShortName(eventID);
//	////wchar_t *eventIdText = Web::Helper::GetEventID(eventID);
//	//if (eventName == NULL) return;
//	//if (eventShortName == NULL) return;
//	//out_html.WriteText(L" ");
//	//out_html.WriteText(eventName);
//	////
//	//wchar_t text[128];
//	//_snwprintf_s(text, 128, _TRUNCATE, L"=\"%s_%s(\'%s\', \'%s\', \'%s\');\"", 
//	//	ID.c_str(), eventShortName, url, ID.c_str(), eventShortName);
//	//out_html.WriteText(text);
//}

//void Object::Indent(const int indentCount, Sys::ITextWriterW& out_html)
//{
//	if (indentCount == -1) return;
//	for (int i = 0; i < indentCount; i++) out_html.WriteText(L"  ");
//}

//void Object::EndIndent(int& indentCount, bool newLine, Sys::ITextWriterW& out_html)
//{
//	if (indentCount == -1) return;
//	if (newLine == true) out_html.WriteText(L"\r\n");
//	indentCount--;
//	if (newLine == true) 
//	{
//		for (int i=0; i<indentCount; i++) out_html.WriteText(L"  ");
//	}
//}

/* vaData has three columns as follows:
0 -> Caption                 1 -> Value               2 -> Color
each row is an entry 
 You can define css.background and css.background before 
calling BarGraph*/
//void Shtml::BarGraph(vector<StrArray>& vaData, 
//					int nWidth, 
//					int nHeight, 
//					int nPositionX, 
//					int nPositionY,
//					int nFontSize,
//					int nDecimals)
//{
//	int nMaxIndex=0;//flData.GetMaxValue(1);
//	double dMaxValue=-1000000;
//	int i=0;
//	int j=0;
//	int nDigitCount=0;
//	int nRowCount=(int)vaData.size();
//	double dCaptionPositionX=0;
//	double dCaptionPositionY=0;
//	double dDeltaX=0;
//	double dDeltaY=0;
//	double dMaxY=0;
//	double dDeltaValue=0;
//	double dMarkDeltaX=0;
//	double dMarkY=0;
//	double dDotsPerY=0;
//	double dBarSizeY=0;
//	double dBarPositionX=0;
//	double dBarPositionY=0;
//	double dTablePositionX=0;
//	StrArray sa;
//
//	sa.SetColumnCount(3);
//
//	if (nRowCount>0)
//	{
//		/****************************** We compute the MAXIMUM value */
//		for(i=0; i<nRowCount; i++)
//		{
//			sa=vaData[i];
//			if (   StrArray::ToDouble(sa.GetValue(1))  >dMaxValue)
//			{
//				dMaxValue=StrArray::ToDouble(sa.GetValue(1));
//				nMaxIndex=i;
//			}
//		}
//		//
//		dDeltaX=nWidth/(nRowCount+1);
//		dDeltaY=nHeight/10;
//		dTablePositionX=nPositionX+4*nFontSize+0.5;
//
//		/****************************************************** Border */
//		css.size((int)(nWidth-0.5*dDeltaX), nHeight);
//		css.xy((int)dTablePositionX, (int)nPositionY);
//		table(NULL);
//		tr(NULL);
//		td(NULL);
//		Spaces(1);
//		tdtrtableEnd();
//
//		span(NULL);
//		
//		/**************************************************** X Caption */
//		dCaptionPositionY=nHeight+nPositionY+0.5*nFontSize;
//		for (i=0; i<nRowCount; i++)
//		{
//			sa=vaData[i];
//			//
//			if (sa.GetValue(0))
//			{
//				dCaptionPositionX=dDeltaX*i+dTablePositionX+0.4*dDeltaX;
//				css.xy((int)dCaptionPositionX, (int)dCaptionPositionY);
//				css.font("Times New Roman", nFontSize);
//				Text(sa.GetValue(0), NULL);
//			}
//		}
//
//		/***************************************************** Y Caption */
//		dMaxY=dMaxValue;
//		dDeltaValue=dMaxY/10;
//		for(i=0; i<11; i++)
//		{
//			dMarkY=nPositionY+nHeight-dDeltaY*i-0.5*nFontSize;
//			// Number 
//			css.xy(nPositionX, (int)dMarkY);
//			css.font("Times New Roman", nFontSize);
//			span(NULL);
//			SendDouble(i*dDeltaValue, 1);
//			spanEnd();
//			/* Mark */
//			if (i!=0 && i!=10)
//			{
//				dMarkDeltaX=nWidth;
//				dMarkY=nPositionY+nHeight-dDeltaY*i;
//				Line((int)dTablePositionX, 
//					(int)dMarkY,
//					(int)(dTablePositionX+dMarkDeltaX),
//					(int)dMarkY,
//					1,
//					"ffffff");
//			}
//		}
//		nPositionX+=10;
//
//		/********************************************************** Bars */
//		dDotsPerY=nHeight/dMaxY;
//		for (i=0; i<nRowCount; i++)
//		{
//			sa=vaData[i];
//			if (StrArray::ToDouble(sa.GetValue(1))>0)
//			{
//				dBarPositionX=dDeltaX*i+dTablePositionX+0.3*dDeltaX;
//				dBarSizeY=dDotsPerY*(StrArray::ToDouble(sa.GetValue(1)));
//				dBarPositionY=nPositionY+nHeight-(int)(dBarSizeY+0.5);
//				css.xy((int)(dBarPositionX+0.5), (int)(dBarPositionY+0.5));
//				css.size((int)(dDeltaX*0.80), (int)(dBarSizeY+0.5));
//				css.font("Times New Roman", 1);
//				if (sa.GetValue(2))
//					css.background(NULL, sa.GetValue(2));
//				Text("&nbsp;", NULL);
//			}
//		}
//	}
//	spanEnd();
//}


/* bPictureServerName indicates whether or not you want to include the
name of the server of the PictureFile */
//void Shtml::Mail(char* cTo, char* cSubject, char* cBody, char* cCC, char* cClass)
//{	
//	ostream& o=Out();
//	m_nTag_link++;
//	TagIni("A", cClass, false, false);
//	o<<" href=\"mailto: "<<cTo;
//	if (cSubject)
//		o<<"?subject="<<cSubject;
//	if (cBody)
//		o<<"&body="<<cBody;
//	if (cCC)
//		o<<"&cc="<<cCC;
//	o<<"\">";
//	o.flush();
//}

///* va =>  Date, Caption, Class, Link, VariableValue
//       "01/02/2002", "Dinner with President", "Elegant", "dinner.htm", NULL
//	   Please define the css class CalendarHeader */
//bool Shtml::CalendarView(int nMonth, int nDay, int nYear,
//				  bool bDisplayHeader,
//				  bool bDisplayWeekend,
//				  vector<StrArray>& va)
//{
//	bool bOK=false;
//	int nRow;
//	int nColumn;
//	int i=0;
//	time_t lLocalTime;
//	time_t lTime;
//	int nLocalMonth;
//	int nLocalDay;
//	int nLocalYear;
//	struct tm  *today;
//	struct tm When;
//	char cTmp[20];
//	char cDate[20];// It saves the date on the format MM/DD/YYYY
//	char cBorder[]="groove";
//	const int nBorder=1;
//	StrArray sa;
//
//	sa.SetColumnCount(5);
//
//	if ((nMonth==0) && (nDay==0) && (nYear==0))
//	{
//		time(&lTime);
//		today=localtime(&lTime);
//		nMonth=today->tm_mon;
//		nDay=today->tm_mday;
//		nYear=today->tm_year;
//		lLocalTime=FindFirstSunday(lTime);
//		bOK=true;
//	}
//
//	if  (  (0<nMonth) && (nMonth<=12) && (1900<nYear) && (nYear<=9999))
//	{
//		nMonth--;
//		nYear-=1900;
//		When.tm_year=nYear;
//		When.tm_mon=nMonth;
//		When.tm_mday=1;
//		When.tm_hour=12;
//		When.tm_min=0;
//		When.tm_sec=0;
//
//		if ( (lLocalTime=mktime(&When))  !=(time_t)-1)
//		{
//			lLocalTime=FindFirstSunday(lLocalTime);
//			bOK=true;
//		}
//		else
//			bOK=false;
//	}
//
//	if (bOK)
//	{
////		css.background(NULL, "d0d0ff");
//		css.border(3, "outset", "c0c0c0");
//		css.width("100%");
////		css.height("100%");
////		SetCustom("border=\"1\"");
//		table(NULL); // This table has two rows.  Each row is another table
//		tr(NULL);
//		td(NULL);
//		//
//		css.width("100%");
//		table(NULL);
//		tr(NULL);
//		//
//		css.textAlign("right");
//		td(NULL);	
//		if (bDisplayHeader)
//		{
//		/******************************************************************* Main Label */
//			// We create the previous month button
//			if (nMonth==0)
//			{	
//				itoa(nYear+1900-1, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				SetVariable("nCalendarMonth", "12");	
//			}
//			else
//			{
//				itoa(nYear+1900, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				itoa(nMonth, cTmp, 10); // it should be (nMonth+1)-1
//				SetVariable("nCalendarMonth", cTmp);
//			}
//			ActiveLink(NULL);
//			css.border(0, "solid", "ffffff");
//			css.textDecoration("none");
//			Text("<b>&lt;&lt;</b>", "CalendarHeader");
//			ActiveLinkEnd();
//		}
//		else
//			Spaces(1);
//		tdEnd();
//		//
//		css.textAlign("center");
//		td("CalendarHeader");
//		s(MonthName(nMonth, true));
//		Spaces(2);
//		SendInt(nYear+1900);
//		tdEnd();
//		//
//		css.textAlign("left");
//		td(NULL);
//				
//		if (bDisplayHeader)
//		{
//			// We create the next month button
//			if (nMonth==11)
//			{	
//				itoa(nYear+1900+1, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				SetVariable("nCalendarMonth", "1");
//			}
//			else
//			{
//				itoa(nYear+1900, cTmp, 10);
//				SetVariable("nCalendarYear", cTmp);
//				itoa(nMonth+2, cTmp, 10); // it should be (nMonth+1)+1
//				SetVariable("nCalendarMonth", cTmp);
//			}
//			ActiveLink(NULL);
//			css.border(0, "solid", "ffffff");
//			css.textDecoration("none");
//			Text("<b>&gt;&gt;</b>", "CalendarHeader");
//			ActiveLinkEnd();
//		}
//		else
//			Spaces(1);
//		tdEnd();
//		//
//		trEnd();
//		tableEnd(); // End of the first table
//		//
//		tdtrEnd();
//        /******************************************************************* Days of the month */
//		css.width("100%");
//		css.height("100%");
//		tr(NULL);
//		css.width("100%");
//		css.height("100%");
//		td(NULL);
//		css.border(nBorder, cBorder, "ffffff");
//		//SetCustom("border=\"1\"");
//		css.width("100%");
//		css.height("100%");
//		table(NULL);
//		//
//		css.height("30px");
//		tr(NULL);
//		//
//		if (bDisplayWeekend)
//		{
//			css.border(nBorder, cBorder, "ffffff");
//			css.background(NULL, "c0d0ff");
//			css.textAlign("center");
//			td(NULL);		
//			Text("Sunday", "CalendarHeader");
//			tdEnd();
//		}
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Text("Monday", "CalendarHeader");
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Spaces(1);
//		Text("Tuesday", "CalendarHeader");
//		Spaces(1);
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Text("Wednesday", "CalendarHeader");
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Text("Thursday", "CalendarHeader");
//		tdEnd();
//		//
//		css.border(nBorder, cBorder, "ffffff");
//		css.background(NULL, "d0f0ff");
//		css.textAlign("center");
//		td(NULL);	
//		Spaces(2);
//		Text("Friday", "CalendarHeader");
//		Spaces(2);
//		tdEnd();
//		//
//		if (bDisplayWeekend)
//		{
//			css.border(nBorder, cBorder, "ffffff");
//			css.background(NULL, "c0d0ff");
//			css.textAlign("center");
//			td(NULL);	
//			Text("Saturday", "CalendarHeader");
//			tdEnd();
//		}
//		//
//		trEnd();
//
//		today=localtime(&lLocalTime);
//		nLocalDay=today->tm_mday;
//		nLocalMonth=today->tm_mon;
//		nLocalYear=today->tm_year;
//		for (nRow=0; nRow<6; nRow++)
//		{
//			css.verticalAlign("top");
//			tr(NULL);
//			for(nColumn=0; nColumn<7; nColumn++)
//			{
//				if (  (nColumn!=0 && nColumn!=6) || bDisplayWeekend )
//				{
//					if (nLocalMonth==nMonth)
//						css.background(NULL, "ffffff");
//					else
//						css.background(NULL, "c0c0c0");
//					
//					if (bDisplayWeekend)
//						css.width("14.29%");
//					else
//						css.width("20%");
//					css.border(nBorder, cBorder, "ffffff");
//					td(NULL); // Another color
//			
//					/* We create cDate MM/DD/YYYY */
//					itoa(nLocalMonth+1, cTmp, 10);
//					if (nLocalMonth+1<10)
//						strcpy(cDate, "0");
//					else
//						cDate[0]='\0';
//					strcat(cDate, cTmp);
//					strcat(cDate, "/");
//					//
//					itoa(nLocalDay, cTmp, 10);
//					if (nLocalDay<10)
//						strcat(cDate, "0");
//					strcat(cDate, cTmp);
//					strcat(cDate, "/");
//					itoa(nLocalYear+1900, cTmp, 10);
//					strcat(cDate, cTmp);
//				
//					if (nLocalMonth==nMonth)
//					{
//						css.fontWeight("bold");
//						css.font("Times New Roman", 17);
//						css.color("f00000");
//						span(NULL);
//						SendInt(nLocalDay);
//						spanEnd();
//						NewLine(1);
//						for (i=0; i<(int)va.size(); i++)
//						{
//							/* Date, Caption, Class, Link, VariableValue */
//							sa=va[i];
//							if (strcmp(cDate, sa.GetValue(0))==0)
//							{
//								if (sa.GetValue(4))
//								{
//									SetVariable("nCalendarIndex", sa.GetValue(4));
//									ActiveLink(NULL);
//								}
//								else if (sa.GetValue(3))
//									Link(sa.GetValue(3), NULL);
//								span(sa.GetValue(2));
//								s(sa.GetValue(1));
//								spanEnd();
//								if (sa.GetValue(4))
//									ActiveLinkEnd();
//								else if (sa.GetValue(3))
//									LinkEnd();
//							}
//						}
//					}
//					else
//					{
//						css.fontWeight("bold");
//						css.font("Times New Roman", 17);
//						css.color("e0e0e0");
//						span(NULL);
//						SendInt(nLocalDay);
//						spanEnd();
//					}
//					tdEnd();
//				}
//				lLocalTime=lLocalTime+86400;
//				today=localtime(&lLocalTime);
//				nLocalDay=today->tm_mday;
//				nLocalMonth=today->tm_mon;
//				nLocalYear=today->tm_year;
//			}
//			trEnd();
//		}
//		tableEnd();
//		tdtrEnd();
//		tableEnd();
//	}
//	return bOK;
//}


//________________________________________________________ VisibleObject
VisibleObject::VisibleObject(void)
{
	memoryBlock = (__int32)0;
	Enabled = true;
	SetOriginalEnabled(true);
}

VisibleObject::~VisibleObject(void)
{
}

void VisibleObject::CreateXmlNode(Web::HttpConnector& httpConnector, const wchar_t* id, wchar_t* node_name, bool visibilityOnly)
{
	httpConnector.WriteText(L"<c><id>");
	httpConnector.WriteText(id);
	httpConnector.WriteText(L"</id><tp>");
	httpConnector.WriteText(node_name);
	httpConnector.WriteText(L"</tp>");
	//___________________________________________________ Enabled
	if (GetOriginalEnabled() != IsEnabled())
	{
		if (IsEnabled() == true)
		{
			httpConnector.WriteText(L"<en>true</en>");
		}
		else
		{
			httpConnector.WriteText(L"<en>false</en>");
		}
	}
	css.GetXml(httpConnector, _originalCss, visibilityOnly);
}


wstring& VisibleObject::GetText()
{
	return _text;
}

void VisibleObject::SetText(const wstring& text)
{
	_text = text;
}

bool VisibleObject::LoadState(Web::HttpConnector& httpConnector, bool visibilityOnly, list<Sys::Xml>::const_iterator& out_control)
{
	if (httpConnector.GetAjaxControlIterator(ID.c_str(), out_control) == false) return false;
	list<Sys::Xml>::const_iterator element = out_control->child.begin();
	const list<Sys::Xml>::const_iterator element_end = out_control->child.end();
	for(; element != element_end; element++)
	{
		if (element->name == L"enabled")
		{
			SetEnabled(element->value == L"true");
			SetOriginalEnabled(IsEnabled());
			break;
		}
	}
	css.LoadState(visibilityOnly, out_control);
	_originalCss = this->css;
	return true;
}

void VisibleObject::RenderClassAndStyle(Sys::ITextWriterW& out_html)
{
	css.GetHtml(out_html);
	if (cssClass.length()>0)
	{
		out_html.WriteText(L" class=\"");
		out_html.WriteText(cssClass);
		out_html.WriteText(L"\"");
	}
}

void VisibleObject::SetVisible(bool visible)
{
	// memoryBlock: 0000 0000 0000 0000 00000 1000 0000 0000
	//if (visible == true)
	//{
	//	memoryBlock |= 0x00000800;
	//}
	//else
	//{
	//	memoryBlock &= 0xFFFFF7FF;
	//}
	if (visible == true)
	{
		css.visibility = Web::CssType::VisibilityVisible;
	}
	else
	{
		css.visibility = Web::CssType::VisibilityHidden;
	}
}

bool VisibleObject::IsVisible()
{
	// memoryBlock: 0000 0000 0000 0000 00000 1000 0000 0000
	//return ((memoryBlock & 0x00000800) != 0);
	return (css.visibility != Web::CssType::VisibilityHidden);
}

void VisibleObject::SetEnabled(bool enabled)
{
	// memoryBlock: 0000 0000 0000 0000 00000 0100 0000 0000
	if (enabled == true)
	{
		memoryBlock |= 0x00000400;
	}
	else
	{
		memoryBlock &= 0xFFFFFBFF;
	}
}

bool VisibleObject::IsEnabled()
{
	// memoryBlock: 0000 0000 0000 0000 00000 0100 0000 0000
	return ((memoryBlock & 0x00000400) != 0);
}

void VisibleObject::SetOriginalEnabled(bool enabled)
{
	// memoryBlock: 0000 0000 0000 0000 00000 0010 0000 0000
	if (enabled == true)
	{
		memoryBlock |= 0x00000200;
	}
	else
	{
		memoryBlock &= 0xFFFFFDFF;
	}
}

bool VisibleObject::GetOriginalEnabled()
{
	// memoryBlock: 0000 0000 0000 0000 00000 0010 0000 0000
	return ((memoryBlock & 0x00000200) != 0);
}

void VisibleObject::RenderName(Sys::ITextWriterW& out_html)
{
	if (ID.length() == 0) return;
	out_html.WriteText(L" name=\"");
	out_html.WriteText(ID);
	out_html.WriteText(L"Data\"");
}

//________________________________________________________ Button
Button::Button()
{
	SetSubmit(true);
}

Button::~Button()
{
}

wstring& Button::GetText()
{
	return _text;
}

void Button::SetText(const wstring& text)
{
	_text = text;
}

void Button::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool Button::IsVisible()
{
	return VisibleObject::IsVisible();
}

void Button::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool Button::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

void Button::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Button::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//if (Visible == false) return;
	RenderTagAndId(out_html);
	if (Submit == true)
	{
		out_html.WriteText(L" type=\"submit\"");
	}
	else
	{
		out_html.WriteText(L" type=\"button\"");
	}
	RenderClassAndStyle(out_html);
	RenderPair(L"value", Text, out_html);
	if (Enabled == false) RenderPair(L"disabled", L"disabled", out_html);
	
	if (isBrowserView == false)
	{
		if (Submit == true)
		{
			//________________________________________________ onclick Javascript event
			wchar_t onclickFunc[128];
			_snwprintf_s(onclickFunc, 128, _TRUNCATE,  
				L"var hid = document.getElementById('serverClick'); if (hid!=null){hid.value='%s';}", ID.c_str());
			RenderPair(L"onclick", onclickFunc, out_html);
		}
		else
		{
			javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
		}
	}
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
}

void Button::GetXml(Web::HttpConnector& httpConnector)
{
	CreateXmlNode(httpConnector, ID.c_str(), L"Button", false);
	//_______________________________________________ Value
	if (_originalText.length() != 0 && _text.length() == 0)
	{
		httpConnector.WriteText(L"<d>Execute</d>");
	}
	else if (_originalText.length() != 0 && _text.length() != 0 && _originalText != _text)
	{
		wstring xmlText;
		Sys::Convert::ToXml(_text.c_str(), xmlText);
		httpConnector.WriteText(L"<d>");
		httpConnector.WriteText(xmlText);
		httpConnector.WriteText(L"</d>");
	}
	httpConnector.WriteText(L"</c>");
}

void Button::LoadState(Web::HttpConnector& httpConnector)
{
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator control;
		if (Web::VisibleObject::LoadState(httpConnector, false, control) == false) return;
		//_________________________________________________ Value
		if (control->GetChildValue(L"d", _text) == true) _originalText = _text;
	}
}

wchar_t* Button::GetTag()
{
	return L"input";
}

void Button::SetSubmit(bool isSubmit)
{
	// memoryBlock:0000 0000 0000 0000 00000 0000 0100 0000
	if (isSubmit == true)
	{
		memoryBlock |= 0x00000040;
	}
	else
	{
		memoryBlock &= 0xFFFFFFBF;
	}
}

bool Button::IsSubmit()
{
	// mmemoryBlock2:0000 0000 0000 0000 00000 0000 0100 0000
	return ((memoryBlock & 0x00000040) != 0);
}

//________________________________________________________ Textbox
Textbox::Textbox()
{
	_maxTextLength = 32;
	RowCount = 1;
	ColCount = 16;
	SetReadOnly(false);
	SetPassword(false);
	//
	//_balloonCaption;
	//_balloonText;
	_balloonIcon = -1;
	_originalReadonly = ReadOnly;
}

Textbox::~Textbox()
{
}

wstring& Textbox::GetText()
{
	return _text;
}

void Textbox::SetText(const wstring& text)
{
	_text = text;
}

void Textbox::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool Textbox::IsVisible()
{
	return VisibleObject::IsVisible();
}

void Textbox::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool Textbox::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

void Textbox::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Textbox::ShowBalloonTip(const wchar_t* caption, const wchar_t* text, int icon)
{
	//icon: TTI_INFO, TTI_WARNING, TTI_ERROR
	_balloonCaption = caption;
	_balloonText = text;
	_balloonIcon = icon;
}

void Textbox::ShowBalloonTip(const wstring& caption, const wstring& text, int icon)
{
	//icon: TTI_INFO, TTI_WARNING, TTI_ERROR
	_balloonCaption = caption;
	_balloonText = text;
	_balloonIcon = icon;
}

void Textbox::HideBalloonTip()
{
	_balloonCaption.clear();
	_balloonText.clear();
	_balloonIcon = -1;
}

void Textbox::SetPassword(bool isPassword)
{
	// memoryBlock: 0000 0000 0000 0000 00000 0000 0010 0000
	if (isPassword == true)
	{
		memoryBlock |= 0x00000020;
	}
	else
	{
		memoryBlock &= 0xFFFFFFDF;
	}
}

bool Textbox::IsPassword()
{
	// memoryBlock: 0000 0000 0000 0000 00000 0000 0010 0000
	return ((memoryBlock & 0x00000020) != 0);
}

void Textbox::SetReadOnly(bool readOnly)
{
	// memoryBlock: 0000 0000 0000 0000 00000 0000 0001 0000
	if (readOnly == true)
	{
		memoryBlock |= 0x00000010;
	}
	else
	{
		memoryBlock &= 0xFFFFFFEF;
	}
}

bool Textbox::IsReadOnly()
{
	// memoryBlock: 0000 0000 0000 0000 00000 0000 0001 0000
	return ((memoryBlock & 0x00000010) != 0);
}


void Textbox::SetMaxTextLength(int maxTextLength)
{
	_maxTextLength = maxTextLength;
}

int Textbox::GetMaxTextLength()
{
	return _maxTextLength;
}

void Textbox::SetMultiline(bool isMultiline)
{
	RowCount = 32;
	ColCount = 64;
}

bool Textbox::IsMultiline()
{
	return (RowCount >1);
}

const wchar_t* Textbox::GetTooltipHexColor(int balloon_icon)
{
	if (balloon_icon == TTI_WARNING) return L"#FFFF20";
	if (balloon_icon == TTI_ERROR) return L"#FF5050";
	if (balloon_icon == TTI_INFO) return L"#50B0FF";
	return L"#FFFFFF";
}

void Textbox::RenderBalloon(Sys::ITextWriterW& out_html)
{
	const bool visible = (_balloonIcon == TTI_WARNING || _balloonIcon == TTI_ERROR || _balloonIcon == TTI_INFO);
	//__________________________________________________________________________ Icon
	out_html.WriteText(L"<span id=\"");
	out_html.WriteText(ID);
	out_html.WriteText(L"BI\" style=\"border-width:1px;border-style:solid;border-color:#000000;font-family:Arial;font-size:12px;color:#000000;font-weight:900;text-align:center");
	if (visible == true)
	{
		out_html.WriteText(L";visibility:visible;background-color:");
	}
	else
	{
		out_html.WriteText(L";visibility:hidden;background-color:");
	}
	out_html.WriteText(GetTooltipHexColor(_balloonIcon));
	if (visible == true)
	{
		out_html.WriteText(L"\">&nbsp;!&nbsp;</span><span id=\"");
	}
	else
	{
		out_html.WriteText(L"\"></span><span id=\"");
	}
	//__________________________________________________________________________ Caption and Text
	out_html.WriteText(ID);
	out_html.WriteText(L"BT\" style=\"border-width:1px;border-style:solid;border-color:#000000;font-family:Arial;font-size:10px;color:#000000;background-color:#FFFFFF");
	if (visible == true)
	{
		out_html.WriteText(L";visibility:visible\">");
		if (_balloonCaption.length() > 0)
		{
			out_html.WriteText(L"&nbsp;<b>");
			out_html.WriteText(_balloonCaption);
			out_html.WriteText(L"</b>:&nbsp;");
		}
		if (_balloonText.length() > 0) out_html.WriteText(_balloonText);
		out_html.WriteText(L"&nbsp;");
	}
	else
	{
		out_html.WriteText(L";visibility:hidden\">");
	}
	out_html.WriteText(L"</span>");
}

void Textbox::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"disabled", out_html);
	if (ReadOnly == true) RenderPair(L"readonly", L"readonly", out_html);
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());

	if (RowCount <= 1) //______________________________ type="text"
	{
		if (Password == true)
		{
			RenderPair(L"type", L"password", out_html);
		}
		else
		{
			RenderPair(L"type", L"text", out_html);
		}
		if (_maxTextLength > 0) RenderPair(L"maxlength", _maxTextLength, out_html);
		if (ColCount > 0) RenderPair(L"size", ColCount, out_html);
		if (_text.length() > 0) RenderPair(L"value", _text, out_html);
		out_html.WriteText(L"/>");
	}
	else //__________________________________________ Text Area
	{
		if (_maxTextLength > 0) RenderPair(L"maxlength", _maxTextLength, out_html);
		if (RowCount > 0) RenderPair(L"rows", RowCount, out_html);
		if (ColCount > 0) RenderPair(L"cols", ColCount, out_html);
		//if (Wrap == true) RenderPair(L"wrap", L"hard", out_html);
		out_html.WriteText(L">");
		if (_text.length() > 0) out_html.WriteText(_text);
		out_html.WriteText(L"</textarea>");
	}
	//_________________________________ Render Ballon Tip
	RenderBalloon(out_html);
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void Textbox::GetXml(Web::HttpConnector& httpConnector)
{
	wstring xmlText;
	CreateXmlNode(httpConnector, ID.c_str(), L"TB", false);
	if (IsReadOnly() == true) httpConnector.WriteText(L"<ro>true</ro>"); // Readonly
	//___________________________________________________________________________________________ Value
	if (_originalText.length() != 0 && _text.length() == 0) //________________________ Clear text in textbox
	{
		httpConnector.WriteText(L"<d>&amp;nbsp;</d>");
	}
	else if (_text.length() != 0 && _originalText != _text)// Update text in textbox
	{
		Sys::Convert::ToXml(_text.c_str(), xmlText);
		httpConnector.WriteText(L"<d>");
		httpConnector.WriteText(xmlText);
		httpConnector.WriteText(L"</d>");
	}
	httpConnector.WriteText(L"</c>");
	//__________________________________________________________________________________ Balloon
	const bool hasBalloon = (_balloonIcon == TTI_WARNING || _balloonIcon == TTI_ERROR || _balloonIcon == TTI_INFO);
	//___________________________________________________________ Icon
	httpConnector.WriteText(L"<c><tp>TX</tp><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"BI</id>");
	if (hasBalloon == true)
	{
		httpConnector.WriteText(L"<ih>&amp;nbsp;!&amp;nbsp;</ih>");
		COLORREF ttColor = Sys::Convert::TextToColorRef(GetTooltipHexColor(_balloonIcon));
		Sys::Format(xmlText, L"rgb(%d, %d, %d)", GetRValue(ttColor), GetGValue(ttColor), GetBValue(ttColor));
		httpConnector.WriteText(L"<bc>"); //background_color
		httpConnector.WriteText(xmlText);
		httpConnector.WriteText(L"</bc><vi>visible</vi></c>");
	}
	else
	{
		httpConnector.WriteText(L"<ih>&amp;nbsp;</ih><vi>hidden</vi></c>");
	}
	//_________________________________________________________ Caption
	httpConnector.WriteText(L"<c><tp>TX</tp><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"BT</id>");
	if (hasBalloon == true)
	{
		wstring desc = L"&nbsp;<b>";
		desc += _balloonCaption;
		desc += L"</b>:&nbsp;";
		desc += _balloonText;
		desc += L"&nbsp;";
		Sys::Convert::ToXml(desc.c_str(), xmlText);
		httpConnector.WriteText(L"<ih>");
		httpConnector.WriteText(xmlText);
		httpConnector.WriteText(L"</ih><vi>visible</vi></c>");
	}
	else
	{
		httpConnector.WriteText(L"<ih>&amp;nbsp;</ih><vi>hidden</vi></c>");
	}
}

void Textbox::LoadState(Web::HttpConnector& httpConnector)
{
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator control;
		if (Web::VisibleObject::LoadState(httpConnector, false, control) == false) return;
		//_________________________________________________ data
		if (control->GetChildValue(L"d", _originalText) == true) _text = _originalText;
		//_________________________________________________ Readonly
		list<Sys::Xml>::const_iterator element = control->child.begin();
		const list<Sys::Xml>::const_iterator element_end = control->child.end();
		for(; element != element_end; element++)
		{
			if (element->name == L"ro")
			{
				SetReadOnly(element->value == L"true");
				break;
			}
		}
	}
	else
	{
		wstring name(ID);
		name += L"Data";
		multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
		if (state == httpConnector.value.end()) return;
		if (state->second.length() == 0)
		{
			_text = L"";
		}
		else
		{
			_text = state->second;
		}
	}
}

//_____________________________________________________________________ ISelectString
wstring& Textbox::SqlGetString()
{
	return _text;
}

void Textbox::SqlUpdate(bool toGui)
{
	// The content of _text has inside the NULL terminator
	if (toGui == true)
	{
		_text.resize(wcslen(_text.c_str())); // Remove extra NULL terminator
	}
}

wchar_t* Textbox::GetTag()
{
	if (RowCount <= 1) return L"input";
	return L"textarea";
}

int Textbox::GetIntValue(void)
{
	return Sys::Convert::ToInt(_text);
}

void Textbox::SetIntValue(int value)
{
	_text = Sys::Convert::ToString(value);
}

double Textbox::GetDoubleValue()
{
	return Sys::Convert::ToDouble(_text);
}

void Textbox::SetDoubleValue(double value, const wchar_t* format)
{
	if (format==NULL) format = L"%g";
	Sys::Format(_text, format, value);
}

void Textbox::SetDoubleValue(double value)
{
	this->SetDoubleValue(value, L"%g");
}

//_____________________________________________________________________ Service
Service::Service(void)
{
	css.width = -100;
}

Service::~Service(void)
{
}

wchar_t* Service::GetTag()
{
	return L"table";
}

int Service::GetIntParameter(Web::HttpConnector& httpConnector, const wchar_t* name)
{
	Web::ServiceVariable variable;
	variable.name = name;
	variable.type = WEBSERVICE_VARIABLE_INT;
	int value = 0;
	if (httpConnector.GetVariable(name, value) == true)
	{
		Sys::Convert::ToString(value, variable.value);
	}
	parameter.push_back(variable);
	return value;
}

int Service::GetIntParameter(Web::HttpConnector& httpConnector, const wstring& name)
{
	return GetIntParameter(httpConnector, name.c_str());
}

double Service::GetDoubleParameter(Web::HttpConnector& httpConnector, const wchar_t* name)
{
	Web::ServiceVariable variable;
	variable.name = name;
	variable.type = WEBSERVICE_VARIABLE_DOUBLE;
	double value = 0.0;
	if (httpConnector.GetVariable(name, value) == true)
	{
		Sys::Convert::ToString(value, variable.value);
	}
	parameter.push_back(variable);
	return value;
}

double Service::GetDoubleParameter(Web::HttpConnector& httpConnector, const wstring& name)
{
	return GetDoubleParameter(httpConnector, name.c_str());
}

bool Service::GetBoolParameter(Web::HttpConnector& httpConnector, const wchar_t* name)
{
	Web::ServiceVariable variable;
	variable.name = name;
	variable.type = WEBSERVICE_VARIABLE_BOOL;
	bool value = false;
	if (httpConnector.GetVariable(name, value) == true)
	{
		Sys::Convert::ToString(value, variable.value);
	}
	parameter.push_back(variable);
	return value;
}

bool Service::GetBoolParameter(Web::HttpConnector& httpConnector, const wstring& name)
{
	return GetBoolParameter(httpConnector, name.c_str());
}

wstring Service::GetStringParameter(Web::HttpConnector& httpConnector, const wchar_t* name)
{
	Web::ServiceVariable variable;
	variable.name = name;
	variable.type = WEBSERVICE_VARIABLE_TEXT;
	httpConnector.GetVariable(name, variable.value);
	parameter.push_back(variable);
	return variable.value;
}

wstring Service::GetStringParameter(Web::HttpConnector& httpConnector, const wstring& name)
{
	return GetStringParameter(httpConnector, name.c_str());
}

bool Service::GetStringParameter(Web::HttpConnector& httpConnector, const wchar_t* name, wstring& out_value)
{
	out_value.clear();
	Web::ServiceVariable variable;
	variable.name = name;
	variable.type = WEBSERVICE_VARIABLE_TEXT;
	const bool ok = httpConnector.GetVariable(name, variable.value);
	parameter.push_back(variable);
	out_value = variable.value;
	return ok;
}

bool Service::GetStringParameter(Web::HttpConnector& httpConnector, const wstring& name, wstring& out_value)
{
	return GetStringParameter(httpConnector, name.c_str(), out_value);
}

void Service::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	soapEnvelope.ActionName = Text;
	soapEnvelope.ActionName += L"Response";
	//______________________________________________________________ <table id= ... >
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	out_html.WriteText(L">");
	//_______________________________________________________________ Title HTML
	out_html.WriteText(L"<tr style=\"width:100%\"><td style=\"text-align:left;font-weight:bold;\">");
	if (Text.empty() == true)
	{
		out_html.WriteText(L"Web Service using Simple Object Access Protocol (SOAP)");
	}
	else
	{
		out_html.WriteText(Text);
	}
	out_html.WriteText(L"</td><td style=\"text-align:right\">");
	out_html.WriteText(L"<input type=\"submit\" name=\"Run\" value=\"Run\" />&nbsp;");
	if (isBrowserView == true)
	{
		out_html.WriteText(L"<input type=\"submit\" value=\"Home\" />");
	}
	else
	{
		out_html.WriteText(L"<input type=\"submit\" value=\"Home\" onclick=\"var hid=document.getElementById('windowInfo'); if (hid!=null){hid.value='Index';}\" />");
	}
	out_html.WriteText(L"</td></tr></table><hr />");
	//_______________________________________________________________ Parameters Table
	out_html.WriteText(L"<table ");
	RenderClassAndStyle(out_html);
	out_html.WriteText(L">");
	//____________ parameters
	vector<Web::ServiceVariable>::iterator param = parameter.begin();
	vector<Web::ServiceVariable>::const_iterator param_end = parameter.end();
	for (; param != param_end; param++)
	{
		out_html.WriteText(L"<tr style=\"width:100%\"><td>");
		out_html.WriteText(param->name);
		out_html.WriteText(L"</td><td><input type=\"text\" size=\"60\" name=\"");
		out_html.WriteText(param->name);
		if (param->value.empty() == false)
		{
			out_html.WriteText(L"\" value=\"");
			out_html.WriteText(param->value);
		}
		out_html.WriteText(L"\" />&nbsp;<span style=\"color:#2020FF\">");
		out_html.WriteText(param->GetTypeText());
		out_html.WriteText(L"</span></td></tr>");
	}
	out_html.WriteText(L"</table><hr />");
	//______________________________________  Get Resource name
	wstring resource;
	if (httpConnector.GetServerVariable(L"HTTP_URL", resource) == false)
	{
		resource = L"/";
	}
	//______________________________________ HTTP Request  sample
	Sys::SoapEnvelope soapEnvelopeSample;
	soapEnvelopeSample.ActionXmlns = soapEnvelope.GetActionXmlns();
	soapEnvelopeSample.ActionName = Text;
	for (param = parameter.begin(); param != param_end; param++)
	{
		if (param->value.empty() == true)
		{
			soapEnvelopeSample.AddParameter(param->name, L"value");
		}
		else
		{
			soapEnvelopeSample.AddParameter(param->name, param->value);
		}
	}
	//______________________________________ Get HTTP Response
	wstring responseXml;
	soapEnvelope.GetHtml(responseXml);
	//______________________________________ Get HTTP Response length
	wstring xmlText;
	soapEnvelope.GetXmlText(xmlText);
	const size_t response_len = xmlText.size();
	//______________________________________ SOAP 1.1
	soapEnvelopeSample.majorVersion = 1;
	soapEnvelopeSample.minorVersion = 1;
	SoapSample(resource, (int)response_len, soapEnvelopeSample, false, out_html);
	out_html.WriteText(responseXml);
	out_html.WriteText(L"</td></tr></table>");
	//______________________________________ SOAP 1.2
	soapEnvelopeSample.minorVersion = 2;
	SoapSample(resource, (int)response_len, soapEnvelopeSample, false, out_html);
	out_html.WriteText(responseXml);
	out_html.WriteText(L"</td></tr></table>");
	//_____________________________________ HTTP POST
	//SoapSample(resource, response_len, soapEnvelopeSample, true, out_html);
	//out_html.WriteText(responseXml);
	//out_html.WriteText(L"</td></tr></table>");
}

void Service::SoapSample(const wstring& resource, const int response_len, Sys::SoapEnvelope& sample, bool isHttpPost, Sys::ITextWriterW& out_html)
{
	wstring text;
	if (isHttpPost == true)
	{
		Sys::Format(text, L"<h3>HTTP POST</h3>", sample.majorVersion, sample.minorVersion);
	}
	else
	{
		Sys::Format(text, L"<h3>SOAP %d.%d</h3>", sample.majorVersion, sample.minorVersion);
	}
	out_html.WriteText(text);
	//___________________________________ Create SOAP Action
	wstring soapAction = soapEnvelope.ActionXmlns;
	if (soapAction.empty() == false)
	{
		size_t len = soapAction.size();
		if (soapAction[len-1] != '/') soapAction += '/';
	}
	soapAction += soapEnvelope.ActionName;
	//_________HTTP Request
	Web::HttpRequest httpRequest;
	httpRequest.Create(sample);
	httpRequest.method = L"POST";
	if (isHttpPost == true)
	{
		httpRequest.head[L"Content-type"] = L"application/x-www-form-urlencoded";
	}
	else
	{
		if (sample.minorVersion == 1)
		{
			httpRequest.head[L"Content-type"] = L"text/xml; charset=utf-8";
			httpRequest.head[L"SOAPAction"] = soapAction;
		}
		else
		{
			httpRequest.head[L"Content-type"] = L"application/soap+xml; charset=utf-8";
		}
	}
	httpRequest.resource = resource;
	out_html.WriteText(L"<span style=\"color:#606070\">HTTP Request</span><br /><table style=\"background-color:#FFFFFF;border-width:1px;border-color:#909090;border-style:solid;width:100%\"><tr style=\"width:100%\"><td style=\"width:100%\">");
	out_html.WriteText(L"<span style=\"color:#8080A0\">");
	httpRequest.GetHeadHtml(false, text);
	out_html.WriteText(text);
	out_html.WriteText(L"</span>");
	sample.GetHtml(text);
	out_html.WriteText(text);
	out_html.WriteText(L"</td></tr></table><br /><br />");
	//_________HTTP Response
	Web::HttpResponse httpResponse;
	httpResponse.body.SetSize(response_len);
	httpResponse.code = 200; // OK
	if (isHttpPost == true)
	{
		httpResponse.head[L"Content-type"] = L"text/xml; charset=utf-8";
	}
	else
	{
		if (sample.minorVersion == 1)
		{
			httpResponse.head[L"Content-type"] = L"text/xml; charset=utf-8";
		}
		else
		{
			httpResponse.head[L"Content-type"] = L"application/soap+xml; charset=utf-8";
		}
	}
	out_html.WriteText(L"<span style=\"color:#606070\">HTTP Response</span><br /><table style=\"background-color:#FFFFFF;border-width:1px;border-color:#909090;border-style:solid;width:100%\"><tr style=\"width:100%\"><td style=\"width:100%\">");
	out_html.WriteText(L"<span style=\"color:#8080A0\">");
	httpResponse.GetHeadHtml(false, text);
	out_html.WriteText(text);
	out_html.WriteText(L"</span>");
	//out_html.WriteText(responseXml);
	//out_html.WriteText(L"</td></tr></table>");
}

void Service::GetXml(Web::HttpConnector& httpConnector)
{
	soapEnvelope.ActionName = Text;
	soapEnvelope.ActionName += L"Response";
	wstring xmlError;
	if (httpConnector.soapXmlError.empty() == false)
	{
		httpConnector.WriteText(httpConnector.soapXmlError);
		return;
	}
	soapEnvelope.GetXmlText(httpConnector);
}

void Service::LoadState(Web::HttpConnector& httpConnector)
{
	wstring xmlns;
	if (httpConnector.GetVariable(L"soapEvelopeXmlns", xmlns) == true)
	{
		const size_t xmlns_size = xmlns.size();
		if (xmlns_size > 0)
		{
			//___________________________________________________ Create encoding
			wstring encoding(xmlns);
			Sys::TextAssistant::Replace(encoding, L"soap-envelope", L"soap-encoding", true);
			//________________________________________________
			soapEnvelope.SetAttribute(L"xmlns:soap", xmlns.c_str());
			soapEnvelope.SetAttribute(L"soap:encodingStyle", encoding.c_str());
		}
	}
}

void Service::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_____________________________________________________________________ ListItem
ListItem::ListItem()
{
}

ListItem::~ListItem()
{
}

void ListItem::Clear()
{
	Selected = false;
	Text.clear();
	Data.clear();
}

bool ListItem::operator==(const ListItem& init) const
{
	if (Text != init.Text) return false;
	if (Data != init.Data) return false;
	if (Selected != init.Selected) return false;
	return true;
}

bool ListItem::operator!=(const ListItem& init) const
{
	if (Text != init.Text) return true;
	if (Data != init.Data) return true;
	if (Selected != init.Selected) return true;
	return false;
}

//_____________________________________________________________________ ListItemCollection
ListItemCollection::ListItemCollection(void)
{
	//_selectedIndex = -1;
}

ListItemCollection::~ListItemCollection(void)
{
}

bool ListItemCollection::operator==(const ListItemCollection& init) const
{
	const size_t len = storage.size();
	if (len != init.storage.size()) return false;
	for(size_t i = 0; i<len; i++)
	{
		if (storage[i] != init.storage[i]) return false;
	}
	//if (this->_selectedIndex != init._selectedIndex) return false;
	return true;
}

bool ListItemCollection::operator!=(const ListItemCollection& init) const
{
	const size_t len = storage.size();
	if (len != init.storage.size()) return true;
	for(size_t i = 0; i<len; i++)
	{
		if (storage[i] != init.storage[i]) return true;
	}
	//if (this->_selectedIndex != init._selectedIndex) return true;
	return false;
}

Web::ListItem& ListItemCollection::operator[](long index)
{
	return storage[index];
}

bool ListItemCollection::Delete(int index)
{
	const int len = (int)storage.size();
	if (index < 0 || index >= len) return false;
	vector<Web::ListItem>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

//___________________________ returns the index if the data is already set during LoadState
//int ListItemCollection::GetLoadItemIndex(const wchar_t* data)
//{
//	if (data == NULL) return -1;
//	const vector<Web::ListItem>::iterator itemEnd = storage.end();
//	vector<Web::ListItem>::iterator p;
//	int index = 0;
//	for(p = storage.begin(); p != itemEnd; p++, index++)
//	{
//		if (p->Text.length() != 1) continue;
//		if (p->Text[0] != '-') continue;
//		if (p->Data == data) return index;
//	}
//	return -1;
//}

//void ListItemCollection::Add(const wchar_t* text, const wchar_t* data, bool selected)
//{
//	Web::ListItem item;
//	item.Text = text;
//	item.Data = data;
//	item.Selected = selected;
//	const int index = GetLoadItemIndex(data);
//	if (index == -1)
//	{
//		item.Selected = selected;
//		storage.push_back(item);
//	}
//	else // There is an item with the same data
//	{
//		item.Selected = true; // Keep the selection that was set during LoadState()
//		storage[index] = item;
//	}
//}

//void ListItemCollection::Add(const wstring& text, const wstring& data, bool selected)
//{
//	Add(text.c_str(), data.c_str(), selected);
//}

void ListItemCollection::Add(const wchar_t* text, const wchar_t* data)
{
	Web::ListItem item;
	item.Text = text;
	item.Data = data;
	set<wstring>::iterator p = _selectedData.find(data);
	item.Selected = (p  != _selectedData.end());
	storage.push_back(item);
}

void ListItemCollection::Add(const wstring& text, const wstring& data)
{
	Add(text.c_str(), data.c_str());
}

int ListItemCollection::GetCount()
{
	return (int)storage.size();
}

int ListItemCollection::GetIndex(const wstring& text)
{
	return GetIndex(text.c_str());
}

int ListItemCollection::GetIndex(const wchar_t* text)
{
	vector<Web::ListItem>::iterator pEnd = storage.end();
	int index = 0;
	for (vector<Web::ListItem>::iterator p = storage.begin(); p != pEnd; p++, index++)
	{
		if (p->Text == text)
		{
			return index;
		}
	}
	return -1;
}

void ListItemCollection::DeleteAll()
{
	storage.clear();
}

//________________________________________________________ DropDownList
DropDownList::DropDownList()
{
	_rowCount = 1;
}

DropDownList::~DropDownList()
{
}

wstring& DropDownList::GetText()
{
	return _text;
}

void DropDownList::SetText(const wstring& text)
{
	_text = text;
}

void DropDownList::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool DropDownList::IsVisible()
{
	return VisibleObject::IsVisible();
}

void DropDownList::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool DropDownList::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

int DropDownList::GetItemCount()
{
	return (int)Items.storage.size();
}

void DropDownList::AddItem(const wchar_t* text, LPARAM data)
{
	wchar_t text_data[32];
	_snwprintf_s(text_data, 32, _TRUNCATE, L"%d", (int)data);
	Items.Add(text, text_data);
}

void DropDownList::AddItem(const wstring& text, LPARAM data)
{
	wchar_t text_data[32];
	_snwprintf_s(text_data, 32, _TRUNCATE, L"%d", (int)data);
	Items.Add(text, text_data);
}

bool DropDownList::DeleteItem(int index)
{
	return Items.Delete(index);
}

void DropDownList::DeleteAllItems()
{
	return Items.DeleteAll();
}

bool DropDownList::GetItemText(int index, wstring& out_text)
{
	out_text.clear();
	const int len = (int)Items.storage.size();
	if (index < 0 || index >= len) return false;
	out_text = Items.storage[index].Text;
	return true;
}

bool DropDownList::GetItemText(int index, wchar_t* buffer, int buffer_length)
{
	const int len = (int)Items.storage.size();
	if (index < 0 || index >= len) return false;
	_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"%s", Items.storage[index].Text.c_str());
	return true;
}

LPARAM DropDownList::GetItemData(int index)
{
	const int len = (int)Items.storage.size();
	if (index < 0 || index >= len) return -1;
	return Sys::Convert::ToInt(Items.storage[index].Data);
}

bool DropDownList::SetItemData(int index, const LPARAM data)
{
	const int len = (int)Items.storage.size();
	if (index < 0 || index >= len) return false;
	//
	wchar_t text_data[32];
	_snwprintf_s(text_data, 32, _TRUNCATE, L"%d", (int)data);
	Items.storage[index].Data = text_data;
	return true;
}

bool DropDownList::GetSelectedData(LPARAM& out_data)
{
	out_data = -1;
	const int index = GetSelectedIndex();
	if (index < 0) return false;
	out_data = Sys::Convert::ToInt(Items.storage[index].Data);
	return true;
}

bool DropDownList::SetSelectedByData(LPARAM data)
{
	const int index = GetSelectedIndex();
	if (index < 0) return false;
	return SetItemData(index, data);
}

void DropDownList::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_____________________________________________________________________ Sys::ISelectInt
LPARAM& DropDownList::SqlGetInt()
{
	return _sqlData;
}

void DropDownList::SqlUpdate(bool toGui)
{
	if (toGui == true)
	{
		const int count = this->Items.GetCount();
		for(int i = 0; i<count; i++)
		{
			if (Sys::Convert::ToInt(this->Items[i].Data) == _sqlData)
			{
				this->SetSelectedIndex(i);
				break;
			}
		}
	}
	else
	{
		GetSelectedData(_sqlData);
	}
}

wstring DropDownList::GetSelectedTextData()
{
	if (Items.storage.empty() == true)
	{
		if (Items._selectedData.empty() != false)
		{
			return *Items._selectedData.begin();
		}
	}
	else
	{
		vector<Web::ListItem>::iterator pEnd = Items.storage.end();
		for (vector<Web::ListItem>::iterator p = Items.storage.begin(); p != pEnd; p++)
		{
			if (p->Selected == true)
			{
				return p->Data;
			}
		}
	}
	return L"";
}

// data[0] must be an integer primary key, data[1] must be the caption shown to the user
void DropDownList::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	if (colCount>=2)
	{
		this->Items.Add(data[1], data[0]);
	}
	else if (colCount==1)
	{
		this->Items.Add(data[0], L"");
	}
}

bool DropDownList::SetSelectedIndex(int index)
{
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (i == index)
		{
			Items.storage[i].Selected =  true;
			//Items._selectedIndex = i;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

int DropDownList::GetSelectedIndex()
{
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Selected ==  true) return i;
	}
	return -1;
}

bool DropDownList::SetSelected(const wchar_t* text)
{
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Text ==  text)
		{
			Items.storage[i].Selected = true;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

bool DropDownList::SetSelectedByTextData(const wstring& data)
{
	//_selectedData = data; // We store a copy in case there are no items
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Data ==  data)
		{
			Items.storage[i].Selected = true;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

//void DropDownList::RenderInvisible(int& indentCount, Sys::ITextWriterW& out_html)
//{
//	RenderHiddenValue(false, indentCount, GetSelectedData().c_str(), out_html);
//}

void DropDownList::RenderMultipleSelection(Sys::ITextWriterW& out_html)
{
}

void DropDownList::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//_______________________________________________________ <input type ="select"
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"disabled", out_html);
	if (_rowCount == HTML_SIZE_AUTO)
	{
		RenderPair(L"size", 8, out_html);
	}
	else
	{
		RenderPair(L"size", _rowCount, out_html);
	}
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	RenderMultipleSelection(out_html);
	out_html.WriteText(L" />");
	//____________________________________________________ Options
	vector<Web::ListItem>::iterator p = Items.storage.begin();
	const vector<Web::ListItem>::iterator pEnd = Items.storage.end();
	for(; p != pEnd; p++)
	{
		out_html.WriteText(L"<option value=\"");
		out_html.WriteText(p->Data);
		out_html.WriteText(L"\"");
		if (p->Selected == true) out_html.WriteText(L" selected");
		out_html.WriteText(L">");
		out_html.WriteText(p->Text);
		out_html.WriteText(L"</option>");
	}
	out_html.WriteText(L"</select>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void DropDownList::GetXml(Web::HttpConnector& httpConnector)
{
	wstring xmlText;
	CreateXmlNode(httpConnector, ID.c_str(), L"SE", false);
	const int itemCount = (int)Items.storage.size();
	const vector<Web::ListItem>::iterator itemEnd = Items.storage.end();
	vector<Web::ListItem>::iterator item;
	wstring xmlValue;
	//__________________________________ Items (Options) 
	for(item = Items.storage.begin(); item != itemEnd; item++)
	{
		httpConnector.WriteText(L"<o><n>"); // <option><name>
		Sys::Convert::ToXml(item->Text, xmlValue);
		httpConnector.WriteText(xmlValue);
		httpConnector.WriteText(L"</n><v>"); // </name><value>
		Sys::Convert::ToXml(item->Data, xmlValue);
		httpConnector.WriteText(xmlValue);
		if (item->Selected == true)
		{
			httpConnector.WriteText(L"</v><s>true</s></o>"); // </value><selected>true</selected></option>
		}
		else
		{
			httpConnector.WriteText(L"</v><s>false</s></o>"); // </value><selected>false</selected></option>
		}
	}
	httpConnector.WriteText(L"</c>");
}

void DropDownList::LoadState(Web::HttpConnector& httpConnector)
{
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator control;
		if (Web::VisibleObject::LoadState(httpConnector, false, control) == false) return;
		//_________________________________________________ Items
		list<Sys::Xml>::const_iterator element = control->child.begin();
		const list<Sys::Xml>::const_iterator element_end = control->child.end();
		for(; element != element_end; element++)
		{
			if (element->name == L"d") Items._selectedData.insert(element->value);
		}
	}
	else
	{
		wstring name(ID);
		name += L"Data";
		pair<multimap<wstring,wstring>::iterator,multimap<wstring,wstring>::iterator> ret;
		ret = httpConnector.value.equal_range(name);
		if (ret.first == httpConnector.value.end()) return;
		if (ret.second == httpConnector.value.end()) return;
		for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
		{
			Items._selectedData.insert((*state).second);
		}
	}
}

wchar_t* DropDownList::GetTag()
{
	return L"select";
}

//________________________________________________________ ListBox
ListBox::ListBox()
{
	_rowCount = 8;
	_multipleSelection = false;
}

ListBox::~ListBox()
{
}

int ListBox::GetItemCount()
{
	return Web::DropDownList::GetItemCount();
}

void ListBox::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	Web::DropDownList::Enumerate(data, colCount, rowIndex);
}

wstring& ListBox::GetText()
{
	return VisibleObject::GetText();
}

void ListBox::SetText(const wstring& text)
{
	VisibleObject::SetText(text);
}

void ListBox::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool ListBox::IsVisible()
{
	return VisibleObject::IsVisible();
}

void ListBox::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool ListBox::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

LPARAM& ListBox::SqlGetInt()
{
	return Web::DropDownList::SqlGetInt();
}

void ListBox::SqlUpdate(bool toGui)
{
	Web::DropDownList::SqlUpdate(toGui);
}

void ListBox::AddItem(const wchar_t* text, LPARAM data)
{
	DropDownList::AddItem(text, data);
}

void ListBox::AddItem(const wstring& text, LPARAM data)
{
	DropDownList::AddItem(text, data);
}

bool ListBox::DeleteItem(int index)
{
	return DropDownList::DeleteItem(index);
}

void ListBox::DeleteAllItems()
{
	DropDownList::DeleteAllItems();
}

bool ListBox::GetItemText(int index, wstring& out_text)
{
	return DropDownList::GetItemText(index, out_text);
}

bool ListBox::GetItemText(int index, wchar_t* buffer, int buffer_length)
{
	return DropDownList::GetItemText(index, buffer, buffer_length);
}

LPARAM ListBox::GetItemData(int index)
{
	return DropDownList::GetItemData(index);
}

bool ListBox::SetItemData(int index, const LPARAM data)
{
	return DropDownList::SetItemData(index, data);
}

int ListBox::GetSelectedIndex()
{
	return DropDownList::GetSelectedIndex();
}

bool ListBox::SetSelectedIndex(int index)
{
	return DropDownList::SetSelectedIndex(index);
}

bool ListBox::GetSelectedData(LPARAM& out_data)
{
	return DropDownList::GetSelectedData(out_data);
}

bool ListBox::SetSelectedByData(LPARAM data)
{
	return DropDownList::SetSelectedByData(data);
}

bool ListBox::IsItemSelected(int index)
{
	const int len = (int)Items.storage.size();
	if (index < 0 || index >= len) return false;
	return Items.storage[index].Selected;
}

bool ListBox::SetSelection(int index, bool selected)
{
	if (index == -1)
	{
		if (selected == true)
		{
			for_each(Items.storage.begin(), Items.storage.end(), [] (Web::ListItem& n) { n.Selected = true; });
		}
		else
		{
			for_each(Items.storage.begin(), Items.storage.end(), [] (Web::ListItem& n) { n.Selected = false; });
		}
		return true;
	}
	else
	{
		const int len = (int)Items.storage.size();
		if (index < 0 || index >= len) return false;
		Items.storage[index].Selected = selected;
	}
	return true;
}

void ListBox::SetMultipleSelection(bool multipleSelection)
{
	_multipleSelection = multipleSelection;
}

bool ListBox::GetMultipleSelection()
{
	return _multipleSelection;
}

void ListBox::RenderMultipleSelection(Sys::ITextWriterW& out_html)
{
	if (_multipleSelection == true) out_html.WriteText(L" multiple=\"multiple\"");
}

//void ListBox::LoadState(Web::HttpConnector& httpConnector)
//{
//	const int len = Items.storage.size();
//	int i = 0;
//	wstring name(ID);
//	name += L"Data";
//	SetSelected(-1, false); // Unselect All
//	pair<multimap<wstring,wstring>::iterator,multimap<wstring,wstring>::iterator> ret;
//	ret = httpConnector.value.equal_range(name);
//	bool found = false;
//	if (ret.first == httpConnector.value.end()) return;
//	if (ret.second == httpConnector.value.end()) return;
//
//	if (len == 0) //__________________________________ If empty, then insert all the selected items
//	{
//		Web::ListItem listItem;
//		listItem.Selected = true;
//		listItem.Text = L"-";
//		for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
//		{
//			listItem.Data = (*state).second;
//			Items.storage.push_back(listItem);
//		}
//	}
//	else//__________________________________ If NOT empty, then sync the selection
//	{
//		for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
//		{
//			for(i = 0; i<len; i++)
//			{
//				if (Items.storage[i].Data ==  (*state).second)
//				{
//					Items.storage[i].Selected = true;
//					if (found == false) // Set the selected index to the first selected element
//					{
//						Items._selectedIndex = i;
//						found = true;
//					}
//				}
//			}
//		}
//	}
//}

void ListBox::SetHeight(int height)
{
	_rowCount = height;
}

int ListBox::GetHeight()
{
	return _rowCount;
}

//void ListBox::RenderInvisible(int& indentCount, Sys::ITextWriterW& out_html)
//{
//	const vector<ListItem>::iterator itemEnd = Items.storage.end();
//	for(vector<ListItem>::iterator item = Items.storage.begin(); item != itemEnd; item++)
//	{
//		if (item->Selected == true)
//		{
//			RenderHiddenValue(false, indentCount, item->Data.c_str(), out_html);
//		}
//	}
//}


//_____________________________________________________________________ ListViewItem
ListViewItem::ListViewItem()
{
}

ListViewItem::~ListViewItem()
{
}

bool ListViewItem::operator==(const ListViewItem& init) const
{
	if (Text != init.Text) return false;
	if (Data != init.Data) return false;
	if (Selected != init.Selected) return false;
	return true;
}

bool ListViewItem::operator!=(const ListViewItem& init) const
{
	if (Text != init.Text) return true;
	if (Data != init.Data) return true;
	if (Selected != init.Selected) return true;
	return false;
}

void ListViewItem::Clear()
{
	Text.clear();
	Data.clear();
	Selected = false;
}

//_____________________________________________________________________ CheckBoxItem
CheckBoxItem::CheckBoxItem()
{
}

CheckBoxItem::~CheckBoxItem()
{
}

bool CheckBoxItem::operator==(const CheckBoxItem& init) const
{
	if (Text != init.Text) return false;
	if (Data != init.Data) return false;
	if (Checked != init.Checked) return false;
	return true;
}

bool CheckBoxItem::operator!=(const CheckBoxItem& init) const
{
	if (Text != init.Text) return true;
	if (Data != init.Data) return true;
	if (Checked != init.Checked) return true;
	return false;
}
//_____________________________________________________________________ ListViewColumn

//_____________________________________________________________________ CheckBoxColumn

//_____________________________________________________________________ ListViewItemCollection
ListViewItemCollection::ListViewItemCollection(void)
{
	colsCollection = NULL;
	//_selectedIndex = -1;
}

ListViewItemCollection::~ListViewItemCollection(void)
{
}

bool ListViewItemCollection::operator==(const ListViewItemCollection& init) const
{
	const size_t len = storage.size();
	if (len != init.storage.size()) return false;
	for(size_t i = 0; i<len; i++)
	{
		if (storage[i] != init.storage[i]) return false;
	}
	return true;
}

Web::ListViewItem& ListViewItemCollection::operator[](long index)
{
	return storage[index];
}

bool ListViewItemCollection::Delete(int index)
{
	const int len = (int)storage.size();
	if (index < 0 || index >= len) return false;
	vector<Web::ListViewItem>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

//___________________________ returns the index if the data is already set during LoadState
//int ListViewItemCollection::GetLoadItemIndex(const wchar_t* data)
//{
//	if (data == NULL) return -1;
//	const vector<Web::ListViewItem>::iterator itemEnd = storage.end();
//	vector<Web::ListViewItem>::iterator p;
//	int colCount = 0;
//	int index = 0;
//	int i = 0;
//	bool isPreLoad = true;
//	for(p = storage.begin(); p != itemEnd; p++, index++)
//	{
//		if (index == 0) colCount = (int)p->Text.size();
//		isPreLoad = true;
//		for(i = 0; i < colCount; i++)
//		{
//			if (p->Text[i].length() != 1)
//			{
//				isPreLoad = false;
//				break;
//			}
//			if (p->Text[i][0] != '-')
//			{
//				isPreLoad = false;
//				break;
//			}
//		}
//		if (isPreLoad == true)
//		{
//			if (p->Data == data) return index;
//		}
//	}
//	return -1;
//}

//void ListViewItemCollection::Add(const wchar_t* text, const wchar_t* data, bool selected)
//{
//	Web::ListViewItem item;
//	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
//	item.Text[0] = text;
//	item.Data = data;
//	item.Selected = selected;
//	const int index = GetLoadItemIndex(data);
//	if (index == -1)
//	{
//		storage.push_back(item);
//		if (selected == true)
//		{
//			_selectedIndex = (int)storage.size() - 1;
//		}
//	}
//	else
//	{
//		storage[index] = item;
//		if (selected == true)
//		{
//			_selectedIndex = index;
//		}
//	}
//}

//void ListViewItemCollection::Add(const wstring& text, const wstring& data, bool selected)
//{
//	Add(text.c_str(), data.c_str(), selected);
//}

void ListViewItemCollection::Add(const wchar_t* text, const wchar_t* data)
{
	Web::ListViewItem item;
	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
	item.Text[0] = text;
	item.Data = data;
	set<wstring>::iterator p = _selectedData.find(data);
	item.Selected = (p != _selectedData.end());
	storage.push_back(item);
}

void ListViewItemCollection::Add(const wstring& text, const wstring& data)
{
	Add(text.c_str(), data.c_str());
}

int ListViewItemCollection::GetCount()
{
	return (int)storage.size();
}

int ListViewItemCollection::GetIndex(const wstring& text)
{
	return GetIndex(text.c_str());
}

int ListViewItemCollection::GetIndex(const wchar_t* text)
{
	vector<Web::ListViewItem>::iterator pEnd = storage.end();
	int index = 0;
	for (vector<Web::ListViewItem>::iterator p = storage.begin(); p != pEnd; p++, index++)
	{
		if (p->Text[0] == text)
		{
			return index;
		}
	}
	return -1;
}

void ListViewItemCollection::DeleteAll()
{
	storage.clear();
	//_selectedIndex = -1;
}

//_____________________________________________________________________ CheckBoxItemCollection
CheckBoxItemCollection::CheckBoxItemCollection(void)
{
	colsCollection = NULL;
}

CheckBoxItemCollection::~CheckBoxItemCollection(void)
{
}

bool CheckBoxItemCollection::operator==(const CheckBoxItemCollection& init) const
{
	const size_t len = storage.size();
	if (len != init.storage.size()) return false;
	for(size_t i = 0; i<len; i++)
	{
		if (storage[i] != init.storage[i]) return false;
	}
	return true;
}

Web::CheckBoxItem& CheckBoxItemCollection::operator[](long index)
{
	return storage[index];
}

bool CheckBoxItemCollection::Delete(int index)
{
	const int len = (int)storage.size();
	if (index < 0 || index >= len) return false;
	vector<Web::CheckBoxItem>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

//___________________________ returns the index if the data is already set during LoadState
//int CheckBoxItemCollection::GetLoadItemIndex(const wchar_t* data)
//{
//	if (data == NULL) return -1;
//	const vector<Web::CheckBoxItem>::iterator itemEnd = storage.end();
//	vector<Web::CheckBoxItem>::iterator p;
//	int colCount = 0;
//	int index = 0;
//	int i = 0;
//	bool isPreLoad = true;
//	for(p = storage.begin(); p != itemEnd; p++, index++)
//	{
//		if (index == 0) colCount = (int)p->Text.size();
//		isPreLoad = true;
//		for(i = 0; i < colCount; i++)
//		{
//			if (p->Text[i].length() != 1)
//			{
//				isPreLoad = false;
//				break;
//			}
//			if (p->Text[i][0] != '-')
//			{
//				isPreLoad = false;
//				break;
//			}
//		}
//		if (isPreLoad == true)
//		{
//			if (p->Data == data) return index;
//		}
//	}
//	return -1;
//}

//void CheckBoxItemCollection::Add(const wchar_t* text, const wchar_t* data, bool checked)
//{
//	Web::CheckBoxItem item;
//	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
//	item.Text[0] = text;
//	item.Data = data;
//	item.Checked = checked;
//	const int index = GetLoadItemIndex(data);
//	if (index == -1)
//	{
//		storage.push_back(item);
//	}
//	else
//	{
//		storage[index] = item;
//	}
//}

//void CheckBoxItemCollection::Add(const wstring& text, const wstring& data, bool checked)
//{
//	Add(text.c_str(), data.c_str(), checked);
//}

void CheckBoxItemCollection::Add(const wchar_t* text, const wchar_t* data)
{
	Web::CheckBoxItem item;
	if (this->colsCollection != NULL) item.Text.resize(colsCollection->size());
	item.Text[0] = text;
	item.Data = data;
	set<wstring>::iterator p = _selectedData.find(data);
	item.Checked = (p != _selectedData.end());
	storage.push_back(item);
}

void CheckBoxItemCollection::Add(const wstring& text, const wstring& data)
{
	Add(text.c_str(), data.c_str());
}

int CheckBoxItemCollection::GetCount()
{
	return (int)storage.size();
}

//The return value is the zero-based index of the matching item. If the search is unsuccessful, it is -1
int CheckBoxItemCollection::GetIndex(const wchar_t* text)
{
	vector<Web::CheckBoxItem>::iterator pEnd = storage.end();
	int index = 0;
	for (vector<Web::CheckBoxItem>::iterator p = storage.begin(); p != pEnd; p++, index++)
	{
		if (p->Text[0] == text)
		{
			return index;
		}
	}
	return -1;
}

void CheckBoxItemCollection::DeleteAll()
{
	storage.clear();
}

//_____________________________________________________________________ ListViewColCollection
ListViewColCollection::ListViewColCollection(void)
{
}

ListViewColCollection::~ListViewColCollection(void)
{
}

// truncated is passed to reduce memory allocation time at each function call
void ListViewColCollection::RenderColumn(const wstring& text, vector<Web::ListViewColumn>::iterator& col, const wchar_t * space, wstring& truncated, Sys::ITextWriterW& out_html)
{
	const int len = (int)text.length();
	const int remaining = col->width - len-1; //left one space between columns
	if (remaining < 0)//__________________________________________________ Truncate Text
	{
		const int lenTruncated = col->width - 4; // ...&nbsp;
		truncated.assign(text.begin(), text.begin()+lenTruncated);
		out_html.WriteText(truncated);
		out_html.WriteText(L"... ");
	}
	else if (remaining == 0)//__________________________________________________ Exact Text
	{
		out_html.WriteText(text);
		out_html.WriteText(space);
	}
	else//______________________________________________________________ Complete Text
	{
		int i;
		if (col->format == LVCFMT_LEFT)//________________ LEFT
		{
			out_html.WriteText(text);
			for(i = 0; i < remaining+1; i++) out_html.WriteText(space);
		}
		else if (col->format == LVCFMT_RIGHT)//____________ RIGHT
		{
			for(i = 0; i < remaining; i++) out_html.WriteText(space);
			out_html.WriteText(text);
			out_html.WriteText(space);
		}
		else //_________________________________________ CENTER
		{
			const int beginCount = remaining/2;
			for(i=0; i < beginCount; i++) out_html.WriteText(space);
			out_html.WriteText(text);
			const int remainCount = remaining - beginCount;
			for(i=0; i < remainCount+1; i++) out_html.WriteText(space);
		}
	}
}

int ListViewColCollection::GetTotalWidth()
{
	const vector<Web::ListViewColumn>::iterator colEnd = storage.end();
	int totalLen = 0;
	for(vector<Web::ListViewColumn>::iterator col = storage.begin(); col != colEnd; col++)
	{
		totalLen += col->width;
	}
	return totalLen;
}

void ListViewColCollection::GetHtml(int fontSize, int width, const wstring& ID, Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//________________________________________________ You add this because IE does not properly compute the
	//________________________________________________ control width. You may remove it, if the problem is solved
	//________________________________________________ by Microsoft in the future
	wchar_t text[256];
	if (width == -1)
	{
		_snwprintf_s(text, 256, _TRUNCATE, 
			L"<tr><td><select size=\"1\" class=\"Header\" style=\"width:100%%;font-size:%dpx;white-space:pre;font-family:'Courier New','Courier','monospace','Lucida Console','Monaco';-webkit-appearance:menulist-text\" name=\"%sHead\" id=\"%sHead\" />", 
			fontSize, ID.c_str(), ID.c_str());
	}
	else
	{
		_snwprintf_s(text, 256, _TRUNCATE, 
			L"<tr><td><select size=\"1\" class=\"Header\" style=\"width:%dpx;font-size:%dpx;white-space:pre;font-family:'Courier New','Courier','monospace','Lucida Console','Monaco';-webkit-appearance:menulist-text\",  name=\"%sHead\" id=\"%sHead\" />", 
			width, fontSize, ID.c_str(), ID.c_str());
	}
	out_html.WriteText(text);
	int i = 0;
	vector<Web::ListViewColumn>::iterator col;
	const vector<Web::ListViewColumn>::iterator colEnd = storage.end();

	//____________________________________________ Column
	out_html.WriteText(L"<option value=\"0\">");
	wstring truncated;

	for(col = storage.begin(); col != colEnd; col++)
	{
		RenderColumn(col->Text, col,  L"&nbsp;", truncated, out_html);
	}
	out_html.WriteText(L"</option>");
	out_html.WriteText(L"</select>");
	//________________________________________________________________ Hidden Variable for columns information
	//out_html.WriteText(L"<input type=\"hidden\" id=\"");
	//out_html.WriteText(ID);
	//out_html.WriteText(L"Col\" name=\"");
	//out_html.WriteText(ID);
	//out_html.WriteText(L"Col\" value=\"");
	//vector<Web::ListViewColumn>::iterator column = storage.begin();
	//const vector<Web::ListViewColumn>::iterator column_end = storage.end();
	//for ( ; column != column_end; column++)
	//{
	//	_snwprintf_s(text, 256, L"%d;%d;%d;", (int)column->format, column->width, (int)column->Text.size());
	//	out_html.WriteText(text);
	//	out_html.WriteText(column->Text);
	//}
	//out_html.WriteText(L"\" /></td></tr>");
	out_html.WriteText(L"</td></tr>");
}

void ListViewColCollection::GetXml(const wstring& ID, Web::HttpConnector& httpConnector)
{
	// We do not support changing columns using AJAX
}

void ListViewColCollection::LoadState(bool ajax, const wstring& ID, Web::HttpConnector& httpConnector)
{
	if (ajax == true)
	{
		wstring colID = ID;
		colID += L"Col";
		list<Sys::Xml>::const_iterator control;
		if (httpConnector.GetAjaxControlIterator(colID.c_str(), control) == false) return;
		//________________________________________________________________________ Find the value
		list<Sys::Xml>::const_iterator element = control->child.begin();
		const list<Sys::Xml>::const_iterator element_end = control->child.end();
		for(; element != element_end; element++)
		{
			if (element->name == L"value")
			{
				string utf8;
				wstring data;
				Sys::Convert::HexToUTF8(element->value.c_str(), utf8);
				Sys::Convert::UTF8ToWstring(utf8, data);
				CreateFromValue(data);
				break;
			}
		}
	}
	else
	{
		// Not required
	}
}

void ListViewColCollection::CreateFromValue(const wstring& input)
{
	const int len = (int)input.length();
	wchar_t text[256];
	int i = 0, j = 0;
	Web::ListViewColumn column;
	column.format = LVCFMT_LEFT;
	column.width = 0;
	column.Text.clear();

	int text_len = 0;
	while (i < len)
	{
		//___________________________________ Format
		for(j = 0; i < len && j < 10; i++, j++)
		{
			if (input[i] == ';')
			{
				text[j] = '\0';
				column.format= _wtoi (text);
				i++; // Move after ;
				break;
			}
			text[j] = input[i];
		}
		//___________________________________ width
		for(j = 0; i < len && j < 10; i++, j++)
		{
			if (input[i] == ';')
			{
				text[j] = '\0';
				column.width = _wtoi (text);
				i++; // Move after ;
				break;
			}
			text[j] = input[i];
		}
		//___________________________________ text_len
		for(j = 0; i < len && j < 10; i++, j++)
		{
			if (input[i] == ';')
			{
				text[j] = '\0';
				text_len = _wtoi (text);
				i++; // Move after ;
				break;
			}
			text[j] = input[i];
		}
		//___________________________________ Column Text
		column.Text.resize(text_len);
		for(j = 0; i < len && j < text_len; i++, j++)
		{
			column.Text[j] = input[i];
		}
		storage.push_back(column);
		//
		column.format = LVCFMT_LEFT;
		column.width = 0;
		column.Text.clear();
	}
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool ListViewColCollection::Add(int format, int width, const wchar_t* text)
{

	ListViewColumn col;
	col.format = format;
	col.width = width;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool ListViewColCollection::Add(int format, int width, wstring& text)
{
	ListViewColumn col;
	col.format = format;
	col.width = width;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

bool ListViewColCollection::Delete(int index)
{
	const int len = (int)storage.size();
	if (index<0 || index >= len) return false;
	vector<ListViewColumn>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

void ListViewColCollection::DeleteAll(void)
{
	storage.clear();
}

int ListViewColCollection::GetCount()
{
	return (int)storage.size();
}

Web::ListViewColumn& ListViewColCollection::operator[](long index)
{
	return storage[index];
}

//_____________________________________________________________________ CheckBoxColCollection
CheckBoxColCollection::CheckBoxColCollection(void)
{
}

CheckBoxColCollection::~CheckBoxColCollection(void)
{
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool CheckBoxColCollection::Add(int format, const wchar_t* text)
{
	CheckBoxColumn col;
	col.format = format;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

//format: LVCFMT_LEFT, LVCFMT_CENTER, LVCFMT_RIGHT
bool CheckBoxColCollection::Add(int format, wstring& text)
{
	CheckBoxColumn col;
	col.format = format;
	col.Text = text;
	try
	{
		storage.push_back(col);
	}
	catch(const std::bad_alloc&)
	{
		return false;
	}
	return true;
}

bool CheckBoxColCollection::Delete(int index)
{
	const int len = (int)storage.size();
	if (index<0 || index >= len) return false;
	vector<CheckBoxColumn>::iterator p = storage.begin()+index;
	storage.erase(p);
	return true;
}

void CheckBoxColCollection::DeleteAll(void)
{
	storage.clear();
}

int CheckBoxColCollection::GetCount()
{
	return (int)storage.size();
}

Web::CheckBoxColumn& CheckBoxColCollection::operator[](long index)
{
	return storage[index];
}

//________________________________________________________ ListView
ListView::ListView()
{
	Items.colsCollection = &Cols.storage;
	Height = 10;
	FontSize = 16;
	cssClass = L"Data";
	MultipleSelection = false;
}

ListView::~ListView()
{
}

wstring& ListView::GetText()
{
	return VisibleObject::GetText();
}

void ListView::SetText(const wstring& text)
{
	VisibleObject::SetText(text);
}

void ListView::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool ListView::IsVisible()
{
	return VisibleObject::IsVisible();
}

void ListView::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool ListView::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

int ListView::GetColumnCount()
{
	return (int)Cols.storage.size();
}

void ListView::AddColumn(int format, int width, const wchar_t* text)
{
	Web::ListViewColumn column;
	column.format = format;
	column.width = width;
	column.Text = text;
	Cols.storage.push_back(column);
}

void ListView::AddColumn(int format, int width, const wstring& text)
{
	AddColumn(format, width, text.c_str());
}

bool ListView::DeleteColumn(int index)
{
	return Cols.Delete(index);
}

void ListView::DeleteAllColumns()
{
	Cols.storage.clear();
}

bool ListView::GetColumnText(int index, wstring& out_text)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	out_text = Cols.storage[index].Text;
	return true;
}

bool ListView::GetColumnText(int index, wchar_t* buffer, int buffer_length)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"%s", Cols.storage[index].Text.c_str());
	return true;
}

bool ListView::SetColumnText(int index, const wstring& text)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	Cols.storage[index].Text = text;
	return true;
}

bool ListView::SetColumnText(int index, const wchar_t* text)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	Cols.storage[index].Text = text;
	return true;
}

bool ListView::GetColumnFormat(int index, int& out_format)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	out_format = Cols.storage[index].format;
	return true;
}

bool ListView::SetColumnFormat(int index, int format)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	Cols.storage[index].format = format;
	return true;
}

bool ListView::GetColumnWidth(int index, int& out_width)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	out_width = Cols.storage[index].width;
	return true;
}

bool ListView::SetColumnWidth(int index, int width)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	Cols.storage[index].width = width;
	return true;
}

int ListView::GetItemCount()
{
	return (int)Items.storage.size();
}

void ListView::AddItem(const wchar_t* text, LPARAM data)
{
	wchar_t wdata[32];
	_snwprintf_s(wdata, 32, _TRUNCATE, L"%d", (int)data);
	Items.Add(text, wdata);
}

void ListView::AddItem(const wstring& text, LPARAM data)
{
	AddItem(text.c_str(), data);
}

bool ListView::DeleteItem(int row)
{
	return Items.Delete(row);
}

void ListView::DeleteAllItems()
{
	Items.storage.clear();
}

void ListView::Delete()
{
	DeleteAllColumns();
	DeleteAllItems();
}

bool ListView::GetItemText(int row, int column, wstring& out_text)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return false;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return false;
	out_text = Items.storage[row].Text[column];
	return true;
}

int ListView::GetItemText(int row, int column, wchar_t* buffer, int buffer_length)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return 0;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return 0;
	return _snwprintf_s(buffer, buffer_length, _TRUNCATE, L"%s", Items.storage[row].Text[column].c_str());
}

bool ListView::SetItemText(int row, int column, const wstring& text)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return false;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return false;
	Items.storage[row].Text[column] = text;
	return true;
}

bool ListView::SetItemText(int row, int column, const wchar_t* text)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return false;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return false;
	Items.storage[row].Text[column] = text;
	return true;
}

bool ListView::GetItemData(int row, LPARAM& out_data)
{
	const int count = (int)Items.storage.size();
	if (row < 0 || row >= count) return false;
	out_data = (LPARAM)Sys::Convert::ToInt(Items.storage[row].Data);
	return true;
}

bool ListView::SetItemData(int row, const LPARAM data)
{
	const int count = (int)Items.storage.size();
	if (row < 0 || row >= count) return false;
	Items.storage[row].Data = Sys::Convert::ToString((int)data);
	return true;
}

bool ListView::GetSelectedData(LPARAM& out_data)
{
	const int index = GetSelectedIndex();
	if (index < 0) return false;
	return GetItemData(index, out_data);
}

bool ListView::SetSelectedByData(LPARAM data)
{
	const int count = (int)Items.storage.size();
	for(int index = 0; index < count; index++)
	{
		if ((LPARAM)Sys::Convert::ToInt(Items.storage[index].Data) == data)
		{
			return SetSelectedIndex(index);
		}
	}
	return false;
}

bool ListView::IsItemSelected(int row)
{
	const int count = (int)Items.storage.size();
	if (row < 0 || row >= count) return false;
	return Items.storage[row].Selected;
}

int ListView::GetSelectedCount()
{
	const int count = (int)Items.storage.size();
	int selectedCount = 0;
	for(int index = 0; index < count; index++)
	{
		if (Items.storage[index].Selected == true) selectedCount++;
	}
	return selectedCount;
}

int ListView::GetNextSelectedIndex(int row)
{
	int index = (row == -1) ? 0 : row + 1;
	const int count = (int)Items.storage.size();
	for(; index < count; index++)
	{
		if (Items.storage[index].Selected == true) return index;
	}
	return -1;
}

void ListView::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void ListView::RenderItem(Web::ListViewItem& item, const wchar_t * space, Sys::ITextWriterW& out_html)
{
	if (Cols.storage.empty() == true) return;
	vector<Web::ListViewColumn>::iterator col;
	const vector<Web::ListViewColumn>::iterator colEnd = Cols.storage.end();
	wstring truncated;

	int itemIndex = 0;
	for(col = Cols.storage.begin(); col != colEnd; col++, itemIndex++)
	{
		Cols.RenderColumn(item.Text[itemIndex], col,  space, truncated, out_html);
	}
}

void ListView::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	wchar_t text[256];
	//______________________________________________ table
	if (BeginHtml.length() > 0) out_html.WriteText(BeginHtml);
	//______________________________________ tag
	out_html.WriteText(L"<table");
	//______________________________________ id
	_snwprintf_s(text, 256, _TRUNCATE, L"%s_", ID.c_str());
	RenderPair(L"id", text, out_html);
	RenderClassAndStyle(out_html);
	out_html.WriteText(L">");
	//
	//_____________________________________________ caption
	if (Text.length() > 0)
	{
		out_html.WriteText(L"<caption>");
		out_html.WriteText(Text);
		out_html.WriteText(L"</caption>");
	}

	//_________________________________________________________ 1. Columns Collection
	const int _fontSize = (FontSize == HTML_SIZE_AUTO) ? 16 : FontSize;
	const int totalWidth = (int)(Cols.GetTotalWidth()*_fontSize*0.65+0.5);
	const int explorerID = httpConnector.GetExplorerID();
	if (explorerID == HTML_BROWSER_IE)
	{
		Cols.GetHtml(_fontSize, totalWidth, ID, out_html, httpConnector);
	}
	else
	{
		Cols.GetHtml(_fontSize, -1, ID, out_html, httpConnector);
	}
	//_________________________________________________________ 2. Items Collection
	if (explorerID == HTML_BROWSER_IE)
	{
		_snwprintf_s(text, 256, _TRUNCATE, 
			L"<tr><td><select style=\"width:%dpx;font-size:%dpx;white-space:pre;font-family:'Courier New','Courier','monospace','Lucida Console','Monaco';-webkit-appearance:menulist-text\"", 
				totalWidth, _fontSize);
	}
	else
	{
		_snwprintf_s(text, 256, _TRUNCATE, 
			L"<tr><td><select style=\"width:100%%;font-size:%dpx;white-space:pre;font-family:'Courier New','Courier','monospace','Lucida Console','Monaco';-webkit-appearance:menulist-text\"", 
				_fontSize);
	}
	out_html.WriteText(text);
	//
	if (MultipleSelection == true) out_html.WriteText(L" multiple=\"multiple\"");
	//
	RenderName(out_html);
	//_snwprintf_s(text, 256, _TRUNCATE, L"%sData", ID.c_str());
	RenderPair(L"id", ID, out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	if (Height == HTML_SIZE_AUTO)
	{
		RenderPair(L"size", 10, out_html);
	}
	else
	{
		RenderPair(L"size", Height, out_html);
	}
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	out_html.WriteText(L"/>");
	//____________________________________________________ Options
	vector<Web::ListViewItem>::iterator item = Items.storage.begin();
	const vector<Web::ListViewItem>::iterator pEnd = Items.storage.end();
	for(; item != pEnd; item++)
	{
		//Indent(indentCount, out_html);
		out_html.WriteText(L"<option value=\"");
		out_html.WriteText(item->Data);
		out_html.WriteText(L"\"");
		if (item->Selected == true) out_html.WriteText(L" selected");
		out_html.WriteText(L">");
		RenderItem(*item, L"&nbsp;", out_html);
		out_html.WriteText(L"</option>");
	}
	out_html.WriteText(L"</select></td></tr>");
	//____________________________________________________ </table>
	out_html.WriteText(L"</table>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void ListView::GetXml(Web::HttpConnector& httpConnector)
{
	//_________________________________________________________ 1. Columns Collection
	//Cols.GetXml(ID, httpConnector);
	//_________________________________________________________ 2. Items Collection
	wstring xmlText;
	CreateXmlNode(httpConnector, ID.c_str(), L"SE", false);
	const int itemCount = (int)Items.storage.size();
	const vector<Web::ListViewItem>::iterator itemEnd = Items.storage.end();
	vector<Web::ListViewItem>::iterator item;
	wstring xmlValue;
	Sys::TextBufferW itemText;
	wchar_t * separator = L" ";
	//__________________________________ Items (Options)
	for(item = Items.storage.begin(); item != itemEnd; item++)
	{
		httpConnector.WriteText(L"<o><n xml:space=\"preserve\">"); // <option><name>
		itemText.buffer.clear();
		RenderItem(*item, separator, itemText);
		Sys::Convert::ToXml(itemText.buffer, xmlValue);
		httpConnector.WriteText(xmlValue);
		httpConnector.WriteText(L"</n><v>");// </name><value>
		Sys::Convert::ToXml(item->Data, xmlValue);
		httpConnector.WriteText(xmlValue);
		if (item->Selected == true)
		{
			httpConnector.WriteText(L"</v><s>true</s></o>");// </value><selected>true</selected></option>
		}
		else
		{
			httpConnector.WriteText(L"</v><s>false</s></o>");// </value><selected>false</selected></option>
		}
	}
	httpConnector.WriteText(L"</c>");
}

bool ListView::CreateTextVector(const wstring& input, vector<wstring>& output)
{
	const int colCount = (int)Cols.storage.size();
	output.resize(colCount);
	int col;
	size_t offset = 0;
	int width;
	for (col = 0; col < colCount; col++)
	{
		//____________________________________  Separate item text
		width = Cols.storage[col].width;
		output[col].assign(input.begin()+offset, input.begin()+offset+width);
		offset += width;
		//____________________________________ Remove spaces
		Sys::TextAssistant::RemoveTrailingSpaces(output[col]);
	}
	return true;
}

void ListView::LoadState(Web::HttpConnector& httpConnector)
{
	//__________________________________________________________ 1. Load Columns Collection
	//Cols.LoadState(httpConnector.Ajax, ID, httpConnector);
	//__________________________________________________________ 2. Load Items Collection
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator control;
		if (Web::VisibleObject::LoadState(httpConnector, false, control) == false) return;
		//_________________________________________________ Items
		list<Sys::Xml>::const_iterator element = control->child.begin();
		const list<Sys::Xml>::const_iterator element_end = control->child.end();
		wstring option_name;
		for(; element != element_end; element++)
		{
			if (element->name == L"d") Items._selectedData.insert(element->value);
		}
	}
	else
	{
		wstring name(ID);
		name += L"Data";
		pair<multimap<wstring,wstring>::iterator,multimap<wstring,wstring>::iterator> ret;
		ret = httpConnector.value.equal_range(name);
		if (ret.first == httpConnector.value.end()) return;
		if (ret.second == httpConnector.value.end()) return;
		for (multimap<wstring, wstring>::iterator state = ret.first; state != ret.second; ++state)
		{
			Items._selectedData.insert((*state).second);
		}
	}
}

wchar_t* ListView::GetTag()
{
	return L"table";
}

void ListView::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	int itemCount = 0;
	if (colCount==Cols.GetCount()+1)
	{
		this->Items.Add(data[1], data[0]);
		itemCount = (int)Items.storage.size();
		for(int i=2; i<colCount; i++) this->Items[itemCount-1].Text[i-1] = data[i];
	}
	else if (colCount==Cols.GetCount())
	{
		this->Items.Add(data[0], L"");
		itemCount = (int)Items.storage.size();
		for(int i=1; i<colCount; i++) this->Items[itemCount-1].Text[i] = data[i];
	}
}

bool ListView::IsItemChecked(int row)
{
	return true;
}

void ListView::SetItemChecked(int row, bool checked)
{
}

bool ListView::SetSelection(int row, bool selected)
{
	if (row == -1)
	{
		vector<Web::ListViewItem>::iterator item = Items.storage.begin();
		const vector<Web::ListViewItem>::iterator item_end = Items.storage.end();
		for( ; item != item_end; item++) item->Selected = selected;
		return true;
	}
	else
	{
		const int len = (int)Items.storage.size();
		if (row < 0 || row >= len) return false;
		Items.storage[row].Selected = selected;
	}
	return true;
}

wstring ListView::GetSelectedTextData()
{
	if (Items.storage.empty() == true)
	{
		if (Items._selectedData.empty() != false)
		{
			return *Items._selectedData.begin();
		}
	}
	else
	{
		vector<Web::ListViewItem>::iterator pEnd = Items.storage.end();
		for (vector<Web::ListViewItem>::iterator p = Items.storage.begin(); p != pEnd; p++)
		{
			if (p->Selected == true)
			{
				return p->Data;
			}
		}
	}
	return L"";
}

bool ListView::SetSelectedIndex(int index)
{
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (i == index)
		{
			Items.storage[i].Selected =  true;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

int ListView::GetSelectedIndex()
{
	const int len = (int)Items.storage.size();
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Selected ==  true) return i;
	}
	return -1;
}

bool ListView::SetSelected(const wchar_t* text)
{
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Text[0] ==  text)
		{
			Items.storage[i].Selected = true;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

bool ListView::SetSelectedByTextData(const wstring data)
{
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Data==  data)
		{
			Items.storage[i].Selected = true;
			ok = true;
		}
		else
		{
			Items.storage[i].Selected = false;
		}
	}
	return ok;
}

//________________________________________________________ RadioButton
RadioButton::RadioButton()
{
	_checked = false;
	SetOriginalChecked(false); // Used for AJAX
}

RadioButton::~RadioButton()
{
}

wstring& RadioButton::GetText()
{
	return _text;
}

void RadioButton::SetText(const wstring& text)
{
	_text = text;
}


void RadioButton::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool RadioButton::IsVisible()
{
	return VisibleObject::IsVisible();
}

void RadioButton::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool RadioButton::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

bool RadioButton::IsChecked()
{
	return _checked;
}

void RadioButton::SetChecked(bool checked)
{
	this->_checked = checked;
}

void RadioButton::SetOriginalChecked(bool checked)
{
	// memoryBlock: 0000 0000 0000 0000 00000 0001 0000 0000
	if (checked == true)
	{
		memoryBlock |= 0x00000100;
	}
	else
	{
		memoryBlock &= 0xFFFFFEFF;
	}
}

bool RadioButton::GetOriginalChecked()
{
	// memoryBlock: 0000 0000 0000 0000 00000 0001 0000 0000
	return ((memoryBlock & 0x00000100) != 0);
}

void RadioButton::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_____________________________________________________________________ ISelectBool
bool& RadioButton::SqlGetBool()
{
	return _checked;
}

void RadioButton::SqlUpdate(bool toGui)
{
}

void RadioButton::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	RenderTagAndId(out_html);
	out_html.WriteText(L" type=\"radio\"");
	if (Name.find(L"Data") != std::wstring::npos)
	{
		RenderPair(L"name", Name, out_html);
	}
	else
	{
		RenderPair(L"name", Name+L"Data", out_html);
	}
	RenderPair(L"accesskey", AccessKey, out_html);
	if (_checked == true) RenderPair(L"checked", L"checked", out_html);
	if (Enabled == false) RenderPair(L"disabled", L"disabled", out_html);
	if (IsVisible() == false) httpConnector.WriteText(L" style=\"visibility:hidden\"");
	//___________________________________ value
	if (Data.length() == 0)
	{
		RenderPair(L"value", Text, out_html);
	}
	else
	{
		RenderPair(L"value", Data, out_html);
	}

	//_________________
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	if (Text.length() > 0)
	{
		out_html.WriteText(L"<span id=\"");
		out_html.WriteText(ID);
		out_html.WriteText(L"Text\"");
		RenderClassAndStyle(out_html);
		out_html.WriteText(L">");
		out_html.WriteText(Text);
		out_html.WriteText(L"</span>");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void RadioButton::GetXml(Web::HttpConnector& httpConnector)
{
	//________________________________________________________________________ Control 1 (radiobutton)
	CreateXmlNode(httpConnector, ID.c_str(), L"RB", true);	
	if (GetOriginalChecked() != _checked) // Update
	{
		if (_checked == true)
		{
			httpConnector.WriteText(L"<ck>true</ck>");
		}
		else
		{
			httpConnector.WriteText(L"<ck>false</ck>");
		}
	}
	httpConnector.WriteText(L"</c>");
	//________________________________________________________________________ Control 2 (caption span)
	wstring textId = ID;
	textId += L"Text";
	CreateXmlNode(httpConnector, textId.c_str(), L"TX", false);
	httpConnector.WriteText(L"</c>");
}

void RadioButton::LoadState(Web::HttpConnector& httpConnector)
{
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator control;
		if (Web::VisibleObject::LoadState(httpConnector, true, control) == false) return;
		//_________________________________________________ Checked
		list<Sys::Xml>::const_iterator element = control->child.begin();
		const list<Sys::Xml>::const_iterator element_end = control->child.end();
		for(; element != element_end; element++)
		{
			if (element->name == L"ck")
			{
				_checked = (element->value == L"true");
				SetOriginalChecked(_checked);
				break;
			}
		}
		//________________________________________________ Data
		//for(element = httpConnector.ajaxResponse.child[control_index].child.begin() ; element != element_end; element++)
		//{
		//	if (element->name == L"d")
		//	{
		//		Data = element->value;
		//		break;
		//	}
		//}
	}
	else
	{
		wstring name(Name);
		name += L"Data";
		multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
		if (state == httpConnector.value.end()) return;
		if (state->second.length() == 0)
		{
			_checked = false;
		}
		else
		{
			if (Data.length() == 0)
			{
				_checked = (state->second == _text);
			}
			else
			{
				_checked = (state->second == Data);
			}
		}
	}
}

wchar_t* RadioButton::GetTag()
{
	return L"input";
}

//________________________________________________________ CheckBox
CheckBox::CheckBox()
{
	_checked = false;
	SetOriginalChecked(false);
}

CheckBox::~CheckBox()
{
}

wstring& CheckBox::GetText()
{
	return _text;
}

void CheckBox::SetText(const wstring& text)
{
	_text = text;
}

void CheckBox::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool CheckBox::IsVisible()
{
	return VisibleObject::IsVisible();
}

void CheckBox::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool CheckBox::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

void CheckBox::SetChecked(bool checked)
{
	_checked = checked;
}

bool CheckBox::IsChecked()
{
	return _checked;
}

void CheckBox::SetOriginalChecked(bool checked)
{
	// memoryBlock: 0000 0000 0000 0000 00000 0001 0000 0000
	if (checked == true)
	{
		memoryBlock |= 0x00000100;
	}
	else
	{
		memoryBlock &= 0xFFFFFEFF;
	}
}

bool CheckBox::GetOriginalChecked()
{
	// memoryBlock: 0000 0000 0000 0000 00000 0001 0000 0000
	return ((memoryBlock & 0x00000100) != 0);
}

void CheckBox::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//_____________________________________________________________________ ISelectBool
bool& CheckBox::SqlGetBool()
{
	return _checked;
}

void CheckBox::SqlUpdate(bool toGui)
{
}

void CheckBox::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	RenderTagAndId(out_html);
	out_html.WriteText(L" type=\"checkbox\"");
	RenderName(out_html);
	if (_checked == true) RenderPair(L"checked", L"checked", out_html);
	if (Enabled == false) RenderPair(L"disabled", L"disabled", out_html);
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	if (IsVisible() == false) httpConnector.WriteText(L" style=\"visibility:hidden\"");
	out_html.WriteText(L" />");
	if (Text.length() > 0)
	{
		out_html.WriteText(L"&nbsp;<span id=\"");
		out_html.WriteText(ID);
		out_html.WriteText(L"Text\"");
		RenderClassAndStyle(out_html);
		out_html.WriteText(L">");
		out_html.WriteText(Text);
		out_html.WriteText(L"</span>");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void CheckBox::GetXml(Web::HttpConnector& httpConnector)
{
	//________________________________________________________________________ Control 1 (checkbox)
	CreateXmlNode(httpConnector, ID.c_str(), L"CB", true);	
	if (GetOriginalChecked() != _checked)  // Update
	{
		if (_checked == true)
		{
			httpConnector.WriteText(L"<ck>true</ck>");
		}
		else
		{
			httpConnector.WriteText(L"<ck>false</ck>");
		}
	}
	httpConnector.WriteText(L"</c>");
	//________________________________________________________________________ Control 2 (caption span)
	wstring textId = ID;
	textId += L"Text";
	CreateXmlNode(httpConnector, textId.c_str(), L"TX", false);
	httpConnector.WriteText(L"</c>");
}

void CheckBox::LoadState(Web::HttpConnector& httpConnector)
{
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator control;
		if (Web::VisibleObject::LoadState(httpConnector, true, control) == false) return;
		//_________________________________________________ Checked
		list<Sys::Xml>::const_iterator element = control->child.begin();
		const list<Sys::Xml>::const_iterator element_end = control->child.end();
		for(; element != element_end; element++)
		{
			if (element->name == L"ck")
			{
				_checked = (element->value == L"true");
				SetOriginalChecked(_checked);
				break;
			}
		}
	}
	else
	{
		wstring name(ID);
		name += L"Data";
		multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
		if (state == httpConnector.value.end()) return;
		if (state->second.length() == 0)
		{
			_checked = false;
		}
		else
		{
			_checked = Sys::Convert::ToBool(state->second);
		}
	}
}

wchar_t* CheckBox::GetTag()
{
	return L"input";
}

//________________________________________________________ HiddenValue
HiddenValue::HiddenValue()
{
}

HiddenValue::~HiddenValue()
{
}

Web::HiddenValue& HiddenValue::operator=(const int data)
{
	SetIntData(data);
	return *this;
}

Web::HiddenValue& HiddenValue::operator=(const double data)
{
	SetDoubleData(data);
	return *this;
}

Web::HiddenValue& HiddenValue::operator=(const bool data)
{
	SetBoolData(data);
	return *this;
}

Web::HiddenValue& HiddenValue::operator=(const wchar_t* data)
{
	SetTextData(data);
	return *this;
}

Web::HiddenValue& HiddenValue::operator=(const wstring& data)
{
	SetTextData(data);
	return *this;
}

HiddenValue::operator int const()
{
	return GetIntData();
}

HiddenValue::operator double const()
{
	return GetDoubleData();
}

HiddenValue::operator bool const()
{
	return GetBoolData();
}

HiddenValue::operator const wchar_t* const()
{
	return Data.c_str();
}

HiddenValue::operator wchar_t* const()
{
	return (wchar_t*)Data.c_str();
}

HiddenValue::operator wstring const()
{
	return Data.c_str();
}

int HiddenValue::GetIntData()
{
	return Sys::Convert::ToInt(Data);
}

void HiddenValue::SetIntData(int value)
{
	Data = Sys::Convert::ToString(value);
}

double HiddenValue::GetDoubleData()
{
	return Sys::Convert::ToDouble(Data);
}

void HiddenValue::SetDoubleData(double value)
{
	Data = Sys::Convert::ToString(value);
}

bool HiddenValue::GetBoolData()
{
	return Sys::Convert::ToBool(Data);
}

void HiddenValue::SetBoolData(bool value)
{
	Data = Sys::Convert::ToString(value);
}

wstring& HiddenValue::GetTextData()
{
	return Data;
}

void HiddenValue::SetTextData(const wstring& value)
{
	Data = value;
}

void HiddenValue::OnNavigateAway(Web::HttpConnector& httpConnector)
{
	wstring name(ID);
	name+=L"Data";
	if (Data.length() > 0)
	{
		httpConnector.AddVariable(name.c_str(), Data.c_str());
	}
}

void HiddenValue::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	RenderTagAndId(out_html);
	out_html.WriteText(L" type=\"hidden\"");
	RenderPair(L"value", Data, out_html);
	wstring name(ID);
	name+= L"Data";
	RenderPair(L"name", name, out_html);
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void HiddenValue::GetXml(Web::HttpConnector& httpConnector)
{
	//____ If value is the same as original, Xml Data for this control is not necessary
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		if (Data.length() == 0) return;
	}
	else
	{
		if (Data == state->second) return;
	}
	//_____ Create a Control Node for the Xml Data
	httpConnector.WriteText(L"<control><id>");
	httpConnector.WriteText(ID);
	httpConnector.WriteText(L"</id><type>Hidden</type><value>");
	if (Data.length() > 0)
	{
		wstring xmlValue;
		Sys::Convert::ToXml(Data.c_str(), xmlValue);
		httpConnector.WriteText(xmlValue);
	}
	httpConnector.WriteText(L"</value></control>");
}

void HiddenValue::LoadState(Web::HttpConnector& httpConnector)
{
	wstring name(ID);
	name += L"Data";
	multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
	if (state == httpConnector.value.end()) return;
	if (state->second.length() == 0)
	{
		Data = L"";
	}
	else
	{
		Data = state->second;
	}
}

wchar_t* HiddenValue::GetTag()
{
	return L"input";
}

//________________________________________________________ Image
Image::Image()
{
}
	
Image::~Image()
{
}

void Image::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Image::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	RenderPair(L"src", src, out_html);
	RenderPair(L"alt", Text, out_html);
	RenderPair(L"title", Text, out_html);
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
}

void Image::GetXml(Web::HttpConnector& httpConnector)
{
}

void Image::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* Image::GetTag()
{
	return L"img";
}

//________________________________________________________ ImageLink
ImageLink::ImageLink()
{
}

ImageLink::~ImageLink()
{
}

void ImageLink::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

bool ImageLink::HrefNavigateTo(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	const int len = (int)href.size();
	wchar_t c;
	for(int i = 0; i < len; i++)
	{
		c = href[i];
		if (c == '.') return false;
		if (c == ':') return false;
		if (c == '/') return false;
		if (c == '\\') return false;
		if (c == ' ') return false;
	}
	wstring script_name;
	httpConnector.GetServerVariable("SCRIPT_NAME", script_name);
	script_name += L"?windowID=";
	script_name += href;
	RenderPair(L"href", script_name, out_html);
	return true;
}

void ImageLink::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	if (HrefNavigateTo(out_html, httpConnector) == false) RenderPair(L"href", href, out_html);
	RenderPair(L"target", targetWindowName, out_html);
	RenderPair(L"accesskey", AccessKey, out_html);
	RenderPair(L"tabindex", tabIndex, out_html);
	RenderPair(L"title", Text, out_html);
	//___________________________________________ img
	out_html.WriteText(L"><img");
	if (imageCssClass.length()>0)
	{
		out_html.WriteText(L" class=\"");
		out_html.WriteText(imageCssClass);
		out_html.WriteText(L"\"");
	}
	RenderPair(L"src", src, out_html);
	RenderPair(L"alt", Text, out_html);
	RenderPair(L"title", Text, out_html);
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	//________________________________________________ close the tag
	out_html.WriteText(L" /></a>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
}

void ImageLink::GetXml(Web::HttpConnector& httpConnector)
{
}

void ImageLink::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* ImageLink::GetTag()
{
	return L"a";
}

//________________________________________________________ TextLink
TextLink::TextLink()
{
}

TextLink::~TextLink()
{
}

void TextLink::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

bool TextLink::HrefNavigateTo(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	const int len = (int)href.size();
	wchar_t c;
	for(int i = 0; i < len; i++)
	{
		c = href[i];
		if (c == '.') return false;
		if (c == ':') return false;
		if (c == '/') return false;
		if (c == '\\') return false;
		if (c == ' ') return false;
	}
	wstring script_name;
	httpConnector.GetServerVariable("SCRIPT_NAME", script_name);
	script_name += L"?windowID=";
	script_name += href;
	RenderPair(L"href", script_name, out_html);
	return true;
}

void TextLink::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	if (HrefNavigateTo(out_html, httpConnector) == false) RenderPair(L"href", href, out_html);
	RenderPair(L"target", targetWindowName, out_html);
	RenderPair(L"accesskey", AccessKey, out_html);
	RenderPair(L"tabindex", tabIndex, out_html);
	RenderPair(L"title", Text, out_html);
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	out_html.WriteText(L">");
	out_html.WriteText(Text);
	out_html.WriteText(L"</a>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
}

void TextLink::GetXml(Web::HttpConnector& httpConnector)
{
}

void TextLink::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* TextLink::GetTag()
{
	return L"a";
}

#ifdef WIN_GDI_PLUS_ON
//________________________________________________________ DynamicImage
DynamicImage::DynamicImage()
{
	this->css.font_size = 12;
	this->css.background_color = RGB(250, 250, 250);
	this->css.color = RGB(0, 0, 200);
	this->css.width = 400;
	this->css.height = 300;
	this->LineColor = RGB(235, 235, 255);
	this->css.font_family = Web::CssType::FontFamilyArial;
	this->WhiteAndBlack = false;
	//
	this->css.border_color=RGB(192, 192, 192);
	this->css.border_width=1;
	this->css.border_style=Web::CssType::BorderStyleSolid;
}

DynamicImage::~DynamicImage()
{
}

void DynamicImage::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void DynamicImage::RenderValue(const wchar_t* name, wstring& value, wstring& output)
{
	if (value.length() <= 0) return;
	output += L"&";
	output += name;
	output += L"=";
	Sys::Convert::WstringToHex(value.c_str(), encodedText);
	output += encodedText;
}

void DynamicImage::RenderValue(const wchar_t* name, double value, wstring& output)
{
	output += L"&";
	output += name;
	output += L"=";
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%g", value);
	Sys::Convert::WstringToHex(text, encodedText);
	output += encodedText;
}

void DynamicImage::RenderValue(const wchar_t* name, int value, wstring& output)
{
	output += L"&";
	output += name;
	output += L"=";
	wchar_t text[32];
	_snwprintf_s(text, 32, _TRUNCATE, L"%d", value);
	Sys::Convert::WstringToHex(text, encodedText);
	output += encodedText;
}

void DynamicImage::RenderValue(const wchar_t* name, bool value, wstring& output)
{
	output += L"&";
	output += name;
	if (value == true)
	{
		output += L"=true";
	}
	else
	{
		output += L"=false";
	}
}

bool DynamicImage::ColorSync(Web::HttpConnector& h, const wchar_t* red, const wchar_t* green, const wchar_t* blue, COLORREF& color)
{
	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	p = h.value.find(red);
	if (p == valueEnd) return false;
	const int color_red = Sys::Convert::ToInt(p->second);
	//
	p = h.value.find(green);
	if (p == valueEnd) return false;
	const int color_green = Sys::Convert::ToInt(p->second);
	//
	p = h.value.find(blue);
	if (p == valueEnd) return false;
	const int color_blue = Sys::Convert::ToInt(p->second);
	//
	color = RGB(color_red, color_green, color_blue);
	return true;
}

void DynamicImage::BasicSync(Web::HttpConnector& h)
{
	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();
	COLORREF a = RGB(0, 0, 0);
	//__________________________________________ FontSize
	p = h.value.find(L"FontSize"); 
	if (p != valueEnd) css.font_size = Sys::Convert::ToInt(p->second);
	//__________________________________________ Background
	if (ColorSync(h, L"BkRed", L"BkGreen", L"BkBlue", a) == true) css.background_color = a;
	//__________________________________________ Color
	if (ColorSync(h, L"Red", L"Green", L"Blue", a) == true) css.color = a;
	//__________________________________________ Width
	p = h.value.find(L"Width"); 
	if (p != valueEnd) css.width = Sys::Convert::ToInt(p->second);

	//__________________________________________ Height
	p = h.value.find(L"Height"); 
	if (p != valueEnd) css.height = Sys::Convert::ToInt(p->second);

	//__________________________________________ Line Color
	if (ColorSync(h, L"LRed", L"LGreen", L"LBlue", a) == true) LineColor = a;
	//__________________________________________ Font Family
	p = h.value.find(L"FontFamily"); 
	if (p != valueEnd) css.font_family = (Web::CssType::FontFamily)Sys::Convert::ToInt(p->second);

	//__________________________________________ isWhiteAndBlack
	p = h.value.find(L"WB"); 
	if (p != valueEnd) WhiteAndBlack = (Web::CssType::FontFamily)Sys::Convert::ToBool(p->second);

	//__________________________________________ Border Color
	if (ColorSync(h, L"BdRed", L"BdGreen", L"BdBlue", a) == true) css.border_color = a;

	//__________________________________________ Border Width
	p = h.value.find(L"BorderWidth"); 
	if (p != valueEnd) css.border_width = Sys::Convert::ToInt(p->second);

	//__________________________________________ Border Style
	p = h.value.find(L"BorderStyle"); 
	if (p != valueEnd) css.border_style = (Web::CssType::BorderStyle)Sys::Convert::ToInt(p->second);

	//__________________________________________ Text
	p = h.value.find(L"Text"); 
	if (p != valueEnd)
	{
		if (p->second.length() > 0) Text = p->second;
	}
}

void DynamicImage::RenderImage(string& data)
{	
	COLORREF _backColor = css.background_color;
	COLORREF _textColor = css.color;
	COLORREF _lineColor = LineColor;

	if (WhiteAndBlack == true)
	{
		_backColor = RGB(255, 255, 255);
		_textColor = RGB(0, 0, 0);
		_lineColor = RGB(180, 180, 180);
	}

	const int width = abs(css.width);
	const int height = abs(css.height);
	IStream* pIs = Sys::ImageStream::CreateAllocator(&data);
	Gdiplus::Bitmap bitmap(width, height);
	Gdiplus::Graphics imageGraphics(&bitmap);

	//________________________________________________________ Background
	Gdiplus::SolidBrush brushBackground(Gdiplus::Color(255, GetRValue(_backColor), GetGValue(_backColor), GetBValue(_backColor)));
	imageGraphics.FillRectangle(&brushBackground, 0, 0, width, height);
	//________________________________________________________ Font
	wchar_t * fontFamily = L"Arial";
	if (css.font_family == Web::CssType::FontFamilyCourier)
	{
		fontFamily = L"Courier";
	}
	else if (css.font_family == Web::CssType::FontFamilyTimesNewRoman)
	{
		fontFamily = L"Times New Roman";
	}
	Gdiplus::FontFamily gdiFontFamily(fontFamily);
	Gdiplus::Font font(&gdiFontFamily, (Gdiplus::REAL)css.font_size, Gdiplus::FontStyleRegular, Gdiplus::UnitPixel); 
	//________________________________________________________ Font Brush
	Gdiplus::SolidBrush brushFont(Gdiplus::Color(255, GetRValue(_textColor), GetGValue(_textColor), GetBValue(_textColor)));
	//________________________________________________________ Line Pen
	Gdiplus::Pen penLine(Gdiplus::Color(255, GetRValue(_lineColor), GetGValue(_lineColor), GetBValue(_lineColor)), 1.0f);
	//________________________________________________________ Text Pen
	Gdiplus::Pen penText(Gdiplus::Color(255, GetRValue(_textColor), GetGValue(_textColor), GetBValue(_textColor)), 1.0f);
	
	//
	BuildBitmap(imageGraphics, font, brushFont, penLine, penText);

   CLSID imgClsid;
   if (Sys::ImageStream::GetEncoderClsid(L"image/png", &imgClsid) != -1) //L"image/jpeg", L"image/png", 
   {
	     //________________________________________________ Set the quality of the encoder
		Gdiplus::EncoderParameters encoderParameters;
		ULONG quality;
		encoderParameters.Count = 1;
		encoderParameters.Parameter[0].Guid = Gdiplus::EncoderQuality;
		encoderParameters.Parameter[0].Type = Gdiplus::EncoderParameterValueTypeLong;
		encoderParameters.Parameter[0].NumberOfValues = 1;
  
		 quality = 100; // 0 most compresion, 100 Best quality
		 encoderParameters.Parameter[0].Value = &quality;

		bitmap.Save(pIs, &imgClsid, &encoderParameters);
	}
	pIs->Release();
}

void DynamicImage::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	wstring src;
	GetSource(src, httpConnector.url.c_str());
	RenderPair(L"src", src, out_html);
	RenderPair(L"alt", Text, out_html);
	javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
}

void DynamicImage::RenderProperties(Web::DynamicImage& di, wstring& text)
{
	wchar_t tmp[128];
	//__________________________________________ Font Size
	if (this->css.font_size != di.css.font_size)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&FontSize=%d", css.font_size);
		text += tmp;
	}
	//__________________________________________ Background
	if (this->css.background_color != di.css.background_color)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BkRed=%d&BkGreen=%d&BkBlue=%d", 
			GetRValue(css.background_color), GetGValue(css.background_color), GetBValue(css.background_color));
		text += tmp;
	}
	//__________________________________________ Color
	if (this->css.color != di.css.color)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Red=%d&Green=%d&Blue=%d", 
			GetRValue(css.color), GetGValue(css.color), GetBValue(css.color));
		text += tmp;
	}
	//__________________________________________ Width
	if (this->css.width != di.css.width)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Width=%d", css.width);
		text += tmp;
	}
	//__________________________________________ Height
	if (this->css.height != di.css.height)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Height=%d", css.height);
		text += tmp;
	}
	//__________________________________________ Line Color
	if (this->LineColor != di.LineColor)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&LRed=%d&LGreen=%d&LBlue=%d", 
			GetRValue(LineColor), GetGValue(LineColor), GetBValue(LineColor));
		text += tmp;
	}
	//__________________________________________ Font Family
	if (this->css.font_family != di.css.font_family)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&FontFamily=%d", css.font_family);
		text += tmp;
	}
	//__________________________________________ isWhiteAndBlack
	if (this->WhiteAndBlack != di.WhiteAndBlack)
	{
		if (WhiteAndBlack == true)
		{
			text +=L"&WB=true";
		}
		else
		{
			text +=L"&WB=false";
		}
	}
	//__________________________________________ Border Color
	if (this->css.border_color != di.css.border_color)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BdRed=%d&BdGreen=%d&BdBlue=%d", 
			GetRValue(css.border_color), GetGValue(css.border_color), GetBValue(css.border_color));
		text += tmp;
	}
	//__________________________________________ Border Width
	if (this->css.border_width != di.css.border_width)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BorderWidth=%d", css.border_width);
		text += tmp;
	}
	//__________________________________________ Border Style
	if (this->css.border_style != di.css.border_style)
	{
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&BorderStyle=%d", css.border_style);
		text += tmp;
	}
	//___________________________________________ Text
	if (Text.length() > 0)
	{
		wstring encodedText;
		Sys::Convert::WstringToHex(Text.c_str(), encodedText);
		_snwprintf_s(tmp, 128, _TRUNCATE, L"&Text=%s", encodedText.c_str());
		text += tmp;
	}
}

void DynamicImage::GetXml(Web::HttpConnector& httpConnector)
{
}

void DynamicImage::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* DynamicImage::GetTag()
{
	return L"img";
}

#endif

//________________________________________________________ Bar
Bar::Bar()
{
}

Bar::~Bar()
{
}

bool Bar::operator<(const Web::Bar& bar) const
{
	return (Value < bar.Value);
}

//________________________________________________________ BarCollection
BarCollection::BarCollection()
{
}

BarCollection::~BarCollection()
{
}

void BarCollection::Add(const wstring& text, COLORREF color, double value)
{
	Web::Bar bar;
	bar.Color = color;
	bar.Text = text;
	bar.Value = value;
	storage.push_back(bar);
}

void BarCollection::DeleteAll()
{
	storage.clear();
}

Web::Bar& BarCollection::operator[](long index)
{
	return storage[index];
}

int BarCollection::GetCount()
{
	return (int)storage.size();
}

#ifdef WIN_GDI_PLUS_ON
//________________________________________________________ BarChart
BarChart::BarChart()
{
	DivYCount = 5;
	MaxY = 0.0;
	AutoScale = true;
}

BarChart::~BarChart()
{
}

void BarChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{
	const double maxY = GetMaxY();
	Gdiplus::RectF box;
	Gdiplus::RectF rect;
	ComputeBox(box);
	const int barCount = Bars.Count;
	int i= 0;

	const Gdiplus::REAL deltaX = (barCount > 0) ? (box.Width/barCount) : 0.0f;
	const Gdiplus::REAL deltaY = (DivYCount > 0) ? (box.Height/DivYCount) : 0.0f;
	const Gdiplus::REAL barWidth = 0.8f*deltaX;
	Gdiplus::REAL x = 0.0f;
	Gdiplus::REAL y = 0.0f;
	//______________________________________________ Grid
	for(i = 0; i < DivYCount-1; i++)
	{
		y = box.Y + box.Height - (i+1)*deltaY;
		graphics.DrawLine(&penLine, box.X, y, box.X+box.Width, y);
	}

	//______________________________________________CaptionX
	Gdiplus::StringFormat sfCaptionX;
	sfCaptionX.SetAlignment(Gdiplus::StringAlignmentCenter);
	sfCaptionX.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	if (barCount > 0)
	{
		rect.Y = box.Y+box.Height;
		rect.Height = abs(css.height) - box.Y - box.Height;
		y = css.font_size * 0.1f;
		rect.Width = deltaX;
		for(i = 0; i< barCount; i++)
		{
			rect.X = box.X + deltaX*i;
			if (Bars[i].Text.empty() == false)
			{
				graphics.DrawString(Bars[i].Text.c_str(), -1, &font, rect, &sfCaptionX, &brushFont);
			}
			//if (m_bTickX)
			//{
			//	x = (int)((rect.left + rect.right)/2+0.5);
			//	gdi.MoveToEx(x, m_box.bottom-y);
			//	gdi.LineTo(x, m_box.bottom + y);
			//}
		}
	}

	//______________________________________________CaptionY
	if (barCount  > 0)
	{
		Gdiplus::RectF rectCaptionY;
		rectCaptionY.X = 0.0f;
		rectCaptionY.Y = 0.0f;
		rectCaptionY.Width = box.X;
		rectCaptionY.Height = deltaY;
		//
		Gdiplus::StringFormat sfCaptionY;
		sfCaptionY.SetAlignment(Gdiplus::StringAlignmentFar);
		sfCaptionY.SetLineAlignment(Gdiplus::StringAlignmentCenter);
		//
		double captionYScale = (DivYCount == 0) ? 1.0 : (maxY/DivYCount);
		wchar_t text[64];

		x = box.X - css.font_size  / 4;
		for(i= 0 ; i<= DivYCount; i++) 
		{
			y = box.Y + i * deltaY;
			rectCaptionY.Y = box.Y + i *deltaY - 0.5f*deltaY;
			if (y > (box.Y + box.Height))  break;
			Sys::Convert::ToString(maxY - captionYScale*i, text, 64, true, true);
			graphics.DrawString(text, -1, &font, rectCaptionY, &sfCaptionY, &brushFont);
		}
	}

	//_____________________________________________________ Bars
	if (barCount>0)
	{
		bool paint = false;
		double dotsPerY = box.Height / maxY;
		double barPositionX, barPositionY, barSizeY;
		double offset = (deltaX- barWidth)/2.0;

		for (i = 0; i < barCount; i++)
		{
			if (Bars[i].Value > 0)
			{
				barPositionX = deltaX * i + box.X + offset;
				barSizeY = dotsPerY * Bars[i].Value;
				barPositionY = box.Y + box.Height  - (int) (barSizeY + 0.5);
				Gdiplus::SolidBrush brush(Gdiplus::Color(255, GetRValue(Bars[i].Color), GetGValue(Bars[i].Color), GetBValue(Bars[i].Color)));

				rect.X = (Gdiplus::REAL)barPositionX;
				rect.Y = (Gdiplus::REAL)barPositionY;
				rect.Height = (Gdiplus::REAL)(barSizeY);
				rect.Width = (Gdiplus::REAL)(barWidth);

				graphics.FillRectangle(&brush, rect);
			}
		}
	}

	//_____________________________________________________ Sourrounding Box
	graphics.DrawRectangle(&penText, box);

	//_____________________________________________________ Title
	if (Text.length()>0)
	{
		rect.X = 0.0f;
		rect.Y = 0.0f;
		rect.Width = (Gdiplus::REAL)abs(css.width);
		rect.Height = box.Y;
		graphics.DrawString(Text.c_str(), -1, &font, rect, &sfCaptionX, &brushFont);
	}
}

void BarChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);

	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//__________________________________________ DivYCount
	p = h.value.find(L"DivYCount"); 
	if (p != valueEnd) DivYCount = Sys::Convert::ToInt(p->second);

	//___________________________________________ MaxY
	p = h.value.find(L"MaxY"); 
	if (p != valueEnd) MaxY = Sys::Convert::ToDouble(p->second);

	//___________________________________________ AutoScale
	p = h.value.find(L"AutoScale"); 
	if (p != valueEnd) AutoScale = Sys::Convert::ToBool(p->second);

	//___________________________________________ Data
	p = h.value.find(L"Data"); 
	if (p == valueEnd) return;
	const int len = (int)p->second.length();
	double value = 0.0;
	int red = 0;
	int green = 0;
	int blue = 0;
	wstring tmp;
	int i = 0;
	int state = 0;
	wchar_t c;
	for(i = 0; i < len; i++)
	{
		c = p->second[i];
		if (state == 0) //_____________________ Value
		{
			if (c == '#')
			{
				value = Sys::Convert::ToDouble(tmp);
				tmp.clear();
				state = 1;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 1)//_____________________ Red
		{
			if (c == '#')
			{
				red = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 2;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 2)//_____________________ Green
		{
			if (c == '#')
			{
				green = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 3;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 3)//_____________________ Blue
		{
			if (c == '#')
			{
				blue = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 4;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 4)//_____________________ Text
		{
			if (c == '#')
			{
				Bars.Add(tmp, RGB(red, green, blue), value);
				tmp.clear();
				state = 0;
			}
			else
			{
				tmp += c;
			}
		}
	}
}

double BarChart::GetMaxY()
{
	double _maxY = 0.0;
	if (AutoScale == true) 
	{
		vector<Web::Bar>::iterator p = std::max_element(Bars.storage.begin(), Bars.storage.end());
		if (p != Bars.storage.end())
		{
			_maxY = p->Value;
		}
	}
	else
	{
		_maxY= MaxY;
	}
	return _maxY;
}

void BarChart::GetSource(wstring& source, const wchar_t* url)
{
	const vector<Web::Bar>::iterator barEnd = Bars.storage.end();
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=BarChart";
	
	Web::BarChart chart;
	if (chart.DivYCount != this->DivYCount) RenderValue(L"DivYCount", DivYCount, source);
	if (chart.MaxY != this->MaxY) RenderValue(L"MaxY", MaxY, source);
	if (chart.AutoScale != this->AutoScale) RenderValue(L"AutoScale", AutoScale, source);

	this->RenderProperties(chart, source);
	source += L"&Data=";
	
	for(vector<Web::Bar>::iterator bar = Bars.storage.begin(); bar != barEnd; bar++)
	{
		Sys::TextAssistant::ReplaceChar(bar->Text, '#', ' ');
		_snwprintf_s(text, 256, _TRUNCATE, L"%g#%d#%d#%d#%s#",
			bar->Value, GetRValue(bar->Color), GetGValue(bar->Color), GetBValue(bar->Color), bar->Text.c_str());
		Sys::Convert::WstringToHex(text, encodedText);
		source += encodedText;
	}
}

void BarChart::ComputeBox(Gdiplus::RectF& box)
{
	const int charWidth = (int)(abs(css.font_size)/2.0+0.5);
	const int charHeight = abs(css.font_size);
	box.X = (Gdiplus::REAL)(8.0*charWidth);
	box.Width = (Gdiplus::REAL)(abs(css.width) - 12.0*charWidth);
	box.Y = (Gdiplus::REAL)(2.0*charHeight);
	box.Height = (Gdiplus::REAL)(abs(css.height)-4.0*charHeight);
}
#endif

////________________________________________________________ SimpleBarChart
//SimpleBarChart::SimpleBarChart(void)
//{
//	m_pBar = NULL;
//	this->CustomData+=L"valign=\"bottom\"");
//	m_min = 0.0;
//	m_max = 0.0;
//	m_bFirst = true;
//	m_scale = 0.0;
//	m_tableEx.Create(2, 1);
//	m_tableEx.css.width.Set(L"100%"));
//	m_tableEx.css.height.Set(L"100%"));
//	m_tableEx.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	m_tableEx.css.border.Set(L"1px solid #d0d0d5"));
//	//
//	m_span.css.border.Set(L"1px solid #707070"));
//	m_span.css.fontSize = 1;
//	m_span.css.width.Set(L"100%"));
//	m_span.css.height.Set(L"100%"));
//	m_span.SetInnerText(L"&nbsp;"), false);
//	//
//	m_tableEx.GetTd(0, 0).css.background.Set(L"e0e0e0"));
//	//
//	//*************************************************** Layout
//	this->AddChild(this->m_td);
//	this->m_td.AddChild(this->m_tableEx);
//	this->m_tableEx.GetTd(1, 0).AddChild(m_span);
//}
//
//bool SimpleBarChart::Create(int nCount)
//{
//	Destructor();
//	if (nCount<=0) return false;
//	m_pBar = new Web::SimpleBarChart::Bar[nCount];
//	ZeroMemory(m_pBar, nCount*sizeof(Web::SimpleBarChart::Bar));
//	if  (m_pBar==NULL) return false;
//	this->RepeatCount = nCount;
//	return true;
//}
//
//bool SimpleBarChart::SetValue(int index, double value, const wchar_t* pszColor)
//{
//	if (0<=index && index<this->RepeatCount)
//	{
//		m_pBar[index].value = value;
//		lstrcpyn(m_pBar[index].color, pszColor, 7);
//		if (m_bFirst)
//		{
//			m_bFirst = false;
//			m_min = value;
//			m_max = value;
//		}
//		else
//		{
//			if (value<m_min) m_min = value;
//			if (value>m_max) m_max = value;
//		}
//		return true;
//	}
//	return false;
//}
//
//void SimpleBarChart::SetMinMax(double MINIMUM, double MAXIMUM)
//{
//	m_min = MINIMUM;
//	m_max = MAXIMUM;
//}
//
//SimpleBarChart::~SimpleBarChart(void)
//{
//	Destructor();
//}
//
//void SimpleBarChart::Destructor()
//{
//	if (m_pBar)
//	{
//		delete [] m_pBar;
//		m_pBar = NULL;
//	}
//	this->RepeatCount= 0;
//	m_min = 0.0;
//	m_max = 0.0;
//	m_bFirst = true;
//	m_scale = 0.0;
//}
//
//void SimpleBarChart::OnIniRender()
//{
//	Web::Node::OnIniRender();
//}
//
//void SimpleBarChart::OnEndRender()
//{
//	Web::Node::OnEndRender();
//}
//
//double SimpleBarChart::GetMin()
//{
//	return m_min;
//}
//
//double SimpleBarChart::GetMax()
//{
//	return m_max;
//}
//
//void SimpleBarChart::OnPreRender(int nIndex)
//{
//	int i = 0;
//	int height = 0;
//	std::vector<Data::StrArray>::iterator p = NULL;
//	int nBarHeight = 0;
//	wchar_t sz[64];
//	
//	if (nIndex ==0) //************************************************** Find scale
//	{
//		if (m_max>m_min) 
//			m_scale = 100.0 / (m_max-m_min);
//		else
//			m_scale = 1;
//	}
//	//************************************************************* Render the bar
//	nBarHeight = (int)((m_pBar[nIndex].value-m_min)*m_scale+0.5);
//	if (nBarHeight<0) nBarHeight = 0;
//	if (nBarHeight>100) nBarHeight = 100;
//	m_tableEx.GetTd(1, 0).css.background.Set(m_pBar[nIndex].color);
//	_sntprintf(sz, 64, L"%d%%"), 100-nBarHeight);
//	m_tableEx.GetTd(0, 0).css.height.Set(sz);
//	_sntprintf(sz, 64, L"%d%%"), nBarHeight);
//	m_tableEx.GetTd(1, 0).css.height.Set(sz);
//}
//
//}
////________________________________________________________ BarChart
//BarChart::BarChart(void)
//{
//	Web::TableEx::Create(2, 3);
//	//
//	this->GetTd(0, 0).AddChild(tableCaptionY);
//	this->GetTd(0, 1).AddChild(m_tableMark);
//	this->GetTd(0, 2).AddChild(tableChart);
//	this->GetTd(1, 2).AddChild(tableCaptionX);
//	tableChart.AddChild(m_sbc);
//
//	this->GetTd(0, 2).css.width.Set(L"100%"));
//	this->GetTd(1, 2).css.width.Set(L"100%"));
//	tableCaptionX.css.width.Set(L"100%"));
//	tableCaptionX.css.textAlign.Set(L"center"));
//	tableCaptionX.css.fontSize=10;
//	tableChart.css.border.Set(L"1px solid #a0a0a0"));
//	this->css.background.Set(L"ffffff"));
//	this->css.border.Set(L"2px outset #c0c0c0"));
//	formatCaptionY.Set(L"%.1f"));
//	tableCaptionY.css.height.Set(L"100%"));
//	this->GetTd(0, 0).css.height.Set(L"100%"));
//	this->GetTd(0, 1).css.height.Set(L"100%"));
//	tableCaptionY.css.fontSize=10;
//	tableCaptionY.css.width.Set(L"50%"));
//	//
//	tableCaptionX.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	this->CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	tableCaptionY.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	tableChart.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	this->GetTd(0, 2).css.paddingRight = 10;
//	this->GetTd(0, 2).css.paddingTop = 10;
//	this->GetTd(0, 1).css.paddingTop = 10;
//	this->GetTd(0, 0).css.paddingTop = 4;
//	this->GetTd(0, 0).css.paddingBottom = 6;
//	this->GetTd(1, 2).css.paddingRight = 10;
//	//
//	m_tableMark.css.width.Set(L"50%"));
//	m_tableMark.css.height.Set(L"100%"));
//	m_tableMark.CustomData+=L"cellpadding=\"0\" cellspacing=\"0\"");
//	m_tableMark.css.fontSize=10;
//}
//
//void BarChart::OnIniRender()
//{
//	Web::Node::OnIniRender();
//
//	//********************************* Calculate Caption Y
//	wchar_t sz[256];
//	double deltaY = (m_sbc.GetMax()-m_sbc.GetMin())/WEB_BARCHART_CAPTIONYCOUNT;
//	double y = 0;
//	if (deltaY<0) deltaY=1;
//
//	for(int i = 0; i<WEB_BARCHART_CAPTIONYCOUNT; i++)
//	{
//		y = m_sbc.GetMin()+(WEB_BARCHART_CAPTIONYCOUNT-i)*deltaY;
//		_sntprintf(sz, 256, formatCaptionY.Get(), y);
//		if (tableCaptionY.GetRowCount()>0) tableCaptionY.GetTd(i, 0).SetInnerText(sz, true);
//	}
//}
//
//bool BarChart::Create(int nCount)
//{
//	if (m_sbc.Create(nCount)==false) return false;
//	if (tableCaptionX.Create(1, nCount)==false) return false;
//	if (tableCaptionY.Create(WEB_BARCHART_CAPTIONYCOUNT, 1)==false) return false;
//	if (m_tableMark.Create(WEB_BARCHART_CAPTIONYCOUNT, 1)==false) return false;
//	wchar_t sz[256];
//	int nWidth = (int)(100.0/nCount+0.5);
//	_sntprintf(sz, 256, L"%d%%"), nWidth);
//	for(int i = 0; i<WEB_BARCHART_CAPTIONYCOUNT; i++)
//	{
//		tableCaptionY.GetTd(i, 0).css.textAlign.Set(L"center"));
//		tableCaptionY.GetTd(i, 0).css.paddingLeft = 10;
//		tableCaptionY.GetTd(i, 0).css.paddingRight = 2;
//		tableCaptionY.GetTd(i, 0).css.verticalAlign.Set(L"top"));
//		m_tableMark.GetTd(i, 0).css.borderTop.Set(L"1px solid #000000"));
//		m_tableMark.GetTd(i, 0).SetInnerText(L"&nbsp;"), false);
//	}
//	for(int i = 0; i<nCount; i++)
//	{
//		tableCaptionX.GetTd(0, i).css.width.Set(sz);
//		tableCaptionX.GetTd(0, i).css.padding = 5;
//	}
//	return true;
//}
//
//bool BarChart::SetValue(int index, double value, const wchar_t* pszColor, const wchar_t* pszCaptionX)
//{
//	if (m_sbc.SetValue(index, value, pszColor))
//	{
//		tableCaptionX.GetTd(0, index).SetInnerText(pszCaptionX, true);
//		return true;
//	}
//	return false;
//}
//
//void BarChart::SetMinMax(double MINIMUM, double MAXIMUM)
//{
//	m_sbc.SetMinMax(MINIMUM, MAXIMUM);
//}
//
//BarChart::~BarChart(void)
//{
//}

//}




//________________________________________________________ CheckBoxList
CheckBoxList::CheckBoxList()
{
	Items.colsCollection = &Cols.storage;
	//css.height = 200;
	//css.width = 120;
	cssClass = L"Data";
}

CheckBoxList::~CheckBoxList()
{
}

wstring& CheckBoxList::GetText()
{
	return VisibleObject::GetText();
}

void CheckBoxList::SetText(const wstring& text)
{
	VisibleObject::SetText(text);
}

void CheckBoxList::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool CheckBoxList::IsVisible()
{
	return VisibleObject::IsVisible();
}

void CheckBoxList::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool CheckBoxList::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

int CheckBoxList::GetColumnCount()
{
	return (int)Cols.storage.size();
}

void CheckBoxList::AddColumn(int format, int width, const wchar_t* text)
{
	Web::CheckBoxColumn column;
	column.format = format;
	column.Text = text;
	Cols.storage.push_back(column);
}

void CheckBoxList::AddColumn(int format, int width, const wstring& text)
{
	AddColumn(format, width, text.c_str());
}

bool CheckBoxList::DeleteColumn(int index)
{
	return Cols.Delete(index);
}

void CheckBoxList::DeleteAllColumns()
{
	Cols.storage.clear();
}

bool CheckBoxList::GetColumnText(int index, wstring& out_text)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	out_text = Cols.storage[index].Text;
	return true;
}

bool CheckBoxList::GetColumnText(int index, wchar_t* buffer, int buffer_length)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	_snwprintf_s(buffer, buffer_length, _TRUNCATE, L"%s", Cols.storage[index].Text.c_str());
	return true;
}

bool CheckBoxList::SetColumnText(int index, const wstring& text)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	Cols.storage[index].Text = text;
	return true;
}

bool CheckBoxList::SetColumnText(int index, const wchar_t* text)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	Cols.storage[index].Text = text;
	return true;
}

bool CheckBoxList::GetColumnFormat(int index, int& out_format)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	out_format = Cols.storage[index].format;
	return true;
}

bool CheckBoxList::SetColumnFormat(int index, int format)
{
	const int count = (int)Cols.storage.size();
	if (index < 0 || index >= count) return false;
	Cols.storage[index].format = format;
	return true;
}

bool CheckBoxList::GetColumnWidth(int index, int& out_width)
{
	out_width = 0;
	return true;
}

bool CheckBoxList::SetColumnWidth(int index, int width)
{
	return true;
}

int CheckBoxList::GetItemCount()
{
	return (int)Items.storage.size();
}

void CheckBoxList::AddItem(const wchar_t* text, LPARAM data)
{
	wchar_t wdata[32];
	_snwprintf_s(wdata, 32, _TRUNCATE, L"%d", (int)data);
	Items.Add(text, wdata);
}

void CheckBoxList::AddItem(const wstring& text, LPARAM data)
{
	AddItem(text.c_str(), data);
}

bool CheckBoxList::DeleteItem(int row)
{
	return Items.Delete(row);
}

void CheckBoxList::DeleteAllItems()
{
	Items.storage.clear();
}

void CheckBoxList::Delete()
{
	DeleteAllColumns();
	DeleteAllItems();
}

bool CheckBoxList::GetItemText(int row, int column, wstring& out_text)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return false;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return false;
	out_text = Items.storage[row].Text[column];
	return true;
}

int CheckBoxList::GetItemText(int row, int column, wchar_t* buffer, int buffer_length)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return 0;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return 0;
	return _snwprintf_s(buffer, buffer_length, _TRUNCATE, L"%s", Items.storage[row].Text[column].c_str());
}

bool CheckBoxList::SetItemText(int row, int column, const wstring& text)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return false;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return false;
	Items.storage[row].Text[column] = text;
	return true;
}

bool CheckBoxList::SetItemText(int row, int column, const wchar_t* text)
{
	const int rowCount = (int)Items.storage.size();
	if (row < 0 || row >= rowCount) return false;
	const int colCount = (int)Items.storage[row].Text.size();
	if (column < 0 || column >= colCount) return false;
	Items.storage[row].Text[column] = text;
	return true;
}

bool CheckBoxList::GetItemData(int row, LPARAM& out_data)
{
	const int count = (int)Items.storage.size();
	if (row < 0 || row >= count) return false;
	out_data = (LPARAM)Sys::Convert::ToInt(Items.storage[row].Data);
	return true;
}

bool CheckBoxList::SetItemData(int row, const LPARAM data)
{
	const int count = (int)Items.storage.size();
	if (row < 0 || row >= count) return false;
	Items.storage[row].Data = Sys::Convert::ToString((int)data);
	return true;
}

bool CheckBoxList::SetSelectedIndex(int index)
{
	const int len = (int)Items.storage.size();
	bool ok = false;
	for(int i = 0; i<len; i++)
	{
		if (i == index)
		{
			Items.storage[i].Checked =  true;
			ok = true;
		}
		else
		{
			Items.storage[i].Checked = false;
		}
	}
	return ok;
}

int CheckBoxList::GetSelectedIndex()
{
	const int len = (int)Items.storage.size();
	for(int i = 0; i<len; i++)
	{
		if (Items.storage[i].Checked ==  true) return i;
	}
	return -1;
}

bool CheckBoxList::GetSelectedData(LPARAM& out_data)
{
	const int index = GetSelectedIndex();
	if (index < 0) return false;
	return GetItemData(index, out_data);
}

bool CheckBoxList::SetSelectedByData(LPARAM data)
{
	const int count = (int)Items.storage.size();
	for(int index = 0; index < count; index++)
	{
		if ((LPARAM)Sys::Convert::ToInt(Items.storage[index].Data) == data)
		{
			return SetSelectedIndex(index);
		}
	}
	return false;
}

bool CheckBoxList::IsItemSelected(int row)
{
	const int count = (int)Items.storage.size();
	if (row < 0 || row >= count) return false;
	return Items.storage[row].Checked;
}

int CheckBoxList::GetSelectedCount()
{
	const int count = (int)Items.storage.size();
	int selectedCount = 0;
	for(int index = 0; index < count; index++)
	{
		if (Items.storage[index].Checked == true) selectedCount++;
	}
	return selectedCount;
}

int CheckBoxList::GetNextSelectedIndex(int row)
{
	int index = (row == -1) ? 0 : row + 1;
	const int count = (int)Items.storage.size();
	for(; index < count; index++)
	{
		if (Items.storage[index].Checked == true) return index;
	}
	return -1;
}

bool CheckBoxList::SetSelection(int row, bool selected)
{
	if (row == -1)
	{
		vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
		const vector<Web::CheckBoxItem>::iterator item_end = Items.storage.end();
		for( ; item != item_end; item++) item->Checked = selected;
		return true;
	}
	else
	{
		const int len = (int)Items.storage.size();
		if (row < 0 || row >= len) return false;
		Items.storage[row].Checked = selected;
	}
	return true;
}

bool CheckBoxList::IsItemChecked(int row)
{
	const int len = (int)Items.storage.size();
	if (row < 0 || row >= len) return false;
	return Items.storage[row].Checked;
}

void CheckBoxList::SetItemChecked(int row, bool checked)
{
	const int len = (int)Items.storage.size();
	if (row < 0 || row >= len) return;
	Items.storage[row].Checked = checked;
}

void CheckBoxList::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

wchar_t* CheckBoxList::GetTag()
{
	if (Cols.storage.size() == 1) return L"div";
	return L"table";
}

void CheckBoxList::Enumerate(wchar_t** data, int colCount, int rowIndex)
{
	int itemCount = 0;
	if (colCount==Cols.GetCount()+1)
	{
		this->Items.Add(data[1], data[0]);
		itemCount = (int)Items.storage.size();
		for(int i=2; i<colCount; i++) this->Items[itemCount-1].Text[i-1] = data[i];
	}
	else if (colCount==Cols.GetCount())
	{
		this->Items.Add(data[0], L"");
		itemCount = (int)Items.storage.size();
		for(int i=1; i<colCount; i++) this->Items[itemCount-1].Text[i] = data[i];
	}
}

void CheckBoxList::GetXml(Web::HttpConnector& httpConnector)
{
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	wchar_t text[128];
	for(int i = 0; item != pEnd; item++, i++)
	{
		httpConnector.WriteText(L"<c><tp>CB</tp><id>");
		_snwprintf_s(text, 128, _TRUNCATE, L"%s%04d", ID.c_str(), i);
		httpConnector.WriteText(text);
		//__________________________________________________________ Enabled
		if (Enabled == true)
		{
			httpConnector.WriteText(L"</id><en>true</en>");
		}
		else
		{
			httpConnector.WriteText(L"</id><en>false</en>");
		}
		//__________________________________________________________ Checked
		if (item->Checked == true)
		{
			httpConnector.WriteText(L"<ck>true</ck></c>");
		}
		else
		{
			httpConnector.WriteText(L"<ck>false</ck></c>");
		}
	}
}

void CheckBoxList::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	const bool isDiv = (Cols.storage.size() == 1);
	const int colCount = (int)Cols.storage.size();
	int i = 0, j = 0;
	//______________________________________________ table or div
	RenderTagAndId(out_html);
	//______________________________________________ class and style
	this->RenderClassAndStyle(out_html);
	//
	out_html.WriteText(L">");
	//_____________________________________________ caption
	if (Text.length() > 0 && isDiv == true)
	{
		out_html.WriteText(L"<caption>");
		out_html.WriteText(Text);
		out_html.WriteText(L"</caption>");
	}
	//________________________________________ First Row (Head)
	if (isDiv == false)
	{
		out_html.WriteText(L"<tr>");
		for(i = 0; i < colCount; i++)
		{
			if (Cols[i].format == LVCFMT_LEFT)
			{
				out_html.WriteText(L"<td style=\"text-align:left\">&nbsp;");
			}
			else if (Cols[i].format == LVCFMT_CENTER)
			{
				out_html.WriteText(L"<td style=\"text-align:center\">&nbsp;");
			}
			else if (Cols[i].format == LVCFMT_RIGHT)
			{
				out_html.WriteText(L"<td style=\"text-align:right\">&nbsp;");
			}
			out_html.WriteText(Cols[i].Text);
			out_html.WriteText(L"&nbsp;</td>");
		}
		out_html.WriteText(L"</tr>");
	}
	//____________________________________________________ Options
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	wchar_t text[256];
	for(i = 0; item != pEnd; item++, i++)
	{
		if (isDiv == false)
		{
			out_html.WriteText(L"<tr class=\"Data\">");
		}
		for(j = 0; j < colCount; j++)
		{
			if (isDiv == false)
			{
				if (Cols[j].format == LVCFMT_LEFT)
				{
					out_html.WriteText(L"<td style=\"text-align:left\">&nbsp;");
				}
				else if (Cols[j].format == LVCFMT_CENTER)
				{
					out_html.WriteText(L"<td style=\"text-align:center\">&nbsp;");
				}
				else if (Cols[j].format == LVCFMT_RIGHT)
				{
					out_html.WriteText(L"<td style=\"text-align:right\">&nbsp;");
				}
			}
			if (j == 0) //________________ Render a checkbox
			{
				_snwprintf_s(text, 256, _TRUNCATE, 
					L"<input type=\"checkbox\" name=\"%s%04d\" id=\"%s%04d\"", 
					ID.c_str(), i, ID.c_str(), i);
				out_html.WriteText(text);
				//
				if (Items[i].Checked == true) RenderPair(L"checked", L"checked", out_html);
				if (Enabled == false) RenderPair(L"disabled", L"disabled", out_html);
				if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
				out_html.WriteText(L" />");
			}
			out_html.WriteText(Items[i].Text[j]);
			if (isDiv == true)
			{
				out_html.WriteText(L"<br />");
			}
			else
			{
				out_html.WriteText(L"&nbsp;</td>");
			}
		}
		if (isDiv == false) out_html.WriteText(L"</tr>");
	}
	//____________________________________________________ </table>
	if (isDiv == true)
	{
		out_html.WriteText(L"</div>");
	}
	else
	{
		out_html.WriteText(L"</table>");
	}
	//____________________________________________________ Item Count
	_snwprintf_s(text, 256, _TRUNCATE, L"<input id=\"%sCount\" type=\"hidden\" name=\"%sCount\" value=\"%d\" />", 
		ID.c_str(), ID.c_str(), (int)Items.storage.size());
	out_html.WriteText(text);
	RenderData(out_html);
	//
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void CheckBoxList::RenderState(Sys::ITextWriterW& out_html)
{
	wchar_t text[128];
	int i = 0;
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	item = Items.storage.begin();
	for(i = 0; item != pEnd; item++, i++)
	{
		if (item->Checked == true)
		{
			_snwprintf_s(text, 128, _TRUNCATE,
				L"<input id=\"%s%04d\" type=\"hidden\" name=\"%s%04d\" value=\"on\" />", 
				ID.c_str(), i, ID.c_str(), i);
		}
		//else
		//{
		//	_snwprintf_s(text, 128, _TRUNCATE,
		//		L"<input ID=\"%s%03d\" type=\"hidden\" name=\"%s%03d\" value=\"%s\" >", 
		//		ID.c_str(), i, ID.c_str(), i, item->Data.c_str());
		//}
		out_html.WriteText(text);
	}
}

void CheckBoxList::RenderData(Sys::ITextWriterW& out_html)
{
	wchar_t text[256];
	int i = 0;
	vector<Web::CheckBoxItem>::iterator item = Items.storage.begin();
	const vector<Web::CheckBoxItem>::iterator pEnd = Items.storage.end();
	item = Items.storage.begin();
	for(i = 0; item != pEnd; item++, i++)
	{
		_snwprintf_s(text, 256, _TRUNCATE,
			L"<input id=\"%s%04dData\" type=\"hidden\" name=\"%s%04dData\" value=\"%s\" />", 
			ID.c_str(), i, ID.c_str(), i, item->Data.c_str());
		out_html.WriteText(text);
	}
}

void CheckBoxList::LoadState(Web::HttpConnector& httpConnector)
{
	wchar_t text[128];
	int i = 0;
	string utf8;
	wstring item_data;
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator icontrol;
		wstring value;
		//___________________________________________ Get Item Count
		_snwprintf_s(text, 128, _TRUNCATE, L"%sCount", ID.c_str());
		if (httpConnector.GetAjaxControlIterator(text, icontrol) == false) return;
		if (icontrol->GetChildValue(L"d", value) == false) return;
		const int itemCount = Sys::Convert::ToInt(value);
		if (itemCount <= 0) return;

		bool checked;
		for(i = 0; i < itemCount; i++)
		{
			//________________________________________________ Checked
			_snwprintf_s(text, 128, _TRUNCATE, L"%s%04d", ID.c_str(), i);
			if (httpConnector.GetAjaxControlIterator(text, icontrol) == false) continue;
			if (icontrol->GetChildValue(L"ck", value) == false) continue;
			checked = Sys::Convert::ToBool(value);
			if (checked == true)
			{
				//________________________________________________ Data
				_snwprintf_s(text, 128, _TRUNCATE, L"%s%04dData", ID.c_str(), i);
				if (httpConnector.GetAjaxControlIterator(text, icontrol) == false) continue;
				if (icontrol->GetChildValue(L"d", item_data) == true) Items._selectedData.insert(item_data);
			}
		}
	}
	else
	{	
		multimap<wstring, wstring>::iterator p;
		//___________________________________________ Get Item Count
		_snwprintf_s(text, 128, _TRUNCATE, L"%sCount", ID.c_str());
		p = httpConnector.value.find(text);
		if (p == httpConnector.value.end()) return;
		const int itemCount = Sys::Convert::ToInt(p->second);
		if (itemCount <= 0) return;
		for(i = 0; i < itemCount; i++)
		{
			//________________________________________________ Checked
			_snwprintf_s(text, 128, _TRUNCATE, L"%s%04d", ID.c_str(), i);
			p = httpConnector.value.find(text);
			if (p != httpConnector.value.end())
			{
				//________________________________________________ Data
				_snwprintf_s(text, 128, _TRUNCATE, L"%s%04dData", ID.c_str(), i);
				p = httpConnector.value.find(text);
				if (p == httpConnector.value.end()) continue; // Impossible to get here
				Sys::Convert::HexToUTF8(p->second.c_str(), utf8);
				Sys::Convert::UTF8ToWstring(utf8, item_data);
				Items._selectedData.insert(item_data);
			}
		}
	}
}

//________________________________________________________ DateTimeBox
DateTimeBox::DateTimeBox()
{
	_snwprintf_s(_monthsText, 37, _TRUNCATE, L"JanFebMarAprMayJunJulAugSepOctNovDic");
	_snwprintf_s(_daysText, 22, _TRUNCATE, L"SunMonTueWedThuFriSat");
	//css.text_align = Web::CssType::TextAlignCenter;
}

DateTimeBox::~DateTimeBox()
{
}

wstring& DateTimeBox::GetText()
{
	return _text;
}

void DateTimeBox::SetText(const wstring& text)
{
	_text = text;
}

void DateTimeBox::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool DateTimeBox::IsVisible()
{
	return VisibleObject::IsVisible();
}

void DateTimeBox::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool DateTimeBox::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

Sys::Time DateTimeBox::GetSelectedDateTime()
{
	return _selectedDate;
}

bool DateTimeBox::SetSelectedDateTime(Sys::Time& systime)
{
	_selectedDate = systime;
	return true;
}

wstring DateTimeBox::GetMonthsText()
{
	return _monthsText;
}

void DateTimeBox::SetMonthsText(const wstring monthsText)
{
	if (monthsText.size() != 36) return;
	_snwprintf_s(_monthsText, 37, _TRUNCATE, L"%s", monthsText.c_str());
}

wstring DateTimeBox::GetDaysText()
{
	return _daysText;
}

void DateTimeBox::SetDaysText(const wstring daysText)
{
	if (daysText.size() != 22) return;
	_snwprintf_s(_daysText, 22, _TRUNCATE, L"%s", daysText.c_str());
}

void DateTimeBox::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

//________________________________________________________ Sys::ISelectTime
Sys::SqlTime& DateTimeBox::SqlGetTime()
{
	return _sqltime;
}

Sys::Time& DateTimeBox::SqlGetSysTime()
{
	return _selectedDate;
}

void DateTimeBox::SqlUpdate(bool toGui)
{
	if (toGui == true)
	{
		Sys::Convert::SqlTimeToSysTime(_sqltime, _selectedDate);
	}
	else
	{
		Sys::Convert::SysTimeToSqlTime(_selectedDate, _sqltime);
	}
}

bool DateTimeBox::GetCurrentSelection(int& month, int& day, int& year)
{
	month = _selectedDate.wMonth;
	day = _selectedDate.wDay;
	year = _selectedDate.wYear;
	return true;
}
	
bool DateTimeBox::SetCurrentSelection(int month, int day, int year)
{
	_selectedDate.wMonth = month;
	_selectedDate.wYear = year;
	_selectedDate.wDay = day;
	return true;
}

void DateTimeBox::GetText(wchar_t* buffer, int bufferLength)
{
	//_______________________________________________ Get Month Text
	const int offset = 3*(_selectedDate.wMonth - 1);
	wchar_t monthText[4];
	monthText[0] = _monthsText[offset];
	monthText[1] = _monthsText[offset+1];
	monthText[2] = _monthsText[offset+2];
	monthText[3] = '\0';
	_snwprintf_s(buffer, bufferLength, _TRUNCATE, L"%s %02d %d", monthText, _selectedDate.wDay, _selectedDate.wYear);
}

void DateTimeBox::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	wchar_t text[16];
	GetText(text, 16);
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	RenderName(out_html);
	if (Enabled == false) RenderPair(L"disabled", L"true", out_html);
	RenderPair(L"type", L"text", out_html);
	RenderPair(L"readonly", L"true", out_html);
	RenderPair(L"size", 11, out_html);
	RenderPair(L"value", text, out_html);
	if (isBrowserView == false)
	{
		if (Enabled == true)
		{
			//out_html.WriteText(L" onclick=\"DisplayCalendar('");
			//out_html.WriteText(ID);
			//out_html.WriteText(L"', '");
			//out_html.WriteText(_monthsText);
			//out_html.WriteText(L"', '");
			//out_html.WriteText(_daysText);
			//out_html.WriteText(L"', '");
			//out_html.WriteText(CssFile);
			//out_html.WriteText(L"')\"");
			out_html.WriteText(L" onclick=\"var win = window.open(\'http://");
			out_html.WriteText(httpConnector.url);
			out_html.WriteText(L"?windowID=CalendarWindowX&destinationDateTimeBoxID=");
			out_html.WriteText(ID);
			out_html.WriteText(L"&monthsText=");
			out_html.WriteText(_monthsText);
			out_html.WriteText(L"&daysText=");
			out_html.WriteText(_daysText);
			out_html.WriteText(L"', 'CalendarWindow', 'width=350,height=280,resizable=1,titlebar=0,scrollbars=1;status=0'); if (win == null) return; win.focus();\"");
		}
	}
	out_html.WriteText(L" />");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
}

void DateTimeBox::GetXml(Web::HttpConnector& httpConnector)
{
	wstring xmlText;
	CreateXmlNode(httpConnector, ID.c_str(), L"Textbox", false);
	if (_selectedDate != _originalDate) //_____________________________________ Update date time
	{
		wchar_t text[16];
		GetText(text, 16);
		httpConnector.WriteText(L"<value>");
		wstring xmlValue;
		Sys::Convert::ToXml(text, xmlValue);
		httpConnector.WriteText(xmlValue);
		httpConnector.WriteText(L"</value>");
	}
	//else  //____________________________________________________________ Nothing to do (date time is the same)
	//{
	//   We do not send:  <value>Apr 20 3001</value>
	//}
	httpConnector.WriteText(L"</control>");
}

void DateTimeBox::SetCurrentSelection(const wchar_t* text)
{
	if (text == NULL) return;
	const int len = (int)wcslen(text);
	if (len < 11) return;
	//______________________________________ Convert To Date
	wchar_t tmp[5];
	_selectedDate.wHour = 0;
	_selectedDate.wMinute = 0;
	_selectedDate.wSecond = 0;
	_selectedDate.wMilliseconds = 0;
	_selectedDate.wDayOfWeek = 0;
	//___ month
	tmp[0] = text[0];
	tmp[1] = text[1];
	tmp[2] = text[2];
	tmp[3] = '\0';
	_selectedDate.wMonth = GetMonth(tmp);
	//___ day
	tmp[0] = text[4];
	tmp[1] = text[5];
	tmp[2] = '\0';
	_selectedDate.wDay = _wtoi(tmp);
	if (_selectedDate.wDay < 1) _selectedDate.wDay = 1;
	if (_selectedDate.wMonth == 1 || _selectedDate.wMonth == 3 || _selectedDate.wMonth == 5 || _selectedDate.wMonth == 7
		|| _selectedDate.wMonth == 8 || _selectedDate.wMonth == 10 || _selectedDate.wMonth == 12)
	{
		if (_selectedDate.wDay > 31) _selectedDate.wDay = 31;
	}
	else if (_selectedDate.wMonth == 2)
	{
		if (_selectedDate.wDay > 29) _selectedDate.wDay = 28;
	}
	else
	{
		if (_selectedDate.wDay > 30) _selectedDate.wDay = 30;
	}
	//___ year
	tmp[0] = text[7];
	tmp[1] = text[8];
	tmp[2] = text[9];
	tmp[3] = text[10];
	tmp[4] = '\0';
	_selectedDate.wYear = _wtoi(tmp);
	if (_selectedDate.wYear < 1900) _selectedDate.wYear = 1900;
	if (_selectedDate.wYear > 5000) _selectedDate.wYear = 5000;
}
	
void DateTimeBox::SetCurrentSelection(const wstring& text)
{
	SetCurrentSelection(text.c_str());
}

void DateTimeBox::LoadState(Web::HttpConnector& httpConnector)
{
	if (httpConnector.Ajax == true)
	{
		list<Sys::Xml>::const_iterator control;
		if (Web::VisibleObject::LoadState(httpConnector, false, control) == false) return;
		//_________________________________________________ Value
		list<Sys::Xml>::const_iterator element = control->child.begin();
		const list<Sys::Xml>::const_iterator element_end = control->child.end();
		for(; element != element_end; element++)
		{
			if (element->name == L"d")
			{
				_text = element->value;
				//_originalText = _text; // It is not necessary to store the original text as we are storing the original date
				SetCurrentSelection(_text);
				_originalDate = _selectedDate;
				break;
			}
		}
	}
	else
	{
		wstring name(ID);
		name += L"Data";
		multimap<wstring, wstring>::iterator state = httpConnector.value.find(name);
		if (state == httpConnector.value.end()) return;
		SetCurrentSelection(state->second);
	}
}

int DateTimeBox::GetMonth(wchar_t* text)
{
	int i;
	int offset;
	for (i = 0; i < 12; i++)
	{
		offset = 3 * i;
		if (_monthsText[offset] != text[0]) continue;
		if (_monthsText[offset + 1] != text[1]) continue;
		if (_monthsText[offset + 2] != text[2]) continue;
		return i + 1;
	}
	return 1;
}

wchar_t* DateTimeBox::GetTag()
{
	return L"input";
}

void DateTimeBox::CreateMonthsName(const string& monthsText, vector<string>& out_month)
{
	const int len = (int)monthsText.length();
	out_month.resize(12);
	if (len != 36)
	{
		out_month[0] = "Jan";
		out_month[1] = "Feb";
		out_month[2] = "Mar";
		out_month[3] = "Apr";
		out_month[4] = "May";
		out_month[5] = "Jun";
		out_month[6] = "Jul";
		out_month[7] = "Aug";
		out_month[8] = "Sep";
		out_month[9] = "Oct";
		out_month[10] = "Nov";
		out_month[11] = "Dec";
		return;
	}
	int i;
	int offset;
	string text;
	for (i = 0; i < 12; i++)
	{
		offset = 3 * i;
		text.assign(monthsText.begin()+offset, monthsText.begin()+offset + 3);
		out_month[i] = text;
	}
}

void DateTimeBox::CreateDaysName(const string& daysText, vector<string>& out_days)
{
	const int len = (int)daysText.length();
	out_days.resize(7);
	if (len != 21)
	{
		out_days[0] = "Sun";
		out_days[1] = "Mon";
		out_days[2] = "Tue";
		out_days[3] = "Web";
		out_days[4] = "Thu";
		out_days[5] = "Fri";
		out_days[6] = "Sat";
		return;
	}
	int i;
	int offset;
	string text;
	for (i = 0; i < 7; i++)
	{
		offset = 3 * i;
		text.assign(daysText.begin()+offset, daysText.begin()+offset + 3);
		out_days[i] = text;
	}
}

void DateTimeBox::GetCalendarWindowHtml(const wstring& destinationDateTimeBoxID, const wstring& monthsText, const wstring& daysText, string& out_html)
{
	//______________________________________________________________________ Convert input variables to string
	string destinationDateTimeBoxIDA;
	string monthsTextA;
	string daysTextA;
	//string cssFileA;
	Sys::Convert::WstringToString(destinationDateTimeBoxID, destinationDateTimeBoxIDA);
	Sys::Convert::WstringToString(monthsText, monthsTextA);
	Sys::Convert::WstringToString(daysText, daysTextA);
	//Sys::Convert::WstringToString(cssFile, cssFileA);
	//if (cssFileA.empty() == true) cssFileA = "cyan.css";
	//______________________________________________________________________ Get a vector for monthName and dayName
	vector<string> monthName;
	vector<string> dayName;
	CreateMonthsName(monthsTextA, monthName);
	CreateDaysName(daysTextA, dayName);

	out_html = "<html><head><title>Calendar</title><script language=\"javascript\" type=\"text/javascript\" src=\"Wintempla.js\"></script>";
    //_________________________________________________________ Stylesheet
	//out_html += "<link rel=\"stylesheet\" type=\"text/css\" href=\''";
	//out_html += cssFileA;
	//out_html += "\" />";
	//_________________________________________________________ body
	out_html += "</head><body style=\"margin:0px;padding-left:0px\" onload=\"LoadCalendar('";
	out_html += destinationDateTimeBoxIDA;
	out_html += "\', \'";
	out_html += monthsTextA;
	out_html += "\')\" >";
	//_____________________
	out_html += "<table style=\"width:100%\" cellspacing=\"0\"  cellspadding=\"0\"><tr style=\"width:100%\"><td style=\"width:100%\"><table style=\"width:100%;background-color:#E0E8E8;border-style:solid;border-width:1px;border-color:#C0C0C0\"><tr>";
	 //_____________________________________________ Month
	out_html += "<td><select id=\"DropDownMonth\" onchange=\"UpdateMonth()\" />";
    int row, col;
	char text[256];
	for (row = 0;row < 12;row++)
	{
		if (row == 0)
		{
			_snprintf_s(text, 256, _TRUNCATE, "<option value=\"%d\" selected=\"selected\">%s</option>", row, monthName[row].c_str());
		}
		else
		{
			_snprintf_s(text, 256, _TRUNCATE, "<option value=\"%d\">%s</option>", row, monthName[row].c_str());
		}
		out_html += text;
	}
	out_html += "</select><td style=\"text-align:right\" ><input style=\"text-align:center\" type=\"text\" value=\"2015\" id=\"TextBoxYear\" onkeyup=\"UpdateYear()\" /></td></tr></table>";
	out_html += "<tr><td style=\"width:100%\"><table style=\"width:100%\" ><tr><td style=\"text-align:center;font-family:'Arial';width:14%%;color:#C00000\" >&nbsp;";
	out_html += dayName[0];
	out_html += "&nbsp;</td>";
	for (col= 1; col < 7; col++)
	{
		_snprintf_s(text, 256, _TRUNCATE, "<td style=\"text-align:center;font-family:'Arial';width:14%%\" >&nbsp;%s&nbsp;</td>", dayName[col].c_str());
		out_html += text;
	}
	out_html += "</tr>";

	for (row = 0; row < 6; row++) 
	{
		out_html += "<tr>";
		for (col = 0; col < 7; col++)
		{
			_snprintf_s(text, 256, _TRUNCATE, 
				"<td style=\"width:14%%\"><input style=\"width:100%%;color:#000000;font-weight:normal\" type=\"button\" id=\"ButtonCa%d%d\" onclick=\"SelectDay(\'ButtonCa%d%d\', \'%s\', \'%s\')\" class=\"Calendar\" /></td>",
				row, col, row, col, monthsTextA.c_str(), destinationDateTimeBoxIDA.c_str());
			out_html += text;
		}
		out_html += "</tr>";
	}
	out_html += "</table></td></tr></table><noscript><h2>This page requires Javascript.</h2></noscript></body></html>";
}

//________________________________________________________ DateView
DateView::DateView()
{
}

DateView::~DateView()
{
}

wstring& DateView::GetText()
{
	return _text;
}

void DateView::SetText(const wstring& text)
{
	_text = text;
}

void DateView::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool DateView::IsVisible()
{
	return VisibleObject::IsVisible();
}

void DateView::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool DateView::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

Sys::Time DateView::GetSelectedDateTime()
{
	return _selectedDate;
}

bool DateView::SetSelectedDateTime(Sys::Time& systime)
{
	_selectedDate = systime;
	return true;
}

//________________________________________________________ Sys::ISelectTime
Sys::SqlTime& DateView::SqlGetTime()
{
	return _sqltime;
}

Sys::Time& DateView::SqlGetSysTime()
{
	return _selectedDate;
}

void DateView::SqlUpdate(bool toGui)
{
	Web::DateTimeBox::SqlUpdate(toGui);
}

bool DateView::GetCurrentSelection(int& month, int& day, int& year)
{
	return Web::DateTimeBox::GetCurrentSelection(month, day, year);
}
	
bool DateView::SetCurrentSelection(int month, int day, int year)
{
	return Web::DateTimeBox::SetCurrentSelection(month, day, year);
}

void DateView::SetCurrentSelection(const wchar_t* text)
{
	Web::DateTimeBox::SetCurrentSelection(text);
}
	
void DateView::SetCurrentSelection(const wstring& text)
{
	SetCurrentSelection(text.c_str());
}

void DateView::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//if (Visible == false) return;
	//RenderTagAndId(false, indentCount, out_html);
	//RenderClassAndStyle(out_html);
	//RenderPair(L"src", src, out_html);
	//RenderPair(L"alt", Text, out_html);
	//javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	//out_html.WriteText(L" />");
	//if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
	////________________________________________________________ CalendarView
//CalendarView::CalendarView(void)
//{
//	m_nTdCount = 0;
//	Web::TableEx::Create(3, 1);
//
//	//********************************************** main table css setup
//	this->css.background.Set(L"d0d0ff"));
//	this->css.border.Set(L"3px outset #c0c0c0"));
//	this->css.width.Set("100%");
//	this->css.height.Set("100%");
//	//this->CustomData+=("border=\"1\"");
//	//********************************************** Header setup
//	m_tableHeader.css.width.Set(L"100%"));
//	m_tableHeader.Create(1, 3);
//	//
//	// Prev
//	m_tableHeader.GetTd(0, 0).css.textAlign.Set(L"left"));
//	m_tableHeader.GetTd(0, 0).AddChild(m_alPrev);
//	m_alPrev.AddChild(m_spanPrev);
//	m_spanPrev.css.border.Set(L"0px solid #ffffff"));
//	m_spanPrev.css.textDecoration.Set(L"none"));
//	m_spanPrev.SetInnerText(L"<b>&lt;&lt;Prev</b>"), false);
//	//
//	// Header Month, Year
//	m_tableHeader.GetTd(0, 1).css.textAlign.Set(L"center"));
//	//
//	// Next
//	m_tableHeader.GetTd(0, 2).css.textAlign.Set(L"right"));
//	m_tableHeader.GetTd(0, 2).AddChild(m_alNext);
//	m_alNext.AddChild(m_spanNext);
//	m_spanNext.css.border.Set(L"0px solid #ffffff"));
//	m_spanNext.css.textDecoration.Set(L"none"));
//	m_spanNext.SetInnerText(L"<b>Next&gt;&gt;</b>"), false);
//	this->GetTd(0, 0).AddChild(m_tableHeader);
//	this->GetTd(1, 0).AddChild(m_tableDayNames);
//	this->GetTd(2, 0).AddChild(m_tableDays);
//	//
//	this->GetTd(2, 0).css.width.Set(L"100%"));
//	this->GetTr(2).css.width.Set(L"100%"));
//	//
//	m_tableDayNames.css.border.Set(L"1px groove #ffffff"));
//	m_tableDayNames.css.width.Set(L"100%"));
//	m_tableDayNames.css.height.Set(L"100%"));
//	//
//	m_tableDays.css.width.Set(L"100%"));
//	m_tableDays.css.height.Set(L"100%"));
//}
//
//CalendarView::~CalendarView(void)
//{
//}
//
//void CalendarView::Create(bool bDisplayDayNames, bool bDisplayWeekend, int nCalendarPage, bool bSpanish)
//{
//	int nDay = 0;
//	int nMonth = server.GetIntVariable(L"nCalendarMonth"));
//	int nYear = server.GetIntVariable(L"nCalendarYear"));
//	__time64_t lTime, lLocalTime;
//	const int nColCount = bDisplayWeekend ? 7 : 5;
//	m_tableDayNames.Visible = bDisplayDayNames;
//	tm * today;
//	tm When;
//	bool bOk = false;
//	wchar_t szMonth[32];
//	wchar_t szYear[32];
//	wchar_t sz[256];
//	Web::Value wvMonth;
//	Web::Value wvYear;
//	wchar_t szMonthYear[128];
//	Data::DateAndTime dt;
//	int nLocalDay, nLocalMonth, nLocalYear, index, i, j;
//	int nCurrentMonth, nCurrentDay, nCurrentYear;
//
//	if (bDisplayDayNames)
//	{
//		this->GetTr(0).css.height.Set(L"20px"));
//		this->GetTr(1).css.height.Set(L"30px"));
//	}
//	else
//	{
//		this->GetTr(0).css.height.Set(L"20px"));
//		this->GetTr(1).css.height.Set(L"0px"));
//	}
//
//	//
//	if ((nMonth==0) && (nDay==0) && (nYear==0))
//	{
//		_time64(&lTime);
//		today=_localtime64(&lTime);
//		nMonth=today->tm_mon;
//		nDay=today->tm_mday;
//		nYear=today->tm_year;
//		lLocalTime=Data::DateAndTime::FindFirstSunday(lTime);
//		bOk=true;
//	}
//
//	if  (  (0<nMonth) && (nMonth<=12) && (1900<nYear) && (nYear<=9999))
//	{
//		nMonth--;
//		nYear-=1900;
//		When.tm_year=nYear;
//		When.tm_mon=nMonth;
//		When.tm_mday=1;
//		When.tm_hour=12;
//		When.tm_min=0;
//		When.tm_sec=0;
//
//		if ( (lLocalTime=mktime(&When))  !=(time_t)-1)
//		{
//			lLocalTime=Data::DateAndTime::FindFirstSunday(lLocalTime);
//			bOk=true;
//		}
//		else
//			bOk=false;
//	}
//
//	//************************************************ Prev button
//	if (nMonth==0)
//	{	
//		_itot(nYear+1900-1, szYear, 10);
//		lstrcpy(szMonth, L"12"));
//	}
//	else
//	{
//		itoa(nYear+1900, szYear, 10);
//		_itot(nMonth, szMonth, 10); // it should be (nMonth+1)-1
//	}
//	wvMonth.Set(L"nCalendarMonth"), szMonth);
//	wvYear.Set(L"nCalendarYear"), szYear);
//	m_alPrev.AddWebValue(wvMonth);
//	m_alPrev.AddWebValue(wvYear);
//	m_alPrev.Create(false, nCalendarPage);
//
//	//**************************************************** Month, Year
//	_sntprintf(szMonthYear, 128, L"<b>%s, %d</b>"), dt.GetMonthName(nMonth, true), nYear+1900);
//	m_tableHeader.GetTd(0, 1).SetInnerText(szMonthYear, true);
//
//	//************************************************ Next button
//	if (nMonth==11)
//	{	
//		_itot(nYear+1900+1, szYear, 10);
//		lstrcpy(szMonth, L"1"));
//	}
//	else
//	{
//		itoa(nYear+1900, szYear, 10);
//		_itot(nMonth+2, szMonth, 10); // it should be (nMonth+1)+1
//	}
//	wvMonth.Set(L"nCalendarMonth"), szMonth);
//	wvYear.Set(L"nCalendarYear"), szYear);
//	m_alNext.AddWebValue(wvMonth);
//	m_alNext.AddWebValue(wvYear);
//	m_alNext.Create(false, nCalendarPage);
//
//	//************************************************ Sun, Mon ... Sat
//	m_tableDayNames.Create(1, nColCount);
//	m_tableDayNames.GetTr(0).css.height.Set(L"30px"));
//	for(i= 0; i< nColCount; i++)
//	{
//		m_tableDayNames.GetTd(0, i).css.border.Set(L"1px groove #ffffff"));
//		m_tableDayNames.GetTd(0, i).css.textAlign.Set(L"center"));
//		if (bDisplayWeekend)
//		{
//			m_tableDayNames.GetTd(0, i).css.width.Set(L"14.29%"));
//			if (i==0 || i==6)
//			{
//				m_tableDayNames.GetTd(0, i).css.background.Set(L"c0d0ff"));
//			}
//			else
//			{
//				m_tableDayNames.GetTd(0, i).css.background.Set(L"d0f0ff"));
//			}
//		}
//		else
//		{
//			m_tableDayNames.GetTd(0, i).css.width.Set(L"20%"));
//			m_tableDayNames.GetTd(0, i).css.background.Set(L"d0f0ff"));
//		}
//	}
//	if (bDisplayWeekend)
//	{
//		m_tableDayNames.GetTd(0, 0).SetInnerText(L"Sunday"), false);
//		m_tableDayNames.GetTd(0, 1).SetInnerText(L"Monday"), false);
//		m_tableDayNames.GetTd(0, 2).SetInnerText(L"&nbsp;Tuesday&nbsp;"), false);
//		m_tableDayNames.GetTd(0, 3).SetInnerText(L"Wednesday"), false);
//		m_tableDayNames.GetTd(0, 4).SetInnerText(L"Thursday"), false);
//		m_tableDayNames.GetTd(0, 5).SetInnerText(L"&nbsp;&nbsp;Friday&nbsp;&nbsp;"), false);
//		m_tableDayNames.GetTd(0, 6).SetInnerText(L"Saturday"), false);
//	}
//	else
//	{
//		m_tableDayNames.GetTd(0, 0).SetInnerText(L"Monday"), false);
//		m_tableDayNames.GetTd(0, 1).SetInnerText(L"&nbsp;Tuesday&nbsp;"), false);
//		m_tableDayNames.GetTd(0, 2).SetInnerText(L"Wednesday"), false);
//		m_tableDayNames.GetTd(0, 3).SetInnerText(L"Thursday"), false);
//		m_tableDayNames.GetTd(0, 4).SetInnerText(L"&nbsp;&nbsp;Friday&nbsp;&nbsp;"), false);
//	}
//
//	//****************************************** point m_td and css setup
//	index = 0;
//	m_tableDays.Create(6, nColCount);
//	m_nTdCount = 6*nColCount;
//	for(i = 0; i<6; i++)
//	{
//		m_tableDays.GetTr(i).css.verticalAlign.Set(L"top"));
//		for(j = 0; j<nColCount; j++)
//		{
//			m_tdCell[index] = &m_tableDays.GetTd(i, j);
//			//
//			m_tdCell[index]->AddChild(m_span[index]);
//			//
//			if (bDisplayWeekend)
//				m_tdCell[index]->css.width.Set(L"14.29%"));
//			else
//				m_tdCell[index]->css.width.Set(L"20%"));
//			index++;
//		}
//	}
//
//	//********************************************************** tds setup
//	today=_localtime64(&lLocalTime);
//	nLocalDay=today->tm_mday;
//	nLocalMonth=today->tm_mon;
//	nLocalYear=today->tm_year;
//	index = 0;
//	bool bIsWeekend = false;
//	bool bIsToday = false;
//	Data::DateAndTime::GetCurrentDate(nCurrentMonth, nCurrentDay, nCurrentYear);
//	for (i=0; i<42; i++)
//	{
//		bIsWeekend = ((i%7)==0 || ((i+1)%7==0));
//		bIsToday = (nLocalDay == nCurrentDay && nLocalMonth == nCurrentMonth && nLocalYear+1900==nCurrentYear);
//		if (bDisplayWeekend)//***************************** Display working days and weekend
//		{
//			m_tm[index]=lLocalTime;
//			if (bIsToday)
//			{
//				_sntprintf(sz, 256, L"<b><u>%d</u></b>"), nLocalDay);
//			}
//			else
//			{
//				_sntprintf(sz, 256, L"%d"), nLocalDay);
//			}
//			m_span[index].css.SetFont(L"Times New Roman"), 17);
//			m_span[index].SetInnerText(sz, true);
//			//		
//			if (nLocalMonth==nMonth)
//			{
//				if (bIsToday)
//				{
//					m_tdCell[index]->css.background.Set(L"ffffe0"));
//				}
//				else
//				{
//					m_tdCell[index]->css.background.Set(L"ffffff"));
//				}
//			}
//			else
//				m_tdCell[index]->css.background.Set(L"c0c0c0"));
//
//			m_tdCell[index]->css.border.Set(L"1px groove #ffffff"));
//			//
//			if (bIsWeekend)
//			{
//				m_span[index].css.color.Set(L"b0b0b0"));
//			}
//			else
//			{
//				m_span[index].css.color.Set(L"f00000"));
//			}
//			index++;
//		}
//		else//**************************************************Display only working days
//		{
//			if (!bIsWeekend)
//			{
//				m_tm[index]=lLocalTime;
//				m_span[index].css.SetFont(L"Times New Roman"), 17);
//				if (bIsToday)
//				{
//					_sntprintf(sz, 256, L"<b><u>%d</u></b>"), nLocalDay);
//				}
//				else
//				{
//					_sntprintf(sz, 256, L"%d"), nLocalDay);
//				}
//				m_span[index].SetInnerText(sz, true);
//				//		
//				if (nLocalMonth==nMonth)
//				{
//					if (bIsToday)
//					{
//						m_tdCell[index]->css.background.Set(L"ffffe0"));
//					}
//					else
//					{
//						m_tdCell[index]->css.background.Set(L"ffffff"));
//					}
//				}
//				else
//				{
//					m_tdCell[index]->css.background.Set(L"c0c0c0"));
//				}
//
//				m_tdCell[index]->css.border.Set(L"1px groove #ffffff"));
//				//
//				m_span[index].css.color.Set(L"f00000"));
//
//				index++;
//			}
//		}
//		lLocalTime=lLocalTime+86400;
//		today=_localtime64(&lLocalTime);
//		nLocalDay=today->tm_mday;
//		nLocalMonth=today->tm_mon;
//		nLocalYear=today->tm_year;
//	}
//}
//
//int CalendarView::GetCellCount()
//{
//	return m_nTdCount;
//}
//
//Web::Td* CalendarView::GetCell(int index)
//{
//	if (0<=index && index<m_nTdCount)
//	{
//		return m_tdCell[index];
//	}
//	else
//	{
//		return NULL;
//	}
//}
//
//__time64_t CalendarView::GetCellInfo(int index)
//{
//	if (0<=index && index<m_nTdCount)
//	{
//		return m_tm[index];
//	}
//	else
//	{
//		return 0;
//	}
//}
//

}

//________________________________________________________ PlugIn: FlashPlayer, ...
PlugIn::PlugIn()
{
	//Type = L"application/x-shockwave-flash";
	css.width = 400;
	css.height = 220;
}

PlugIn::~PlugIn()
{
}

void PlugIn::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void PlugIn::GetPreview(int& indentCount, Sys::ITextWriterW& out_html, bool isBrowserView)
{
	if (BeginHtml.length() > 0) out_html.WriteText(BeginHtml);
	//Indent(indentCount, out_html);
	if (isBrowserView == true)
	{
		out_html.WriteText(L"<span");
	}
	else
	{
		out_html.WriteText(L"<object");
	}
	
	//______________________________________ id
	RenderPair(L"id", ID, out_html);

	RenderClassAndStyle(out_html);
	out_html.WriteText(L" />");

	if (isBrowserView == true)
	{
		out_html.WriteText(ID);
		out_html.WriteText(L"</span>");
	}
	else
	{
		out_html.WriteText(L"</object>");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void PlugIn::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	RenderTagAndId(out_html);
	RenderClassAndStyle(out_html);
	RenderPair(L"type", Type, out_html);
	RenderPair(L"data", Data, out_html);
	if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
	out_html.WriteText(L" />");
	//__________________________ params
	const vector<Web::ObjectParam>::iterator paramEnd = param.end();
	vector<Web::ObjectParam>::iterator par;
	for(par = param.begin(); par != paramEnd; par++)
	{
		out_html.WriteText(L"<param name=\"");
		out_html.WriteText(par->name);
		out_html.WriteText(L"\" value=\"");
		out_html.WriteText(par->value);
		out_html.WriteText(L"\" >");
	}
	out_html.WriteText(L"</object>");
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void PlugIn::AddParam(const wchar_t* name, const wchar_t* value)
{
	Web::ObjectParam op;
	op.name = name;
	op.value = value;
	param.push_back(op);
}

void PlugIn::AddParam(const wstring& name, const wstring& value)
{
	Web::ObjectParam op;
	op.name = name;
	op.value = value;
	param.push_back(op);
}

void PlugIn::GetXml(Web::HttpConnector& httpConnector)
{
}

void PlugIn::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* PlugIn::GetTag()
{
	return L"object";
}

//________________________________________________________ Pie
Pie::Pie()
{
}

Pie::~Pie()
{
}

bool Pie::operator<(const Web::Pie& pie) const
{
	return (Value < pie.Value);
}

//________________________________________________________ PieCollection
PieCollection::PieCollection()
{
}

PieCollection::~PieCollection()
{
}

void PieCollection::Add(const wstring& text, COLORREF color, double value)
{
	Web::Pie pie;
	pie.Color = color;
	pie.Text = text;
	pie.Value = value;
	storage.push_back(pie);
}

void PieCollection::DeleteAll()
{
	storage.clear();
}

Web::Pie& PieCollection::operator[](long index)
{
	return storage[index];
}

int PieCollection::GetCount()
{
	return (int)storage.size();
}

#ifdef WIN_GDI_PLUS_ON
//_____________________________________________________________________ Graph
Graph::Graph()
{
	type = Web::Graph::TypeLine;
	color = RGB(200, 60, 60);
	penWidth = 1;
}

Graph::~Graph()
{
}

double Graph::GetMaxX(void)
{
	const int pointCount = (int)point.size();
	if (pointCount== 0) return 0.0;
	double maximum = point[0].x;
	for(int i = 1; i<pointCount; i++)
	{
		if (maximum<point[i].x) maximum = point[i].x;
	}
	return maximum;
}

double Graph::GetMaxY(void)
{
	const int pointCount = (int)point.size();
	if (pointCount== 0) return 0.0;
	double maximum = point[0].y;
	for(int i = 1; i<pointCount; i++)
	{
		if (maximum<point[i].y) maximum = point[i].y;
	}
	return maximum;
}

//_____________________________________________________________________ GraphCollection
GraphCollection::GraphCollection()
{
}

GraphCollection::~GraphCollection()
{
}

int GraphCollection::GetCount()
{
	return (int)storage.size();
}

int GraphCollection::Add()
{
	Web::Graph graph;
	storage.push_back(graph);
	return (int)storage.size();
}

int GraphCollection::Add(int graphPointCount)
{
	Web::Graph graph;
	storage.push_back(graph);
	storage.back().point.resize(graphPointCount);
	return (int)storage.size();
}

void GraphCollection::Delete(long index)
{
	vector<Web::Graph>::iterator p = storage.begin() +index;
	if (p == storage.end()) return;
	storage.erase(p);
}

void GraphCollection::DeleteAll()
{
	storage.clear();
}

Web::Graph& GraphCollection::operator[](long index)
{
	return storage[index];
}

//________________________________________________________ PieChart
PieChart::PieChart()
{
}

PieChart::~PieChart()
{
}

void PieChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{

	double _xCaption = (int)(12*css.font_size);//(0.4*width+0.5);
	const double pieWidth = abs(css.width) - _xCaption;
	const double _dimension = MINIMUM(pieWidth, abs(css.height));
	const int radius = (int)(_dimension*0.95/2.0+0.5);
	const int xCenter = (int)(radius + 0.05*_dimension+0.5);
	const int yCenter = (int)(abs(css.height)/2.0+0.5);
	_xCaption = (int)(1.05 * _dimension+0.5);
	double _yCaption = _dimension*0.05;
	int i=0;
	double angleIni = 0.0;

	Gdiplus::PointF point;
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentNear);
	sf.SetLineAlignment(Gdiplus::StringAlignmentNear);

	const int pieCount = (int)Pies.storage.size();

	//________________________________________compute total
	double _total = 0.0;
	for(i=0; i<pieCount; i++)
    {
		_total += fabs(Pies.storage[i].Value);
    }
	const double spacing =  font.GetHeight(0.0);
	//_________________________________________ title
	if (Text.length() > 0)
	{
		point.X = (Gdiplus::REAL)_xCaption;
		point.Y = (Gdiplus::REAL)_yCaption;
		graphics.DrawString(Text.c_str(), -1, &font, point, &sf, &brushFont);
		point.Y += (Gdiplus::REAL)(1.5*spacing);
	}

	double value = 0.0;
	double angleDelta = 0.0;
	wchar_t texto[128];
	double percentaje = 0.0;
	wstring wpercent;
	Gdiplus::RectF rect;
	point.X = (Gdiplus::REAL)(_xCaption + 1.05*spacing);
	rect.X = (Gdiplus::REAL)(_xCaption+0.1*spacing);
	rect.Width = (Gdiplus::REAL)(0.8*spacing);
	rect.Height = (Gdiplus::REAL)(0.8*spacing);
	for(i=0; i<pieCount; i++)
    {
		percentaje = fabs(Pies.storage[i].Value*100.0/_total);
		angleDelta = percentaje*360.0/100.0;
		//
		Gdiplus::SolidBrush brush(Gdiplus::Color(255, GetRValue(Pies.storage[i].Color), GetGValue(Pies.storage[i].Color), GetBValue(Pies.storage[i].Color)));
		if (percentaje > 0.0)
		{
			graphics.FillPie(&brush,
			xCenter-radius, 
			yCenter-radius, 
			2*radius, 
			2*radius,
			(Gdiplus::REAL)angleIni,
			(Gdiplus::REAL)angleDelta);
			angleIni += angleDelta;
		}

		//____________________________________________ Caption Square
		rect.Y = (Gdiplus::REAL)(point.Y+0.1*spacing);
		graphics.FillRectangle(&brush, rect);
		//____________________________________________ Caption
		if (percentaje>1.0)
		{
			_snwprintf_s(texto, 128, _TRUNCATE, L"%s %.0f%%", Pies.storage[i].Text.c_str(), percentaje);
		}
		else
		{
			_snwprintf_s(texto, 128, _TRUNCATE, L"%s %.1f%%", Pies.storage[i].Text.c_str(), percentaje);
		}
		//Sys::Convert::ToString(percentaje, texto, 128, true);
		//wpercent = Pies.storage[i].Text;
		//wpercent += ' ';
		//wpercent += texto;
		//wpercent += '%';
		//graphics.DrawString(wpercent.c_str(), -1, &font, point, &sf, &brushFont);
		graphics.DrawString(texto, -1, &font, point, &sf, &brushFont);
		//
		point.Y += (Gdiplus::REAL)(1.1*spacing);
	}
}

void PieChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);

	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//___________________________________________ Data
	p = h.value.find(L"Data"); 
	if (p == valueEnd) return;
	const int len = (int)p->second.length();
	double value = 0.0;
	int red = 0;
	int green = 0;
	int blue = 0;
	wstring tmp;
	int i = 0;
	int state = 0;
	wchar_t c;
	for(i = 0; i < len; i++)
	{
		c = p->second[i];
		if (state == 0) //_____________________ Value
		{
			if (c == '#')
			{
				value = Sys::Convert::ToDouble(tmp);
				tmp.clear();
				state = 1;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 1)//_____________________ Red
		{
			if (c == '#')
			{
				red = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 2;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 2)//_____________________ Green
		{
			if (c == '#')
			{
				green = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 3;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 3)//_____________________ Blue
		{
			if (c == '#')
			{
				blue = Sys::Convert::ToInt(tmp);
				tmp.clear();
				state = 4;
			}
			else
			{
				tmp += c;
			}
		}
		else if (state== 4)//_____________________ Text
		{
			if (c == '#')
			{
				Pies.Add(tmp, RGB(red, green, blue), value);
				tmp.clear();
				state = 0;
			}
			else
			{
				tmp += c;
			}
		}
	}
}

void PieChart::GetSource(wstring& source, const wchar_t* url)
{
	const vector<Web::Pie>::iterator pieEnd = Pies.storage.end();
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=PieChart";

	Web::PieChart chart;
	this->RenderProperties(chart, source);

	source += L"&Data=";
	
	for(vector<Web::Pie>::iterator pie = Pies.storage.begin(); pie != pieEnd; pie++)
	{
		Sys::TextAssistant::ReplaceChar(pie->Text, '#', ' ');
		_snwprintf_s(text, 256, _TRUNCATE, L"%g#%d#%d#%d#%s#",
			pie->Value, GetRValue(pie->Color), GetGValue(pie->Color), GetBValue(pie->Color), pie->Text.c_str());
		Sys::Convert::WstringToHex(text, encodedText);
		source += encodedText;
	}
}

//________________________________________________________ PolarChart
PolarChart::PolarChart()
{
	AutoScale = true;
	_scale = 1.0;
	_centerX = 100.0;
	_centerY = 100.0;
	MaxRadius = 1.0;
	MinRadius = 0.0;
	LineColor = RGB(225, 225, 255);
	SubgridColor = RGB(240, 240, 245);
	ShowSubgrid = true;
}

PolarChart::~PolarChart()
{
}

void PolarChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{
	const int graphCount = (int)Graphs.storage.size();
	double minR=MinRadius;
	double maxR=MaxRadius;
	int i = 0, j, n;
	//int index = 0;
	if (AutoScale == true && graphCount > 0)
	{
		minR = maxR = Graphs[0].point[0].y;
		for(i=0; i<graphCount; i++)
		{
			n = (int)Graphs[i].point.size();
			for(j = 0; j<n; j++)
			{
				if (Graphs[i].point[j].y<minR) minR = Graphs[i].point[j].y;
				if (Graphs[i].point[j].y>maxR) maxR = Graphs[i].point[j].y;
			}
		}
	}
	if (minR == maxR)
	{
		minR = 0.0;
		maxR = 1.0;
	}

	const int max_r = (int)((MINIMUM(abs(css.width), abs(css.height)))/2.1);
	_centerX = abs(css.width)/2.0;
	_centerY = abs(css.height)/2.0;
	_scale = max_r/(maxR - minR);

	const int markCount = 10;
	const double radius = maxR - minR;
	double r = 0.0;
	//___________________________________________________ Sub Grid
	if (ShowSubgrid == true)
	{
		Gdiplus::Pen penSubgrid(Gdiplus::Color(255, GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor)), 1.0f);
		for(i = 1; i <= markCount; i+=2)
		{
			r = i*radius* _scale/markCount;
			graphics.DrawEllipse(&penSubgrid, (Gdiplus::REAL)(_centerX-r), (Gdiplus::REAL)(_centerY-r), 
				(Gdiplus::REAL)(2.0*r), (Gdiplus::REAL)(2.0*r));
		}
		ShortLine(graphics, penSubgrid, 10.0, radius);
		ShortLine(graphics, penSubgrid, 20.0, radius);
		ShortLine(graphics, penSubgrid, 40.0, radius);
		ShortLine(graphics, penSubgrid, 50.0, radius);
		ShortLine(graphics, penSubgrid, 70.0, radius);;
		ShortLine(graphics, penSubgrid, 80.0, radius);
	}


	//__________________________________________________ Grid
	for(i = 2; i <= markCount; i += 2)
	{
		r = i*radius* _scale/markCount;
		graphics.DrawEllipse(&penLine, (Gdiplus::REAL)(_centerX-r), (Gdiplus::REAL)(_centerY-r), 
				(Gdiplus::REAL)(2.0*r), (Gdiplus::REAL)(2.0*r));
	}
	//________________________________________________ X Axis
	graphics.DrawLine(&penLine, 
		(Gdiplus::REAL)(_centerX-radius* _scale), (Gdiplus::REAL)(_centerY), 
		(Gdiplus::REAL)(_centerX+radius* _scale), (Gdiplus::REAL)(_centerY));

	//________________________________________________ Y Axis
	graphics.DrawLine(&penLine, 
		(Gdiplus::REAL)(_centerX), (Gdiplus::REAL)(_centerY-radius* _scale), 
		(Gdiplus::REAL)(_centerX), (Gdiplus::REAL)(_centerY+radius* _scale));


	Line(graphics, penLine, 30.0, radius);
	Line(graphics, penLine, 60.0, radius);

	//_______________________________________________________________ Paint Window Text
	if (Text.length() > 0)
	{
		Gdiplus::StringFormat stringFormat;
		stringFormat.SetAlignment(Gdiplus::StringAlignmentNear);
		stringFormat.SetLineAlignment(Gdiplus::StringAlignmentNear);
		Gdiplus::PointF point;
		point.X = (Gdiplus::REAL)(css.font_size/2);
		point.Y = (Gdiplus::REAL)(css.font_size/4);
		graphics.DrawString(Text.c_str(), -1, &font, point, &stringFormat, &brushFont);
	}


	//_______________________________________________________________ Paint Scale
	Gdiplus::PointF position;
	const double cosp = cos(45.0*M_PI/180.0);
	const double sinp = sin(45.0*M_PI/180.0);
	for(i = 2; i <= markCount; i += 2) 
	{
		position.X = (Gdiplus::REAL)(_centerX+i*sinp*radius* _scale/markCount);
		position.Y = (Gdiplus::REAL)(_centerY+i*cosp*radius* _scale/markCount);
		OnPaintScaleR(graphics, font, brushFont, position, minR + i*radius/markCount);
	}
	//
	double tetha = 0.0;
	wchar_t texto[64];
	Gdiplus::StringFormat stringFormatC;
	stringFormatC.SetAlignment(Gdiplus::StringAlignmentCenter);
	stringFormatC.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	for(i=0; i<12; i++)
	{
		//if (i==9) continue; // skip 270
		tetha = i *(2.0*M_PI)/12.0;
		_snwprintf_s(texto, 64, _TRUNCATE, L"%d", i*30);
		position.X = (Gdiplus::REAL)(radius* _scale*cos(tetha)+ _centerX);
		position.Y = (Gdiplus::REAL)(-radius* _scale*sin(tetha)+ _centerY);
		graphics.DrawString(texto, -1, &font, position, &stringFormatC, &brushFont);
	}
	this->PaintGraphs(graphics);
}

void PolarChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);
	COLORREF a;

	multimap<wstring, wstring>::iterator p;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//__________________________________________ MinRadius
	p = h.value.find(L"MinRadius"); 
	if (p != valueEnd) MinRadius = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MaxRadius
	p = h.value.find(L"MaxRadius"); 
	if (p != valueEnd) MaxRadius = Sys::Convert::ToDouble(p->second);

	//___________________________________________ Autoscale
	p = h.value.find(L"AutoScale"); 
	if (p != valueEnd) AutoScale = Sys::Convert::ToBool(p->second);

	//___________________________________________ ShowSubgrid
	p = h.value.find(L"ShowSubgrid"); 
	if (p != valueEnd) ShowSubgrid = Sys::Convert::ToBool(p->second);

	//__________________________________________ SubgridColor
	if (ColorSync(h, L"SgRed", L"SgGreen", L"SgBlue", a) == true) SubgridColor = a;

	//___________________________________________ Data

	int i = 0;
	int j = 0;
	wchar_t text[256];
	int len = 0;
	Sys::PointF point;
	wstring tmp;
	int state = 0;
	wchar_t c;
	int red = 0;
	int green = 0;
	int blue = 0;
	int type = 0;
	for(i = 0; i < 4; i++)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"Data%d", i);
		p = h.value.find(text); 
		if (p == valueEnd) break;
		len = (int)p->second.length();
		Graphs.Add();
		state = 0;
		for(j= 0; j < len; j++)
		{
			c = p->second[j];
			if (state == 0) //_____________________ type
			{
				if (c == 's')
				{
					type = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 1;
					Graphs[i].type = (Web::Graph::Type)type;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 1) //_____________________ red
			{
				if (c == 's')
				{
					red = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 2;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 2) //_____________________ green
			{
				if (c == 's')
				{
					green = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 3;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 3)//_____________________ blue
			{
				if (c == 's')
				{
					blue = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].color = RGB(red, green, blue);
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 4) //_____________________ X
			{
				if (c == 's')
				{
					point.x = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 5;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 5)//_____________________ Y
			{
				if (c == 's')
				{
					point.y = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].point.push_back(point);
				}
				else
				{
					tmp += c;
				}
			}
		}
	}
}

void PolarChart::GetSource(wstring& source, const wchar_t* url)
{
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=PolarChart";

	Web::PolarChart chart;
	if (chart.MinRadius != this->MinRadius) RenderValue(L"MinRadius", MinRadius, source);
	if (chart.MaxRadius != this->MaxRadius) RenderValue(L"MaxRadius", MaxRadius, source);
	if (chart.AutoScale != this->AutoScale) RenderValue(L"AutoScale", AutoScale, source);
	if (chart.ShowSubgrid != this->ShowSubgrid) RenderValue(L"ShowSubgrid", ShowSubgrid, source);
	if (this->SubgridColor != chart.SubgridColor)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"&SgRed=%d&SgGreen=%d&SgBlue=%d", 
			GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor));
		source += text;
	}

	this->RenderProperties(chart, source);
	const int graphCount = (int)Graphs.storage.size();
	if (graphCount <= 0) return;
	int pointCount = 0;
	int i = 0, j = 0;
	for(i = 0; i < graphCount; i++)
	{
		pointCount = (int)Graphs[i].point.size();
		_snwprintf_s(text, 256, _TRUNCATE, L"&Data%d=%ds%ds%ds%ds", i, (int)Graphs[i].type, (int)GetRValue(Graphs[i].color), 
			(int)GetGValue(Graphs[i].color), (int)GetBValue(Graphs[i].color));
		source += text;
		for(j = 0; j < pointCount; j++)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L"%gs%gs", Graphs[i].point[j].x, Graphs[i].point[j].y);
			Sys::Convert::WstringToHex(text, encodedText);
			source += encodedText;
		}
	}
}

void PolarChart::Line(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen, double angle, double radius)
{
	angle = M_PI*angle/180.0;
	const double x = radius* _scale*cos(angle);
	const double y = radius* _scale*sin(angle);

	graphics.DrawLine(&pen, 
		(Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY-y), 
		(Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY+y));

	graphics.DrawLine(&pen, 
		(Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY+y), 
		(Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY-y));

//	points[index].x = (int)(_centerX-x+0.5);
//	points[index].y = (int)(_centerY-y+0.5);
//	index++;
//	//
//	points[index].x = (int)(_centerX+x+0.5);
//	points[index].y = (int)(_centerY+y-0.5);
//	index++;
//	//
//	points[index].x = (int)(_centerX-x+0.5);
//	points[index].y = (int)(_centerY+y+0.5);
//	index++;
//	//
//	points[index].x = (int)(_centerX+x+0.5);
//	points[index].y = (int)(_centerY-y-0.5);
//	index++;
	//return index;
}

void PolarChart::ShortLine(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen, double angle, double radius)
{
	angle = M_PI*angle/180.0;
	const double x = radius* _scale*cos(angle);
	const double y = radius* _scale*sin(angle);
	const double lengthX = 2.0* _scale*cos(angle)*radius/5.0;
	const double lengthY = 2.0* _scale*sin(angle)*radius/5.0;
	//points[index].X = (Gdiplus::REAL)(_centerX-x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-y+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX-lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-lengthY-0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+lengthY+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+y-0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX-x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+y+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX-lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY+lengthY-0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+lengthX+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-lengthY+0.5);
	//index++;
	////
	//points[index].X = (Gdiplus::REAL)(_centerX+x+0.5);
	//points[index].Y = (Gdiplus::REAL)(_centerY-y-0.5);
	//index++;
	////
	//return index;
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY-y), (Gdiplus::REAL)(_centerX-lengthX), (Gdiplus::REAL)(_centerY-lengthY));
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX+lengthX), (Gdiplus::REAL)(_centerY+lengthY), (Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY+y));
	//
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX-x), (Gdiplus::REAL)(_centerY+y), (Gdiplus::REAL)(_centerX-lengthX), (Gdiplus::REAL)(_centerY+lengthY));
	graphics.DrawLine(&pen, (Gdiplus::REAL)(_centerX+lengthX), (Gdiplus::REAL)(_centerY-lengthY), (Gdiplus::REAL)(_centerX+x), (Gdiplus::REAL)(_centerY-y));
}

//
void PolarChart::OnPaintScaleR(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::PointF& center, double value)
{
	wchar_t texto[64];
	Sys::Convert::ToString(value, texto, 64, true, true);
	Gdiplus::StringFormat stringFormat;
	stringFormat.SetAlignment(Gdiplus::StringAlignmentCenter);
	stringFormat.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	graphics.DrawString(texto, -1, &font, center, &stringFormat, &brushFont);
}

void PolarChart::PaintGraphs(Gdiplus::Graphics& graphics)
{
//	//HRGN hRgn = CreateRectRgnIndirect(&this->m_rcMain);
//	//if (!bPrintting) gdi.SelectClipRgn(hRgn);
	int pointCount = 0;
	const int graphCount = Graphs.GetCount();
	COLORREF graphColor;
	for(int i = 0; i<graphCount; i++)
	{
		graphColor = (WhiteAndBlack == true) ? RGB(0, 0, 0) : Graphs.storage[i].color;
		Gdiplus::Pen pen(Gdiplus::Color(255, GetRValue(graphColor), GetGValue(graphColor), GetBValue(graphColor)), 1.0f);
		this->DrawGraph(graphics, pen, i);
	}
//	//DeleteObject(hRgn);
}


void PolarChart::DrawGraph(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen, int graphIndex)
{
	int i = 0;
	const int pointCount = (int)Graphs.storage[graphIndex].point.size();
	if (pointCount==0) return;
	Gdiplus::REAL dimension = 0.015f*abs(css.height);

	Gdiplus::PointF *screenPoints = new Gdiplus::PointF[pointCount];
	if (screenPoints == NULL) return;

	for(i = 0; i<pointCount; i++)
	{
		screenPoints[i].X= (Gdiplus::REAL)TransformToScreenCoordinatesX(Graphs.storage[graphIndex].point[i].x, Graphs.storage[graphIndex].point[i].y);
		screenPoints[i].Y= (Gdiplus::REAL)TransformToScreenCoordinatesY(Graphs.storage[graphIndex].point[i].x, Graphs.storage[graphIndex].point[i].y);
	}

	switch(Graphs.storage[graphIndex].type)
	{
	case Web::Graph::TypeCircle:
			for(i = 0; i<pointCount; i++)
			{
				graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeCross:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawLine(&pen, screenPoints[i].X, screenPoints[i].Y-dimension, screenPoints[i].X, screenPoints[i].Y + dimension);
			graphics.DrawLine(&pen, screenPoints[i].X-dimension, screenPoints[i].Y, screenPoints[i].X + dimension, screenPoints[i].Y);
		}
		break;
	case Web::Graph::TypeDot:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, 0.3f*dimension, 0.3f*dimension);
		}
		break;
	case Web::Graph::TypeSquare:
		for(i = 0; i<pointCount; i++)
			{
				graphics.DrawRectangle(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeLine:
		graphics.DrawLines(&pen, screenPoints, pointCount);
		break;
	}
	if (screenPoints != NULL) delete [] screenPoints;
}

//________________________________________________________ XyChart
XyChart::XyChart()
{
	_minX = 0.0;
	_maxX = 10.0;
	_minY = 0.0;
	_maxY = 10.0;
	_scaleX = 1.0;
	_scaleY = 1.0;
	_originX = 0.0;
	_originY = 0.0;
	//
	css.color = RGB(0, 0, 200);
	LineColor = RGB(235, 235, 255);
	//
	MinX = _minX;
	MaxX = _maxX;
	MinY = _minY;
	MaxY = _maxY;
	DivisionCountX = 5;
	DivisionCountY = 5;
	SubDivisionCountX = 4;
	SubDivisionCountY = 4;
	CaptionX = L"X";
	CaptionY = L"Y";
	LogScaleX = false;
	LogScaleY = false;
	SubgridColor = RGB(245, 245, 245);
	AutoScaleX = false;
	AutoScaleY = false;
	//
	_boxCaptionHeight = 1.0;
}

XyChart::~XyChart()
{
}

void XyChart::Sync(Web::HttpConnector& h)
{
	BasicSync(h);
	COLORREF a;

	multimap<wstring, wstring>::iterator p;
	multimap<wstring, wstring>::iterator caption;
	const multimap<wstring, wstring>::iterator valueEnd = h.value.end();

	//__________________________________________ CaptionX
	p = h.value.find(L"CaptionX"); 
	if (p != valueEnd)
	{
		if (p->second.length() > 0) CaptionX = p->second;
	}

	//__________________________________________ CaptionY
	p = h.value.find(L"CaptionY"); 
	if (p != valueEnd)
	{
		if (p->second.length() > 0) CaptionY = p->second;
	}

	//__________________________________________ MinX
	p = h.value.find(L"MinX"); 
	if (p != valueEnd) MinX = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MaxX
	p = h.value.find(L"MaxX"); 
	if (p != valueEnd) MaxX = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MinY
	p = h.value.find(L"MinY"); 
	if (p != valueEnd) MinY = Sys::Convert::ToDouble(p->second);

	//__________________________________________ MaxY
	p = h.value.find(L"MaxY"); 
	if (p != valueEnd) MaxY = Sys::Convert::ToDouble(p->second);

	//__________________________________________ DivisionCountX
	p = h.value.find(L"DivisionCountX"); 
	if (p != valueEnd) DivisionCountX = Sys::Convert::ToInt(p->second);

	//__________________________________________ DivisionCountY
	p = h.value.find(L"DivisionCountY"); 
	if (p != valueEnd) DivisionCountY = Sys::Convert::ToInt(p->second);

	//__________________________________________ SubDivisionCountX
	p = h.value.find(L"SubDivisionCountX"); 
	if (p != valueEnd) SubDivisionCountX = Sys::Convert::ToInt(p->second);

	//__________________________________________ SubDivisionCountY
	p = h.value.find(L"SubDivisionCountY"); 
	if (p != valueEnd) SubDivisionCountY = Sys::Convert::ToInt(p->second);

	//___________________________________________ LogScaleX
	p = h.value.find(L"LogScaleX"); 
	if (p != valueEnd) LogScaleX = Sys::Convert::ToBool(p->second);

	//___________________________________________ LogScaleY
	p = h.value.find(L"LogScaleY"); 
	if (p != valueEnd) LogScaleY = Sys::Convert::ToBool(p->second);

	//___________________________________________ AutoScaleX
	p = h.value.find(L"AutoScaleX"); 
	if (p != valueEnd) AutoScaleX = Sys::Convert::ToBool(p->second);

	//___________________________________________ AutoScaleY
	p = h.value.find(L"AutoScaleY"); 
	if (p != valueEnd) AutoScaleY = Sys::Convert::ToBool(p->second);

	//__________________________________________ SubgridColor
	if (ColorSync(h, L"SgRed", L"SgGreen", L"SgBlue", a) == true) SubgridColor = a;

	//___________________________________________ Data

	int i = 0;
	int j = 0;
	wchar_t text[256];
	int len = 0;
	Sys::PointF point;
	wstring tmp;
	int state = 0;
	wchar_t c;
	int red = 0;
	int green = 0;
	int blue = 0;
	int type = 0;
	for(i = 0; i < 4; i++)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"Data%d", i);
		p = h.value.find(text); 
		if (p == valueEnd) break;
		len = (int)p->second.length();
		Graphs.Add();
		//___________________________ Caption
		_snwprintf_s(text, 256, _TRUNCATE, L"Caption%d", i);
		caption = h.value.find(text); 
		if (caption != valueEnd) Graphs[i].caption =caption->second;
		//
		state = 0;
		for(j= 0; j < len; j++)
		{
			c = p->second[j];
			if (state == 0) //_____________________ type
			{
				if (c == 's')
				{
					type = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 1;
					Graphs[i].type = (Web::Graph::Type)type;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 1) //_____________________ red
			{
				if (c == 's')
				{
					red = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 2;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 2) //_____________________ green
			{
				if (c == 's')
				{
					green = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 3;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 3)//_____________________ blue
			{
				if (c == 's')
				{
					blue = Sys::Convert::ToInt(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].color = RGB(red, green, blue);
				}
				else
				{
					tmp += c;
				}
			}
			else if (state == 4) //_____________________ X
			{
				if (c == 's')
				{
					point.x = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 5;
				}
				else
				{
					tmp += c;
				}
			}
			else if (state== 5)//_____________________ Y
			{
				if (c == 's')
				{
					point.y = Sys::Convert::ToDouble(tmp);
					tmp.clear();
					state = 4;
					Graphs[i].point.push_back(point);
				}
				else
				{
					tmp += c;
				}
			}
		}
	}
}

void XyChart::BuildBitmap(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::SolidBrush& brushFont, Gdiplus::Pen& penLine, Gdiplus::Pen& penText)
{
	OnSizePrivate();

	Gdiplus::Pen penSubDiv(Gdiplus::Color(255, GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor)), 1.0f);

	const double deltaX = (_rcMain.right-_rcMain.left)/(double)DivisionCountX;
	const double deltaY = (_rcMain.bottom-_rcMain.top)/(double)DivisionCountY;
	this->PaintCaptionY(graphics, font, brushFont);
	this->PaintCaptionX(graphics, font, brushFont);
	//
	this->PaintScaleX(graphics, font, brushFont, deltaX);
	this->PaintScaleY(graphics, font, brushFont, deltaY);
	//
	this->PaintSubDivX(graphics, penSubDiv);
	this->PaintSubDivY(graphics, penSubDiv);
	//
	this->PaintDivX(graphics, penLine);
	this->PaintDivY(graphics, penLine);
	//
	Gdiplus::RectF rc;
	rc.X = (Gdiplus::REAL)_rcMain.left;
	rc.Y = (Gdiplus::REAL)_rcMain.top;
	rc.Width = (Gdiplus::REAL)(_rcMain.right - _rcMain.left);
	rc.Height = (Gdiplus::REAL)(_rcMain.bottom - _rcMain.top);
	graphics.DrawRectangle(&penText, rc);
//		gdi.Rectangle(_rcMain.left, _rcMain.top, _rcMain.right+1, _rcMain.bottom+1);
	this->PaintGraphs(graphics, font);

}

void XyChart::GetSource(wstring& source, const wchar_t* url)
{
	wchar_t text[256];
	wstring encodedText;

	source = L"http://";
	source += url;
	source += L"?windowID=XyChart";
	Web::XyChart chart;

	//__________________________________________ SubgridColor
	if (chart.SubgridColor != SubgridColor)
	{
		_snwprintf_s(text, 256, _TRUNCATE, L"&SgRed=%d&SgGreen=%d&SgBlue=%d", 
			GetRValue(SubgridColor), GetGValue(SubgridColor), GetBValue(SubgridColor));
		source += text;
	}
	RenderValue(L"CaptionX", CaptionX, source);
	RenderValue(L"CaptionY", CaptionY, source);
	if (chart.MinX != this->MinX) RenderValue(L"MinX", MinX, source);
	if (chart.MaxX != this->MaxX) RenderValue(L"MaxX", MaxX, source);
	if (chart.MinY != this->MinY) RenderValue(L"MinY", MinY, source);
	if (chart.MaxY != this->MaxY) RenderValue(L"MaxY", MaxY, source);
	if (chart.DivisionCountX != this->DivisionCountX) RenderValue(L"DivisionCountX", DivisionCountX, source);
	if (chart.DivisionCountY != this->DivisionCountY) RenderValue(L"DivisionCountY", DivisionCountY, source);
	if (chart.SubDivisionCountX != this->SubDivisionCountX) RenderValue(L"SubDivisionCountX", SubDivisionCountX, source);
	if (chart.SubDivisionCountY != this->SubDivisionCountY) RenderValue(L"SubDivisionCountY", SubDivisionCountY, source);
	if (chart.LogScaleX != this->LogScaleX) RenderValue(L"LogScaleX", LogScaleX, source);
	if (chart.LogScaleY != this->LogScaleY) RenderValue(L"LogScaleY", LogScaleY, source);
	if (chart.AutoScaleX != this->AutoScaleX) RenderValue(L"AutoScaleX", AutoScaleX, source);
	if (chart.AutoScaleY != this->AutoScaleY) RenderValue(L"AutoScaleY", AutoScaleY, source);
	this->RenderProperties(chart, source);
	const int graphCount = (int)Graphs.storage.size();
	if (graphCount <= 0) return;
	int pointCount = 0;
	int i = 0, j = 0;
	for(i = 0; i < graphCount; i++)
	{
		pointCount = (int)Graphs[i].point.size();
		//_______________________________________ Caption
		if (Graphs.storage[i].caption.length() > 0)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L"Caption%d", i);
			RenderValue(text, Graphs.storage[i].caption, source);
		}

		//_______________________________________ Data
		_snwprintf_s(text, 256, _TRUNCATE, L"&Data%d=%ds%ds%ds%ds", i, (int)Graphs[i].type, (int)GetRValue(Graphs[i].color), 
			(int)GetGValue(Graphs[i].color), (int)GetBValue(Graphs[i].color));
		source += text;
		for(j = 0; j < pointCount; j++)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L"%gs%gs", Graphs[i].point[j].x, Graphs[i].point[j].y);
			Sys::Convert::WstringToHex(text, encodedText);
			source += encodedText;
		}
	}
}

double XyChart::TransformFromScreenCoordinatesX(int x) 
{
	return (x - _originX)/_scaleX + _minX;
}

double XyChart::TransformFromScreenCoordinatesY(int y) 
{
	return (y - _originY)/_scaleY + _minY;
}

void XyChart::_AutoScaleX()
{
//	double minX=0.0, maxX=0.0;
//	const int graphCount = Graphs.Count;
//	if (graphCount == 0) return;
//	if (Graphs[0].GetPointCount()<=0) return;
//	int i, j, n;
//	
//	minX = maxX = Graphs[0][0].x;
//	for(i=0; i<graphCount; i++)
//	{
//		n = Graphs[i].GetPointCount();
//		for(j = 0; j<n; j++)
//		{
//			if (Graphs[i][j].x<minX) minX = Graphs[i][j].x;
//			if (Graphs[i][j].x>maxX) maxX = Graphs[i][j].x;
//		}
//	}
//	if (minX==maxX)
//	{
//		minX = minX- minX/2;
//		maxX = maxX + maxX/2;
//		if (minX==maxX)
//		{
//			minX = 0.0;
//			maxX = 10.0;
//		}
//	}
//	else
//	{
//		//double tmp = maxX-minX;
//		//minX = minX- tmp/20;
//		//maxX = maxX + tmp/20;
//	}
//	SetMinX(minX);
//	SetMaxX(maxX);
}

void XyChart::_AutoScaleY()
{
//	double minY=0.0, maxY=0.0;
//	const int graphCount = Graphs.Count;
//	if (graphCount== 0) return;
//	if (Graphs[0].GetPointCount()<=0) return;
//	int i, j, n;
//
//	minY = maxY = Graphs[0][0].y;
//	for(i=0; i<graphCount; i++)
//	{
//		n = Graphs[i].GetPointCount();
//		for(j = 0; j<n; j++)
//		{
//			if (Graphs[i][j].y<minY) minY = Graphs[i][j].y;
//			if (Graphs[i][j].y>maxY) maxY = Graphs[i][j].y;
//		}
//	}
//	//minY = maxY = graph[0].y;
//	//for(int i = 1; i<n; i++)
//	//{
//	//	if (graph[i].x<minX) minX = graph[i].x;
//	//	if (graph[i].y<minY) minY = graph[i].y;
//	//	//
//	//	if (graph[i].x>maxX) maxX = graph[i].x;
//	//	if (graph[i].y>maxY) maxY = graph[i].y;
//	//}
//	if (minY==maxY)
//	{
//		minY = minY- minY/2;
//		maxY = maxY + maxY/2;
//		if (minY==maxY)
//		{
//			minY = 0.0;
//			maxY = 10.0;
//		}
//	}
//	else
//	{
//		//double tmp = maxY-minY;
//		//minY = minY- tmp/20;
//		//maxY = maxY + tmp/20;
//	}
//	this->SetMinY(minY);
//	this->SetMaxY(maxY);
}

void XyChart::OnSizePrivate()
{
	if (LogScaleX == true)
	{
		if (MinX <= 0.0)
		{
			_minX = -1.0;
		}
		else
		{
			_minX = log10(MinX);
		}
		if (MaxX <= 0.0)
		{
			_maxX = 1.0;
		}
		else
		{
			_maxX = log10(MaxX);
		}
	}
	else
	{
		_minX = MinX;
		_maxX = MaxX;	
	}

	if (LogScaleY)
	{
		if (MinY <= 0.0)
		{
			_minY = -1.0;
		}
		else
		{
			_minY = log10(MinY);
		}
		if (MaxY <= 0.0)
		{
			_maxY = 1.0;
		}
		else
		{
			_maxY = log10(MaxY);
		}
	}
	else
	{
		_minY = MinY;
		_maxY = MaxY;
	}

//	if (_printerFormat || height>WINFONT_MAXRES || width>WINFONT_MAXRES)
//	{
//		_boxCaptionHeight = 0.05*this->height;
//	} 
//	else // Display
//	{
		_boxCaptionHeight = 1.5*abs(css.font_size); // Each row is 1.5*_fontHeight
//	}
//
	const double offsetLeft = _boxCaptionHeight + 7.0*_boxCaptionHeight/2.0;
	const double offsetRight = 7.0 * _boxCaptionHeight/4.0;
	const double offsetTop = _boxCaptionHeight;
	const double offsetBottom = 2.0 * _boxCaptionHeight;

	//if (_printerFormat == true)
	//{
	//	_originX = offsetLeft + printInfo.position.x;
	//	_originY = this->height-offsetBottom+printInfo.position.y;
	//}
	//else
	//{
		_originX = offsetLeft;
		_originY = abs(css.height) - offsetBottom;
	//}
	
	_scaleX = (abs(css.width)-offsetLeft-offsetRight)/(_maxX - _minX);
	_scaleY =  - (abs(css.height)-offsetBottom-offsetTop)/(_maxY - _minY);

	//___________________________________________________ Graph Box
	_rcMain.top = (int)TransformToScreenCoordinatesY(_maxY);
	_rcMain.left = (int)TransformToScreenCoordinatesX(_minX);
	_rcMain.bottom = (int)TransformToScreenCoordinatesY(_minY);
	_rcMain.right = (int)TransformToScreenCoordinatesX(_maxX);
}

void XyChart::PaintCaptionX(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush)
{
	if (CaptionX.length() <= 0) return;
	const Gdiplus::REAL captionHeight = (abs(css.height) -_rcMain.bottom)/2.0f;
	Gdiplus::RectF rect;
	rect.X = (Gdiplus::REAL)_rcMain.left;
	rect.Y = (Gdiplus::REAL)(_rcMain.bottom+captionHeight);
	rect.Width = (Gdiplus::REAL)(_rcMain.right - _rcMain.left);
	rect.Height = captionHeight;
	//
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentCenter);
	sf.SetLineAlignment(Gdiplus::StringAlignmentCenter);

	graphics.DrawString(CaptionX.c_str(), -1, &font, rect, &sf, &brush);
}

void XyChart::PaintCaptionY(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush)
{
	if (CaptionY.length() <= 0) return;
	//____________________________________________________ Compute Text Size
	Gdiplus::RectF origin;
	origin.X = 0.0f;
	origin.Y = 0.0f;
	origin.Width = 1000;
	origin.Height = 1000;
	//
	Gdiplus::RectF box;
	//
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentNear);
	sf.SetLineAlignment(Gdiplus::StringAlignmentNear);
	//
	graphics.MeasureString(CaptionY.c_str(), -1, &font, origin, &sf, &box);
	const Gdiplus::REAL x = abs(css.font_size)/5.0f;
	const Gdiplus::REAL y = ((_rcMain.bottom + _rcMain.top)/2.0f + box.Width/2.0f); //y

	Gdiplus::PointF point;
	point.X = 0.0f;
	point.Y = 0.0f;
	graphics.TranslateTransform(x, y);  
	graphics.RotateTransform(270);  
	graphics.DrawString(CaptionY.c_str(), -1, &font, point, &brush);  
	graphics.ResetTransform();  
}

void XyChart::PaintScaleX(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, double deltaX)
{
	const Gdiplus::REAL captionHeight = (Gdiplus::REAL)(  (abs(css.height) - _rcMain.bottom)/2.0  );
	double value;
	const double delta = (_maxX - _minX)/(DivisionCountX);

	for(int i = 0; i<DivisionCountX+1; i++)
	{
		value = (LogScaleX == true) ? pow(10.0, _minX + i * delta) : _minX + i * delta;
		this->OnPaintScaleX(graphics, font, brush, i, deltaX, value);
	}
}

void XyChart::PaintScaleY(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, double deltaY)
{
	const double delta = (_maxY - _minY)/ DivisionCountY;
	double value;

	for(int i = 0; i < DivisionCountY+1; i++)
	{
		value = (LogScaleY== true) ? pow(10.0, _minY + i * delta) : _minY + i * delta;
		this->OnPaintScaleY(graphics, font, brush, i, deltaY, value);
	}
}

void XyChart::OnPaintScaleX(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, int index, double delta, double value)
{
	Gdiplus::RectF rc;
	rc.X = (Gdiplus::REAL)(_originX + index * delta - delta/2.0);
	rc.Y = (Gdiplus::REAL)_rcMain.bottom;
	rc.Width = (Gdiplus::REAL)delta;
	rc.Height = (Gdiplus::REAL)(abs(css.height - _rcMain.bottom)/2.0f);
	wchar_t text[256];
	Sys::Convert::ToString(value, text, 256, true, true);
	Gdiplus::StringFormat sf;
	sf.SetAlignment(Gdiplus::StringAlignmentCenter);
	sf.SetLineAlignment(Gdiplus::StringAlignmentCenter);
	graphics.DrawString(text, -1, &font, rc, &sf, &brush); 
}

void XyChart::OnPaintScaleY(Gdiplus::Graphics& graphics, Gdiplus::Font& font, Gdiplus::Brush& brush, int index, double delta, double value)
{
	wchar_t text[256];
	Sys::Convert::ToString(value, text, 256, true, true);

	Gdiplus::RectF box;
	Gdiplus::PointF origin;
	origin.X = 0.0f;
	origin.Y = 0.0f;
	graphics.MeasureString(text, -1, &font, origin, &box); 

	origin.X = (Gdiplus::REAL)(_originX-box.Width - abs(css.font_size)/2.0);
	origin.Y = (Gdiplus::REAL)(_originY - index*delta - box.Height/2.0);
	graphics.DrawString(text, -1, &font, origin, &brush); 
}

void XyChart::PaintDivY(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxY-_minY)/DivisionCountY;
	double deltaSub = 0.0;
	double y = 0;
	int j=0;
	int nY = 0;

	for(double d= _minY; d< _maxY; d+=delta)
	{
		y = TransformToScreenCoordinatesY(d);
		if (d != _minY) 
		{
			nY = (int)(y+0.5);
			graphics.DrawLine(&pen, (Gdiplus::REAL)_rcMain.left, (Gdiplus::REAL)nY, 
				(Gdiplus::REAL)_rcMain.right-1, (Gdiplus::REAL)nY); 
		}
	}
}

void XyChart::PaintDivX(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxX - _minX)/ DivisionCountX;
	double deltaSub = 0.0;
	double x = 0;
	int j=0;
	int nX = 0;

	for(double d= _minX; d < _maxX; d += delta)
	{
		x = TransformToScreenCoordinatesX(d);
		if (d !=  _minX) 
		{
			nX = (int)(x+0.5);
			graphics.DrawLine(&pen, (Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.top, 
				(Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.bottom-1); 
		}
	}
}

void XyChart::PaintSubDivY(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxY - _minY)/ DivisionCountY;
	double deltaSub = 0.0;
	double y = 0;
	int j=0;
	int nY = 0;

	for(double d= _minY; d < _maxY; d += delta)
	{
		y = TransformToScreenCoordinatesY(d);	
		if (LogScaleY) 
		{
			deltaSub = 9.0/SubDivisionCountY;
			for(j = 1; j<SubDivisionCountY; j++)
			{
				nY = (int)(y+ (delta * _scaleY)* log10(1.0+j*deltaSub) + 0.5);
				if (nY <= _rcMain.top) continue;
				if (nY >= _rcMain.bottom) continue; 
				graphics.DrawLine(&pen, (Gdiplus::REAL)_rcMain.left, (Gdiplus::REAL)nY, 
					(Gdiplus::REAL)_rcMain.right-1, (Gdiplus::REAL)nY); 
				//gdi.MoveToEx(_rcMain.left, nY); 
				//gdi.LineTo(_rcMain.right-1, nY);
			}	
		}
		else
		{
			deltaSub = _scaleY*delta/ SubDivisionCountY;
			for(j = 1; j < SubDivisionCountY; j++)
			{
				nY = (int)(y+ j*deltaSub+0.5);
				if (nY>_rcMain.top && nY<_rcMain.bottom)
				{
					graphics.DrawLine(&pen, (Gdiplus::REAL)_rcMain.left, (Gdiplus::REAL)nY, 
						(Gdiplus::REAL)_rcMain.right-1, (Gdiplus::REAL)nY); 
					//gdi.MoveToEx(_rcMain.left, nY); 
					//gdi.LineTo(_rcMain.right-1, nY);
				}
			}
		}
	}
}

void XyChart::PaintSubDivX(Gdiplus::Graphics& graphics, Gdiplus::Pen& pen)
{
	const double delta = (_maxX - _minX)/ DivisionCountX;
	double deltaSub = 0.0;
	double x = 0;
	int j=0;
	int nX = 0;

	for(double d = _minX; d < _maxX; d += delta)
	{
		x = TransformToScreenCoordinatesX(d);
		if (LogScaleX)
		{
			deltaSub = 9.0/SubDivisionCountX;
			for(j = 1; j<SubDivisionCountX; j++)
			{
				nX = (int)(x+ (delta*_scaleX)* log10(1.0+j*deltaSub) + 0.5);
				if (nX <= _rcMain.left) continue;
				if (nX >= _rcMain.right) continue; 
				graphics.DrawLine(&pen, (Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.top, 
						(Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.bottom-1); 
				//gdi.MoveToEx(nX, _rcMain.top); 
				//gdi.LineTo(nX, _rcMain.bottom-1);
			}	
		}
		else
		{
			deltaSub = _scaleX*delta/SubDivisionCountX;
			for(j = 1; j < SubDivisionCountX; j++)
			{
				nX = (int)(x+j*deltaSub+0.5);
				if (nX>_rcMain.left && nX<_rcMain.right)
				{
					graphics.DrawLine(&pen, (Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.top, 
						(Gdiplus::REAL)nX, (Gdiplus::REAL)_rcMain.bottom-1); 
					//gdi.MoveToEx(nX, _rcMain.top); 
					//gdi.LineTo(nX, _rcMain.bottom-1);
				}
			}
		}
	}
}

void XyChart::PaintGraphs(Gdiplus::Graphics& graphics, Gdiplus::Font& font)
{
	const int graphCount = (int)Graphs.storage.size();
	int i = 0;
//	//Win::Gdi::Color3D color3D(bPrintting? RGB(220, 220, 220) : RGB(128, 128, 128));
//	//CG::Brush brocha(RGB(20, 20, 20));
	wchar_t *caption = NULL;
	Gdiplus::RectF rect;
	Gdiplus::PointF point;
	point.X = 0.0f;
	point.Y = 0.0f;
//	RECT rect;
//
//	rect.top = 0;
//	rect.left = 0;
//	rect.right = this->width;
//	rect.bottom = _rcMain.top;
//
	const Gdiplus::REAL space = (Gdiplus::REAL)(css.font_size);
	//________________________________________ Find graph caption width
	Gdiplus::REAL captionWidth = 0.0f;
	
	for(i = 0; i<graphCount; i++)
	{
		if (Graphs.storage[i].caption.length() == 0) continue;
		graphics.MeasureString(Graphs[i].caption.c_str(), -1, &font, point, &rect);
		captionWidth += (Gdiplus::REAL)(rect.Width + 2*space);
	}

	//_____________________________________________________Draw graph caption	
	Gdiplus::REAL xCaption = _rcMain.left +  space + (_rcMain.right - _rcMain.left - captionWidth)/2.2f;

	Gdiplus::StringFormat stringFormat;
	stringFormat.SetAlignment(Gdiplus::StringAlignmentNear);
	stringFormat.SetLineAlignment(Gdiplus::StringAlignmentFar);

	point.Y = (Gdiplus::REAL)_rcMain.top;
	for(i = 0; i<graphCount; i++)
	{
		if (Graphs.storage[i].caption.length() == 0) continue;
		graphics.MeasureString(Graphs[i].caption.c_str(), -1, &font, point, &rect);
		Gdiplus::SolidBrush brush(Gdiplus::Color(255, GetRValue(Graphs.storage[i].color), GetGValue(Graphs.storage[i].color), GetBValue(Graphs.storage[i].color)));
		//gdi.SetTextColor(Graphs[i].color);
		//	gdi.TextOut(xCaption, _rcMain.top, pszCaption);
		point.X = xCaption;
		graphics.DrawString(Graphs.storage[i].caption.c_str(), -1, &font, point, &stringFormat, &brush);
		xCaption += (rect.Width + 2.0f*space);
	}

	//__________________________________________________ Draw Graphs
	Gdiplus::RectF rcClipping;
	rcClipping.X = (Gdiplus::REAL)(_rcMain.left);
	rcClipping.Y = (Gdiplus::REAL)(_rcMain.top);
	rcClipping.Width = (Gdiplus::REAL)(_rcMain.right - _rcMain.left);
	rcClipping.Height = (Gdiplus::REAL)(_rcMain.bottom - _rcMain.top);

	graphics.SetClip(rcClipping, Gdiplus::CombineModeReplace);
	for(i = 0; i<graphCount; i++)
	{	
		this->DrawGraph(graphics, i);
	}
}



void XyChart::DrawGraph(Gdiplus::Graphics& graphics, int graphIndex)
{
	const int pointCount = (int)Graphs.storage[graphIndex].point.size();
	if (pointCount == 0) return;
	Gdiplus::Pen pen(Gdiplus::Color(255, GetRValue(Graphs.storage[graphIndex].color), GetGValue(Graphs.storage[graphIndex].color), GetBValue(Graphs.storage[graphIndex].color)), 1.0f);
	//_____________________________________________________ Transform Graphs
	int i;

	Gdiplus::PointF *screenPoints = new Gdiplus::PointF[pointCount];
	if (screenPoints == NULL) return;

	double x, y;
	for(i = 0; i < pointCount; i++)
	{
		x = Graphs.storage[graphIndex].point[i].x;
		y = Graphs.storage[graphIndex].point[i].y;
		//________________________________________________ Transform X
		if (LogScaleX)
		{
			if (x>0)
				screenPoints[i].X = this->TransformToScreenCoordinatesX(log10(fabs(x)));
			else
				screenPoints[i].X = this->TransformToScreenCoordinatesX(_originX);
		}
		else
		{
			screenPoints[i].X = this->TransformToScreenCoordinatesX(x);
		}
		//________________________________________________ Transform Y
		if (LogScaleY)
		{
			if (y>0)
				screenPoints[i].Y= this->TransformToScreenCoordinatesY(log10(fabs(y)));
			else
				screenPoints[i].Y= this->TransformToScreenCoordinatesY(_originY);
		}
		else
		{
			screenPoints[i].Y= this->TransformToScreenCoordinatesY(y);
		}	
	}

	Gdiplus::REAL dimension = 0.015f*abs(css.height);

		switch(Graphs.storage[graphIndex].type)
	{
	case Web::Graph::TypeCircle:
			for(i = 0; i<pointCount; i++)
			{
				graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeCross:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawLine(&pen, screenPoints[i].X, screenPoints[i].Y-dimension, screenPoints[i].X, screenPoints[i].Y + dimension);
			graphics.DrawLine(&pen, screenPoints[i].X-dimension, screenPoints[i].Y, screenPoints[i].X + dimension, screenPoints[i].Y);
		}
		break;
	case Web::Graph::TypeDot:
		for(i = 0; i<pointCount; i++)
		{
			graphics.DrawEllipse(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, 0.3f*dimension, 0.3f*dimension);
		}
		break;
	case Web::Graph::TypeSquare:
		for(i = 0; i<pointCount; i++)
			{
				graphics.DrawRectangle(&pen, screenPoints[i].X-dimension, screenPoints[i].Y-dimension, dimension, dimension);
			}
		break;
	case Web::Graph::TypeLine:
		graphics.DrawLines(&pen, screenPoints, pointCount);
		break;
	case Web::Graph::TypeHistogram:
		{
			const Gdiplus::REAL yzero = _rcMain.bottom-1.0f;
			for(i = 0; i<pointCount; i++)
			{
				graphics.DrawLine(&pen, screenPoints[i].X, yzero, screenPoints[i].X, screenPoints[i].Y);
			}
		}
		break;
	}

//	Win::Graph& graph = Graphs[graphIndex];
//	int i = 0;
//	POINT * p = graph.GetScreenPoints();
//	const int pointCount = graph.GetPointCount();
//	if (pointCount==0) return;
//	int dimension = (int)(((int)(0.10*this->height/3.7+0.5))/4.0 + 0.5);
//	
//
//	switch(graph.GetType())
//	{
//	case Win::Graph::circle:
//			for(i = 0; i<pointCount; i++) gdi.Circle(p[i].x, p[i].y, dimension);
//		break;
//	case Win::Graph::cross:
//		for(i = 0; i<pointCount; i++)
//		{
//			gdi.MoveToEx(p[i].x, (int)(p[i].y-dimension));
//			gdi.LineTo(p[i].x, (int)(p[i].y+dimension+1));
//			gdi.MoveToEx((int)(p[i].x-dimension), p[i].y);
//			gdi.LineTo((int)(p[i].x+dimension+1), p[i].y);
//		}
//		break;
//	case Win::Graph::dot:
//		for(i = 0; i<pointCount; i++)
//		{
//			gdi.SetPixel(p[i].x, p[i].y, graph.color);
//		}
//		break;
//	case Win::Graph::square:
//		for(i = 0; i<pointCount; i++)
//		{
//			gdi.Rectangle(p[i].x-dimension, p[i].y-dimension,
//				p[i].x+dimension+1, p[i].y+dimension+1);
//		}
//		break;
//	case Win::Graph::line:
//		gdi.Polyline(graph.GetScreenPoints(), pointCount);
//		break;
//	case Win::Graph::histogram:
//		{
//			const int yzero = _rcMain.bottom-1;
//			for(i = 0; i<pointCount; i++)
//			{
//				gdi.Line(p[i].x, yzero, p[i].x, p[i].y);
//			}
//		}
//		break;
//	}
	if (screenPoints != NULL) delete [] screenPoints;
}

//________________________________________________________ Histogram
Histogram::Histogram()
{
	this->Graphs.Add();
	this->Graphs[0].type = Web::Graph::TypeHistogram;
}

Histogram::~Histogram()
{
}

void Histogram::SetData(valarray<double>& data, int resolution, bool percentDisplay)
{
	if (Graphs.Count != 1)
	{
		Graphs.DeleteAll();
		Graphs.Add();
	}
	int i;
	const int data_size = (int)data.size();
	if (data_size <= 1) 
	{
		Graphs[0].point.clear();
		return;
	}
	if (resolution<=0)
	{
		Graphs[0].point.clear();
		return;
	}
	//_______________________________Find minimum and maximum
	double minimum = data[0];
	double maximum = data[0];
	for(i=0; i<data_size; i++)
	{
		if (data[i]<minimum) minimum = data[i];
		if (data[i]>maximum) maximum = data[i];
	}
	if (maximum==minimum)
	{
		Graphs[0].point.clear();
		return;
	}
	Graphs[0].point.resize(resolution);
	//_______________________________ compute x values and clean y
	const double deltaX = (maximum-minimum)/resolution;
	for(i=0; i<resolution; i++)
	{
		Graphs[0].point[i].x = minimum+i*deltaX+deltaX/2.0;
		Graphs[0].point[i].y = 0.0;
	}

	//______________________________ Find Histogram
	int index;
	for(i=0; i<data_size; i++)
	{
		index = (int)((data[i]-minimum)/deltaX);
		if (0<=index && index<resolution)
		{
			Graphs[0].point[index].y ++;
		}
	}
	if (percentDisplay)
	{
		for(i=0; i<resolution; i++)
		{
			Graphs[0].point[i].y = Graphs[0].point[i].y * 100.0 / data_size;
		}
		MinY = 0.0;
		MaxY = 100.0;
		AutoScaleY = false;
	}
	//this->RefreshAll();
}

#endif

//________________________________________________________ ProgressBar
ProgressBar::ProgressBar()
{
}

ProgressBar::~ProgressBar()
{
}

void ProgressBar::RenderImage(string& data)
{
	const unsigned char gifdata[] = {0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x64, 0x00, 0x01, 0x00, 0x91, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x35, 0x35, 0x35, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xFF, 0x0B, 0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 
	0x2E, 0x30, 0x03, 0x01, 0x00, 0x00, 0x00, 0x21, 0xF9, 0x04, 0x09, 0x14, 0x00, 0x01, 0x00, 0x2C, 0x00, 0x00, 
	0x00, 0x00, 0x64, 0x00, 0x01, 0x00, 0x00, 0x08, 0x12, 0x00, 0x03, 0x08, 0x1C, 0x48, 0xB0, 0xA0, 0xC1, 0x83, 
	0x08, 0x13, 0x2A, 0x5C, 0xC8, 0xB0, 0x61, 0xC2, 0x80, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x02, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x07, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0A, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0C, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x0D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x0F, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x12, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x14, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x15, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x16, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x17, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x19, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x1A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1C, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x1E, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x1F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x21, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x23, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x26, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x27, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x29, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2B, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2E, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x2F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x30, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x31, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x33, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x34, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x35, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x36, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x37, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x38, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x39, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x3B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3D, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x3E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x3F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x40, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x42, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x43, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x45, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x46, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x47, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x49, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4A, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x4B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x4D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x4F, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x50, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x51, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x52, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 
	0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x53, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 
	0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x54, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 
	0x00, 0x2C, 0x55, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 
	0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x57, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 
	0x14, 0x00, 0x00, 0x00, 0x2C, 0x58, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 
	0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x59, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 
	0x2C, 0x5A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 
	0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x5B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 
	0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x5C, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 
	0x00, 0x00, 0x00, 0x2C, 0x5D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 
	0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x5E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 
	0x5F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 
	0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x60, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 
	0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x61, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 
	0x00, 0x00, 0x2C, 0x62, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 
	0x00, 0x21, 0xF9, 0x04, 0x20, 0x14, 0x00, 0x00, 0x00, 0x2C, 0x63, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x01, 0x04, 0x04, 0x00, 0x3B};
	data.assign((char*)gifdata, 2584);
}

//________________________________________________________ Label
Label::Label()
{
	Type = HTML_TND_SPAN;
}

Label::~Label()
{
}

wstring& Label::GetText()
{
	return _text;
}

void Label::SetText(const wstring& text)
{
	_text = text;
}

void Label::SetVisible(bool visible)
{
	VisibleObject::SetVisible(visible);
}

bool Label::IsVisible()
{
	return VisibleObject::IsVisible();
}

void Label::SetEnabled(bool enabled)
{
	VisibleObject::SetEnabled(enabled);
}

bool Label::IsEnabled()
{
	return VisibleObject::IsEnabled();
}

void Label::OnNavigateAway(Web::HttpConnector& httpConnector)
{
}

void Label::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	//_______________________________________ <tag>
	wchar_t* tag = RenderTagAndId(out_html);
	if (tag != NULL)
	{
		RenderClassAndStyle(out_html);
		if (isBrowserView == false) javascript.Render(ID.c_str(), out_html, httpConnector.url.c_str());
		out_html.WriteText(L">");
	}
	//_______________________________________ Text
	if (Text.length() > 0) out_html.WriteText(Text);
	//_______________________________________ </tag>
	if (tag != NULL)
	{
		out_html.WriteText(L"</");
		out_html.WriteText(tag);
		out_html.WriteText(L">");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
	//if (indentCount != -1) out_html.WriteText(L"\r\n");
}

void Label::GetXml(Web::HttpConnector& httpConnector)
{
}

void Label::LoadState(Web::HttpConnector& httpConnector)
{
}

wchar_t* Label::GetTag()
{
	return Web::Helper::GetTag(Type);
}

//________________________________________________________ ParentNode
ParentNode::ParentNode()
{
	Type = HTML_PND_TABLE;
	cellpadding = HTML_SIZE_AUTO;
	cellspacing = HTML_SIZE_AUTO;
}

ParentNode::~ParentNode()
{
}

void ParentNode::OnNavigateAway(Web::HttpConnector& httpConnector)
{
	const list<Web::Object*>::iterator childEnd = child.end();
	list<Web::Object*>::iterator pChild = child.begin();

	for(; pChild != childEnd; pChild++)
	{
		(*pChild)->OnNavigateAway(httpConnector);
	}
}

void ParentNode::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (Visible == false) return;
	GetPreHtml(out_html);
	const list<Web::Object*>::iterator childEnd = child.end();
	const int count = (int)child.size();
	int i = 0;
	list<Web::Object*>::iterator pChild = child.begin();
	for (; pChild != childEnd; pChild++)
	{
		(*pChild)->GetHtml(out_html, httpConnector);
	}
	GetPostHtml(out_html);
}

void ParentNode::GetPreHtml(Sys::ITextWriterW& out_html)
{
	wchar_t text[256];
	//_______________________________________ <tag>
	wchar_t* tag = RenderTagAndId(out_html);
	if (tag != NULL)
	{
		RenderClassAndStyle(out_html);
		javascript.Render(ID.c_str(), out_html, L"url");
		if (cellpadding != HTML_SIZE_AUTO)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L" cellpadding=\"%d\"", cellpadding);
			out_html.WriteText(text);
		}
		if (cellspacing != HTML_SIZE_AUTO)
		{
			_snwprintf_s(text, 256, _TRUNCATE, L" cellspacing=\"%d\"", cellpadding);
			out_html.WriteText(text);
		}
		out_html.WriteText(L">");
	}
}

void ParentNode::GetPostHtml(Sys::ITextWriterW& out_html)
{
	//_______________________________________ </tag>
	wchar_t * tag = GetTag();
	if (tag != NULL)
	{
		out_html.WriteText(L"</");
		out_html.WriteText(tag);
		out_html.WriteText(L">");
	}
	if (EndHtml.length() > 0) out_html.WriteText(EndHtml);
}

void ParentNode::GetXml(Web::HttpConnector& httpConnector)
{
	const list<Web::Object*>::iterator childEnd = child.end();
	const int count = (int)child.size();
	int i = 0;
	list<Web::Object*>::iterator pChild = child.begin();
	for (; pChild != childEnd; pChild++)
	{
		(*pChild)->GetXml(httpConnector);
	}
}

void ParentNode::LoadState(Web::HttpConnector& httpConnector)
{
	const list<Web::Object*>::iterator childEnd = child.end();
	const int count = (int)child.size();
	int i = 0;
	list<Web::Object*>::iterator pChild = child.begin();
	for (; pChild != childEnd; pChild++)
	{
		(*pChild)->LoadState(httpConnector);
	}
}

wchar_t* ParentNode::GetTag()
{
	return Web::Helper::GetTag(Type);
}

void ParentNode::AddChild(Web::Object& object)
{
	child.push_back(&object);
}

//________________________________________________________ MessageBoxInfo

//________________________________________________________ Page
Page::Page(void)
{
	GZipEncoding = false;
	isPreview = false;
	formMethod = HTML_FORM_METHOD_POST; //HTML_FORM_METHOD_GET
	showAllServerVariables = false;
}

Page::~Page(void)
{
}

void Page::EndDialog(int result)
{
}

HWND Page::GetHWND()
{
	return NULL;
}

void Page::OnNavigateAway(Web::HttpConnector& httpConnector)
{
	httpConnector.value.clear();
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->OnNavigateAway(httpConnector);
	}
	if (wcslen(httpConnector.GetWindowID()) > 0)
	{
		httpConnector.AddVariable(L"windowID", httpConnector.GetWindowID());
	}
}

int Page::MessageBox(const wchar_t * text, const wchar_t * caption, UINT iconType)
{
	Web::MessageBoxInfo mbi;
	mbi.text = text;
	mbi.caption = caption;
	mbi.iconType = iconType & 0x000000F0L; // Use only seventh byte
	_msgbox.push_back(mbi);
	return 0;
}

int Page::MessageBox(const wstring& text, const wstring& caption, UINT iconType)
{
	Web::MessageBoxInfo mbi;
	mbi.text = text;
	mbi.caption = caption;
	mbi.iconType = iconType & 0x000000F0L; // Use only seventh byte
	_msgbox.push_back(mbi);
	return 0;
}

void Page::Run(Web::HttpConnector& h)
{
	h.SetRequestEvent();
	//_____________________________________________ Get script_name
	h.GetServerVariable("SCRIPT_NAME", script_name);
	//_____________________________________________ Check if server support GZIP Encoding
	GZipEncoding = false;
	char buffer[64];
	if (h.GetServerVariable("HTTP_ACCEPT_ENCODING", buffer, 64))
	{
		if (strstr(buffer, "GZIP") != NULL) GZipEncoding = true;
	}
	InitializeGui();
	//
	LoadState(h);
	Window_Open(h);
	if (h.httpCode != 200) return;
	if (h.HasRequestBeenHandled() == false)
	{
		OnNavigateAway(h);
		return;
	}
	//
	EventHandler(h);
	if (h.httpCode != 200) return;
	if (h.HasRequestBeenHandled() == false)
	{
		OnNavigateAway(h);
		return;
	}
	//
	if (h.ContentType == HTML_CONTENT_TYPE_TEXT_XML || h.ContentType == HTML_CONTENT_TYPE_APPLICATION_XML)
	{
		GetXml(h);
	}
	else if (h.ContentType == HTML_CONTENT_TYPE_SOAP1_1 || h.ContentType == HTML_CONTENT_TYPE_SOAP1_2)
	{
		GetWebServiceXml(h);
	}
	else
	{
		GetHtml(h, h);
	}
}

void Page::EventHandler(Web::HttpConnector& h)
{
}

void Page::InitializeGui()
{
}

void Page::Window_Open(Web::HttpConnector& h)
{
}

void Page::HeadItem(wstring& variable, const wchar_t* tagini, const wchar_t* tagend, Sys::ITextWriterW& out_html)
{
	if (variable.empty() == true) return;
	out_html.WriteText(tagini);
	out_html.WriteText(variable);
	out_html.WriteText(tagend);
}

void Page::GetHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	GetPreHtml(out_html, false);
	//_________________________________________________________ RENDER CHILDREN
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->GetHtml(out_html, httpConnector);
	}
	GetPostHtml(out_html, httpConnector);
}

void Page::RenderMessages(Sys::ITextWriterW& out_html)
{
	vector<MessageBoxInfo>::iterator msg;
	const vector<MessageBoxInfo>::iterator msgEnd = _msgbox.end();
	for(msg = _msgbox.begin(); msg != msgEnd; msg++)
	{
		out_html.WriteText(L"<table style=\"width:100%;background:#A0A0A0\"><tr style=\"background:#ECECEC;\"><td style=\"font-family:Arial;font-size:32px;background:#");
		if (msg->iconType == MB_ICONWARNING)
		{
			out_html.WriteText(L"FFFF20");
		}
		else if (msg->iconType == MB_ICONERROR)
		{
			out_html.WriteText(L"FF2020");
		}
		else if (msg->iconType == MB_ICONINFORMATION)
		{
			out_html.WriteText(L"3090FF");
		}
		out_html.WriteText(L";text-align:center;color:#000000;font-weight:900\">!</td><td style=\"padding:5px;\"><span style=\"font-family:Arial;font-size:16px;\">");
		out_html.WriteText(msg->caption);
		out_html.WriteText(L"</span><br/><span style=\"font-family:Arial;font-size:12px;\">");
		out_html.WriteText(msg->text);
		out_html.WriteText(L"</span></td></tr></table><br />\r\n");
	}
}

void Page::GetPreHtml(Sys::ITextWriterW& out_html, bool isBrowserView)
{
	out_html.WriteText(L"<!DOCTYPE html>\r\n");
	out_html.WriteText(L"<html>\r\n");
	if (GZipEncoding == true) out_html.WriteText(L"<!-- GZIP ENCODING -->\r\n");
	//___________________________________________________________ Head
	out_html.WriteText(L"<head>\r\n");
	//___________________________________________________________ <meta charset
	out_html.WriteText(L"   <meta charset=\"UTF-8\" />\r\n");
	//___________________________________________________________ <meta http-equiv="content-type"
	out_html.WriteText(L"   <meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\" />\r\n");
	//
	HeadItem(Title, L"   <title>", L"</title>\r\n", out_html);
	HeadItem(CssFile, L"   <link rel=\"stylesheet\" type=\"text/css\" href=\"", L"\" />\r\n", out_html);
	//
	if (isBrowserView == false)
	{
		wstring commonJs(L"Wintempla.js");
		HeadItem(commonJs, L"   <script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" ></script>\r\n", out_html); // L"<script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" charset=\"UTF-8\">
		HeadItem(JavascriptFile, L"   <script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" ></script>\r\n", out_html);	// L"<script language=\"javascript\" type=\"text/javascript\" src=\"", L"\" charset=\"UTF-8\">
	}
	HeadItem(Author, L"   <meta name=\"author\" content=\"", L"\" />\r\n", out_html);
	HeadItem(Description, L"   <meta name=\"description\" content=\"", L"\" />\r\n", out_html);
	HeadItem(Refresh, L"   <meta http-equiv=\"refresh\" content=\"", L"\" />\r\n", out_html);
	//
	if (Keywords.length() > 0)
	{
		out_html.WriteText(L"   <meta name=\"robots\" content=\"all, index, follow\" />\r\n");
		HeadItem(Keywords, L"   <meta name=\"keywords\" content=\"", L"\" />\r\n", out_html);
	}

	//__________________________________________________________ WebSiteIcon
	if (WebSiteIcon.length() > 0)
	{
		out_html.WriteText(L"   <link rel=\"icon\" type=\"image/png\" href=\"");
		out_html.WriteText(WebSiteIcon);
		out_html.WriteText(L"\" />\r\n");
	}
	//__________________________________________________________ </head>
	out_html.WriteText(L"</head>\r\n");		
	//__________________________________________________________ <body>
	out_html.WriteText(L"<body");
	css.GetHtml(out_html);
	out_html.WriteText(L">\r\n");
	//__________________________________________________________ MessageBox
	RenderMessages(out_html);
	//__________________________________________________________ form
	if (script_name.length() > 0)
	{
		//Web::Object::Indent(indentCount, out_html);
		if (formMethod == HTML_FORM_METHOD_GET)
		{
			out_html.WriteText(L"<form id=\"formMain\" method=\"get\" action=\"");
		}
		else
		{
			out_html.WriteText(L"<form id=\"formMain\" method=\"post\" action=\"");
		}
		out_html.WriteText(script_name);
		out_html.WriteText(L"\" >\r\n");
	}
}

void Page::GetPostHtml(Sys::ITextWriterW& out_html, Web::HttpConnector& httpConnector)
{
	if (script_name.length() > 0)
	{
		//_________________________________________________________  hidden for Buttons
		out_html.WriteText(L"   <input id=\"serverClick\" type=\"hidden\" name=\"onclickSrc\" value=\"0\" />");
		//_________________________________________________________  WindowID
		if (ID.length() > 0)
		{
			out_html.WriteText(L"   <input id=\"windowInfo\" type=\"hidden\" name=\"windowID\" value=\"");
			out_html.WriteText(ID);
			out_html.WriteText(L"\" />");
		}
		out_html.WriteText(L"</form>\r\n");
	}
	//_______________________________________________________ ProgressBar
	if (isPreview == false)
	{
		out_html.WriteText(L"<img id=\"WebProgressBar\" src=\"http://");
		out_html.WriteText(httpConnector.url);
		out_html.WriteText(L"?windowID=ProgressBar\" style=\"width:300px;height:3px;border-width:1px;border-style:solid;border-color:#909090;background-color:#205020;visibility:hidden\">");
	}
	//__________________________________________________________ Server Variables
	if (showAllServerVariables == true) RenderServerVariables(httpConnector, out_html);
	//_______________________________________________________ body End
	out_html.WriteText(L"</body>\r\n");
	//_______________________________________________________ html End
	out_html.WriteText(L"</html>");
}

void Page::RenderServerVariables(Web::HttpConnector& httpConnector, Sys::ITextWriterW& out_html)
{
	int index;
	const wchar_t * name;
	wstring value;
	//_____________________________________________________________ <table>
	out_html.WriteText(L"<table style=\"border-style:solid;border-width:1px;border-color:#808090\">");
	for(index = 0; index < 100; index++)
	{
		name = httpConnector.GetServerVariableName(index);
		if (name == NULL) break;
		out_html.WriteText(L"<tr><td style=\"background-color:#F0F0FF\">");
		out_html.WriteText(name);
		out_html.WriteText(L"</td><td style=\"background-color:#F0F0FF\">");
		if (httpConnector.GetServerVariable(name, value)== true)
		{
			out_html.WriteText(value);
			out_html.WriteText(L"</td></tr>\r\n");
		}
		else
		{
			out_html.WriteText(L"&nbsp;</td></tr>\r\n");
		}
	}
	out_html.WriteText(L"</table>");
}

void Page::AddChild(Web::Object& object)
{
	child.push_back(&object);
}

void Page::RenderXmlMessages(Web::HttpConnector& httpConnector)
{
	const int count = (int)_msgbox.size();
	if (count == 0) return;
	vector<MessageBoxInfo>::iterator msg;
	const vector<MessageBoxInfo>::iterator msgEnd = _msgbox.end();
	wstring text;
	wstring xmlValue;
	for(msg = _msgbox.begin(); msg != msgEnd; msg++)
	{
		httpConnector.WriteText(L"<c><id>");
		httpConnector.WriteText(ID);
		httpConnector.WriteText(L"</id><tp>MB</tp><d>");
		text = msg->caption;
		text += L": ";
		text += msg->text;
		Sys::Convert::ToXml(text.c_str(), xmlValue);
		httpConnector.WriteText(xmlValue);
		httpConnector.WriteText(L"</d></c>");
	}
}

void Page::GetXml(Web::HttpConnector& httpConnector)
{
	httpConnector.WriteText(L"<?xml version=\"1.0\" encoding=\"UTF-8\"?><gui>");

	RenderXmlMessages(httpConnector);
	//
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->GetXml(httpConnector);
	}
	httpConnector.WriteText(L"</gui>");
}

void Page::GetWebServiceXml(Web::HttpConnector& httpConnector)
{
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->GetXml(httpConnector);
	}
}

void Page::LoadState(Web::HttpConnector& httpConnector)
{
	list<Web::Object*>::iterator p;
	const list<Web::Object*>::iterator pEnd = child.end();
	for(p = child.begin(); p != pEnd; p++)
	{
		if ((*p) == NULL) continue;
		(*p)->LoadState(httpConnector);
	}
}

//void Page::SetOnSubmit(bool fireEvent)
//{
//	// 1000 0000 0000 0000 0000 0000 0000 0000
//	if (fireEvent == true)
//	{
//		memoryBlock |= 0x80000000;
//	}
//	else
//	{
//		memoryBlock &= 0x7FFFFFFF;
//	}
//}
//
//bool Page::GetOnSubmit()
//{
//	// 1000 0000 0000 0000 0000 0000 0000 0000
//	return ((memoryBlock & 0x80000000) != 0);
//}
//
//void Page::SetOnReset(bool fireEvent)
//{
//	// 0100 0000 0000 0000 0000 0000 0000 0000
//	if (fireEvent == true)
//	{
//		memoryBlock |= 0x40000000;
//	}
//	else
//	{
//		memoryBlock &= 0xBFFFFFFF;
//	}
//}
//
//bool Page::GetOnReset()
//{
//	// 0100 0000 0000 0000 0000 0000 0000 0000
//	return ((memoryBlock & 0x40000000) != 0);
//}
//
//void Page::SetOnLoad(bool fireEvent)
//{
//	// 0010 0000 0000 0000 0000 0000 0000 0000
//	if (fireEvent == true)
//	{
//		memoryBlock |= 0x20000000;
//	}
//	else
//	{
//		memoryBlock &= 0xDFFFFFFF;
//	}
//}
//
//bool Page::GetOnLoad()
//{
//	// 0010 0000 0000 0000 0000 0000 0000 0000
//	return ((memoryBlock & 0x20000000) != 0);
//}
//void Page::SetOnUnload(bool fireEvent)
//{
//	// 0001 0000 0000 0000 0000 0000 0000 0000
//	if (fireEvent == true)
//	{
//		memoryBlock |= 0x10000000;
//	}
//	else
//	{
//		memoryBlock &= 0xEFFFFFFF;
//	}
//}
//
//bool Page::GetOnUnload()
//{
//	// 0001 0000 0000 0000 0000 0000 0000 0000
//	return ((memoryBlock & 0x10000000) != 0);
//}

//void Page::SetGZipEncoding(bool gzipEncoding)
//{
//	// 0000 1000 0000 0000 0000 0000 0000 0000
//	if (gzipEncoding == true)
//	{
//		memoryBlock |= 0x08000000;
//	}
//	else
//	{
//		memoryBlock &= 0xF7FFFFFF;
//	}
//}
//
//bool Page::GetGZipEncoding()
//{
//	// 0000 1000 0000 0000 0000 0000 0000 0000
//	return ((memoryBlock & 0x08000000) != 0);
//}

}  //____________________________________________________ namespace Web::End


